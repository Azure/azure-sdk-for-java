// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.ai.formrecognizer.implementation;

import com.azure.ai.formrecognizer.implementation.models.AnalyzeBusinessCardAsyncHeaders;
import com.azure.ai.formrecognizer.implementation.models.AnalyzeIdDocumentAsyncHeaders;
import com.azure.ai.formrecognizer.implementation.models.AnalyzeInvoiceAsyncHeaders;
import com.azure.ai.formrecognizer.implementation.models.AnalyzeLayoutAsyncHeaders;
import com.azure.ai.formrecognizer.implementation.models.AnalyzeOperationResult;
import com.azure.ai.formrecognizer.implementation.models.AnalyzeReceiptAsyncHeaders;
import com.azure.ai.formrecognizer.implementation.models.AnalyzeWithCustomModelHeaders;
import com.azure.ai.formrecognizer.implementation.models.ComposeCustomModelsAsyncHeaders;
import com.azure.ai.formrecognizer.implementation.models.ComposeRequest;
import com.azure.ai.formrecognizer.implementation.models.ContentType;
import com.azure.ai.formrecognizer.implementation.models.CopyAuthorizationResult;
import com.azure.ai.formrecognizer.implementation.models.CopyCustomModelHeaders;
import com.azure.ai.formrecognizer.implementation.models.CopyOperationResult;
import com.azure.ai.formrecognizer.implementation.models.CopyRequest;
import com.azure.ai.formrecognizer.implementation.models.ErrorResponseException;
import com.azure.ai.formrecognizer.implementation.models.GenerateModelCopyAuthorizationHeaders;
import com.azure.ai.formrecognizer.implementation.models.Language;
import com.azure.ai.formrecognizer.implementation.models.Locale;
import com.azure.ai.formrecognizer.implementation.models.Model;
import com.azure.ai.formrecognizer.implementation.models.ModelInfo;
import com.azure.ai.formrecognizer.implementation.models.Models;
import com.azure.ai.formrecognizer.implementation.models.ReadingOrder;
import com.azure.ai.formrecognizer.implementation.models.SourcePath;
import com.azure.ai.formrecognizer.implementation.models.TrainCustomModelAsyncHeaders;
import com.azure.ai.formrecognizer.implementation.models.TrainRequest;
import com.azure.core.annotation.BodyParam;
import com.azure.core.annotation.Delete;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.HeaderParam;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.Post;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.http.HttpPipeline;
import com.azure.core.http.HttpPipelineBuilder;
import com.azure.core.http.policy.CookiePolicy;
import com.azure.core.http.policy.RetryPolicy;
import com.azure.core.http.policy.UserAgentPolicy;
import com.azure.core.http.rest.PagedFlux;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.PagedResponse;
import com.azure.core.http.rest.PagedResponseBase;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.ResponseBase;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.util.BinaryData;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import com.azure.core.util.polling.DefaultPollingStrategy;
import com.azure.core.util.polling.PollerFlux;
import com.azure.core.util.polling.SyncDefaultPollingStrategy;
import com.azure.core.util.polling.SyncPoller;
import com.azure.core.util.serializer.JacksonAdapter;
import com.azure.core.util.serializer.SerializerAdapter;
import com.azure.core.util.serializer.TypeReference;
import java.nio.ByteBuffer;
import java.time.Duration;
import java.util.List;
import java.util.Objects;
import java.util.UUID;
import java.util.stream.Collectors;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

/** Initializes a new instance of the FormRecognizerClient type. */
public final class FormRecognizerClientImpl {
    /** The proxy service used to perform REST calls. */
    private final FormRecognizerClientService service;

    /**
     * Supported Cognitive Services endpoints (protocol and hostname, for example:
     * https://westus2.api.cognitive.microsoft.com).
     */
    private final String endpoint;

    /**
     * Gets Supported Cognitive Services endpoints (protocol and hostname, for example:
     * https://westus2.api.cognitive.microsoft.com).
     *
     * @return the endpoint value.
     */
    public String getEndpoint() {
        return this.endpoint;
    }

    /** The HTTP pipeline to send requests through. */
    private final HttpPipeline httpPipeline;

    /**
     * Gets The HTTP pipeline to send requests through.
     *
     * @return the httpPipeline value.
     */
    public HttpPipeline getHttpPipeline() {
        return this.httpPipeline;
    }

    /** The serializer to serialize an object into a string. */
    private final SerializerAdapter serializerAdapter;

    /**
     * Gets The serializer to serialize an object into a string.
     *
     * @return the serializerAdapter value.
     */
    public SerializerAdapter getSerializerAdapter() {
        return this.serializerAdapter;
    }

    /**
     * Initializes an instance of FormRecognizerClient client.
     *
     * @param endpoint Supported Cognitive Services endpoints (protocol and hostname, for example:
     *     https://westus2.api.cognitive.microsoft.com).
     */
    FormRecognizerClientImpl(String endpoint) {
        this(
                new HttpPipelineBuilder()
                        .policies(new UserAgentPolicy(), new RetryPolicy(), new CookiePolicy())
                        .build(),
                JacksonAdapter.createDefaultSerializerAdapter(),
                endpoint);
    }

    /**
     * Initializes an instance of FormRecognizerClient client.
     *
     * @param httpPipeline The HTTP pipeline to send requests through.
     * @param endpoint Supported Cognitive Services endpoints (protocol and hostname, for example:
     *     https://westus2.api.cognitive.microsoft.com).
     */
    FormRecognizerClientImpl(HttpPipeline httpPipeline, String endpoint) {
        this(httpPipeline, JacksonAdapter.createDefaultSerializerAdapter(), endpoint);
    }

    /**
     * Initializes an instance of FormRecognizerClient client.
     *
     * @param httpPipeline The HTTP pipeline to send requests through.
     * @param serializerAdapter The serializer to serialize an object into a string.
     * @param endpoint Supported Cognitive Services endpoints (protocol and hostname, for example:
     *     https://westus2.api.cognitive.microsoft.com).
     */
    FormRecognizerClientImpl(HttpPipeline httpPipeline, SerializerAdapter serializerAdapter, String endpoint) {
        this.httpPipeline = httpPipeline;
        this.serializerAdapter = serializerAdapter;
        this.endpoint = endpoint;
        this.service =
                RestProxy.create(FormRecognizerClientService.class, this.httpPipeline, this.getSerializerAdapter());
    }

    /**
     * The interface defining all the services for FormRecognizerClient to be used by the proxy service to perform REST
     * calls.
     */
    @Host("{endpoint}/formrecognizer/v2.1")
    @ServiceInterface(name = "FormRecognizerClient")
    public interface FormRecognizerClientService {
        @Post("/custom/models")
        @ExpectedResponses({201})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<ResponseBase<TrainCustomModelAsyncHeaders, Void>> trainCustomModelAsync(
                @HostParam("endpoint") String endpoint,
                @BodyParam("application/json") TrainRequest trainRequest,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/custom/models")
        @ExpectedResponses({201})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        ResponseBase<TrainCustomModelAsyncHeaders, Void> trainCustomModelAsyncSync(
                @HostParam("endpoint") String endpoint,
                @BodyParam("application/json") TrainRequest trainRequest,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/custom/models/{modelId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<Response<Model>> getCustomModel(
                @HostParam("endpoint") String endpoint,
                @PathParam("modelId") UUID modelId,
                @QueryParam("includeKeys") Boolean includeKeys,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/custom/models/{modelId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Response<Model> getCustomModelSync(
                @HostParam("endpoint") String endpoint,
                @PathParam("modelId") UUID modelId,
                @QueryParam("includeKeys") Boolean includeKeys,
                @HeaderParam("Accept") String accept,
                Context context);

        @Delete("/custom/models/{modelId}")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<Response<Void>> deleteCustomModel(
                @HostParam("endpoint") String endpoint,
                @PathParam("modelId") UUID modelId,
                @HeaderParam("Accept") String accept,
                Context context);

        @Delete("/custom/models/{modelId}")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Response<Void> deleteCustomModelSync(
                @HostParam("endpoint") String endpoint,
                @PathParam("modelId") UUID modelId,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/custom/models/{modelId}/analyze")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<ResponseBase<AnalyzeWithCustomModelHeaders, Void>> analyzeWithCustomModel(
                @HostParam("endpoint") String endpoint,
                @PathParam("modelId") UUID modelId,
                @QueryParam("includeTextDetails") Boolean includeTextDetails,
                @QueryParam("pages") String pages,
                @HeaderParam("Content-Type") ContentType contentType,
                @BodyParam("application/octet-stream") Flux<ByteBuffer> fileStream,
                @HeaderParam("Content-Length") Long contentLength,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/custom/models/{modelId}/analyze")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<ResponseBase<AnalyzeWithCustomModelHeaders, Void>> analyzeWithCustomModel(
                @HostParam("endpoint") String endpoint,
                @PathParam("modelId") UUID modelId,
                @QueryParam("includeTextDetails") Boolean includeTextDetails,
                @QueryParam("pages") String pages,
                @HeaderParam("Content-Type") ContentType contentType,
                @BodyParam("application/octet-stream") BinaryData fileStream,
                @HeaderParam("Content-Length") Long contentLength,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/custom/models/{modelId}/analyze")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        ResponseBase<AnalyzeWithCustomModelHeaders, Void> analyzeWithCustomModelSync(
                @HostParam("endpoint") String endpoint,
                @PathParam("modelId") UUID modelId,
                @QueryParam("includeTextDetails") Boolean includeTextDetails,
                @QueryParam("pages") String pages,
                @HeaderParam("Content-Type") ContentType contentType,
                @BodyParam("application/octet-stream") BinaryData fileStream,
                @HeaderParam("Content-Length") Long contentLength,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/custom/models/{modelId}/analyze")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<ResponseBase<AnalyzeWithCustomModelHeaders, Void>> analyzeWithCustomModel(
                @HostParam("endpoint") String endpoint,
                @PathParam("modelId") UUID modelId,
                @QueryParam("includeTextDetails") Boolean includeTextDetails,
                @QueryParam("pages") String pages,
                @BodyParam("application/json") SourcePath fileStream,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/custom/models/{modelId}/analyze")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        ResponseBase<AnalyzeWithCustomModelHeaders, Void> analyzeWithCustomModelSync(
                @HostParam("endpoint") String endpoint,
                @PathParam("modelId") UUID modelId,
                @QueryParam("includeTextDetails") Boolean includeTextDetails,
                @QueryParam("pages") String pages,
                @BodyParam("application/json") SourcePath fileStream,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/custom/models/{modelId}/analyzeResults/{resultId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<Response<AnalyzeOperationResult>> getAnalyzeFormResult(
                @HostParam("endpoint") String endpoint,
                @PathParam("modelId") UUID modelId,
                @PathParam("resultId") UUID resultId,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/custom/models/{modelId}/analyzeResults/{resultId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Response<AnalyzeOperationResult> getAnalyzeFormResultSync(
                @HostParam("endpoint") String endpoint,
                @PathParam("modelId") UUID modelId,
                @PathParam("resultId") UUID resultId,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/custom/models/{modelId}/copy")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<ResponseBase<CopyCustomModelHeaders, Void>> copyCustomModel(
                @HostParam("endpoint") String endpoint,
                @PathParam("modelId") UUID modelId,
                @BodyParam("application/json") CopyRequest copyRequest,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/custom/models/{modelId}/copy")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        ResponseBase<CopyCustomModelHeaders, Void> copyCustomModelSync(
                @HostParam("endpoint") String endpoint,
                @PathParam("modelId") UUID modelId,
                @BodyParam("application/json") CopyRequest copyRequest,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/custom/models/{modelId}/copyResults/{resultId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<Response<CopyOperationResult>> getCustomModelCopyResult(
                @HostParam("endpoint") String endpoint,
                @PathParam("modelId") UUID modelId,
                @PathParam("resultId") UUID resultId,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/custom/models/{modelId}/copyResults/{resultId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Response<CopyOperationResult> getCustomModelCopyResultSync(
                @HostParam("endpoint") String endpoint,
                @PathParam("modelId") UUID modelId,
                @PathParam("resultId") UUID resultId,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/custom/models/copyAuthorization")
        @ExpectedResponses({201})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<ResponseBase<GenerateModelCopyAuthorizationHeaders, CopyAuthorizationResult>>
                generateModelCopyAuthorization(
                        @HostParam("endpoint") String endpoint, @HeaderParam("Accept") String accept, Context context);

        @Post("/custom/models/copyAuthorization")
        @ExpectedResponses({201})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        ResponseBase<GenerateModelCopyAuthorizationHeaders, CopyAuthorizationResult> generateModelCopyAuthorizationSync(
                @HostParam("endpoint") String endpoint, @HeaderParam("Accept") String accept, Context context);

        @Post("/custom/models/compose")
        @ExpectedResponses({201})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<ResponseBase<ComposeCustomModelsAsyncHeaders, Void>> composeCustomModelsAsync(
                @HostParam("endpoint") String endpoint,
                @BodyParam("application/json") ComposeRequest composeRequest,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/custom/models/compose")
        @ExpectedResponses({201})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        ResponseBase<ComposeCustomModelsAsyncHeaders, Void> composeCustomModelsAsyncSync(
                @HostParam("endpoint") String endpoint,
                @BodyParam("application/json") ComposeRequest composeRequest,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/prebuilt/businessCard/analyze")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<ResponseBase<AnalyzeBusinessCardAsyncHeaders, Void>> analyzeBusinessCardAsync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("includeTextDetails") Boolean includeTextDetails,
                @QueryParam("locale") Locale locale,
                @QueryParam("pages") String pages,
                @HeaderParam("Content-Type") ContentType contentType,
                @BodyParam("application/octet-stream") Flux<ByteBuffer> fileStream,
                @HeaderParam("Content-Length") Long contentLength,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/prebuilt/businessCard/analyze")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<ResponseBase<AnalyzeBusinessCardAsyncHeaders, Void>> analyzeBusinessCardAsync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("includeTextDetails") Boolean includeTextDetails,
                @QueryParam("locale") Locale locale,
                @QueryParam("pages") String pages,
                @HeaderParam("Content-Type") ContentType contentType,
                @BodyParam("application/octet-stream") BinaryData fileStream,
                @HeaderParam("Content-Length") Long contentLength,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/prebuilt/businessCard/analyze")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        ResponseBase<AnalyzeBusinessCardAsyncHeaders, Void> analyzeBusinessCardAsyncSync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("includeTextDetails") Boolean includeTextDetails,
                @QueryParam("locale") Locale locale,
                @QueryParam("pages") String pages,
                @HeaderParam("Content-Type") ContentType contentType,
                @BodyParam("application/octet-stream") BinaryData fileStream,
                @HeaderParam("Content-Length") Long contentLength,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/prebuilt/businessCard/analyze")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<ResponseBase<AnalyzeBusinessCardAsyncHeaders, Void>> analyzeBusinessCardAsync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("includeTextDetails") Boolean includeTextDetails,
                @QueryParam("locale") Locale locale,
                @QueryParam("pages") String pages,
                @BodyParam("application/json") SourcePath fileStream,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/prebuilt/businessCard/analyze")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        ResponseBase<AnalyzeBusinessCardAsyncHeaders, Void> analyzeBusinessCardAsyncSync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("includeTextDetails") Boolean includeTextDetails,
                @QueryParam("locale") Locale locale,
                @QueryParam("pages") String pages,
                @BodyParam("application/json") SourcePath fileStream,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/prebuilt/businessCard/analyzeResults/{resultId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<Response<AnalyzeOperationResult>> getAnalyzeBusinessCardResult(
                @HostParam("endpoint") String endpoint,
                @PathParam("resultId") UUID resultId,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/prebuilt/businessCard/analyzeResults/{resultId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Response<AnalyzeOperationResult> getAnalyzeBusinessCardResultSync(
                @HostParam("endpoint") String endpoint,
                @PathParam("resultId") UUID resultId,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/prebuilt/invoice/analyze")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<ResponseBase<AnalyzeInvoiceAsyncHeaders, Void>> analyzeInvoiceAsync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("includeTextDetails") Boolean includeTextDetails,
                @QueryParam("locale") Locale locale,
                @QueryParam("pages") String pages,
                @HeaderParam("Content-Type") ContentType contentType,
                @BodyParam("application/octet-stream") Flux<ByteBuffer> fileStream,
                @HeaderParam("Content-Length") Long contentLength,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/prebuilt/invoice/analyze")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<ResponseBase<AnalyzeInvoiceAsyncHeaders, Void>> analyzeInvoiceAsync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("includeTextDetails") Boolean includeTextDetails,
                @QueryParam("locale") Locale locale,
                @QueryParam("pages") String pages,
                @HeaderParam("Content-Type") ContentType contentType,
                @BodyParam("application/octet-stream") BinaryData fileStream,
                @HeaderParam("Content-Length") Long contentLength,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/prebuilt/invoice/analyze")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        ResponseBase<AnalyzeInvoiceAsyncHeaders, Void> analyzeInvoiceAsyncSync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("includeTextDetails") Boolean includeTextDetails,
                @QueryParam("locale") Locale locale,
                @QueryParam("pages") String pages,
                @HeaderParam("Content-Type") ContentType contentType,
                @BodyParam("application/octet-stream") BinaryData fileStream,
                @HeaderParam("Content-Length") Long contentLength,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/prebuilt/invoice/analyze")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<ResponseBase<AnalyzeInvoiceAsyncHeaders, Void>> analyzeInvoiceAsync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("includeTextDetails") Boolean includeTextDetails,
                @QueryParam("locale") Locale locale,
                @QueryParam("pages") String pages,
                @BodyParam("application/json") SourcePath fileStream,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/prebuilt/invoice/analyze")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        ResponseBase<AnalyzeInvoiceAsyncHeaders, Void> analyzeInvoiceAsyncSync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("includeTextDetails") Boolean includeTextDetails,
                @QueryParam("locale") Locale locale,
                @QueryParam("pages") String pages,
                @BodyParam("application/json") SourcePath fileStream,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/prebuilt/invoice/analyzeResults/{resultId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<Response<AnalyzeOperationResult>> getAnalyzeInvoiceResult(
                @HostParam("endpoint") String endpoint,
                @PathParam("resultId") UUID resultId,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/prebuilt/invoice/analyzeResults/{resultId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Response<AnalyzeOperationResult> getAnalyzeInvoiceResultSync(
                @HostParam("endpoint") String endpoint,
                @PathParam("resultId") UUID resultId,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/prebuilt/idDocument/analyze")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<ResponseBase<AnalyzeIdDocumentAsyncHeaders, Void>> analyzeIdDocumentAsync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("includeTextDetails") Boolean includeTextDetails,
                @QueryParam("pages") String pages,
                @HeaderParam("Content-Type") ContentType contentType,
                @BodyParam("application/octet-stream") Flux<ByteBuffer> fileStream,
                @HeaderParam("Content-Length") Long contentLength,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/prebuilt/idDocument/analyze")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<ResponseBase<AnalyzeIdDocumentAsyncHeaders, Void>> analyzeIdDocumentAsync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("includeTextDetails") Boolean includeTextDetails,
                @QueryParam("pages") String pages,
                @HeaderParam("Content-Type") ContentType contentType,
                @BodyParam("application/octet-stream") BinaryData fileStream,
                @HeaderParam("Content-Length") Long contentLength,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/prebuilt/idDocument/analyze")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        ResponseBase<AnalyzeIdDocumentAsyncHeaders, Void> analyzeIdDocumentAsyncSync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("includeTextDetails") Boolean includeTextDetails,
                @QueryParam("pages") String pages,
                @HeaderParam("Content-Type") ContentType contentType,
                @BodyParam("application/octet-stream") BinaryData fileStream,
                @HeaderParam("Content-Length") Long contentLength,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/prebuilt/idDocument/analyze")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<ResponseBase<AnalyzeIdDocumentAsyncHeaders, Void>> analyzeIdDocumentAsync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("includeTextDetails") Boolean includeTextDetails,
                @QueryParam("pages") String pages,
                @BodyParam("application/json") SourcePath fileStream,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/prebuilt/idDocument/analyze")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        ResponseBase<AnalyzeIdDocumentAsyncHeaders, Void> analyzeIdDocumentAsyncSync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("includeTextDetails") Boolean includeTextDetails,
                @QueryParam("pages") String pages,
                @BodyParam("application/json") SourcePath fileStream,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/prebuilt/idDocument/analyzeResults/{resultId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<Response<AnalyzeOperationResult>> getAnalyzeIdDocumentResult(
                @HostParam("endpoint") String endpoint,
                @PathParam("resultId") UUID resultId,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/prebuilt/idDocument/analyzeResults/{resultId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Response<AnalyzeOperationResult> getAnalyzeIdDocumentResultSync(
                @HostParam("endpoint") String endpoint,
                @PathParam("resultId") UUID resultId,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/prebuilt/receipt/analyze")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<ResponseBase<AnalyzeReceiptAsyncHeaders, Void>> analyzeReceiptAsync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("includeTextDetails") Boolean includeTextDetails,
                @QueryParam("locale") Locale locale,
                @QueryParam("pages") String pages,
                @HeaderParam("Content-Type") ContentType contentType,
                @BodyParam("application/octet-stream") Flux<ByteBuffer> fileStream,
                @HeaderParam("Content-Length") Long contentLength,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/prebuilt/receipt/analyze")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<ResponseBase<AnalyzeReceiptAsyncHeaders, Void>> analyzeReceiptAsync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("includeTextDetails") Boolean includeTextDetails,
                @QueryParam("locale") Locale locale,
                @QueryParam("pages") String pages,
                @HeaderParam("Content-Type") ContentType contentType,
                @BodyParam("application/octet-stream") BinaryData fileStream,
                @HeaderParam("Content-Length") Long contentLength,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/prebuilt/receipt/analyze")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        ResponseBase<AnalyzeReceiptAsyncHeaders, Void> analyzeReceiptAsyncSync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("includeTextDetails") Boolean includeTextDetails,
                @QueryParam("locale") Locale locale,
                @QueryParam("pages") String pages,
                @HeaderParam("Content-Type") ContentType contentType,
                @BodyParam("application/octet-stream") BinaryData fileStream,
                @HeaderParam("Content-Length") Long contentLength,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/prebuilt/receipt/analyze")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<ResponseBase<AnalyzeReceiptAsyncHeaders, Void>> analyzeReceiptAsync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("includeTextDetails") Boolean includeTextDetails,
                @QueryParam("locale") Locale locale,
                @QueryParam("pages") String pages,
                @BodyParam("application/json") SourcePath fileStream,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/prebuilt/receipt/analyze")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        ResponseBase<AnalyzeReceiptAsyncHeaders, Void> analyzeReceiptAsyncSync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("includeTextDetails") Boolean includeTextDetails,
                @QueryParam("locale") Locale locale,
                @QueryParam("pages") String pages,
                @BodyParam("application/json") SourcePath fileStream,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/prebuilt/receipt/analyzeResults/{resultId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<Response<AnalyzeOperationResult>> getAnalyzeReceiptResult(
                @HostParam("endpoint") String endpoint,
                @PathParam("resultId") UUID resultId,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/prebuilt/receipt/analyzeResults/{resultId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Response<AnalyzeOperationResult> getAnalyzeReceiptResultSync(
                @HostParam("endpoint") String endpoint,
                @PathParam("resultId") UUID resultId,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/layout/analyze")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<ResponseBase<AnalyzeLayoutAsyncHeaders, Void>> analyzeLayoutAsync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("pages") String pages,
                @QueryParam("language") Language language,
                @QueryParam("readingOrder") ReadingOrder readingOrder,
                @HeaderParam("Content-Type") ContentType contentType,
                @BodyParam("application/octet-stream") Flux<ByteBuffer> fileStream,
                @HeaderParam("Content-Length") Long contentLength,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/layout/analyze")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<ResponseBase<AnalyzeLayoutAsyncHeaders, Void>> analyzeLayoutAsync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("pages") String pages,
                @QueryParam("language") Language language,
                @QueryParam("readingOrder") ReadingOrder readingOrder,
                @HeaderParam("Content-Type") ContentType contentType,
                @BodyParam("application/octet-stream") BinaryData fileStream,
                @HeaderParam("Content-Length") Long contentLength,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/layout/analyze")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        ResponseBase<AnalyzeLayoutAsyncHeaders, Void> analyzeLayoutAsyncSync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("pages") String pages,
                @QueryParam("language") Language language,
                @QueryParam("readingOrder") ReadingOrder readingOrder,
                @HeaderParam("Content-Type") ContentType contentType,
                @BodyParam("application/octet-stream") BinaryData fileStream,
                @HeaderParam("Content-Length") Long contentLength,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/layout/analyze")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<ResponseBase<AnalyzeLayoutAsyncHeaders, Void>> analyzeLayoutAsync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("pages") String pages,
                @QueryParam("language") Language language,
                @QueryParam("readingOrder") ReadingOrder readingOrder,
                @BodyParam("application/json") SourcePath fileStream,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/layout/analyze")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        ResponseBase<AnalyzeLayoutAsyncHeaders, Void> analyzeLayoutAsyncSync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("pages") String pages,
                @QueryParam("language") Language language,
                @QueryParam("readingOrder") ReadingOrder readingOrder,
                @BodyParam("application/json") SourcePath fileStream,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/layout/analyzeResults/{resultId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<Response<AnalyzeOperationResult>> getAnalyzeLayoutResult(
                @HostParam("endpoint") String endpoint,
                @PathParam("resultId") UUID resultId,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/layout/analyzeResults/{resultId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Response<AnalyzeOperationResult> getAnalyzeLayoutResultSync(
                @HostParam("endpoint") String endpoint,
                @PathParam("resultId") UUID resultId,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/custom/models")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<Response<Models>> listCustomModels(
                @HostParam("endpoint") String endpoint,
                @QueryParam("op") String op,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/custom/models")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Response<Models> listCustomModelsSync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("op") String op,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/custom/models")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<Response<Models>> getCustomModels(
                @HostParam("endpoint") String endpoint,
                @QueryParam("op") String op,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/custom/models")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Response<Models> getCustomModelsSync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("op") String op,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<Response<Models>> listCustomModelsNext(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Response<Models> listCustomModelsNextSync(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                @HeaderParam("Accept") String accept,
                Context context);
    }

    /**
     * Train Custom Model
     *
     * <p>Create and train a custom model. The request must include a source parameter that is either an externally
     * accessible Azure storage blob container Uri (preferably a Shared Access Signature Uri) or valid path to a data
     * folder in a locally mounted drive. When local paths are specified, they must follow the Linux/Unix path format
     * and be an absolute path rooted to the input mount configuration setting value e.g., if '{Mounts:Input}'
     * configuration setting value is '/input' then a valid source path would be '/input/contosodataset'. All data to be
     * trained is expected to be under the source folder or sub folders under it. Models are trained using documents
     * that are of the following content type - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or
     * 'image/bmp'. Other type of content is ignored.
     *
     * @param trainRequest Training request parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<TrainCustomModelAsyncHeaders, Void>> trainCustomModelAsyncWithResponseAsync(
            TrainRequest trainRequest) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context -> service.trainCustomModelAsync(this.getEndpoint(), trainRequest, accept, context));
    }

    /**
     * Train Custom Model
     *
     * <p>Create and train a custom model. The request must include a source parameter that is either an externally
     * accessible Azure storage blob container Uri (preferably a Shared Access Signature Uri) or valid path to a data
     * folder in a locally mounted drive. When local paths are specified, they must follow the Linux/Unix path format
     * and be an absolute path rooted to the input mount configuration setting value e.g., if '{Mounts:Input}'
     * configuration setting value is '/input' then a valid source path would be '/input/contosodataset'. All data to be
     * trained is expected to be under the source folder or sub folders under it. Models are trained using documents
     * that are of the following content type - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or
     * 'image/bmp'. Other type of content is ignored.
     *
     * @param trainRequest Training request parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<TrainCustomModelAsyncHeaders, Void>> trainCustomModelAsyncWithResponseAsync(
            TrainRequest trainRequest, Context context) {
        final String accept = "application/json";
        return service.trainCustomModelAsync(this.getEndpoint(), trainRequest, accept, context);
    }

    /**
     * Train Custom Model
     *
     * <p>Create and train a custom model. The request must include a source parameter that is either an externally
     * accessible Azure storage blob container Uri (preferably a Shared Access Signature Uri) or valid path to a data
     * folder in a locally mounted drive. When local paths are specified, they must follow the Linux/Unix path format
     * and be an absolute path rooted to the input mount configuration setting value e.g., if '{Mounts:Input}'
     * configuration setting value is '/input' then a valid source path would be '/input/contosodataset'. All data to be
     * trained is expected to be under the source folder or sub folders under it. Models are trained using documents
     * that are of the following content type - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or
     * 'image/bmp'. Other type of content is ignored.
     *
     * @param trainRequest Training request parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ResponseBase<TrainCustomModelAsyncHeaders, Void> trainCustomModelAsyncWithResponse(
            TrainRequest trainRequest, Context context) {
        final String accept = "application/json";
        return service.trainCustomModelAsyncSync(this.getEndpoint(), trainRequest, accept, context);
    }

    /**
     * Train Custom Model
     *
     * <p>Create and train a custom model. The request must include a source parameter that is either an externally
     * accessible Azure storage blob container Uri (preferably a Shared Access Signature Uri) or valid path to a data
     * folder in a locally mounted drive. When local paths are specified, they must follow the Linux/Unix path format
     * and be an absolute path rooted to the input mount configuration setting value e.g., if '{Mounts:Input}'
     * configuration setting value is '/input' then a valid source path would be '/input/contosodataset'. All data to be
     * trained is expected to be under the source folder or sub folders under it. Models are trained using documents
     * that are of the following content type - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or
     * 'image/bmp'. Other type of content is ignored.
     *
     * @param trainRequest Training request parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginTrainCustomModelAsyncAsync(TrainRequest trainRequest) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () -> this.trainCustomModelAsyncWithResponseAsync(trainRequest),
                new DefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        Context.NONE),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Train Custom Model
     *
     * <p>Create and train a custom model. The request must include a source parameter that is either an externally
     * accessible Azure storage blob container Uri (preferably a Shared Access Signature Uri) or valid path to a data
     * folder in a locally mounted drive. When local paths are specified, they must follow the Linux/Unix path format
     * and be an absolute path rooted to the input mount configuration setting value e.g., if '{Mounts:Input}'
     * configuration setting value is '/input' then a valid source path would be '/input/contosodataset'. All data to be
     * trained is expected to be under the source folder or sub folders under it. Models are trained using documents
     * that are of the following content type - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or
     * 'image/bmp'. Other type of content is ignored.
     *
     * @param trainRequest Training request parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginTrainCustomModelAsyncAsync(
            TrainRequest trainRequest, Context context) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () -> this.trainCustomModelAsyncWithResponseAsync(trainRequest, context),
                new DefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        context),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Train Custom Model
     *
     * <p>Create and train a custom model. The request must include a source parameter that is either an externally
     * accessible Azure storage blob container Uri (preferably a Shared Access Signature Uri) or valid path to a data
     * folder in a locally mounted drive. When local paths are specified, they must follow the Linux/Unix path format
     * and be an absolute path rooted to the input mount configuration setting value e.g., if '{Mounts:Input}'
     * configuration setting value is '/input' then a valid source path would be '/input/contosodataset'. All data to be
     * trained is expected to be under the source folder or sub folders under it. Models are trained using documents
     * that are of the following content type - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or
     * 'image/bmp'. Other type of content is ignored.
     *
     * @param trainRequest Training request parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginTrainCustomModelAsync(TrainRequest trainRequest) {
        return SyncPoller.createPoller(
                Duration.ofSeconds(1),
                () -> this.trainCustomModelAsyncWithResponse(trainRequest, Context.NONE),
                new SyncDefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        Context.NONE),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Train Custom Model
     *
     * <p>Create and train a custom model. The request must include a source parameter that is either an externally
     * accessible Azure storage blob container Uri (preferably a Shared Access Signature Uri) or valid path to a data
     * folder in a locally mounted drive. When local paths are specified, they must follow the Linux/Unix path format
     * and be an absolute path rooted to the input mount configuration setting value e.g., if '{Mounts:Input}'
     * configuration setting value is '/input' then a valid source path would be '/input/contosodataset'. All data to be
     * trained is expected to be under the source folder or sub folders under it. Models are trained using documents
     * that are of the following content type - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or
     * 'image/bmp'. Other type of content is ignored.
     *
     * @param trainRequest Training request parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginTrainCustomModelAsync(TrainRequest trainRequest, Context context) {
        return SyncPoller.createPoller(
                Duration.ofSeconds(1),
                () -> this.trainCustomModelAsyncWithResponse(trainRequest, context),
                new SyncDefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        context),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Get Custom Model
     *
     * <p>Get detailed information about a custom model.
     *
     * @param modelId Model identifier.
     * @param includeKeys Include list of extracted keys in model information.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return detailed information about a custom model along with {@link Response} on successful completion of {@link
     *     Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Model>> getCustomModelWithResponseAsync(UUID modelId, Boolean includeKeys) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context -> service.getCustomModel(this.getEndpoint(), modelId, includeKeys, accept, context));
    }

    /**
     * Get Custom Model
     *
     * <p>Get detailed information about a custom model.
     *
     * @param modelId Model identifier.
     * @param includeKeys Include list of extracted keys in model information.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return detailed information about a custom model along with {@link Response} on successful completion of {@link
     *     Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Model>> getCustomModelWithResponseAsync(UUID modelId, Boolean includeKeys, Context context) {
        final String accept = "application/json";
        return service.getCustomModel(this.getEndpoint(), modelId, includeKeys, accept, context);
    }

    /**
     * Get Custom Model
     *
     * <p>Get detailed information about a custom model.
     *
     * @param modelId Model identifier.
     * @param includeKeys Include list of extracted keys in model information.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return detailed information about a custom model on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Model> getCustomModelAsync(UUID modelId, Boolean includeKeys) {
        return getCustomModelWithResponseAsync(modelId, includeKeys).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get Custom Model
     *
     * <p>Get detailed information about a custom model.
     *
     * @param modelId Model identifier.
     * @param includeKeys Include list of extracted keys in model information.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return detailed information about a custom model on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Model> getCustomModelAsync(UUID modelId, Boolean includeKeys, Context context) {
        return getCustomModelWithResponseAsync(modelId, includeKeys, context)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get Custom Model
     *
     * <p>Get detailed information about a custom model.
     *
     * @param modelId Model identifier.
     * @param includeKeys Include list of extracted keys in model information.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return detailed information about a custom model along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Model> getCustomModelWithResponse(UUID modelId, Boolean includeKeys, Context context) {
        final String accept = "application/json";
        return service.getCustomModelSync(this.getEndpoint(), modelId, includeKeys, accept, context);
    }

    /**
     * Get Custom Model
     *
     * <p>Get detailed information about a custom model.
     *
     * @param modelId Model identifier.
     * @param includeKeys Include list of extracted keys in model information.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return detailed information about a custom model.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Model getCustomModel(UUID modelId, Boolean includeKeys) {
        return getCustomModelWithResponse(modelId, includeKeys, Context.NONE).getValue();
    }

    /**
     * Delete Custom Model
     *
     * <p>Mark model for deletion. Model artifacts will be permanently removed within a predetermined period.
     *
     * @param modelId Model identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteCustomModelWithResponseAsync(UUID modelId) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.deleteCustomModel(this.getEndpoint(), modelId, accept, context));
    }

    /**
     * Delete Custom Model
     *
     * <p>Mark model for deletion. Model artifacts will be permanently removed within a predetermined period.
     *
     * @param modelId Model identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteCustomModelWithResponseAsync(UUID modelId, Context context) {
        final String accept = "application/json";
        return service.deleteCustomModel(this.getEndpoint(), modelId, accept, context);
    }

    /**
     * Delete Custom Model
     *
     * <p>Mark model for deletion. Model artifacts will be permanently removed within a predetermined period.
     *
     * @param modelId Model identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteCustomModelAsync(UUID modelId) {
        return deleteCustomModelWithResponseAsync(modelId).flatMap(ignored -> Mono.empty());
    }

    /**
     * Delete Custom Model
     *
     * <p>Mark model for deletion. Model artifacts will be permanently removed within a predetermined period.
     *
     * @param modelId Model identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteCustomModelAsync(UUID modelId, Context context) {
        return deleteCustomModelWithResponseAsync(modelId, context).flatMap(ignored -> Mono.empty());
    }

    /**
     * Delete Custom Model
     *
     * <p>Mark model for deletion. Model artifacts will be permanently removed within a predetermined period.
     *
     * @param modelId Model identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteCustomModelWithResponse(UUID modelId, Context context) {
        final String accept = "application/json";
        return service.deleteCustomModelSync(this.getEndpoint(), modelId, accept, context);
    }

    /**
     * Delete Custom Model
     *
     * <p>Mark model for deletion. Model artifacts will be permanently removed within a predetermined period.
     *
     * @param modelId Model identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteCustomModel(UUID modelId) {
        deleteCustomModelWithResponse(modelId, Context.NONE);
    }

    /**
     * Analyze Form
     *
     * <p>Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one
     * of the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri or local path) of the document to be
     * analyzed.
     *
     * @param modelId Model identifier.
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeWithCustomModelHeaders, Void>> analyzeWithCustomModelWithResponseAsync(
            UUID modelId,
            ContentType contentType,
            Boolean includeTextDetails,
            List<String> pages,
            Flux<ByteBuffer> fileStream,
            Long contentLength) {
        final String accept = "application/json";
        String pagesConverted =
                (pages == null)
                        ? null
                        : pages.stream().map(value -> Objects.toString(value, "")).collect(Collectors.joining(","));
        return FluxUtil.withContext(
                context ->
                        service.analyzeWithCustomModel(
                                this.getEndpoint(),
                                modelId,
                                includeTextDetails,
                                pagesConverted,
                                contentType,
                                fileStream,
                                contentLength,
                                accept,
                                context));
    }

    /**
     * Analyze Form
     *
     * <p>Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one
     * of the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri or local path) of the document to be
     * analyzed.
     *
     * @param modelId Model identifier.
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeWithCustomModelHeaders, Void>> analyzeWithCustomModelWithResponseAsync(
            UUID modelId,
            ContentType contentType,
            Boolean includeTextDetails,
            List<String> pages,
            Flux<ByteBuffer> fileStream,
            Long contentLength,
            Context context) {
        final String accept = "application/json";
        String pagesConverted =
                (pages == null)
                        ? null
                        : pages.stream().map(value -> Objects.toString(value, "")).collect(Collectors.joining(","));
        return service.analyzeWithCustomModel(
                this.getEndpoint(),
                modelId,
                includeTextDetails,
                pagesConverted,
                contentType,
                fileStream,
                contentLength,
                accept,
                context);
    }

    /**
     * Analyze Form
     *
     * <p>Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one
     * of the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri or local path) of the document to be
     * analyzed.
     *
     * @param modelId Model identifier.
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginAnalyzeWithCustomModelAsync(
            UUID modelId,
            ContentType contentType,
            Boolean includeTextDetails,
            List<String> pages,
            Flux<ByteBuffer> fileStream,
            Long contentLength) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () ->
                        this.analyzeWithCustomModelWithResponseAsync(
                                modelId, contentType, includeTextDetails, pages, fileStream, contentLength),
                new DefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        Context.NONE),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze Form
     *
     * <p>Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one
     * of the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri or local path) of the document to be
     * analyzed.
     *
     * @param modelId Model identifier.
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginAnalyzeWithCustomModelAsync(
            UUID modelId,
            ContentType contentType,
            Boolean includeTextDetails,
            List<String> pages,
            Flux<ByteBuffer> fileStream,
            Long contentLength,
            Context context) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () ->
                        this.analyzeWithCustomModelWithResponseAsync(
                                modelId, contentType, includeTextDetails, pages, fileStream, contentLength, context),
                new DefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        context),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze Form
     *
     * <p>Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one
     * of the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri or local path) of the document to be
     * analyzed.
     *
     * @param modelId Model identifier.
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeWithCustomModelHeaders, Void>> analyzeWithCustomModelWithResponseAsync(
            UUID modelId,
            ContentType contentType,
            Boolean includeTextDetails,
            List<String> pages,
            BinaryData fileStream,
            Long contentLength) {
        final String accept = "application/json";
        String pagesConverted =
                (pages == null)
                        ? null
                        : pages.stream().map(value -> Objects.toString(value, "")).collect(Collectors.joining(","));
        return FluxUtil.withContext(
                context ->
                        service.analyzeWithCustomModel(
                                this.getEndpoint(),
                                modelId,
                                includeTextDetails,
                                pagesConverted,
                                contentType,
                                fileStream,
                                contentLength,
                                accept,
                                context));
    }

    /**
     * Analyze Form
     *
     * <p>Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one
     * of the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri or local path) of the document to be
     * analyzed.
     *
     * @param modelId Model identifier.
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeWithCustomModelHeaders, Void>> analyzeWithCustomModelWithResponseAsync(
            UUID modelId,
            ContentType contentType,
            Boolean includeTextDetails,
            List<String> pages,
            BinaryData fileStream,
            Long contentLength,
            Context context) {
        final String accept = "application/json";
        String pagesConverted =
                (pages == null)
                        ? null
                        : pages.stream().map(value -> Objects.toString(value, "")).collect(Collectors.joining(","));
        return service.analyzeWithCustomModel(
                this.getEndpoint(),
                modelId,
                includeTextDetails,
                pagesConverted,
                contentType,
                fileStream,
                contentLength,
                accept,
                context);
    }

    /**
     * Analyze Form
     *
     * <p>Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one
     * of the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri or local path) of the document to be
     * analyzed.
     *
     * @param modelId Model identifier.
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ResponseBase<AnalyzeWithCustomModelHeaders, Void> analyzeWithCustomModelWithResponse(
            UUID modelId,
            ContentType contentType,
            Boolean includeTextDetails,
            List<String> pages,
            BinaryData fileStream,
            Long contentLength,
            Context context) {
        final String accept = "application/json";
        String pagesConverted =
                (pages == null)
                        ? null
                        : pages.stream().map(value -> Objects.toString(value, "")).collect(Collectors.joining(","));
        return service.analyzeWithCustomModelSync(
                this.getEndpoint(),
                modelId,
                includeTextDetails,
                pagesConverted,
                contentType,
                fileStream,
                contentLength,
                accept,
                context);
    }

    /**
     * Analyze Form
     *
     * <p>Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one
     * of the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri or local path) of the document to be
     * analyzed.
     *
     * @param modelId Model identifier.
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginAnalyzeWithCustomModelAsync(
            UUID modelId,
            ContentType contentType,
            Boolean includeTextDetails,
            List<String> pages,
            BinaryData fileStream,
            Long contentLength) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () ->
                        this.analyzeWithCustomModelWithResponseAsync(
                                modelId, contentType, includeTextDetails, pages, fileStream, contentLength),
                new DefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        Context.NONE),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze Form
     *
     * <p>Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one
     * of the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri or local path) of the document to be
     * analyzed.
     *
     * @param modelId Model identifier.
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginAnalyzeWithCustomModelAsync(
            UUID modelId,
            ContentType contentType,
            Boolean includeTextDetails,
            List<String> pages,
            BinaryData fileStream,
            Long contentLength,
            Context context) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () ->
                        this.analyzeWithCustomModelWithResponseAsync(
                                modelId, contentType, includeTextDetails, pages, fileStream, contentLength, context),
                new DefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        context),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze Form
     *
     * <p>Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one
     * of the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri or local path) of the document to be
     * analyzed.
     *
     * @param modelId Model identifier.
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginAnalyzeWithCustomModel(
            UUID modelId,
            ContentType contentType,
            Boolean includeTextDetails,
            List<String> pages,
            BinaryData fileStream,
            Long contentLength) {
        return SyncPoller.createPoller(
                Duration.ofSeconds(1),
                () ->
                        this.analyzeWithCustomModelWithResponse(
                                modelId,
                                contentType,
                                includeTextDetails,
                                pages,
                                fileStream,
                                contentLength,
                                Context.NONE),
                new SyncDefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        Context.NONE),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze Form
     *
     * <p>Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one
     * of the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri or local path) of the document to be
     * analyzed.
     *
     * @param modelId Model identifier.
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginAnalyzeWithCustomModel(
            UUID modelId,
            ContentType contentType,
            Boolean includeTextDetails,
            List<String> pages,
            BinaryData fileStream,
            Long contentLength,
            Context context) {
        return SyncPoller.createPoller(
                Duration.ofSeconds(1),
                () ->
                        this.analyzeWithCustomModelWithResponse(
                                modelId, contentType, includeTextDetails, pages, fileStream, contentLength, context),
                new SyncDefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        context),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze Form
     *
     * <p>Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one
     * of the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri or local path) of the document to be
     * analyzed.
     *
     * @param modelId Model identifier.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeWithCustomModelHeaders, Void>> analyzeWithCustomModelWithResponseAsync(
            UUID modelId, Boolean includeTextDetails, List<String> pages, SourcePath fileStream) {
        final String accept = "application/json";
        String pagesConverted =
                (pages == null)
                        ? null
                        : pages.stream().map(value -> Objects.toString(value, "")).collect(Collectors.joining(","));
        return FluxUtil.withContext(
                context ->
                        service.analyzeWithCustomModel(
                                this.getEndpoint(),
                                modelId,
                                includeTextDetails,
                                pagesConverted,
                                fileStream,
                                accept,
                                context));
    }

    /**
     * Analyze Form
     *
     * <p>Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one
     * of the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri or local path) of the document to be
     * analyzed.
     *
     * @param modelId Model identifier.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeWithCustomModelHeaders, Void>> analyzeWithCustomModelWithResponseAsync(
            UUID modelId, Boolean includeTextDetails, List<String> pages, SourcePath fileStream, Context context) {
        final String accept = "application/json";
        String pagesConverted =
                (pages == null)
                        ? null
                        : pages.stream().map(value -> Objects.toString(value, "")).collect(Collectors.joining(","));
        return service.analyzeWithCustomModel(
                this.getEndpoint(), modelId, includeTextDetails, pagesConverted, fileStream, accept, context);
    }

    /**
     * Analyze Form
     *
     * <p>Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one
     * of the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri or local path) of the document to be
     * analyzed.
     *
     * @param modelId Model identifier.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ResponseBase<AnalyzeWithCustomModelHeaders, Void> analyzeWithCustomModelWithResponse(
            UUID modelId, Boolean includeTextDetails, List<String> pages, SourcePath fileStream, Context context) {
        final String accept = "application/json";
        String pagesConverted =
                (pages == null)
                        ? null
                        : pages.stream().map(value -> Objects.toString(value, "")).collect(Collectors.joining(","));
        return service.analyzeWithCustomModelSync(
                this.getEndpoint(), modelId, includeTextDetails, pagesConverted, fileStream, accept, context);
    }

    /**
     * Analyze Form
     *
     * <p>Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one
     * of the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri or local path) of the document to be
     * analyzed.
     *
     * @param modelId Model identifier.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginAnalyzeWithCustomModelAsync(
            UUID modelId, Boolean includeTextDetails, List<String> pages, SourcePath fileStream) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () -> this.analyzeWithCustomModelWithResponseAsync(modelId, includeTextDetails, pages, fileStream),
                new DefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        Context.NONE),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze Form
     *
     * <p>Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one
     * of the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri or local path) of the document to be
     * analyzed.
     *
     * @param modelId Model identifier.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginAnalyzeWithCustomModelAsync(
            UUID modelId, Boolean includeTextDetails, List<String> pages, SourcePath fileStream, Context context) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () ->
                        this.analyzeWithCustomModelWithResponseAsync(
                                modelId, includeTextDetails, pages, fileStream, context),
                new DefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        context),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze Form
     *
     * <p>Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one
     * of the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri or local path) of the document to be
     * analyzed.
     *
     * @param modelId Model identifier.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginAnalyzeWithCustomModel(
            UUID modelId, Boolean includeTextDetails, List<String> pages, SourcePath fileStream) {
        return SyncPoller.createPoller(
                Duration.ofSeconds(1),
                () ->
                        this.analyzeWithCustomModelWithResponse(
                                modelId, includeTextDetails, pages, fileStream, Context.NONE),
                new SyncDefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        Context.NONE),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze Form
     *
     * <p>Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one
     * of the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri or local path) of the document to be
     * analyzed.
     *
     * @param modelId Model identifier.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginAnalyzeWithCustomModel(
            UUID modelId, Boolean includeTextDetails, List<String> pages, SourcePath fileStream, Context context) {
        return SyncPoller.createPoller(
                Duration.ofSeconds(1),
                () -> this.analyzeWithCustomModelWithResponse(modelId, includeTextDetails, pages, fileStream, context),
                new SyncDefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        context),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Get Analyze Form Result
     *
     * <p>Obtain current status and the result of the analyze form operation.
     *
     * @param modelId Model identifier.
     * @param resultId Analyze operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation along with {@link Response} on successful completion of
     *     {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AnalyzeOperationResult>> getAnalyzeFormResultWithResponseAsync(UUID modelId, UUID resultId) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context -> service.getAnalyzeFormResult(this.getEndpoint(), modelId, resultId, accept, context));
    }

    /**
     * Get Analyze Form Result
     *
     * <p>Obtain current status and the result of the analyze form operation.
     *
     * @param modelId Model identifier.
     * @param resultId Analyze operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation along with {@link Response} on successful completion of
     *     {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AnalyzeOperationResult>> getAnalyzeFormResultWithResponseAsync(
            UUID modelId, UUID resultId, Context context) {
        final String accept = "application/json";
        return service.getAnalyzeFormResult(this.getEndpoint(), modelId, resultId, accept, context);
    }

    /**
     * Get Analyze Form Result
     *
     * <p>Obtain current status and the result of the analyze form operation.
     *
     * @param modelId Model identifier.
     * @param resultId Analyze operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalyzeOperationResult> getAnalyzeFormResultAsync(UUID modelId, UUID resultId) {
        return getAnalyzeFormResultWithResponseAsync(modelId, resultId)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get Analyze Form Result
     *
     * <p>Obtain current status and the result of the analyze form operation.
     *
     * @param modelId Model identifier.
     * @param resultId Analyze operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalyzeOperationResult> getAnalyzeFormResultAsync(UUID modelId, UUID resultId, Context context) {
        return getAnalyzeFormResultWithResponseAsync(modelId, resultId, context)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get Analyze Form Result
     *
     * <p>Obtain current status and the result of the analyze form operation.
     *
     * @param modelId Model identifier.
     * @param resultId Analyze operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<AnalyzeOperationResult> getAnalyzeFormResultWithResponse(
            UUID modelId, UUID resultId, Context context) {
        final String accept = "application/json";
        return service.getAnalyzeFormResultSync(this.getEndpoint(), modelId, resultId, accept, context);
    }

    /**
     * Get Analyze Form Result
     *
     * <p>Obtain current status and the result of the analyze form operation.
     *
     * @param modelId Model identifier.
     * @param resultId Analyze operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public AnalyzeOperationResult getAnalyzeFormResult(UUID modelId, UUID resultId) {
        return getAnalyzeFormResultWithResponse(modelId, resultId, Context.NONE).getValue();
    }

    /**
     * Copy Custom Model
     *
     * <p>Copy custom model stored in this resource (the source) to user specified target Form Recognizer resource.
     *
     * @param modelId Model identifier.
     * @param copyRequest Copy request parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<CopyCustomModelHeaders, Void>> copyCustomModelWithResponseAsync(
            UUID modelId, CopyRequest copyRequest) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context -> service.copyCustomModel(this.getEndpoint(), modelId, copyRequest, accept, context));
    }

    /**
     * Copy Custom Model
     *
     * <p>Copy custom model stored in this resource (the source) to user specified target Form Recognizer resource.
     *
     * @param modelId Model identifier.
     * @param copyRequest Copy request parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<CopyCustomModelHeaders, Void>> copyCustomModelWithResponseAsync(
            UUID modelId, CopyRequest copyRequest, Context context) {
        final String accept = "application/json";
        return service.copyCustomModel(this.getEndpoint(), modelId, copyRequest, accept, context);
    }

    /**
     * Copy Custom Model
     *
     * <p>Copy custom model stored in this resource (the source) to user specified target Form Recognizer resource.
     *
     * @param modelId Model identifier.
     * @param copyRequest Copy request parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ResponseBase<CopyCustomModelHeaders, Void> copyCustomModelWithResponse(
            UUID modelId, CopyRequest copyRequest, Context context) {
        final String accept = "application/json";
        return service.copyCustomModelSync(this.getEndpoint(), modelId, copyRequest, accept, context);
    }

    /**
     * Copy Custom Model
     *
     * <p>Copy custom model stored in this resource (the source) to user specified target Form Recognizer resource.
     *
     * @param modelId Model identifier.
     * @param copyRequest Copy request parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginCopyCustomModelAsync(UUID modelId, CopyRequest copyRequest) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () -> this.copyCustomModelWithResponseAsync(modelId, copyRequest),
                new DefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        Context.NONE),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Copy Custom Model
     *
     * <p>Copy custom model stored in this resource (the source) to user specified target Form Recognizer resource.
     *
     * @param modelId Model identifier.
     * @param copyRequest Copy request parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginCopyCustomModelAsync(
            UUID modelId, CopyRequest copyRequest, Context context) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () -> this.copyCustomModelWithResponseAsync(modelId, copyRequest, context),
                new DefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        context),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Copy Custom Model
     *
     * <p>Copy custom model stored in this resource (the source) to user specified target Form Recognizer resource.
     *
     * @param modelId Model identifier.
     * @param copyRequest Copy request parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginCopyCustomModel(UUID modelId, CopyRequest copyRequest) {
        return SyncPoller.createPoller(
                Duration.ofSeconds(1),
                () -> this.copyCustomModelWithResponse(modelId, copyRequest, Context.NONE),
                new SyncDefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        Context.NONE),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Copy Custom Model
     *
     * <p>Copy custom model stored in this resource (the source) to user specified target Form Recognizer resource.
     *
     * @param modelId Model identifier.
     * @param copyRequest Copy request parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginCopyCustomModel(
            UUID modelId, CopyRequest copyRequest, Context context) {
        return SyncPoller.createPoller(
                Duration.ofSeconds(1),
                () -> this.copyCustomModelWithResponse(modelId, copyRequest, context),
                new SyncDefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        context),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Get Custom Model Copy Result
     *
     * <p>Obtain current status and the result of a custom model copy operation.
     *
     * @param modelId Model identifier.
     * @param resultId Copy operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued copy operation along with {@link Response} on successful completion of
     *     {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<CopyOperationResult>> getCustomModelCopyResultWithResponseAsync(UUID modelId, UUID resultId) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context -> service.getCustomModelCopyResult(this.getEndpoint(), modelId, resultId, accept, context));
    }

    /**
     * Get Custom Model Copy Result
     *
     * <p>Obtain current status and the result of a custom model copy operation.
     *
     * @param modelId Model identifier.
     * @param resultId Copy operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued copy operation along with {@link Response} on successful completion of
     *     {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<CopyOperationResult>> getCustomModelCopyResultWithResponseAsync(
            UUID modelId, UUID resultId, Context context) {
        final String accept = "application/json";
        return service.getCustomModelCopyResult(this.getEndpoint(), modelId, resultId, accept, context);
    }

    /**
     * Get Custom Model Copy Result
     *
     * <p>Obtain current status and the result of a custom model copy operation.
     *
     * @param modelId Model identifier.
     * @param resultId Copy operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued copy operation on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<CopyOperationResult> getCustomModelCopyResultAsync(UUID modelId, UUID resultId) {
        return getCustomModelCopyResultWithResponseAsync(modelId, resultId)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get Custom Model Copy Result
     *
     * <p>Obtain current status and the result of a custom model copy operation.
     *
     * @param modelId Model identifier.
     * @param resultId Copy operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued copy operation on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<CopyOperationResult> getCustomModelCopyResultAsync(UUID modelId, UUID resultId, Context context) {
        return getCustomModelCopyResultWithResponseAsync(modelId, resultId, context)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get Custom Model Copy Result
     *
     * <p>Obtain current status and the result of a custom model copy operation.
     *
     * @param modelId Model identifier.
     * @param resultId Copy operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued copy operation along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<CopyOperationResult> getCustomModelCopyResultWithResponse(
            UUID modelId, UUID resultId, Context context) {
        final String accept = "application/json";
        return service.getCustomModelCopyResultSync(this.getEndpoint(), modelId, resultId, accept, context);
    }

    /**
     * Get Custom Model Copy Result
     *
     * <p>Obtain current status and the result of a custom model copy operation.
     *
     * @param modelId Model identifier.
     * @param resultId Copy operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued copy operation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public CopyOperationResult getCustomModelCopyResult(UUID modelId, UUID resultId) {
        return getCustomModelCopyResultWithResponse(modelId, resultId, Context.NONE).getValue();
    }

    /**
     * Generate Copy Authorization
     *
     * <p>Generate authorization to copy a model into the target Form Recognizer resource.
     *
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return request parameter that contains authorization claims for copy operation along with {@link ResponseBase}
     *     on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<GenerateModelCopyAuthorizationHeaders, CopyAuthorizationResult>>
            generateModelCopyAuthorizationWithResponseAsync() {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context -> service.generateModelCopyAuthorization(this.getEndpoint(), accept, context));
    }

    /**
     * Generate Copy Authorization
     *
     * <p>Generate authorization to copy a model into the target Form Recognizer resource.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return request parameter that contains authorization claims for copy operation along with {@link ResponseBase}
     *     on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<GenerateModelCopyAuthorizationHeaders, CopyAuthorizationResult>>
            generateModelCopyAuthorizationWithResponseAsync(Context context) {
        final String accept = "application/json";
        return service.generateModelCopyAuthorization(this.getEndpoint(), accept, context);
    }

    /**
     * Generate Copy Authorization
     *
     * <p>Generate authorization to copy a model into the target Form Recognizer resource.
     *
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return request parameter that contains authorization claims for copy operation on successful completion of
     *     {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<CopyAuthorizationResult> generateModelCopyAuthorizationAsync() {
        return generateModelCopyAuthorizationWithResponseAsync().flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Generate Copy Authorization
     *
     * <p>Generate authorization to copy a model into the target Form Recognizer resource.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return request parameter that contains authorization claims for copy operation on successful completion of
     *     {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<CopyAuthorizationResult> generateModelCopyAuthorizationAsync(Context context) {
        return generateModelCopyAuthorizationWithResponseAsync(context)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Generate Copy Authorization
     *
     * <p>Generate authorization to copy a model into the target Form Recognizer resource.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return request parameter that contains authorization claims for copy operation along with {@link ResponseBase}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ResponseBase<GenerateModelCopyAuthorizationHeaders, CopyAuthorizationResult>
            generateModelCopyAuthorizationWithResponse(Context context) {
        final String accept = "application/json";
        return service.generateModelCopyAuthorizationSync(this.getEndpoint(), accept, context);
    }

    /**
     * Generate Copy Authorization
     *
     * <p>Generate authorization to copy a model into the target Form Recognizer resource.
     *
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return request parameter that contains authorization claims for copy operation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public CopyAuthorizationResult generateModelCopyAuthorization() {
        return generateModelCopyAuthorizationWithResponse(Context.NONE).getValue();
    }

    /**
     * Compose trained with labels models into one composed model.
     *
     * <p>Compose request would include list of models ids. It would validate what all models either trained with labels
     * model or composed model. It would validate limit of models put together.
     *
     * @param composeRequest Compose models.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<ComposeCustomModelsAsyncHeaders, Void>> composeCustomModelsAsyncWithResponseAsync(
            ComposeRequest composeRequest) {
        final String accept = "application/json, text/json";
        return FluxUtil.withContext(
                context -> service.composeCustomModelsAsync(this.getEndpoint(), composeRequest, accept, context));
    }

    /**
     * Compose trained with labels models into one composed model.
     *
     * <p>Compose request would include list of models ids. It would validate what all models either trained with labels
     * model or composed model. It would validate limit of models put together.
     *
     * @param composeRequest Compose models.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<ComposeCustomModelsAsyncHeaders, Void>> composeCustomModelsAsyncWithResponseAsync(
            ComposeRequest composeRequest, Context context) {
        final String accept = "application/json, text/json";
        return service.composeCustomModelsAsync(this.getEndpoint(), composeRequest, accept, context);
    }

    /**
     * Compose trained with labels models into one composed model.
     *
     * <p>Compose request would include list of models ids. It would validate what all models either trained with labels
     * model or composed model. It would validate limit of models put together.
     *
     * @param composeRequest Compose models.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ResponseBase<ComposeCustomModelsAsyncHeaders, Void> composeCustomModelsAsyncWithResponse(
            ComposeRequest composeRequest, Context context) {
        final String accept = "application/json, text/json";
        return service.composeCustomModelsAsyncSync(this.getEndpoint(), composeRequest, accept, context);
    }

    /**
     * Compose trained with labels models into one composed model.
     *
     * <p>Compose request would include list of models ids. It would validate what all models either trained with labels
     * model or composed model. It would validate limit of models put together.
     *
     * @param composeRequest Compose models.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginComposeCustomModelsAsyncAsync(ComposeRequest composeRequest) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () -> this.composeCustomModelsAsyncWithResponseAsync(composeRequest),
                new DefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        Context.NONE),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Compose trained with labels models into one composed model.
     *
     * <p>Compose request would include list of models ids. It would validate what all models either trained with labels
     * model or composed model. It would validate limit of models put together.
     *
     * @param composeRequest Compose models.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginComposeCustomModelsAsyncAsync(
            ComposeRequest composeRequest, Context context) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () -> this.composeCustomModelsAsyncWithResponseAsync(composeRequest, context),
                new DefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        context),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Compose trained with labels models into one composed model.
     *
     * <p>Compose request would include list of models ids. It would validate what all models either trained with labels
     * model or composed model. It would validate limit of models put together.
     *
     * @param composeRequest Compose models.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginComposeCustomModelsAsync(ComposeRequest composeRequest) {
        return SyncPoller.createPoller(
                Duration.ofSeconds(1),
                () -> this.composeCustomModelsAsyncWithResponse(composeRequest, Context.NONE),
                new SyncDefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        Context.NONE),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Compose trained with labels models into one composed model.
     *
     * <p>Compose request would include list of models ids. It would validate what all models either trained with labels
     * model or composed model. It would validate limit of models put together.
     *
     * @param composeRequest Compose models.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginComposeCustomModelsAsync(
            ComposeRequest composeRequest, Context context) {
        return SyncPoller.createPoller(
                Duration.ofSeconds(1),
                () -> this.composeCustomModelsAsyncWithResponse(composeRequest, context),
                new SyncDefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        context),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze Business Card
     *
     * <p>Extract field text and semantic values from a given business card document. The input document must be of one
     * of the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeBusinessCardAsyncHeaders, Void>> analyzeBusinessCardAsyncWithResponseAsync(
            ContentType contentType,
            Boolean includeTextDetails,
            Locale locale,
            List<String> pages,
            Flux<ByteBuffer> fileStream,
            Long contentLength) {
        final String accept = "application/json";
        String pagesConverted =
                (pages == null)
                        ? null
                        : pages.stream().map(value -> Objects.toString(value, "")).collect(Collectors.joining(","));
        return FluxUtil.withContext(
                context ->
                        service.analyzeBusinessCardAsync(
                                this.getEndpoint(),
                                includeTextDetails,
                                locale,
                                pagesConverted,
                                contentType,
                                fileStream,
                                contentLength,
                                accept,
                                context));
    }

    /**
     * Analyze Business Card
     *
     * <p>Extract field text and semantic values from a given business card document. The input document must be of one
     * of the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeBusinessCardAsyncHeaders, Void>> analyzeBusinessCardAsyncWithResponseAsync(
            ContentType contentType,
            Boolean includeTextDetails,
            Locale locale,
            List<String> pages,
            Flux<ByteBuffer> fileStream,
            Long contentLength,
            Context context) {
        final String accept = "application/json";
        String pagesConverted =
                (pages == null)
                        ? null
                        : pages.stream().map(value -> Objects.toString(value, "")).collect(Collectors.joining(","));
        return service.analyzeBusinessCardAsync(
                this.getEndpoint(),
                includeTextDetails,
                locale,
                pagesConverted,
                contentType,
                fileStream,
                contentLength,
                accept,
                context);
    }

    /**
     * Analyze Business Card
     *
     * <p>Extract field text and semantic values from a given business card document. The input document must be of one
     * of the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginAnalyzeBusinessCardAsyncAsync(
            ContentType contentType,
            Boolean includeTextDetails,
            Locale locale,
            List<String> pages,
            Flux<ByteBuffer> fileStream,
            Long contentLength) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () ->
                        this.analyzeBusinessCardAsyncWithResponseAsync(
                                contentType, includeTextDetails, locale, pages, fileStream, contentLength),
                new DefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        Context.NONE),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze Business Card
     *
     * <p>Extract field text and semantic values from a given business card document. The input document must be of one
     * of the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginAnalyzeBusinessCardAsyncAsync(
            ContentType contentType,
            Boolean includeTextDetails,
            Locale locale,
            List<String> pages,
            Flux<ByteBuffer> fileStream,
            Long contentLength,
            Context context) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () ->
                        this.analyzeBusinessCardAsyncWithResponseAsync(
                                contentType, includeTextDetails, locale, pages, fileStream, contentLength, context),
                new DefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        context),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze Business Card
     *
     * <p>Extract field text and semantic values from a given business card document. The input document must be of one
     * of the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeBusinessCardAsyncHeaders, Void>> analyzeBusinessCardAsyncWithResponseAsync(
            ContentType contentType,
            Boolean includeTextDetails,
            Locale locale,
            List<String> pages,
            BinaryData fileStream,
            Long contentLength) {
        final String accept = "application/json";
        String pagesConverted =
                (pages == null)
                        ? null
                        : pages.stream().map(value -> Objects.toString(value, "")).collect(Collectors.joining(","));
        return FluxUtil.withContext(
                context ->
                        service.analyzeBusinessCardAsync(
                                this.getEndpoint(),
                                includeTextDetails,
                                locale,
                                pagesConverted,
                                contentType,
                                fileStream,
                                contentLength,
                                accept,
                                context));
    }

    /**
     * Analyze Business Card
     *
     * <p>Extract field text and semantic values from a given business card document. The input document must be of one
     * of the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeBusinessCardAsyncHeaders, Void>> analyzeBusinessCardAsyncWithResponseAsync(
            ContentType contentType,
            Boolean includeTextDetails,
            Locale locale,
            List<String> pages,
            BinaryData fileStream,
            Long contentLength,
            Context context) {
        final String accept = "application/json";
        String pagesConverted =
                (pages == null)
                        ? null
                        : pages.stream().map(value -> Objects.toString(value, "")).collect(Collectors.joining(","));
        return service.analyzeBusinessCardAsync(
                this.getEndpoint(),
                includeTextDetails,
                locale,
                pagesConverted,
                contentType,
                fileStream,
                contentLength,
                accept,
                context);
    }

    /**
     * Analyze Business Card
     *
     * <p>Extract field text and semantic values from a given business card document. The input document must be of one
     * of the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ResponseBase<AnalyzeBusinessCardAsyncHeaders, Void> analyzeBusinessCardAsyncWithResponse(
            ContentType contentType,
            Boolean includeTextDetails,
            Locale locale,
            List<String> pages,
            BinaryData fileStream,
            Long contentLength,
            Context context) {
        final String accept = "application/json";
        String pagesConverted =
                (pages == null)
                        ? null
                        : pages.stream().map(value -> Objects.toString(value, "")).collect(Collectors.joining(","));
        return service.analyzeBusinessCardAsyncSync(
                this.getEndpoint(),
                includeTextDetails,
                locale,
                pagesConverted,
                contentType,
                fileStream,
                contentLength,
                accept,
                context);
    }

    /**
     * Analyze Business Card
     *
     * <p>Extract field text and semantic values from a given business card document. The input document must be of one
     * of the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginAnalyzeBusinessCardAsyncAsync(
            ContentType contentType,
            Boolean includeTextDetails,
            Locale locale,
            List<String> pages,
            BinaryData fileStream,
            Long contentLength) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () ->
                        this.analyzeBusinessCardAsyncWithResponseAsync(
                                contentType, includeTextDetails, locale, pages, fileStream, contentLength),
                new DefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        Context.NONE),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze Business Card
     *
     * <p>Extract field text and semantic values from a given business card document. The input document must be of one
     * of the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginAnalyzeBusinessCardAsyncAsync(
            ContentType contentType,
            Boolean includeTextDetails,
            Locale locale,
            List<String> pages,
            BinaryData fileStream,
            Long contentLength,
            Context context) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () ->
                        this.analyzeBusinessCardAsyncWithResponseAsync(
                                contentType, includeTextDetails, locale, pages, fileStream, contentLength, context),
                new DefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        context),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze Business Card
     *
     * <p>Extract field text and semantic values from a given business card document. The input document must be of one
     * of the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginAnalyzeBusinessCardAsync(
            ContentType contentType,
            Boolean includeTextDetails,
            Locale locale,
            List<String> pages,
            BinaryData fileStream,
            Long contentLength) {
        return SyncPoller.createPoller(
                Duration.ofSeconds(1),
                () ->
                        this.analyzeBusinessCardAsyncWithResponse(
                                contentType,
                                includeTextDetails,
                                locale,
                                pages,
                                fileStream,
                                contentLength,
                                Context.NONE),
                new SyncDefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        Context.NONE),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze Business Card
     *
     * <p>Extract field text and semantic values from a given business card document. The input document must be of one
     * of the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginAnalyzeBusinessCardAsync(
            ContentType contentType,
            Boolean includeTextDetails,
            Locale locale,
            List<String> pages,
            BinaryData fileStream,
            Long contentLength,
            Context context) {
        return SyncPoller.createPoller(
                Duration.ofSeconds(1),
                () ->
                        this.analyzeBusinessCardAsyncWithResponse(
                                contentType, includeTextDetails, locale, pages, fileStream, contentLength, context),
                new SyncDefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        context),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze Business Card
     *
     * <p>Extract field text and semantic values from a given business card document. The input document must be of one
     * of the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeBusinessCardAsyncHeaders, Void>> analyzeBusinessCardAsyncWithResponseAsync(
            Boolean includeTextDetails, Locale locale, List<String> pages, SourcePath fileStream) {
        final String accept = "application/json";
        String pagesConverted =
                (pages == null)
                        ? null
                        : pages.stream().map(value -> Objects.toString(value, "")).collect(Collectors.joining(","));
        return FluxUtil.withContext(
                context ->
                        service.analyzeBusinessCardAsync(
                                this.getEndpoint(),
                                includeTextDetails,
                                locale,
                                pagesConverted,
                                fileStream,
                                accept,
                                context));
    }

    /**
     * Analyze Business Card
     *
     * <p>Extract field text and semantic values from a given business card document. The input document must be of one
     * of the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeBusinessCardAsyncHeaders, Void>> analyzeBusinessCardAsyncWithResponseAsync(
            Boolean includeTextDetails, Locale locale, List<String> pages, SourcePath fileStream, Context context) {
        final String accept = "application/json";
        String pagesConverted =
                (pages == null)
                        ? null
                        : pages.stream().map(value -> Objects.toString(value, "")).collect(Collectors.joining(","));
        return service.analyzeBusinessCardAsync(
                this.getEndpoint(), includeTextDetails, locale, pagesConverted, fileStream, accept, context);
    }

    /**
     * Analyze Business Card
     *
     * <p>Extract field text and semantic values from a given business card document. The input document must be of one
     * of the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ResponseBase<AnalyzeBusinessCardAsyncHeaders, Void> analyzeBusinessCardAsyncWithResponse(
            Boolean includeTextDetails, Locale locale, List<String> pages, SourcePath fileStream, Context context) {
        final String accept = "application/json";
        String pagesConverted =
                (pages == null)
                        ? null
                        : pages.stream().map(value -> Objects.toString(value, "")).collect(Collectors.joining(","));
        return service.analyzeBusinessCardAsyncSync(
                this.getEndpoint(), includeTextDetails, locale, pagesConverted, fileStream, accept, context);
    }

    /**
     * Analyze Business Card
     *
     * <p>Extract field text and semantic values from a given business card document. The input document must be of one
     * of the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginAnalyzeBusinessCardAsyncAsync(
            Boolean includeTextDetails, Locale locale, List<String> pages, SourcePath fileStream) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () -> this.analyzeBusinessCardAsyncWithResponseAsync(includeTextDetails, locale, pages, fileStream),
                new DefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        Context.NONE),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze Business Card
     *
     * <p>Extract field text and semantic values from a given business card document. The input document must be of one
     * of the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginAnalyzeBusinessCardAsyncAsync(
            Boolean includeTextDetails, Locale locale, List<String> pages, SourcePath fileStream, Context context) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () ->
                        this.analyzeBusinessCardAsyncWithResponseAsync(
                                includeTextDetails, locale, pages, fileStream, context),
                new DefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        context),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze Business Card
     *
     * <p>Extract field text and semantic values from a given business card document. The input document must be of one
     * of the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginAnalyzeBusinessCardAsync(
            Boolean includeTextDetails, Locale locale, List<String> pages, SourcePath fileStream) {
        return SyncPoller.createPoller(
                Duration.ofSeconds(1),
                () ->
                        this.analyzeBusinessCardAsyncWithResponse(
                                includeTextDetails, locale, pages, fileStream, Context.NONE),
                new SyncDefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        Context.NONE),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze Business Card
     *
     * <p>Extract field text and semantic values from a given business card document. The input document must be of one
     * of the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginAnalyzeBusinessCardAsync(
            Boolean includeTextDetails, Locale locale, List<String> pages, SourcePath fileStream, Context context) {
        return SyncPoller.createPoller(
                Duration.ofSeconds(1),
                () -> this.analyzeBusinessCardAsyncWithResponse(includeTextDetails, locale, pages, fileStream, context),
                new SyncDefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        context),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Get Analyze Business Card Result
     *
     * <p>Track the progress and obtain the result of the analyze business card operation.
     *
     * @param resultId Analyze operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation along with {@link Response} on successful completion of
     *     {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AnalyzeOperationResult>> getAnalyzeBusinessCardResultWithResponseAsync(UUID resultId) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context -> service.getAnalyzeBusinessCardResult(this.getEndpoint(), resultId, accept, context));
    }

    /**
     * Get Analyze Business Card Result
     *
     * <p>Track the progress and obtain the result of the analyze business card operation.
     *
     * @param resultId Analyze operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation along with {@link Response} on successful completion of
     *     {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AnalyzeOperationResult>> getAnalyzeBusinessCardResultWithResponseAsync(
            UUID resultId, Context context) {
        final String accept = "application/json";
        return service.getAnalyzeBusinessCardResult(this.getEndpoint(), resultId, accept, context);
    }

    /**
     * Get Analyze Business Card Result
     *
     * <p>Track the progress and obtain the result of the analyze business card operation.
     *
     * @param resultId Analyze operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalyzeOperationResult> getAnalyzeBusinessCardResultAsync(UUID resultId) {
        return getAnalyzeBusinessCardResultWithResponseAsync(resultId).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get Analyze Business Card Result
     *
     * <p>Track the progress and obtain the result of the analyze business card operation.
     *
     * @param resultId Analyze operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalyzeOperationResult> getAnalyzeBusinessCardResultAsync(UUID resultId, Context context) {
        return getAnalyzeBusinessCardResultWithResponseAsync(resultId, context)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get Analyze Business Card Result
     *
     * <p>Track the progress and obtain the result of the analyze business card operation.
     *
     * @param resultId Analyze operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<AnalyzeOperationResult> getAnalyzeBusinessCardResultWithResponse(UUID resultId, Context context) {
        final String accept = "application/json";
        return service.getAnalyzeBusinessCardResultSync(this.getEndpoint(), resultId, accept, context);
    }

    /**
     * Get Analyze Business Card Result
     *
     * <p>Track the progress and obtain the result of the analyze business card operation.
     *
     * @param resultId Analyze operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public AnalyzeOperationResult getAnalyzeBusinessCardResult(UUID resultId) {
        return getAnalyzeBusinessCardResultWithResponse(resultId, Context.NONE).getValue();
    }

    /**
     * Analyze Invoice Document
     *
     * <p>Extract field text and semantic values from a given invoice document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeInvoiceAsyncHeaders, Void>> analyzeInvoiceAsyncWithResponseAsync(
            ContentType contentType,
            Boolean includeTextDetails,
            Locale locale,
            List<String> pages,
            Flux<ByteBuffer> fileStream,
            Long contentLength) {
        final String accept = "application/json";
        String pagesConverted =
                (pages == null)
                        ? null
                        : pages.stream().map(value -> Objects.toString(value, "")).collect(Collectors.joining(","));
        return FluxUtil.withContext(
                context ->
                        service.analyzeInvoiceAsync(
                                this.getEndpoint(),
                                includeTextDetails,
                                locale,
                                pagesConverted,
                                contentType,
                                fileStream,
                                contentLength,
                                accept,
                                context));
    }

    /**
     * Analyze Invoice Document
     *
     * <p>Extract field text and semantic values from a given invoice document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeInvoiceAsyncHeaders, Void>> analyzeInvoiceAsyncWithResponseAsync(
            ContentType contentType,
            Boolean includeTextDetails,
            Locale locale,
            List<String> pages,
            Flux<ByteBuffer> fileStream,
            Long contentLength,
            Context context) {
        final String accept = "application/json";
        String pagesConverted =
                (pages == null)
                        ? null
                        : pages.stream().map(value -> Objects.toString(value, "")).collect(Collectors.joining(","));
        return service.analyzeInvoiceAsync(
                this.getEndpoint(),
                includeTextDetails,
                locale,
                pagesConverted,
                contentType,
                fileStream,
                contentLength,
                accept,
                context);
    }

    /**
     * Analyze Invoice Document
     *
     * <p>Extract field text and semantic values from a given invoice document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginAnalyzeInvoiceAsyncAsync(
            ContentType contentType,
            Boolean includeTextDetails,
            Locale locale,
            List<String> pages,
            Flux<ByteBuffer> fileStream,
            Long contentLength) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () ->
                        this.analyzeInvoiceAsyncWithResponseAsync(
                                contentType, includeTextDetails, locale, pages, fileStream, contentLength),
                new DefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        Context.NONE),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze Invoice Document
     *
     * <p>Extract field text and semantic values from a given invoice document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginAnalyzeInvoiceAsyncAsync(
            ContentType contentType,
            Boolean includeTextDetails,
            Locale locale,
            List<String> pages,
            Flux<ByteBuffer> fileStream,
            Long contentLength,
            Context context) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () ->
                        this.analyzeInvoiceAsyncWithResponseAsync(
                                contentType, includeTextDetails, locale, pages, fileStream, contentLength, context),
                new DefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        context),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze Invoice Document
     *
     * <p>Extract field text and semantic values from a given invoice document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeInvoiceAsyncHeaders, Void>> analyzeInvoiceAsyncWithResponseAsync(
            ContentType contentType,
            Boolean includeTextDetails,
            Locale locale,
            List<String> pages,
            BinaryData fileStream,
            Long contentLength) {
        final String accept = "application/json";
        String pagesConverted =
                (pages == null)
                        ? null
                        : pages.stream().map(value -> Objects.toString(value, "")).collect(Collectors.joining(","));
        return FluxUtil.withContext(
                context ->
                        service.analyzeInvoiceAsync(
                                this.getEndpoint(),
                                includeTextDetails,
                                locale,
                                pagesConverted,
                                contentType,
                                fileStream,
                                contentLength,
                                accept,
                                context));
    }

    /**
     * Analyze Invoice Document
     *
     * <p>Extract field text and semantic values from a given invoice document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeInvoiceAsyncHeaders, Void>> analyzeInvoiceAsyncWithResponseAsync(
            ContentType contentType,
            Boolean includeTextDetails,
            Locale locale,
            List<String> pages,
            BinaryData fileStream,
            Long contentLength,
            Context context) {
        final String accept = "application/json";
        String pagesConverted =
                (pages == null)
                        ? null
                        : pages.stream().map(value -> Objects.toString(value, "")).collect(Collectors.joining(","));
        return service.analyzeInvoiceAsync(
                this.getEndpoint(),
                includeTextDetails,
                locale,
                pagesConverted,
                contentType,
                fileStream,
                contentLength,
                accept,
                context);
    }

    /**
     * Analyze Invoice Document
     *
     * <p>Extract field text and semantic values from a given invoice document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ResponseBase<AnalyzeInvoiceAsyncHeaders, Void> analyzeInvoiceAsyncWithResponse(
            ContentType contentType,
            Boolean includeTextDetails,
            Locale locale,
            List<String> pages,
            BinaryData fileStream,
            Long contentLength,
            Context context) {
        final String accept = "application/json";
        String pagesConverted =
                (pages == null)
                        ? null
                        : pages.stream().map(value -> Objects.toString(value, "")).collect(Collectors.joining(","));
        return service.analyzeInvoiceAsyncSync(
                this.getEndpoint(),
                includeTextDetails,
                locale,
                pagesConverted,
                contentType,
                fileStream,
                contentLength,
                accept,
                context);
    }

    /**
     * Analyze Invoice Document
     *
     * <p>Extract field text and semantic values from a given invoice document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginAnalyzeInvoiceAsyncAsync(
            ContentType contentType,
            Boolean includeTextDetails,
            Locale locale,
            List<String> pages,
            BinaryData fileStream,
            Long contentLength) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () ->
                        this.analyzeInvoiceAsyncWithResponseAsync(
                                contentType, includeTextDetails, locale, pages, fileStream, contentLength),
                new DefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        Context.NONE),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze Invoice Document
     *
     * <p>Extract field text and semantic values from a given invoice document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginAnalyzeInvoiceAsyncAsync(
            ContentType contentType,
            Boolean includeTextDetails,
            Locale locale,
            List<String> pages,
            BinaryData fileStream,
            Long contentLength,
            Context context) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () ->
                        this.analyzeInvoiceAsyncWithResponseAsync(
                                contentType, includeTextDetails, locale, pages, fileStream, contentLength, context),
                new DefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        context),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze Invoice Document
     *
     * <p>Extract field text and semantic values from a given invoice document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginAnalyzeInvoiceAsync(
            ContentType contentType,
            Boolean includeTextDetails,
            Locale locale,
            List<String> pages,
            BinaryData fileStream,
            Long contentLength) {
        return SyncPoller.createPoller(
                Duration.ofSeconds(1),
                () ->
                        this.analyzeInvoiceAsyncWithResponse(
                                contentType,
                                includeTextDetails,
                                locale,
                                pages,
                                fileStream,
                                contentLength,
                                Context.NONE),
                new SyncDefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        Context.NONE),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze Invoice Document
     *
     * <p>Extract field text and semantic values from a given invoice document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginAnalyzeInvoiceAsync(
            ContentType contentType,
            Boolean includeTextDetails,
            Locale locale,
            List<String> pages,
            BinaryData fileStream,
            Long contentLength,
            Context context) {
        return SyncPoller.createPoller(
                Duration.ofSeconds(1),
                () ->
                        this.analyzeInvoiceAsyncWithResponse(
                                contentType, includeTextDetails, locale, pages, fileStream, contentLength, context),
                new SyncDefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        context),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze Invoice Document
     *
     * <p>Extract field text and semantic values from a given invoice document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeInvoiceAsyncHeaders, Void>> analyzeInvoiceAsyncWithResponseAsync(
            Boolean includeTextDetails, Locale locale, List<String> pages, SourcePath fileStream) {
        final String accept = "application/json";
        String pagesConverted =
                (pages == null)
                        ? null
                        : pages.stream().map(value -> Objects.toString(value, "")).collect(Collectors.joining(","));
        return FluxUtil.withContext(
                context ->
                        service.analyzeInvoiceAsync(
                                this.getEndpoint(),
                                includeTextDetails,
                                locale,
                                pagesConverted,
                                fileStream,
                                accept,
                                context));
    }

    /**
     * Analyze Invoice Document
     *
     * <p>Extract field text and semantic values from a given invoice document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeInvoiceAsyncHeaders, Void>> analyzeInvoiceAsyncWithResponseAsync(
            Boolean includeTextDetails, Locale locale, List<String> pages, SourcePath fileStream, Context context) {
        final String accept = "application/json";
        String pagesConverted =
                (pages == null)
                        ? null
                        : pages.stream().map(value -> Objects.toString(value, "")).collect(Collectors.joining(","));
        return service.analyzeInvoiceAsync(
                this.getEndpoint(), includeTextDetails, locale, pagesConverted, fileStream, accept, context);
    }

    /**
     * Analyze Invoice Document
     *
     * <p>Extract field text and semantic values from a given invoice document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ResponseBase<AnalyzeInvoiceAsyncHeaders, Void> analyzeInvoiceAsyncWithResponse(
            Boolean includeTextDetails, Locale locale, List<String> pages, SourcePath fileStream, Context context) {
        final String accept = "application/json";
        String pagesConverted =
                (pages == null)
                        ? null
                        : pages.stream().map(value -> Objects.toString(value, "")).collect(Collectors.joining(","));
        return service.analyzeInvoiceAsyncSync(
                this.getEndpoint(), includeTextDetails, locale, pagesConverted, fileStream, accept, context);
    }

    /**
     * Analyze Invoice Document
     *
     * <p>Extract field text and semantic values from a given invoice document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginAnalyzeInvoiceAsyncAsync(
            Boolean includeTextDetails, Locale locale, List<String> pages, SourcePath fileStream) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () -> this.analyzeInvoiceAsyncWithResponseAsync(includeTextDetails, locale, pages, fileStream),
                new DefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        Context.NONE),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze Invoice Document
     *
     * <p>Extract field text and semantic values from a given invoice document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginAnalyzeInvoiceAsyncAsync(
            Boolean includeTextDetails, Locale locale, List<String> pages, SourcePath fileStream, Context context) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () -> this.analyzeInvoiceAsyncWithResponseAsync(includeTextDetails, locale, pages, fileStream, context),
                new DefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        context),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze Invoice Document
     *
     * <p>Extract field text and semantic values from a given invoice document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginAnalyzeInvoiceAsync(
            Boolean includeTextDetails, Locale locale, List<String> pages, SourcePath fileStream) {
        return SyncPoller.createPoller(
                Duration.ofSeconds(1),
                () -> this.analyzeInvoiceAsyncWithResponse(includeTextDetails, locale, pages, fileStream, Context.NONE),
                new SyncDefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        Context.NONE),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze Invoice Document
     *
     * <p>Extract field text and semantic values from a given invoice document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginAnalyzeInvoiceAsync(
            Boolean includeTextDetails, Locale locale, List<String> pages, SourcePath fileStream, Context context) {
        return SyncPoller.createPoller(
                Duration.ofSeconds(1),
                () -> this.analyzeInvoiceAsyncWithResponse(includeTextDetails, locale, pages, fileStream, context),
                new SyncDefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        context),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Get Analyze Invoice Result
     *
     * <p>Track the progress and obtain the result of the analyze invoice operation.
     *
     * @param resultId Analyze operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation along with {@link Response} on successful completion of
     *     {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AnalyzeOperationResult>> getAnalyzeInvoiceResultWithResponseAsync(UUID resultId) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context -> service.getAnalyzeInvoiceResult(this.getEndpoint(), resultId, accept, context));
    }

    /**
     * Get Analyze Invoice Result
     *
     * <p>Track the progress and obtain the result of the analyze invoice operation.
     *
     * @param resultId Analyze operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation along with {@link Response} on successful completion of
     *     {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AnalyzeOperationResult>> getAnalyzeInvoiceResultWithResponseAsync(
            UUID resultId, Context context) {
        final String accept = "application/json";
        return service.getAnalyzeInvoiceResult(this.getEndpoint(), resultId, accept, context);
    }

    /**
     * Get Analyze Invoice Result
     *
     * <p>Track the progress and obtain the result of the analyze invoice operation.
     *
     * @param resultId Analyze operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalyzeOperationResult> getAnalyzeInvoiceResultAsync(UUID resultId) {
        return getAnalyzeInvoiceResultWithResponseAsync(resultId).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get Analyze Invoice Result
     *
     * <p>Track the progress and obtain the result of the analyze invoice operation.
     *
     * @param resultId Analyze operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalyzeOperationResult> getAnalyzeInvoiceResultAsync(UUID resultId, Context context) {
        return getAnalyzeInvoiceResultWithResponseAsync(resultId, context)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get Analyze Invoice Result
     *
     * <p>Track the progress and obtain the result of the analyze invoice operation.
     *
     * @param resultId Analyze operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<AnalyzeOperationResult> getAnalyzeInvoiceResultWithResponse(UUID resultId, Context context) {
        final String accept = "application/json";
        return service.getAnalyzeInvoiceResultSync(this.getEndpoint(), resultId, accept, context);
    }

    /**
     * Get Analyze Invoice Result
     *
     * <p>Track the progress and obtain the result of the analyze invoice operation.
     *
     * @param resultId Analyze operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public AnalyzeOperationResult getAnalyzeInvoiceResult(UUID resultId) {
        return getAnalyzeInvoiceResultWithResponse(resultId, Context.NONE).getValue();
    }

    /**
     * Analyze ID Document
     *
     * <p>Extract field text and semantic values from a given ID document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeIdDocumentAsyncHeaders, Void>> analyzeIdDocumentAsyncWithResponseAsync(
            ContentType contentType,
            Boolean includeTextDetails,
            List<String> pages,
            Flux<ByteBuffer> fileStream,
            Long contentLength) {
        final String accept = "application/json";
        String pagesConverted =
                (pages == null)
                        ? null
                        : pages.stream().map(value -> Objects.toString(value, "")).collect(Collectors.joining(","));
        return FluxUtil.withContext(
                context ->
                        service.analyzeIdDocumentAsync(
                                this.getEndpoint(),
                                includeTextDetails,
                                pagesConverted,
                                contentType,
                                fileStream,
                                contentLength,
                                accept,
                                context));
    }

    /**
     * Analyze ID Document
     *
     * <p>Extract field text and semantic values from a given ID document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeIdDocumentAsyncHeaders, Void>> analyzeIdDocumentAsyncWithResponseAsync(
            ContentType contentType,
            Boolean includeTextDetails,
            List<String> pages,
            Flux<ByteBuffer> fileStream,
            Long contentLength,
            Context context) {
        final String accept = "application/json";
        String pagesConverted =
                (pages == null)
                        ? null
                        : pages.stream().map(value -> Objects.toString(value, "")).collect(Collectors.joining(","));
        return service.analyzeIdDocumentAsync(
                this.getEndpoint(),
                includeTextDetails,
                pagesConverted,
                contentType,
                fileStream,
                contentLength,
                accept,
                context);
    }

    /**
     * Analyze ID Document
     *
     * <p>Extract field text and semantic values from a given ID document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginAnalyzeIdDocumentAsyncAsync(
            ContentType contentType,
            Boolean includeTextDetails,
            List<String> pages,
            Flux<ByteBuffer> fileStream,
            Long contentLength) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () ->
                        this.analyzeIdDocumentAsyncWithResponseAsync(
                                contentType, includeTextDetails, pages, fileStream, contentLength),
                new DefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        Context.NONE),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze ID Document
     *
     * <p>Extract field text and semantic values from a given ID document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginAnalyzeIdDocumentAsyncAsync(
            ContentType contentType,
            Boolean includeTextDetails,
            List<String> pages,
            Flux<ByteBuffer> fileStream,
            Long contentLength,
            Context context) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () ->
                        this.analyzeIdDocumentAsyncWithResponseAsync(
                                contentType, includeTextDetails, pages, fileStream, contentLength, context),
                new DefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        context),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze ID Document
     *
     * <p>Extract field text and semantic values from a given ID document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeIdDocumentAsyncHeaders, Void>> analyzeIdDocumentAsyncWithResponseAsync(
            ContentType contentType,
            Boolean includeTextDetails,
            List<String> pages,
            BinaryData fileStream,
            Long contentLength) {
        final String accept = "application/json";
        String pagesConverted =
                (pages == null)
                        ? null
                        : pages.stream().map(value -> Objects.toString(value, "")).collect(Collectors.joining(","));
        return FluxUtil.withContext(
                context ->
                        service.analyzeIdDocumentAsync(
                                this.getEndpoint(),
                                includeTextDetails,
                                pagesConverted,
                                contentType,
                                fileStream,
                                contentLength,
                                accept,
                                context));
    }

    /**
     * Analyze ID Document
     *
     * <p>Extract field text and semantic values from a given ID document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeIdDocumentAsyncHeaders, Void>> analyzeIdDocumentAsyncWithResponseAsync(
            ContentType contentType,
            Boolean includeTextDetails,
            List<String> pages,
            BinaryData fileStream,
            Long contentLength,
            Context context) {
        final String accept = "application/json";
        String pagesConverted =
                (pages == null)
                        ? null
                        : pages.stream().map(value -> Objects.toString(value, "")).collect(Collectors.joining(","));
        return service.analyzeIdDocumentAsync(
                this.getEndpoint(),
                includeTextDetails,
                pagesConverted,
                contentType,
                fileStream,
                contentLength,
                accept,
                context);
    }

    /**
     * Analyze ID Document
     *
     * <p>Extract field text and semantic values from a given ID document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ResponseBase<AnalyzeIdDocumentAsyncHeaders, Void> analyzeIdDocumentAsyncWithResponse(
            ContentType contentType,
            Boolean includeTextDetails,
            List<String> pages,
            BinaryData fileStream,
            Long contentLength,
            Context context) {
        final String accept = "application/json";
        String pagesConverted =
                (pages == null)
                        ? null
                        : pages.stream().map(value -> Objects.toString(value, "")).collect(Collectors.joining(","));
        return service.analyzeIdDocumentAsyncSync(
                this.getEndpoint(),
                includeTextDetails,
                pagesConverted,
                contentType,
                fileStream,
                contentLength,
                accept,
                context);
    }

    /**
     * Analyze ID Document
     *
     * <p>Extract field text and semantic values from a given ID document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginAnalyzeIdDocumentAsyncAsync(
            ContentType contentType,
            Boolean includeTextDetails,
            List<String> pages,
            BinaryData fileStream,
            Long contentLength) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () ->
                        this.analyzeIdDocumentAsyncWithResponseAsync(
                                contentType, includeTextDetails, pages, fileStream, contentLength),
                new DefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        Context.NONE),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze ID Document
     *
     * <p>Extract field text and semantic values from a given ID document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginAnalyzeIdDocumentAsyncAsync(
            ContentType contentType,
            Boolean includeTextDetails,
            List<String> pages,
            BinaryData fileStream,
            Long contentLength,
            Context context) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () ->
                        this.analyzeIdDocumentAsyncWithResponseAsync(
                                contentType, includeTextDetails, pages, fileStream, contentLength, context),
                new DefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        context),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze ID Document
     *
     * <p>Extract field text and semantic values from a given ID document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginAnalyzeIdDocumentAsync(
            ContentType contentType,
            Boolean includeTextDetails,
            List<String> pages,
            BinaryData fileStream,
            Long contentLength) {
        return SyncPoller.createPoller(
                Duration.ofSeconds(1),
                () ->
                        this.analyzeIdDocumentAsyncWithResponse(
                                contentType, includeTextDetails, pages, fileStream, contentLength, Context.NONE),
                new SyncDefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        Context.NONE),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze ID Document
     *
     * <p>Extract field text and semantic values from a given ID document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginAnalyzeIdDocumentAsync(
            ContentType contentType,
            Boolean includeTextDetails,
            List<String> pages,
            BinaryData fileStream,
            Long contentLength,
            Context context) {
        return SyncPoller.createPoller(
                Duration.ofSeconds(1),
                () ->
                        this.analyzeIdDocumentAsyncWithResponse(
                                contentType, includeTextDetails, pages, fileStream, contentLength, context),
                new SyncDefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        context),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze ID Document
     *
     * <p>Extract field text and semantic values from a given ID document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeIdDocumentAsyncHeaders, Void>> analyzeIdDocumentAsyncWithResponseAsync(
            Boolean includeTextDetails, List<String> pages, SourcePath fileStream) {
        final String accept = "application/json";
        String pagesConverted =
                (pages == null)
                        ? null
                        : pages.stream().map(value -> Objects.toString(value, "")).collect(Collectors.joining(","));
        return FluxUtil.withContext(
                context ->
                        service.analyzeIdDocumentAsync(
                                this.getEndpoint(), includeTextDetails, pagesConverted, fileStream, accept, context));
    }

    /**
     * Analyze ID Document
     *
     * <p>Extract field text and semantic values from a given ID document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeIdDocumentAsyncHeaders, Void>> analyzeIdDocumentAsyncWithResponseAsync(
            Boolean includeTextDetails, List<String> pages, SourcePath fileStream, Context context) {
        final String accept = "application/json";
        String pagesConverted =
                (pages == null)
                        ? null
                        : pages.stream().map(value -> Objects.toString(value, "")).collect(Collectors.joining(","));
        return service.analyzeIdDocumentAsync(
                this.getEndpoint(), includeTextDetails, pagesConverted, fileStream, accept, context);
    }

    /**
     * Analyze ID Document
     *
     * <p>Extract field text and semantic values from a given ID document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ResponseBase<AnalyzeIdDocumentAsyncHeaders, Void> analyzeIdDocumentAsyncWithResponse(
            Boolean includeTextDetails, List<String> pages, SourcePath fileStream, Context context) {
        final String accept = "application/json";
        String pagesConverted =
                (pages == null)
                        ? null
                        : pages.stream().map(value -> Objects.toString(value, "")).collect(Collectors.joining(","));
        return service.analyzeIdDocumentAsyncSync(
                this.getEndpoint(), includeTextDetails, pagesConverted, fileStream, accept, context);
    }

    /**
     * Analyze ID Document
     *
     * <p>Extract field text and semantic values from a given ID document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginAnalyzeIdDocumentAsyncAsync(
            Boolean includeTextDetails, List<String> pages, SourcePath fileStream) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () -> this.analyzeIdDocumentAsyncWithResponseAsync(includeTextDetails, pages, fileStream),
                new DefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        Context.NONE),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze ID Document
     *
     * <p>Extract field text and semantic values from a given ID document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginAnalyzeIdDocumentAsyncAsync(
            Boolean includeTextDetails, List<String> pages, SourcePath fileStream, Context context) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () -> this.analyzeIdDocumentAsyncWithResponseAsync(includeTextDetails, pages, fileStream, context),
                new DefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        context),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze ID Document
     *
     * <p>Extract field text and semantic values from a given ID document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginAnalyzeIdDocumentAsync(
            Boolean includeTextDetails, List<String> pages, SourcePath fileStream) {
        return SyncPoller.createPoller(
                Duration.ofSeconds(1),
                () -> this.analyzeIdDocumentAsyncWithResponse(includeTextDetails, pages, fileStream, Context.NONE),
                new SyncDefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        Context.NONE),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze ID Document
     *
     * <p>Extract field text and semantic values from a given ID document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginAnalyzeIdDocumentAsync(
            Boolean includeTextDetails, List<String> pages, SourcePath fileStream, Context context) {
        return SyncPoller.createPoller(
                Duration.ofSeconds(1),
                () -> this.analyzeIdDocumentAsyncWithResponse(includeTextDetails, pages, fileStream, context),
                new SyncDefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        context),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Get Analyze ID Document Result
     *
     * <p>Track the progress and obtain the result of the analyze ID operation.
     *
     * @param resultId Analyze operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation along with {@link Response} on successful completion of
     *     {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AnalyzeOperationResult>> getAnalyzeIdDocumentResultWithResponseAsync(UUID resultId) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context -> service.getAnalyzeIdDocumentResult(this.getEndpoint(), resultId, accept, context));
    }

    /**
     * Get Analyze ID Document Result
     *
     * <p>Track the progress and obtain the result of the analyze ID operation.
     *
     * @param resultId Analyze operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation along with {@link Response} on successful completion of
     *     {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AnalyzeOperationResult>> getAnalyzeIdDocumentResultWithResponseAsync(
            UUID resultId, Context context) {
        final String accept = "application/json";
        return service.getAnalyzeIdDocumentResult(this.getEndpoint(), resultId, accept, context);
    }

    /**
     * Get Analyze ID Document Result
     *
     * <p>Track the progress and obtain the result of the analyze ID operation.
     *
     * @param resultId Analyze operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalyzeOperationResult> getAnalyzeIdDocumentResultAsync(UUID resultId) {
        return getAnalyzeIdDocumentResultWithResponseAsync(resultId).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get Analyze ID Document Result
     *
     * <p>Track the progress and obtain the result of the analyze ID operation.
     *
     * @param resultId Analyze operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalyzeOperationResult> getAnalyzeIdDocumentResultAsync(UUID resultId, Context context) {
        return getAnalyzeIdDocumentResultWithResponseAsync(resultId, context)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get Analyze ID Document Result
     *
     * <p>Track the progress and obtain the result of the analyze ID operation.
     *
     * @param resultId Analyze operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<AnalyzeOperationResult> getAnalyzeIdDocumentResultWithResponse(UUID resultId, Context context) {
        final String accept = "application/json";
        return service.getAnalyzeIdDocumentResultSync(this.getEndpoint(), resultId, accept, context);
    }

    /**
     * Get Analyze ID Document Result
     *
     * <p>Track the progress and obtain the result of the analyze ID operation.
     *
     * @param resultId Analyze operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public AnalyzeOperationResult getAnalyzeIdDocumentResult(UUID resultId) {
        return getAnalyzeIdDocumentResultWithResponse(resultId, Context.NONE).getValue();
    }

    /**
     * Analyze Receipt
     *
     * <p>Extract field text and semantic values from a given receipt document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeReceiptAsyncHeaders, Void>> analyzeReceiptAsyncWithResponseAsync(
            ContentType contentType,
            Boolean includeTextDetails,
            Locale locale,
            List<String> pages,
            Flux<ByteBuffer> fileStream,
            Long contentLength) {
        final String accept = "application/json";
        String pagesConverted =
                (pages == null)
                        ? null
                        : pages.stream().map(value -> Objects.toString(value, "")).collect(Collectors.joining(","));
        return FluxUtil.withContext(
                context ->
                        service.analyzeReceiptAsync(
                                this.getEndpoint(),
                                includeTextDetails,
                                locale,
                                pagesConverted,
                                contentType,
                                fileStream,
                                contentLength,
                                accept,
                                context));
    }

    /**
     * Analyze Receipt
     *
     * <p>Extract field text and semantic values from a given receipt document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeReceiptAsyncHeaders, Void>> analyzeReceiptAsyncWithResponseAsync(
            ContentType contentType,
            Boolean includeTextDetails,
            Locale locale,
            List<String> pages,
            Flux<ByteBuffer> fileStream,
            Long contentLength,
            Context context) {
        final String accept = "application/json";
        String pagesConverted =
                (pages == null)
                        ? null
                        : pages.stream().map(value -> Objects.toString(value, "")).collect(Collectors.joining(","));
        return service.analyzeReceiptAsync(
                this.getEndpoint(),
                includeTextDetails,
                locale,
                pagesConverted,
                contentType,
                fileStream,
                contentLength,
                accept,
                context);
    }

    /**
     * Analyze Receipt
     *
     * <p>Extract field text and semantic values from a given receipt document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginAnalyzeReceiptAsyncAsync(
            ContentType contentType,
            Boolean includeTextDetails,
            Locale locale,
            List<String> pages,
            Flux<ByteBuffer> fileStream,
            Long contentLength) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () ->
                        this.analyzeReceiptAsyncWithResponseAsync(
                                contentType, includeTextDetails, locale, pages, fileStream, contentLength),
                new DefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        Context.NONE),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze Receipt
     *
     * <p>Extract field text and semantic values from a given receipt document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginAnalyzeReceiptAsyncAsync(
            ContentType contentType,
            Boolean includeTextDetails,
            Locale locale,
            List<String> pages,
            Flux<ByteBuffer> fileStream,
            Long contentLength,
            Context context) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () ->
                        this.analyzeReceiptAsyncWithResponseAsync(
                                contentType, includeTextDetails, locale, pages, fileStream, contentLength, context),
                new DefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        context),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze Receipt
     *
     * <p>Extract field text and semantic values from a given receipt document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeReceiptAsyncHeaders, Void>> analyzeReceiptAsyncWithResponseAsync(
            ContentType contentType,
            Boolean includeTextDetails,
            Locale locale,
            List<String> pages,
            BinaryData fileStream,
            Long contentLength) {
        final String accept = "application/json";
        String pagesConverted =
                (pages == null)
                        ? null
                        : pages.stream().map(value -> Objects.toString(value, "")).collect(Collectors.joining(","));
        return FluxUtil.withContext(
                context ->
                        service.analyzeReceiptAsync(
                                this.getEndpoint(),
                                includeTextDetails,
                                locale,
                                pagesConverted,
                                contentType,
                                fileStream,
                                contentLength,
                                accept,
                                context));
    }

    /**
     * Analyze Receipt
     *
     * <p>Extract field text and semantic values from a given receipt document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeReceiptAsyncHeaders, Void>> analyzeReceiptAsyncWithResponseAsync(
            ContentType contentType,
            Boolean includeTextDetails,
            Locale locale,
            List<String> pages,
            BinaryData fileStream,
            Long contentLength,
            Context context) {
        final String accept = "application/json";
        String pagesConverted =
                (pages == null)
                        ? null
                        : pages.stream().map(value -> Objects.toString(value, "")).collect(Collectors.joining(","));
        return service.analyzeReceiptAsync(
                this.getEndpoint(),
                includeTextDetails,
                locale,
                pagesConverted,
                contentType,
                fileStream,
                contentLength,
                accept,
                context);
    }

    /**
     * Analyze Receipt
     *
     * <p>Extract field text and semantic values from a given receipt document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ResponseBase<AnalyzeReceiptAsyncHeaders, Void> analyzeReceiptAsyncWithResponse(
            ContentType contentType,
            Boolean includeTextDetails,
            Locale locale,
            List<String> pages,
            BinaryData fileStream,
            Long contentLength,
            Context context) {
        final String accept = "application/json";
        String pagesConverted =
                (pages == null)
                        ? null
                        : pages.stream().map(value -> Objects.toString(value, "")).collect(Collectors.joining(","));
        return service.analyzeReceiptAsyncSync(
                this.getEndpoint(),
                includeTextDetails,
                locale,
                pagesConverted,
                contentType,
                fileStream,
                contentLength,
                accept,
                context);
    }

    /**
     * Analyze Receipt
     *
     * <p>Extract field text and semantic values from a given receipt document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginAnalyzeReceiptAsyncAsync(
            ContentType contentType,
            Boolean includeTextDetails,
            Locale locale,
            List<String> pages,
            BinaryData fileStream,
            Long contentLength) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () ->
                        this.analyzeReceiptAsyncWithResponseAsync(
                                contentType, includeTextDetails, locale, pages, fileStream, contentLength),
                new DefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        Context.NONE),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze Receipt
     *
     * <p>Extract field text and semantic values from a given receipt document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginAnalyzeReceiptAsyncAsync(
            ContentType contentType,
            Boolean includeTextDetails,
            Locale locale,
            List<String> pages,
            BinaryData fileStream,
            Long contentLength,
            Context context) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () ->
                        this.analyzeReceiptAsyncWithResponseAsync(
                                contentType, includeTextDetails, locale, pages, fileStream, contentLength, context),
                new DefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        context),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze Receipt
     *
     * <p>Extract field text and semantic values from a given receipt document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginAnalyzeReceiptAsync(
            ContentType contentType,
            Boolean includeTextDetails,
            Locale locale,
            List<String> pages,
            BinaryData fileStream,
            Long contentLength) {
        return SyncPoller.createPoller(
                Duration.ofSeconds(1),
                () ->
                        this.analyzeReceiptAsyncWithResponse(
                                contentType,
                                includeTextDetails,
                                locale,
                                pages,
                                fileStream,
                                contentLength,
                                Context.NONE),
                new SyncDefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        Context.NONE),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze Receipt
     *
     * <p>Extract field text and semantic values from a given receipt document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginAnalyzeReceiptAsync(
            ContentType contentType,
            Boolean includeTextDetails,
            Locale locale,
            List<String> pages,
            BinaryData fileStream,
            Long contentLength,
            Context context) {
        return SyncPoller.createPoller(
                Duration.ofSeconds(1),
                () ->
                        this.analyzeReceiptAsyncWithResponse(
                                contentType, includeTextDetails, locale, pages, fileStream, contentLength, context),
                new SyncDefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        context),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze Receipt
     *
     * <p>Extract field text and semantic values from a given receipt document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeReceiptAsyncHeaders, Void>> analyzeReceiptAsyncWithResponseAsync(
            Boolean includeTextDetails, Locale locale, List<String> pages, SourcePath fileStream) {
        final String accept = "application/json";
        String pagesConverted =
                (pages == null)
                        ? null
                        : pages.stream().map(value -> Objects.toString(value, "")).collect(Collectors.joining(","));
        return FluxUtil.withContext(
                context ->
                        service.analyzeReceiptAsync(
                                this.getEndpoint(),
                                includeTextDetails,
                                locale,
                                pagesConverted,
                                fileStream,
                                accept,
                                context));
    }

    /**
     * Analyze Receipt
     *
     * <p>Extract field text and semantic values from a given receipt document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeReceiptAsyncHeaders, Void>> analyzeReceiptAsyncWithResponseAsync(
            Boolean includeTextDetails, Locale locale, List<String> pages, SourcePath fileStream, Context context) {
        final String accept = "application/json";
        String pagesConverted =
                (pages == null)
                        ? null
                        : pages.stream().map(value -> Objects.toString(value, "")).collect(Collectors.joining(","));
        return service.analyzeReceiptAsync(
                this.getEndpoint(), includeTextDetails, locale, pagesConverted, fileStream, accept, context);
    }

    /**
     * Analyze Receipt
     *
     * <p>Extract field text and semantic values from a given receipt document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ResponseBase<AnalyzeReceiptAsyncHeaders, Void> analyzeReceiptAsyncWithResponse(
            Boolean includeTextDetails, Locale locale, List<String> pages, SourcePath fileStream, Context context) {
        final String accept = "application/json";
        String pagesConverted =
                (pages == null)
                        ? null
                        : pages.stream().map(value -> Objects.toString(value, "")).collect(Collectors.joining(","));
        return service.analyzeReceiptAsyncSync(
                this.getEndpoint(), includeTextDetails, locale, pagesConverted, fileStream, accept, context);
    }

    /**
     * Analyze Receipt
     *
     * <p>Extract field text and semantic values from a given receipt document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginAnalyzeReceiptAsyncAsync(
            Boolean includeTextDetails, Locale locale, List<String> pages, SourcePath fileStream) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () -> this.analyzeReceiptAsyncWithResponseAsync(includeTextDetails, locale, pages, fileStream),
                new DefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        Context.NONE),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze Receipt
     *
     * <p>Extract field text and semantic values from a given receipt document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginAnalyzeReceiptAsyncAsync(
            Boolean includeTextDetails, Locale locale, List<String> pages, SourcePath fileStream, Context context) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () -> this.analyzeReceiptAsyncWithResponseAsync(includeTextDetails, locale, pages, fileStream, context),
                new DefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        context),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze Receipt
     *
     * <p>Extract field text and semantic values from a given receipt document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginAnalyzeReceiptAsync(
            Boolean includeTextDetails, Locale locale, List<String> pages, SourcePath fileStream) {
        return SyncPoller.createPoller(
                Duration.ofSeconds(1),
                () -> this.analyzeReceiptAsyncWithResponse(includeTextDetails, locale, pages, fileStream, Context.NONE),
                new SyncDefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        Context.NONE),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze Receipt
     *
     * <p>Extract field text and semantic values from a given receipt document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     *
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     *     en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginAnalyzeReceiptAsync(
            Boolean includeTextDetails, Locale locale, List<String> pages, SourcePath fileStream, Context context) {
        return SyncPoller.createPoller(
                Duration.ofSeconds(1),
                () -> this.analyzeReceiptAsyncWithResponse(includeTextDetails, locale, pages, fileStream, context),
                new SyncDefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        context),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Get Analyze Receipt Result
     *
     * <p>Track the progress and obtain the result of the analyze receipt operation.
     *
     * @param resultId Analyze operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation along with {@link Response} on successful completion of
     *     {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AnalyzeOperationResult>> getAnalyzeReceiptResultWithResponseAsync(UUID resultId) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context -> service.getAnalyzeReceiptResult(this.getEndpoint(), resultId, accept, context));
    }

    /**
     * Get Analyze Receipt Result
     *
     * <p>Track the progress and obtain the result of the analyze receipt operation.
     *
     * @param resultId Analyze operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation along with {@link Response} on successful completion of
     *     {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AnalyzeOperationResult>> getAnalyzeReceiptResultWithResponseAsync(
            UUID resultId, Context context) {
        final String accept = "application/json";
        return service.getAnalyzeReceiptResult(this.getEndpoint(), resultId, accept, context);
    }

    /**
     * Get Analyze Receipt Result
     *
     * <p>Track the progress and obtain the result of the analyze receipt operation.
     *
     * @param resultId Analyze operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalyzeOperationResult> getAnalyzeReceiptResultAsync(UUID resultId) {
        return getAnalyzeReceiptResultWithResponseAsync(resultId).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get Analyze Receipt Result
     *
     * <p>Track the progress and obtain the result of the analyze receipt operation.
     *
     * @param resultId Analyze operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalyzeOperationResult> getAnalyzeReceiptResultAsync(UUID resultId, Context context) {
        return getAnalyzeReceiptResultWithResponseAsync(resultId, context)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get Analyze Receipt Result
     *
     * <p>Track the progress and obtain the result of the analyze receipt operation.
     *
     * @param resultId Analyze operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<AnalyzeOperationResult> getAnalyzeReceiptResultWithResponse(UUID resultId, Context context) {
        final String accept = "application/json";
        return service.getAnalyzeReceiptResultSync(this.getEndpoint(), resultId, accept, context);
    }

    /**
     * Get Analyze Receipt Result
     *
     * <p>Track the progress and obtain the result of the analyze receipt operation.
     *
     * @param resultId Analyze operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public AnalyzeOperationResult getAnalyzeReceiptResult(UUID resultId) {
        return getAnalyzeReceiptResultWithResponse(resultId, Context.NONE).getValue();
    }

    /**
     * Analyze Layout
     *
     * <p>Extract text and layout information from a given document. The input document must be of one of the supported
     * content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param language Currently, only Afrikaans (af), Albanian (sq), Asturian (ast), Basque (eu), Bislama
     *     (bi), Breton (br), Catalan (ca), Cebuano (ceb), Chamorro (ch), Cornish (kw), Corsican (co),
     *     Crimean Tatar - Latin script(crh), Czech (cs), Danish (da), Dutch (nl), English ('en'), Estonian
     *     (et), Fijian (fj), Filipino (fil), Finnish (fi), French (fr), Friulian (fur), Galician (gl),
     *     German (de), Gilbertese (gil), Greenlandic (kl), Haitian Creole (ht), Hani (hni), Hmong Daw
     *     (mww), Hungarian (hu), Indonesian (id), Interlingua (ia), Inuktitut (iu), Irish (ga), Italian
     *     (it), Japanese (ja), Javanese (jv), Kabuverdianu (kea), Kachin (kac), Kara-Kalpak (kaa),
     *     Kashubian (csb), Khasi (kha), Korean (ko), Kurdish - Latin script (ku), Kiche (quc),
     *     Luxembourgish (lb), Malay (ms), Manx (gv), Neapolitan (nap), Norwegian (no), Occitan (oc), Polish
     *     (pl), Portuguese (pt), Romansh (rm), Scots (sco), Scottish Gaelic (gd), simplified Chinese
     *     (zh-Hans), Slovenian (sl), Spanish (es), Swahili (sw), Swedish (sv), Tatar - Latin script (tt),
     *     Tetum (tet), traditional Chinese (zh-Hant), Turkish (tr), Upper Sorbian (hsb), Uzbek (uz), Volapk
     *     (vo), Walser (wae), Western Frisian (fy), Yucatec Maya (yua), Zhuang (za) and Zulu (zu) are
     *     supported (print  seventy-three languages and handwritten  English only). Layout supports auto language
     *     identification and multi language documents, so only provide a language code if you would like to force the
     *     documented to be processed as that specific language.
     * @param readingOrder Reading order algorithm to sort the text lines returned. Supported reading orders include:
     *     basic(default), natural.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeLayoutAsyncHeaders, Void>> analyzeLayoutAsyncWithResponseAsync(
            ContentType contentType,
            List<String> pages,
            Language language,
            ReadingOrder readingOrder,
            Flux<ByteBuffer> fileStream,
            Long contentLength) {
        final String accept = "application/json";
        String pagesConverted =
                (pages == null)
                        ? null
                        : pages.stream().map(value -> Objects.toString(value, "")).collect(Collectors.joining(","));
        return FluxUtil.withContext(
                context ->
                        service.analyzeLayoutAsync(
                                this.getEndpoint(),
                                pagesConverted,
                                language,
                                readingOrder,
                                contentType,
                                fileStream,
                                contentLength,
                                accept,
                                context));
    }

    /**
     * Analyze Layout
     *
     * <p>Extract text and layout information from a given document. The input document must be of one of the supported
     * content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param language Currently, only Afrikaans (af), Albanian (sq), Asturian (ast), Basque (eu), Bislama
     *     (bi), Breton (br), Catalan (ca), Cebuano (ceb), Chamorro (ch), Cornish (kw), Corsican (co),
     *     Crimean Tatar - Latin script(crh), Czech (cs), Danish (da), Dutch (nl), English ('en'), Estonian
     *     (et), Fijian (fj), Filipino (fil), Finnish (fi), French (fr), Friulian (fur), Galician (gl),
     *     German (de), Gilbertese (gil), Greenlandic (kl), Haitian Creole (ht), Hani (hni), Hmong Daw
     *     (mww), Hungarian (hu), Indonesian (id), Interlingua (ia), Inuktitut (iu), Irish (ga), Italian
     *     (it), Japanese (ja), Javanese (jv), Kabuverdianu (kea), Kachin (kac), Kara-Kalpak (kaa),
     *     Kashubian (csb), Khasi (kha), Korean (ko), Kurdish - Latin script (ku), Kiche (quc),
     *     Luxembourgish (lb), Malay (ms), Manx (gv), Neapolitan (nap), Norwegian (no), Occitan (oc), Polish
     *     (pl), Portuguese (pt), Romansh (rm), Scots (sco), Scottish Gaelic (gd), simplified Chinese
     *     (zh-Hans), Slovenian (sl), Spanish (es), Swahili (sw), Swedish (sv), Tatar - Latin script (tt),
     *     Tetum (tet), traditional Chinese (zh-Hant), Turkish (tr), Upper Sorbian (hsb), Uzbek (uz), Volapk
     *     (vo), Walser (wae), Western Frisian (fy), Yucatec Maya (yua), Zhuang (za) and Zulu (zu) are
     *     supported (print  seventy-three languages and handwritten  English only). Layout supports auto language
     *     identification and multi language documents, so only provide a language code if you would like to force the
     *     documented to be processed as that specific language.
     * @param readingOrder Reading order algorithm to sort the text lines returned. Supported reading orders include:
     *     basic(default), natural.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeLayoutAsyncHeaders, Void>> analyzeLayoutAsyncWithResponseAsync(
            ContentType contentType,
            List<String> pages,
            Language language,
            ReadingOrder readingOrder,
            Flux<ByteBuffer> fileStream,
            Long contentLength,
            Context context) {
        final String accept = "application/json";
        String pagesConverted =
                (pages == null)
                        ? null
                        : pages.stream().map(value -> Objects.toString(value, "")).collect(Collectors.joining(","));
        return service.analyzeLayoutAsync(
                this.getEndpoint(),
                pagesConverted,
                language,
                readingOrder,
                contentType,
                fileStream,
                contentLength,
                accept,
                context);
    }

    /**
     * Analyze Layout
     *
     * <p>Extract text and layout information from a given document. The input document must be of one of the supported
     * content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param language Currently, only Afrikaans (af), Albanian (sq), Asturian (ast), Basque (eu), Bislama
     *     (bi), Breton (br), Catalan (ca), Cebuano (ceb), Chamorro (ch), Cornish (kw), Corsican (co),
     *     Crimean Tatar - Latin script(crh), Czech (cs), Danish (da), Dutch (nl), English ('en'), Estonian
     *     (et), Fijian (fj), Filipino (fil), Finnish (fi), French (fr), Friulian (fur), Galician (gl),
     *     German (de), Gilbertese (gil), Greenlandic (kl), Haitian Creole (ht), Hani (hni), Hmong Daw
     *     (mww), Hungarian (hu), Indonesian (id), Interlingua (ia), Inuktitut (iu), Irish (ga), Italian
     *     (it), Japanese (ja), Javanese (jv), Kabuverdianu (kea), Kachin (kac), Kara-Kalpak (kaa),
     *     Kashubian (csb), Khasi (kha), Korean (ko), Kurdish - Latin script (ku), Kiche (quc),
     *     Luxembourgish (lb), Malay (ms), Manx (gv), Neapolitan (nap), Norwegian (no), Occitan (oc), Polish
     *     (pl), Portuguese (pt), Romansh (rm), Scots (sco), Scottish Gaelic (gd), simplified Chinese
     *     (zh-Hans), Slovenian (sl), Spanish (es), Swahili (sw), Swedish (sv), Tatar - Latin script (tt),
     *     Tetum (tet), traditional Chinese (zh-Hant), Turkish (tr), Upper Sorbian (hsb), Uzbek (uz), Volapk
     *     (vo), Walser (wae), Western Frisian (fy), Yucatec Maya (yua), Zhuang (za) and Zulu (zu) are
     *     supported (print  seventy-three languages and handwritten  English only). Layout supports auto language
     *     identification and multi language documents, so only provide a language code if you would like to force the
     *     documented to be processed as that specific language.
     * @param readingOrder Reading order algorithm to sort the text lines returned. Supported reading orders include:
     *     basic(default), natural.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginAnalyzeLayoutAsyncAsync(
            ContentType contentType,
            List<String> pages,
            Language language,
            ReadingOrder readingOrder,
            Flux<ByteBuffer> fileStream,
            Long contentLength) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () ->
                        this.analyzeLayoutAsyncWithResponseAsync(
                                contentType, pages, language, readingOrder, fileStream, contentLength),
                new DefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        Context.NONE),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze Layout
     *
     * <p>Extract text and layout information from a given document. The input document must be of one of the supported
     * content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param language Currently, only Afrikaans (af), Albanian (sq), Asturian (ast), Basque (eu), Bislama
     *     (bi), Breton (br), Catalan (ca), Cebuano (ceb), Chamorro (ch), Cornish (kw), Corsican (co),
     *     Crimean Tatar - Latin script(crh), Czech (cs), Danish (da), Dutch (nl), English ('en'), Estonian
     *     (et), Fijian (fj), Filipino (fil), Finnish (fi), French (fr), Friulian (fur), Galician (gl),
     *     German (de), Gilbertese (gil), Greenlandic (kl), Haitian Creole (ht), Hani (hni), Hmong Daw
     *     (mww), Hungarian (hu), Indonesian (id), Interlingua (ia), Inuktitut (iu), Irish (ga), Italian
     *     (it), Japanese (ja), Javanese (jv), Kabuverdianu (kea), Kachin (kac), Kara-Kalpak (kaa),
     *     Kashubian (csb), Khasi (kha), Korean (ko), Kurdish - Latin script (ku), Kiche (quc),
     *     Luxembourgish (lb), Malay (ms), Manx (gv), Neapolitan (nap), Norwegian (no), Occitan (oc), Polish
     *     (pl), Portuguese (pt), Romansh (rm), Scots (sco), Scottish Gaelic (gd), simplified Chinese
     *     (zh-Hans), Slovenian (sl), Spanish (es), Swahili (sw), Swedish (sv), Tatar - Latin script (tt),
     *     Tetum (tet), traditional Chinese (zh-Hant), Turkish (tr), Upper Sorbian (hsb), Uzbek (uz), Volapk
     *     (vo), Walser (wae), Western Frisian (fy), Yucatec Maya (yua), Zhuang (za) and Zulu (zu) are
     *     supported (print  seventy-three languages and handwritten  English only). Layout supports auto language
     *     identification and multi language documents, so only provide a language code if you would like to force the
     *     documented to be processed as that specific language.
     * @param readingOrder Reading order algorithm to sort the text lines returned. Supported reading orders include:
     *     basic(default), natural.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginAnalyzeLayoutAsyncAsync(
            ContentType contentType,
            List<String> pages,
            Language language,
            ReadingOrder readingOrder,
            Flux<ByteBuffer> fileStream,
            Long contentLength,
            Context context) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () ->
                        this.analyzeLayoutAsyncWithResponseAsync(
                                contentType, pages, language, readingOrder, fileStream, contentLength, context),
                new DefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        context),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze Layout
     *
     * <p>Extract text and layout information from a given document. The input document must be of one of the supported
     * content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param language Currently, only Afrikaans (af), Albanian (sq), Asturian (ast), Basque (eu), Bislama
     *     (bi), Breton (br), Catalan (ca), Cebuano (ceb), Chamorro (ch), Cornish (kw), Corsican (co),
     *     Crimean Tatar - Latin script(crh), Czech (cs), Danish (da), Dutch (nl), English ('en'), Estonian
     *     (et), Fijian (fj), Filipino (fil), Finnish (fi), French (fr), Friulian (fur), Galician (gl),
     *     German (de), Gilbertese (gil), Greenlandic (kl), Haitian Creole (ht), Hani (hni), Hmong Daw
     *     (mww), Hungarian (hu), Indonesian (id), Interlingua (ia), Inuktitut (iu), Irish (ga), Italian
     *     (it), Japanese (ja), Javanese (jv), Kabuverdianu (kea), Kachin (kac), Kara-Kalpak (kaa),
     *     Kashubian (csb), Khasi (kha), Korean (ko), Kurdish - Latin script (ku), Kiche (quc),
     *     Luxembourgish (lb), Malay (ms), Manx (gv), Neapolitan (nap), Norwegian (no), Occitan (oc), Polish
     *     (pl), Portuguese (pt), Romansh (rm), Scots (sco), Scottish Gaelic (gd), simplified Chinese
     *     (zh-Hans), Slovenian (sl), Spanish (es), Swahili (sw), Swedish (sv), Tatar - Latin script (tt),
     *     Tetum (tet), traditional Chinese (zh-Hant), Turkish (tr), Upper Sorbian (hsb), Uzbek (uz), Volapk
     *     (vo), Walser (wae), Western Frisian (fy), Yucatec Maya (yua), Zhuang (za) and Zulu (zu) are
     *     supported (print  seventy-three languages and handwritten  English only). Layout supports auto language
     *     identification and multi language documents, so only provide a language code if you would like to force the
     *     documented to be processed as that specific language.
     * @param readingOrder Reading order algorithm to sort the text lines returned. Supported reading orders include:
     *     basic(default), natural.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeLayoutAsyncHeaders, Void>> analyzeLayoutAsyncWithResponseAsync(
            ContentType contentType,
            List<String> pages,
            Language language,
            ReadingOrder readingOrder,
            BinaryData fileStream,
            Long contentLength) {
        final String accept = "application/json";
        String pagesConverted =
                (pages == null)
                        ? null
                        : pages.stream().map(value -> Objects.toString(value, "")).collect(Collectors.joining(","));
        return FluxUtil.withContext(
                context ->
                        service.analyzeLayoutAsync(
                                this.getEndpoint(),
                                pagesConverted,
                                language,
                                readingOrder,
                                contentType,
                                fileStream,
                                contentLength,
                                accept,
                                context));
    }

    /**
     * Analyze Layout
     *
     * <p>Extract text and layout information from a given document. The input document must be of one of the supported
     * content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param language Currently, only Afrikaans (af), Albanian (sq), Asturian (ast), Basque (eu), Bislama
     *     (bi), Breton (br), Catalan (ca), Cebuano (ceb), Chamorro (ch), Cornish (kw), Corsican (co),
     *     Crimean Tatar - Latin script(crh), Czech (cs), Danish (da), Dutch (nl), English ('en'), Estonian
     *     (et), Fijian (fj), Filipino (fil), Finnish (fi), French (fr), Friulian (fur), Galician (gl),
     *     German (de), Gilbertese (gil), Greenlandic (kl), Haitian Creole (ht), Hani (hni), Hmong Daw
     *     (mww), Hungarian (hu), Indonesian (id), Interlingua (ia), Inuktitut (iu), Irish (ga), Italian
     *     (it), Japanese (ja), Javanese (jv), Kabuverdianu (kea), Kachin (kac), Kara-Kalpak (kaa),
     *     Kashubian (csb), Khasi (kha), Korean (ko), Kurdish - Latin script (ku), Kiche (quc),
     *     Luxembourgish (lb), Malay (ms), Manx (gv), Neapolitan (nap), Norwegian (no), Occitan (oc), Polish
     *     (pl), Portuguese (pt), Romansh (rm), Scots (sco), Scottish Gaelic (gd), simplified Chinese
     *     (zh-Hans), Slovenian (sl), Spanish (es), Swahili (sw), Swedish (sv), Tatar - Latin script (tt),
     *     Tetum (tet), traditional Chinese (zh-Hant), Turkish (tr), Upper Sorbian (hsb), Uzbek (uz), Volapk
     *     (vo), Walser (wae), Western Frisian (fy), Yucatec Maya (yua), Zhuang (za) and Zulu (zu) are
     *     supported (print  seventy-three languages and handwritten  English only). Layout supports auto language
     *     identification and multi language documents, so only provide a language code if you would like to force the
     *     documented to be processed as that specific language.
     * @param readingOrder Reading order algorithm to sort the text lines returned. Supported reading orders include:
     *     basic(default), natural.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeLayoutAsyncHeaders, Void>> analyzeLayoutAsyncWithResponseAsync(
            ContentType contentType,
            List<String> pages,
            Language language,
            ReadingOrder readingOrder,
            BinaryData fileStream,
            Long contentLength,
            Context context) {
        final String accept = "application/json";
        String pagesConverted =
                (pages == null)
                        ? null
                        : pages.stream().map(value -> Objects.toString(value, "")).collect(Collectors.joining(","));
        return service.analyzeLayoutAsync(
                this.getEndpoint(),
                pagesConverted,
                language,
                readingOrder,
                contentType,
                fileStream,
                contentLength,
                accept,
                context);
    }

    /**
     * Analyze Layout
     *
     * <p>Extract text and layout information from a given document. The input document must be of one of the supported
     * content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param language Currently, only Afrikaans (af), Albanian (sq), Asturian (ast), Basque (eu), Bislama
     *     (bi), Breton (br), Catalan (ca), Cebuano (ceb), Chamorro (ch), Cornish (kw), Corsican (co),
     *     Crimean Tatar - Latin script(crh), Czech (cs), Danish (da), Dutch (nl), English ('en'), Estonian
     *     (et), Fijian (fj), Filipino (fil), Finnish (fi), French (fr), Friulian (fur), Galician (gl),
     *     German (de), Gilbertese (gil), Greenlandic (kl), Haitian Creole (ht), Hani (hni), Hmong Daw
     *     (mww), Hungarian (hu), Indonesian (id), Interlingua (ia), Inuktitut (iu), Irish (ga), Italian
     *     (it), Japanese (ja), Javanese (jv), Kabuverdianu (kea), Kachin (kac), Kara-Kalpak (kaa),
     *     Kashubian (csb), Khasi (kha), Korean (ko), Kurdish - Latin script (ku), Kiche (quc),
     *     Luxembourgish (lb), Malay (ms), Manx (gv), Neapolitan (nap), Norwegian (no), Occitan (oc), Polish
     *     (pl), Portuguese (pt), Romansh (rm), Scots (sco), Scottish Gaelic (gd), simplified Chinese
     *     (zh-Hans), Slovenian (sl), Spanish (es), Swahili (sw), Swedish (sv), Tatar - Latin script (tt),
     *     Tetum (tet), traditional Chinese (zh-Hant), Turkish (tr), Upper Sorbian (hsb), Uzbek (uz), Volapk
     *     (vo), Walser (wae), Western Frisian (fy), Yucatec Maya (yua), Zhuang (za) and Zulu (zu) are
     *     supported (print  seventy-three languages and handwritten  English only). Layout supports auto language
     *     identification and multi language documents, so only provide a language code if you would like to force the
     *     documented to be processed as that specific language.
     * @param readingOrder Reading order algorithm to sort the text lines returned. Supported reading orders include:
     *     basic(default), natural.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ResponseBase<AnalyzeLayoutAsyncHeaders, Void> analyzeLayoutAsyncWithResponse(
            ContentType contentType,
            List<String> pages,
            Language language,
            ReadingOrder readingOrder,
            BinaryData fileStream,
            Long contentLength,
            Context context) {
        final String accept = "application/json";
        String pagesConverted =
                (pages == null)
                        ? null
                        : pages.stream().map(value -> Objects.toString(value, "")).collect(Collectors.joining(","));
        return service.analyzeLayoutAsyncSync(
                this.getEndpoint(),
                pagesConverted,
                language,
                readingOrder,
                contentType,
                fileStream,
                contentLength,
                accept,
                context);
    }

    /**
     * Analyze Layout
     *
     * <p>Extract text and layout information from a given document. The input document must be of one of the supported
     * content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param language Currently, only Afrikaans (af), Albanian (sq), Asturian (ast), Basque (eu), Bislama
     *     (bi), Breton (br), Catalan (ca), Cebuano (ceb), Chamorro (ch), Cornish (kw), Corsican (co),
     *     Crimean Tatar - Latin script(crh), Czech (cs), Danish (da), Dutch (nl), English ('en'), Estonian
     *     (et), Fijian (fj), Filipino (fil), Finnish (fi), French (fr), Friulian (fur), Galician (gl),
     *     German (de), Gilbertese (gil), Greenlandic (kl), Haitian Creole (ht), Hani (hni), Hmong Daw
     *     (mww), Hungarian (hu), Indonesian (id), Interlingua (ia), Inuktitut (iu), Irish (ga), Italian
     *     (it), Japanese (ja), Javanese (jv), Kabuverdianu (kea), Kachin (kac), Kara-Kalpak (kaa),
     *     Kashubian (csb), Khasi (kha), Korean (ko), Kurdish - Latin script (ku), Kiche (quc),
     *     Luxembourgish (lb), Malay (ms), Manx (gv), Neapolitan (nap), Norwegian (no), Occitan (oc), Polish
     *     (pl), Portuguese (pt), Romansh (rm), Scots (sco), Scottish Gaelic (gd), simplified Chinese
     *     (zh-Hans), Slovenian (sl), Spanish (es), Swahili (sw), Swedish (sv), Tatar - Latin script (tt),
     *     Tetum (tet), traditional Chinese (zh-Hant), Turkish (tr), Upper Sorbian (hsb), Uzbek (uz), Volapk
     *     (vo), Walser (wae), Western Frisian (fy), Yucatec Maya (yua), Zhuang (za) and Zulu (zu) are
     *     supported (print  seventy-three languages and handwritten  English only). Layout supports auto language
     *     identification and multi language documents, so only provide a language code if you would like to force the
     *     documented to be processed as that specific language.
     * @param readingOrder Reading order algorithm to sort the text lines returned. Supported reading orders include:
     *     basic(default), natural.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginAnalyzeLayoutAsyncAsync(
            ContentType contentType,
            List<String> pages,
            Language language,
            ReadingOrder readingOrder,
            BinaryData fileStream,
            Long contentLength) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () ->
                        this.analyzeLayoutAsyncWithResponseAsync(
                                contentType, pages, language, readingOrder, fileStream, contentLength),
                new DefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        Context.NONE),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze Layout
     *
     * <p>Extract text and layout information from a given document. The input document must be of one of the supported
     * content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param language Currently, only Afrikaans (af), Albanian (sq), Asturian (ast), Basque (eu), Bislama
     *     (bi), Breton (br), Catalan (ca), Cebuano (ceb), Chamorro (ch), Cornish (kw), Corsican (co),
     *     Crimean Tatar - Latin script(crh), Czech (cs), Danish (da), Dutch (nl), English ('en'), Estonian
     *     (et), Fijian (fj), Filipino (fil), Finnish (fi), French (fr), Friulian (fur), Galician (gl),
     *     German (de), Gilbertese (gil), Greenlandic (kl), Haitian Creole (ht), Hani (hni), Hmong Daw
     *     (mww), Hungarian (hu), Indonesian (id), Interlingua (ia), Inuktitut (iu), Irish (ga), Italian
     *     (it), Japanese (ja), Javanese (jv), Kabuverdianu (kea), Kachin (kac), Kara-Kalpak (kaa),
     *     Kashubian (csb), Khasi (kha), Korean (ko), Kurdish - Latin script (ku), Kiche (quc),
     *     Luxembourgish (lb), Malay (ms), Manx (gv), Neapolitan (nap), Norwegian (no), Occitan (oc), Polish
     *     (pl), Portuguese (pt), Romansh (rm), Scots (sco), Scottish Gaelic (gd), simplified Chinese
     *     (zh-Hans), Slovenian (sl), Spanish (es), Swahili (sw), Swedish (sv), Tatar - Latin script (tt),
     *     Tetum (tet), traditional Chinese (zh-Hant), Turkish (tr), Upper Sorbian (hsb), Uzbek (uz), Volapk
     *     (vo), Walser (wae), Western Frisian (fy), Yucatec Maya (yua), Zhuang (za) and Zulu (zu) are
     *     supported (print  seventy-three languages and handwritten  English only). Layout supports auto language
     *     identification and multi language documents, so only provide a language code if you would like to force the
     *     documented to be processed as that specific language.
     * @param readingOrder Reading order algorithm to sort the text lines returned. Supported reading orders include:
     *     basic(default), natural.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginAnalyzeLayoutAsyncAsync(
            ContentType contentType,
            List<String> pages,
            Language language,
            ReadingOrder readingOrder,
            BinaryData fileStream,
            Long contentLength,
            Context context) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () ->
                        this.analyzeLayoutAsyncWithResponseAsync(
                                contentType, pages, language, readingOrder, fileStream, contentLength, context),
                new DefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        context),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze Layout
     *
     * <p>Extract text and layout information from a given document. The input document must be of one of the supported
     * content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param language Currently, only Afrikaans (af), Albanian (sq), Asturian (ast), Basque (eu), Bislama
     *     (bi), Breton (br), Catalan (ca), Cebuano (ceb), Chamorro (ch), Cornish (kw), Corsican (co),
     *     Crimean Tatar - Latin script(crh), Czech (cs), Danish (da), Dutch (nl), English ('en'), Estonian
     *     (et), Fijian (fj), Filipino (fil), Finnish (fi), French (fr), Friulian (fur), Galician (gl),
     *     German (de), Gilbertese (gil), Greenlandic (kl), Haitian Creole (ht), Hani (hni), Hmong Daw
     *     (mww), Hungarian (hu), Indonesian (id), Interlingua (ia), Inuktitut (iu), Irish (ga), Italian
     *     (it), Japanese (ja), Javanese (jv), Kabuverdianu (kea), Kachin (kac), Kara-Kalpak (kaa),
     *     Kashubian (csb), Khasi (kha), Korean (ko), Kurdish - Latin script (ku), Kiche (quc),
     *     Luxembourgish (lb), Malay (ms), Manx (gv), Neapolitan (nap), Norwegian (no), Occitan (oc), Polish
     *     (pl), Portuguese (pt), Romansh (rm), Scots (sco), Scottish Gaelic (gd), simplified Chinese
     *     (zh-Hans), Slovenian (sl), Spanish (es), Swahili (sw), Swedish (sv), Tatar - Latin script (tt),
     *     Tetum (tet), traditional Chinese (zh-Hant), Turkish (tr), Upper Sorbian (hsb), Uzbek (uz), Volapk
     *     (vo), Walser (wae), Western Frisian (fy), Yucatec Maya (yua), Zhuang (za) and Zulu (zu) are
     *     supported (print  seventy-three languages and handwritten  English only). Layout supports auto language
     *     identification and multi language documents, so only provide a language code if you would like to force the
     *     documented to be processed as that specific language.
     * @param readingOrder Reading order algorithm to sort the text lines returned. Supported reading orders include:
     *     basic(default), natural.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginAnalyzeLayoutAsync(
            ContentType contentType,
            List<String> pages,
            Language language,
            ReadingOrder readingOrder,
            BinaryData fileStream,
            Long contentLength) {
        return SyncPoller.createPoller(
                Duration.ofSeconds(1),
                () ->
                        this.analyzeLayoutAsyncWithResponse(
                                contentType, pages, language, readingOrder, fileStream, contentLength, Context.NONE),
                new SyncDefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        Context.NONE),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze Layout
     *
     * <p>Extract text and layout information from a given document. The input document must be of one of the supported
     * content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param contentType Upload file type.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param language Currently, only Afrikaans (af), Albanian (sq), Asturian (ast), Basque (eu), Bislama
     *     (bi), Breton (br), Catalan (ca), Cebuano (ceb), Chamorro (ch), Cornish (kw), Corsican (co),
     *     Crimean Tatar - Latin script(crh), Czech (cs), Danish (da), Dutch (nl), English ('en'), Estonian
     *     (et), Fijian (fj), Filipino (fil), Finnish (fi), French (fr), Friulian (fur), Galician (gl),
     *     German (de), Gilbertese (gil), Greenlandic (kl), Haitian Creole (ht), Hani (hni), Hmong Daw
     *     (mww), Hungarian (hu), Indonesian (id), Interlingua (ia), Inuktitut (iu), Irish (ga), Italian
     *     (it), Japanese (ja), Javanese (jv), Kabuverdianu (kea), Kachin (kac), Kara-Kalpak (kaa),
     *     Kashubian (csb), Khasi (kha), Korean (ko), Kurdish - Latin script (ku), Kiche (quc),
     *     Luxembourgish (lb), Malay (ms), Manx (gv), Neapolitan (nap), Norwegian (no), Occitan (oc), Polish
     *     (pl), Portuguese (pt), Romansh (rm), Scots (sco), Scottish Gaelic (gd), simplified Chinese
     *     (zh-Hans), Slovenian (sl), Spanish (es), Swahili (sw), Swedish (sv), Tatar - Latin script (tt),
     *     Tetum (tet), traditional Chinese (zh-Hant), Turkish (tr), Upper Sorbian (hsb), Uzbek (uz), Volapk
     *     (vo), Walser (wae), Western Frisian (fy), Yucatec Maya (yua), Zhuang (za) and Zulu (zu) are
     *     supported (print  seventy-three languages and handwritten  English only). Layout supports auto language
     *     identification and multi language documents, so only provide a language code if you would like to force the
     *     documented to be processed as that specific language.
     * @param readingOrder Reading order algorithm to sort the text lines returned. Supported reading orders include:
     *     basic(default), natural.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginAnalyzeLayoutAsync(
            ContentType contentType,
            List<String> pages,
            Language language,
            ReadingOrder readingOrder,
            BinaryData fileStream,
            Long contentLength,
            Context context) {
        return SyncPoller.createPoller(
                Duration.ofSeconds(1),
                () ->
                        this.analyzeLayoutAsyncWithResponse(
                                contentType, pages, language, readingOrder, fileStream, contentLength, context),
                new SyncDefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        context),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze Layout
     *
     * <p>Extract text and layout information from a given document. The input document must be of one of the supported
     * content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param language Currently, only Afrikaans (af), Albanian (sq), Asturian (ast), Basque (eu), Bislama
     *     (bi), Breton (br), Catalan (ca), Cebuano (ceb), Chamorro (ch), Cornish (kw), Corsican (co),
     *     Crimean Tatar - Latin script(crh), Czech (cs), Danish (da), Dutch (nl), English ('en'), Estonian
     *     (et), Fijian (fj), Filipino (fil), Finnish (fi), French (fr), Friulian (fur), Galician (gl),
     *     German (de), Gilbertese (gil), Greenlandic (kl), Haitian Creole (ht), Hani (hni), Hmong Daw
     *     (mww), Hungarian (hu), Indonesian (id), Interlingua (ia), Inuktitut (iu), Irish (ga), Italian
     *     (it), Japanese (ja), Javanese (jv), Kabuverdianu (kea), Kachin (kac), Kara-Kalpak (kaa),
     *     Kashubian (csb), Khasi (kha), Korean (ko), Kurdish - Latin script (ku), Kiche (quc),
     *     Luxembourgish (lb), Malay (ms), Manx (gv), Neapolitan (nap), Norwegian (no), Occitan (oc), Polish
     *     (pl), Portuguese (pt), Romansh (rm), Scots (sco), Scottish Gaelic (gd), simplified Chinese
     *     (zh-Hans), Slovenian (sl), Spanish (es), Swahili (sw), Swedish (sv), Tatar - Latin script (tt),
     *     Tetum (tet), traditional Chinese (zh-Hant), Turkish (tr), Upper Sorbian (hsb), Uzbek (uz), Volapk
     *     (vo), Walser (wae), Western Frisian (fy), Yucatec Maya (yua), Zhuang (za) and Zulu (zu) are
     *     supported (print  seventy-three languages and handwritten  English only). Layout supports auto language
     *     identification and multi language documents, so only provide a language code if you would like to force the
     *     documented to be processed as that specific language.
     * @param readingOrder Reading order algorithm to sort the text lines returned. Supported reading orders include:
     *     basic(default), natural.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeLayoutAsyncHeaders, Void>> analyzeLayoutAsyncWithResponseAsync(
            List<String> pages, Language language, ReadingOrder readingOrder, SourcePath fileStream) {
        final String accept = "application/json";
        String pagesConverted =
                (pages == null)
                        ? null
                        : pages.stream().map(value -> Objects.toString(value, "")).collect(Collectors.joining(","));
        return FluxUtil.withContext(
                context ->
                        service.analyzeLayoutAsync(
                                this.getEndpoint(),
                                pagesConverted,
                                language,
                                readingOrder,
                                fileStream,
                                accept,
                                context));
    }

    /**
     * Analyze Layout
     *
     * <p>Extract text and layout information from a given document. The input document must be of one of the supported
     * content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param language Currently, only Afrikaans (af), Albanian (sq), Asturian (ast), Basque (eu), Bislama
     *     (bi), Breton (br), Catalan (ca), Cebuano (ceb), Chamorro (ch), Cornish (kw), Corsican (co),
     *     Crimean Tatar - Latin script(crh), Czech (cs), Danish (da), Dutch (nl), English ('en'), Estonian
     *     (et), Fijian (fj), Filipino (fil), Finnish (fi), French (fr), Friulian (fur), Galician (gl),
     *     German (de), Gilbertese (gil), Greenlandic (kl), Haitian Creole (ht), Hani (hni), Hmong Daw
     *     (mww), Hungarian (hu), Indonesian (id), Interlingua (ia), Inuktitut (iu), Irish (ga), Italian
     *     (it), Japanese (ja), Javanese (jv), Kabuverdianu (kea), Kachin (kac), Kara-Kalpak (kaa),
     *     Kashubian (csb), Khasi (kha), Korean (ko), Kurdish - Latin script (ku), Kiche (quc),
     *     Luxembourgish (lb), Malay (ms), Manx (gv), Neapolitan (nap), Norwegian (no), Occitan (oc), Polish
     *     (pl), Portuguese (pt), Romansh (rm), Scots (sco), Scottish Gaelic (gd), simplified Chinese
     *     (zh-Hans), Slovenian (sl), Spanish (es), Swahili (sw), Swedish (sv), Tatar - Latin script (tt),
     *     Tetum (tet), traditional Chinese (zh-Hant), Turkish (tr), Upper Sorbian (hsb), Uzbek (uz), Volapk
     *     (vo), Walser (wae), Western Frisian (fy), Yucatec Maya (yua), Zhuang (za) and Zulu (zu) are
     *     supported (print  seventy-three languages and handwritten  English only). Layout supports auto language
     *     identification and multi language documents, so only provide a language code if you would like to force the
     *     documented to be processed as that specific language.
     * @param readingOrder Reading order algorithm to sort the text lines returned. Supported reading orders include:
     *     basic(default), natural.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeLayoutAsyncHeaders, Void>> analyzeLayoutAsyncWithResponseAsync(
            List<String> pages, Language language, ReadingOrder readingOrder, SourcePath fileStream, Context context) {
        final String accept = "application/json";
        String pagesConverted =
                (pages == null)
                        ? null
                        : pages.stream().map(value -> Objects.toString(value, "")).collect(Collectors.joining(","));
        return service.analyzeLayoutAsync(
                this.getEndpoint(), pagesConverted, language, readingOrder, fileStream, accept, context);
    }

    /**
     * Analyze Layout
     *
     * <p>Extract text and layout information from a given document. The input document must be of one of the supported
     * content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param language Currently, only Afrikaans (af), Albanian (sq), Asturian (ast), Basque (eu), Bislama
     *     (bi), Breton (br), Catalan (ca), Cebuano (ceb), Chamorro (ch), Cornish (kw), Corsican (co),
     *     Crimean Tatar - Latin script(crh), Czech (cs), Danish (da), Dutch (nl), English ('en'), Estonian
     *     (et), Fijian (fj), Filipino (fil), Finnish (fi), French (fr), Friulian (fur), Galician (gl),
     *     German (de), Gilbertese (gil), Greenlandic (kl), Haitian Creole (ht), Hani (hni), Hmong Daw
     *     (mww), Hungarian (hu), Indonesian (id), Interlingua (ia), Inuktitut (iu), Irish (ga), Italian
     *     (it), Japanese (ja), Javanese (jv), Kabuverdianu (kea), Kachin (kac), Kara-Kalpak (kaa),
     *     Kashubian (csb), Khasi (kha), Korean (ko), Kurdish - Latin script (ku), Kiche (quc),
     *     Luxembourgish (lb), Malay (ms), Manx (gv), Neapolitan (nap), Norwegian (no), Occitan (oc), Polish
     *     (pl), Portuguese (pt), Romansh (rm), Scots (sco), Scottish Gaelic (gd), simplified Chinese
     *     (zh-Hans), Slovenian (sl), Spanish (es), Swahili (sw), Swedish (sv), Tatar - Latin script (tt),
     *     Tetum (tet), traditional Chinese (zh-Hant), Turkish (tr), Upper Sorbian (hsb), Uzbek (uz), Volapk
     *     (vo), Walser (wae), Western Frisian (fy), Yucatec Maya (yua), Zhuang (za) and Zulu (zu) are
     *     supported (print  seventy-three languages and handwritten  English only). Layout supports auto language
     *     identification and multi language documents, so only provide a language code if you would like to force the
     *     documented to be processed as that specific language.
     * @param readingOrder Reading order algorithm to sort the text lines returned. Supported reading orders include:
     *     basic(default), natural.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ResponseBase<AnalyzeLayoutAsyncHeaders, Void> analyzeLayoutAsyncWithResponse(
            List<String> pages, Language language, ReadingOrder readingOrder, SourcePath fileStream, Context context) {
        final String accept = "application/json";
        String pagesConverted =
                (pages == null)
                        ? null
                        : pages.stream().map(value -> Objects.toString(value, "")).collect(Collectors.joining(","));
        return service.analyzeLayoutAsyncSync(
                this.getEndpoint(), pagesConverted, language, readingOrder, fileStream, accept, context);
    }

    /**
     * Analyze Layout
     *
     * <p>Extract text and layout information from a given document. The input document must be of one of the supported
     * content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param language Currently, only Afrikaans (af), Albanian (sq), Asturian (ast), Basque (eu), Bislama
     *     (bi), Breton (br), Catalan (ca), Cebuano (ceb), Chamorro (ch), Cornish (kw), Corsican (co),
     *     Crimean Tatar - Latin script(crh), Czech (cs), Danish (da), Dutch (nl), English ('en'), Estonian
     *     (et), Fijian (fj), Filipino (fil), Finnish (fi), French (fr), Friulian (fur), Galician (gl),
     *     German (de), Gilbertese (gil), Greenlandic (kl), Haitian Creole (ht), Hani (hni), Hmong Daw
     *     (mww), Hungarian (hu), Indonesian (id), Interlingua (ia), Inuktitut (iu), Irish (ga), Italian
     *     (it), Japanese (ja), Javanese (jv), Kabuverdianu (kea), Kachin (kac), Kara-Kalpak (kaa),
     *     Kashubian (csb), Khasi (kha), Korean (ko), Kurdish - Latin script (ku), Kiche (quc),
     *     Luxembourgish (lb), Malay (ms), Manx (gv), Neapolitan (nap), Norwegian (no), Occitan (oc), Polish
     *     (pl), Portuguese (pt), Romansh (rm), Scots (sco), Scottish Gaelic (gd), simplified Chinese
     *     (zh-Hans), Slovenian (sl), Spanish (es), Swahili (sw), Swedish (sv), Tatar - Latin script (tt),
     *     Tetum (tet), traditional Chinese (zh-Hant), Turkish (tr), Upper Sorbian (hsb), Uzbek (uz), Volapk
     *     (vo), Walser (wae), Western Frisian (fy), Yucatec Maya (yua), Zhuang (za) and Zulu (zu) are
     *     supported (print  seventy-three languages and handwritten  English only). Layout supports auto language
     *     identification and multi language documents, so only provide a language code if you would like to force the
     *     documented to be processed as that specific language.
     * @param readingOrder Reading order algorithm to sort the text lines returned. Supported reading orders include:
     *     basic(default), natural.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginAnalyzeLayoutAsyncAsync(
            List<String> pages, Language language, ReadingOrder readingOrder, SourcePath fileStream) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () -> this.analyzeLayoutAsyncWithResponseAsync(pages, language, readingOrder, fileStream),
                new DefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        Context.NONE),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze Layout
     *
     * <p>Extract text and layout information from a given document. The input document must be of one of the supported
     * content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param language Currently, only Afrikaans (af), Albanian (sq), Asturian (ast), Basque (eu), Bislama
     *     (bi), Breton (br), Catalan (ca), Cebuano (ceb), Chamorro (ch), Cornish (kw), Corsican (co),
     *     Crimean Tatar - Latin script(crh), Czech (cs), Danish (da), Dutch (nl), English ('en'), Estonian
     *     (et), Fijian (fj), Filipino (fil), Finnish (fi), French (fr), Friulian (fur), Galician (gl),
     *     German (de), Gilbertese (gil), Greenlandic (kl), Haitian Creole (ht), Hani (hni), Hmong Daw
     *     (mww), Hungarian (hu), Indonesian (id), Interlingua (ia), Inuktitut (iu), Irish (ga), Italian
     *     (it), Japanese (ja), Javanese (jv), Kabuverdianu (kea), Kachin (kac), Kara-Kalpak (kaa),
     *     Kashubian (csb), Khasi (kha), Korean (ko), Kurdish - Latin script (ku), Kiche (quc),
     *     Luxembourgish (lb), Malay (ms), Manx (gv), Neapolitan (nap), Norwegian (no), Occitan (oc), Polish
     *     (pl), Portuguese (pt), Romansh (rm), Scots (sco), Scottish Gaelic (gd), simplified Chinese
     *     (zh-Hans), Slovenian (sl), Spanish (es), Swahili (sw), Swedish (sv), Tatar - Latin script (tt),
     *     Tetum (tet), traditional Chinese (zh-Hant), Turkish (tr), Upper Sorbian (hsb), Uzbek (uz), Volapk
     *     (vo), Walser (wae), Western Frisian (fy), Yucatec Maya (yua), Zhuang (za) and Zulu (zu) are
     *     supported (print  seventy-three languages and handwritten  English only). Layout supports auto language
     *     identification and multi language documents, so only provide a language code if you would like to force the
     *     documented to be processed as that specific language.
     * @param readingOrder Reading order algorithm to sort the text lines returned. Supported reading orders include:
     *     basic(default), natural.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginAnalyzeLayoutAsyncAsync(
            List<String> pages, Language language, ReadingOrder readingOrder, SourcePath fileStream, Context context) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () -> this.analyzeLayoutAsyncWithResponseAsync(pages, language, readingOrder, fileStream, context),
                new DefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        context),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze Layout
     *
     * <p>Extract text and layout information from a given document. The input document must be of one of the supported
     * content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param language Currently, only Afrikaans (af), Albanian (sq), Asturian (ast), Basque (eu), Bislama
     *     (bi), Breton (br), Catalan (ca), Cebuano (ceb), Chamorro (ch), Cornish (kw), Corsican (co),
     *     Crimean Tatar - Latin script(crh), Czech (cs), Danish (da), Dutch (nl), English ('en'), Estonian
     *     (et), Fijian (fj), Filipino (fil), Finnish (fi), French (fr), Friulian (fur), Galician (gl),
     *     German (de), Gilbertese (gil), Greenlandic (kl), Haitian Creole (ht), Hani (hni), Hmong Daw
     *     (mww), Hungarian (hu), Indonesian (id), Interlingua (ia), Inuktitut (iu), Irish (ga), Italian
     *     (it), Japanese (ja), Javanese (jv), Kabuverdianu (kea), Kachin (kac), Kara-Kalpak (kaa),
     *     Kashubian (csb), Khasi (kha), Korean (ko), Kurdish - Latin script (ku), Kiche (quc),
     *     Luxembourgish (lb), Malay (ms), Manx (gv), Neapolitan (nap), Norwegian (no), Occitan (oc), Polish
     *     (pl), Portuguese (pt), Romansh (rm), Scots (sco), Scottish Gaelic (gd), simplified Chinese
     *     (zh-Hans), Slovenian (sl), Spanish (es), Swahili (sw), Swedish (sv), Tatar - Latin script (tt),
     *     Tetum (tet), traditional Chinese (zh-Hant), Turkish (tr), Upper Sorbian (hsb), Uzbek (uz), Volapk
     *     (vo), Walser (wae), Western Frisian (fy), Yucatec Maya (yua), Zhuang (za) and Zulu (zu) are
     *     supported (print  seventy-three languages and handwritten  English only). Layout supports auto language
     *     identification and multi language documents, so only provide a language code if you would like to force the
     *     documented to be processed as that specific language.
     * @param readingOrder Reading order algorithm to sort the text lines returned. Supported reading orders include:
     *     basic(default), natural.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginAnalyzeLayoutAsync(
            List<String> pages, Language language, ReadingOrder readingOrder, SourcePath fileStream) {
        return SyncPoller.createPoller(
                Duration.ofSeconds(1),
                () -> this.analyzeLayoutAsyncWithResponse(pages, language, readingOrder, fileStream, Context.NONE),
                new SyncDefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        Context.NONE),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Analyze Layout
     *
     * <p>Extract text and layout information from a given document. The input document must be of one of the supported
     * content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     *
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     *     get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param language Currently, only Afrikaans (af), Albanian (sq), Asturian (ast), Basque (eu), Bislama
     *     (bi), Breton (br), Catalan (ca), Cebuano (ceb), Chamorro (ch), Cornish (kw), Corsican (co),
     *     Crimean Tatar - Latin script(crh), Czech (cs), Danish (da), Dutch (nl), English ('en'), Estonian
     *     (et), Fijian (fj), Filipino (fil), Finnish (fi), French (fr), Friulian (fur), Galician (gl),
     *     German (de), Gilbertese (gil), Greenlandic (kl), Haitian Creole (ht), Hani (hni), Hmong Daw
     *     (mww), Hungarian (hu), Indonesian (id), Interlingua (ia), Inuktitut (iu), Irish (ga), Italian
     *     (it), Japanese (ja), Javanese (jv), Kabuverdianu (kea), Kachin (kac), Kara-Kalpak (kaa),
     *     Kashubian (csb), Khasi (kha), Korean (ko), Kurdish - Latin script (ku), Kiche (quc),
     *     Luxembourgish (lb), Malay (ms), Manx (gv), Neapolitan (nap), Norwegian (no), Occitan (oc), Polish
     *     (pl), Portuguese (pt), Romansh (rm), Scots (sco), Scottish Gaelic (gd), simplified Chinese
     *     (zh-Hans), Slovenian (sl), Spanish (es), Swahili (sw), Swedish (sv), Tatar - Latin script (tt),
     *     Tetum (tet), traditional Chinese (zh-Hant), Turkish (tr), Upper Sorbian (hsb), Uzbek (uz), Volapk
     *     (vo), Walser (wae), Western Frisian (fy), Yucatec Maya (yua), Zhuang (za) and Zulu (zu) are
     *     supported (print  seventy-three languages and handwritten  English only). Layout supports auto language
     *     identification and multi language documents, so only provide a language code if you would like to force the
     *     documented to be processed as that specific language.
     * @param readingOrder Reading order algorithm to sort the text lines returned. Supported reading orders include:
     *     basic(default), natural.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginAnalyzeLayoutAsync(
            List<String> pages, Language language, ReadingOrder readingOrder, SourcePath fileStream, Context context) {
        return SyncPoller.createPoller(
                Duration.ofSeconds(1),
                () -> this.analyzeLayoutAsyncWithResponse(pages, language, readingOrder, fileStream, context),
                new SyncDefaultPollingStrategy<>(
                        this.getHttpPipeline(),
                        "{endpoint}/formrecognizer/v2.1".replace("{endpoint}", this.getEndpoint()),
                        null,
                        context),
                TypeReference.createInstance(BinaryData.class),
                TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Get Analyze Layout Result
     *
     * <p>Track the progress and obtain the result of the analyze layout operation.
     *
     * @param resultId Analyze operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation along with {@link Response} on successful completion of
     *     {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AnalyzeOperationResult>> getAnalyzeLayoutResultWithResponseAsync(UUID resultId) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context -> service.getAnalyzeLayoutResult(this.getEndpoint(), resultId, accept, context));
    }

    /**
     * Get Analyze Layout Result
     *
     * <p>Track the progress and obtain the result of the analyze layout operation.
     *
     * @param resultId Analyze operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation along with {@link Response} on successful completion of
     *     {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AnalyzeOperationResult>> getAnalyzeLayoutResultWithResponseAsync(
            UUID resultId, Context context) {
        final String accept = "application/json";
        return service.getAnalyzeLayoutResult(this.getEndpoint(), resultId, accept, context);
    }

    /**
     * Get Analyze Layout Result
     *
     * <p>Track the progress and obtain the result of the analyze layout operation.
     *
     * @param resultId Analyze operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalyzeOperationResult> getAnalyzeLayoutResultAsync(UUID resultId) {
        return getAnalyzeLayoutResultWithResponseAsync(resultId).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get Analyze Layout Result
     *
     * <p>Track the progress and obtain the result of the analyze layout operation.
     *
     * @param resultId Analyze operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalyzeOperationResult> getAnalyzeLayoutResultAsync(UUID resultId, Context context) {
        return getAnalyzeLayoutResultWithResponseAsync(resultId, context)
                .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get Analyze Layout Result
     *
     * <p>Track the progress and obtain the result of the analyze layout operation.
     *
     * @param resultId Analyze operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<AnalyzeOperationResult> getAnalyzeLayoutResultWithResponse(UUID resultId, Context context) {
        final String accept = "application/json";
        return service.getAnalyzeLayoutResultSync(this.getEndpoint(), resultId, accept, context);
    }

    /**
     * Get Analyze Layout Result
     *
     * <p>Track the progress and obtain the result of the analyze layout operation.
     *
     * @param resultId Analyze operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public AnalyzeOperationResult getAnalyzeLayoutResult(UUID resultId) {
        return getAnalyzeLayoutResultWithResponse(resultId, Context.NONE).getValue();
    }

    /**
     * List Custom Models
     *
     * <p>Get information about all custom models.
     *
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about all custom models along with {@link PagedResponse} on successful completion of {@link
     *     Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<ModelInfo>> listCustomModelsSinglePageAsync() {
        final String op = "full";
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.listCustomModels(this.getEndpoint(), op, accept, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getModelList(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * List Custom Models
     *
     * <p>Get information about all custom models.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about all custom models along with {@link PagedResponse} on successful completion of {@link
     *     Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<ModelInfo>> listCustomModelsSinglePageAsync(Context context) {
        final String op = "full";
        final String accept = "application/json";
        return service.listCustomModels(this.getEndpoint(), op, accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getModelList(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * List Custom Models
     *
     * <p>Get information about all custom models.
     *
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about all custom models as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<ModelInfo> listCustomModelsAsync() {
        return new PagedFlux<>(
                () -> listCustomModelsSinglePageAsync(), nextLink -> listCustomModelsNextSinglePageAsync(nextLink));
    }

    /**
     * List Custom Models
     *
     * <p>Get information about all custom models.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about all custom models as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<ModelInfo> listCustomModelsAsync(Context context) {
        return new PagedFlux<>(
                () -> listCustomModelsSinglePageAsync(context),
                nextLink -> listCustomModelsNextSinglePageAsync(nextLink, context));
    }

    /**
     * List Custom Models
     *
     * <p>Get information about all custom models.
     *
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about all custom models along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<ModelInfo> listCustomModelsSinglePage() {
        final String op = "full";
        final String accept = "application/json";
        Response<Models> res = service.listCustomModelsSync(this.getEndpoint(), op, accept, Context.NONE);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getModelList(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * List Custom Models
     *
     * <p>Get information about all custom models.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about all custom models along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<ModelInfo> listCustomModelsSinglePage(Context context) {
        final String op = "full";
        final String accept = "application/json";
        Response<Models> res = service.listCustomModelsSync(this.getEndpoint(), op, accept, context);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getModelList(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * List Custom Models
     *
     * <p>Get information about all custom models.
     *
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about all custom models as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<ModelInfo> listCustomModels() {
        return new PagedIterable<>(
                () -> listCustomModelsSinglePage(Context.NONE), nextLink -> listCustomModelsNextSinglePage(nextLink));
    }

    /**
     * List Custom Models
     *
     * <p>Get information about all custom models.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about all custom models as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<ModelInfo> listCustomModels(Context context) {
        return new PagedIterable<>(
                () -> listCustomModelsSinglePage(context),
                nextLink -> listCustomModelsNextSinglePage(nextLink, context));
    }

    /**
     * Get Custom Models
     *
     * <p>Get information about all custom models.
     *
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about all custom models along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Models>> getCustomModelsWithResponseAsync() {
        final String op = "summary";
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.getCustomModels(this.getEndpoint(), op, accept, context));
    }

    /**
     * Get Custom Models
     *
     * <p>Get information about all custom models.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about all custom models along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Models>> getCustomModelsWithResponseAsync(Context context) {
        final String op = "summary";
        final String accept = "application/json";
        return service.getCustomModels(this.getEndpoint(), op, accept, context);
    }

    /**
     * Get Custom Models
     *
     * <p>Get information about all custom models.
     *
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about all custom models on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Models> getCustomModelsAsync() {
        return getCustomModelsWithResponseAsync().flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get Custom Models
     *
     * <p>Get information about all custom models.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about all custom models on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Models> getCustomModelsAsync(Context context) {
        return getCustomModelsWithResponseAsync(context).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get Custom Models
     *
     * <p>Get information about all custom models.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about all custom models along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Models> getCustomModelsWithResponse(Context context) {
        final String op = "summary";
        final String accept = "application/json";
        return service.getCustomModelsSync(this.getEndpoint(), op, accept, context);
    }

    /**
     * Get Custom Models
     *
     * <p>Get information about all custom models.
     *
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about all custom models.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Models getCustomModels() {
        return getCustomModelsWithResponse(Context.NONE).getValue();
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response to the list custom models operation along with {@link PagedResponse} on successful completion of
     *     {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<ModelInfo>> listCustomModelsNextSinglePageAsync(String nextLink) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context -> service.listCustomModelsNext(nextLink, this.getEndpoint(), accept, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getModelList(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response to the list custom models operation along with {@link PagedResponse} on successful completion of
     *     {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<ModelInfo>> listCustomModelsNextSinglePageAsync(String nextLink, Context context) {
        final String accept = "application/json";
        return service.listCustomModelsNext(nextLink, this.getEndpoint(), accept, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        res.getValue().getModelList(),
                                        res.getValue().getNextLink(),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response to the list custom models operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<ModelInfo> listCustomModelsNextSinglePage(String nextLink) {
        final String accept = "application/json";
        Response<Models> res = service.listCustomModelsNextSync(nextLink, this.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getModelList(),
                res.getValue().getNextLink(),
                null);
    }

    /**
     * Get the next page of items.
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response to the list custom models operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<ModelInfo> listCustomModelsNextSinglePage(String nextLink, Context context) {
        final String accept = "application/json";
        Response<Models> res = service.listCustomModelsNextSync(nextLink, this.getEndpoint(), accept, context);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                res.getValue().getModelList(),
                res.getValue().getNextLink(),
                null);
    }
}
