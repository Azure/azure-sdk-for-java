// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.ai.formrecognizer.implementation;

import com.azure.ai.formrecognizer.implementation.models.AnalyzeBusinessCardAsyncHeaders;
import com.azure.ai.formrecognizer.implementation.models.AnalyzeIdDocumentAsyncHeaders;
import com.azure.ai.formrecognizer.implementation.models.AnalyzeInvoiceAsyncHeaders;
import com.azure.ai.formrecognizer.implementation.models.AnalyzeLayoutAsyncHeaders;
import com.azure.ai.formrecognizer.implementation.models.AnalyzeOperationResult;
import com.azure.ai.formrecognizer.implementation.models.AnalyzeReceiptAsyncHeaders;
import com.azure.ai.formrecognizer.implementation.models.AnalyzeWithCustomModelHeaders;
import com.azure.ai.formrecognizer.implementation.models.ComposeCustomModelsAsyncHeaders;
import com.azure.ai.formrecognizer.implementation.models.ComposeRequest;
import com.azure.ai.formrecognizer.implementation.models.ContentType;
import com.azure.ai.formrecognizer.implementation.models.CopyAuthorizationResult;
import com.azure.ai.formrecognizer.implementation.models.CopyCustomModelHeaders;
import com.azure.ai.formrecognizer.implementation.models.CopyOperationResult;
import com.azure.ai.formrecognizer.implementation.models.CopyRequest;
import com.azure.ai.formrecognizer.implementation.models.ErrorResponseException;
import com.azure.ai.formrecognizer.implementation.models.GenerateModelCopyAuthorizationHeaders;
import com.azure.ai.formrecognizer.implementation.models.Language;
import com.azure.ai.formrecognizer.implementation.models.Locale;
import com.azure.ai.formrecognizer.implementation.models.Model;
import com.azure.ai.formrecognizer.implementation.models.ModelInfo;
import com.azure.ai.formrecognizer.implementation.models.Models;
import com.azure.ai.formrecognizer.implementation.models.ReadingOrder;
import com.azure.ai.formrecognizer.implementation.models.SourcePath;
import com.azure.ai.formrecognizer.implementation.models.TrainCustomModelAsyncHeaders;
import com.azure.ai.formrecognizer.implementation.models.TrainRequest;
import com.azure.core.annotation.BodyParam;
import com.azure.core.annotation.Delete;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.HeaderParam;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.Post;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.http.HttpPipeline;
import com.azure.core.http.HttpPipelineBuilder;
import com.azure.core.http.policy.RetryPolicy;
import com.azure.core.http.policy.UserAgentPolicy;
import com.azure.core.http.rest.PagedFlux;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.PagedResponse;
import com.azure.core.http.rest.PagedResponseBase;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.ResponseBase;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.util.BinaryData;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import com.azure.core.util.serializer.JacksonAdapter;
import com.azure.core.util.serializer.SerializerAdapter;
import java.nio.ByteBuffer;
import java.util.List;
import java.util.Objects;
import java.util.UUID;
import java.util.stream.Collectors;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

/**
 * Initializes a new instance of the FormRecognizerClient type.
 */
public final class FormRecognizerClientImpl {
    /**
     * The proxy service used to perform REST calls.
     */
    private final FormRecognizerClientService service;

    /**
     * Supported Cognitive Services endpoints (protocol and hostname, for example:
     * https://westus2.api.cognitive.microsoft.com).
     */
    private final String endpoint;

    /**
     * Gets Supported Cognitive Services endpoints (protocol and hostname, for example:
     * https://westus2.api.cognitive.microsoft.com).
     * 
     * @return the endpoint value.
     */
    public String getEndpoint() {
        return this.endpoint;
    }

    /**
     * Form Recognizer API version.
     */
    private final String apiVersion;

    /**
     * Gets Form Recognizer API version.
     * 
     * @return the apiVersion value.
     */
    public String getApiVersion() {
        return this.apiVersion;
    }

    /**
     * The HTTP pipeline to send requests through.
     */
    private final HttpPipeline httpPipeline;

    /**
     * Gets The HTTP pipeline to send requests through.
     * 
     * @return the httpPipeline value.
     */
    public HttpPipeline getHttpPipeline() {
        return this.httpPipeline;
    }

    /**
     * The serializer to serialize an object into a string.
     */
    private final SerializerAdapter serializerAdapter;

    /**
     * Gets The serializer to serialize an object into a string.
     * 
     * @return the serializerAdapter value.
     */
    public SerializerAdapter getSerializerAdapter() {
        return this.serializerAdapter;
    }

    /**
     * Initializes an instance of FormRecognizerClient client.
     * 
     * @param endpoint Supported Cognitive Services endpoints (protocol and hostname, for example:
     * https://westus2.api.cognitive.microsoft.com).
     * @param apiVersion Form Recognizer API version.
     */
    public FormRecognizerClientImpl(String endpoint, String apiVersion) {
        this(new HttpPipelineBuilder().policies(new UserAgentPolicy(), new RetryPolicy()).build(),
            JacksonAdapter.createDefaultSerializerAdapter(), endpoint, apiVersion);
    }

    /**
     * Initializes an instance of FormRecognizerClient client.
     * 
     * @param httpPipeline The HTTP pipeline to send requests through.
     * @param endpoint Supported Cognitive Services endpoints (protocol and hostname, for example:
     * https://westus2.api.cognitive.microsoft.com).
     * @param apiVersion Form Recognizer API version.
     */
    public FormRecognizerClientImpl(HttpPipeline httpPipeline, String endpoint, String apiVersion) {
        this(httpPipeline, JacksonAdapter.createDefaultSerializerAdapter(), endpoint, apiVersion);
    }

    /**
     * Initializes an instance of FormRecognizerClient client.
     * 
     * @param httpPipeline The HTTP pipeline to send requests through.
     * @param serializerAdapter The serializer to serialize an object into a string.
     * @param endpoint Supported Cognitive Services endpoints (protocol and hostname, for example:
     * https://westus2.api.cognitive.microsoft.com).
     * @param apiVersion Form Recognizer API version.
     */
    public FormRecognizerClientImpl(HttpPipeline httpPipeline, SerializerAdapter serializerAdapter, String endpoint,
        String apiVersion) {
        this.httpPipeline = httpPipeline;
        this.serializerAdapter = serializerAdapter;
        this.endpoint = endpoint;
        this.apiVersion = apiVersion;
        this.service
            = RestProxy.create(FormRecognizerClientService.class, this.httpPipeline, this.getSerializerAdapter());
    }

    /**
     * The interface defining all the services for FormRecognizerClient to be used by the proxy service to perform REST
     * calls.
     */
    @Host("{endpoint}/formrecognizer/{ApiVersion}")
    @ServiceInterface(name = "FormRecognizerClient")
    public interface FormRecognizerClientService {
        @Post("/custom/models")
        @ExpectedResponses({ 201 })
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<ResponseBase<TrainCustomModelAsyncHeaders, Void>> trainCustomModelAsync(
            @HostParam("endpoint") String endpoint, @HostParam("ApiVersion") String apiVersion,
            @BodyParam("application/json") TrainRequest trainRequest, @HeaderParam("Accept") String accept,
            Context context);

        @Get("/custom/models/{modelId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<Response<Model>> getCustomModel(@HostParam("endpoint") String endpoint,
            @HostParam("ApiVersion") String apiVersion, @PathParam("modelId") UUID modelId,
            @QueryParam("includeKeys") Boolean includeKeys, @HeaderParam("Accept") String accept, Context context);

        @Delete("/custom/models/{modelId}")
        @ExpectedResponses({ 204 })
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<Response<Void>> deleteCustomModel(@HostParam("endpoint") String endpoint,
            @HostParam("ApiVersion") String apiVersion, @PathParam("modelId") UUID modelId,
            @HeaderParam("Accept") String accept, Context context);

        @Post("/custom/models/{modelId}/analyze")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<ResponseBase<AnalyzeWithCustomModelHeaders, Void>> analyzeWithCustomModel(
            @HostParam("endpoint") String endpoint, @HostParam("ApiVersion") String apiVersion,
            @PathParam("modelId") UUID modelId, @QueryParam("includeTextDetails") Boolean includeTextDetails,
            @QueryParam("pages") String pages, @HeaderParam("Content-Type") ContentType contentType,
            @BodyParam("application/octet-stream") Flux<ByteBuffer> fileStream,
            @HeaderParam("Content-Length") Long contentLength, @HeaderParam("Accept") String accept, Context context);

        @Post("/custom/models/{modelId}/analyze")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<ResponseBase<AnalyzeWithCustomModelHeaders, Void>> analyzeWithCustomModel(
            @HostParam("endpoint") String endpoint, @HostParam("ApiVersion") String apiVersion,
            @PathParam("modelId") UUID modelId, @QueryParam("includeTextDetails") Boolean includeTextDetails,
            @QueryParam("pages") String pages, @HeaderParam("Content-Type") ContentType contentType,
            @BodyParam("application/octet-stream") BinaryData fileStream,
            @HeaderParam("Content-Length") Long contentLength, @HeaderParam("Accept") String accept, Context context);

        @Post("/custom/models/{modelId}/analyze")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<ResponseBase<AnalyzeWithCustomModelHeaders, Void>> analyzeWithCustomModel(
            @HostParam("endpoint") String endpoint, @HostParam("ApiVersion") String apiVersion,
            @PathParam("modelId") UUID modelId, @QueryParam("includeTextDetails") Boolean includeTextDetails,
            @QueryParam("pages") String pages, @BodyParam("application/json") SourcePath fileStream,
            @HeaderParam("Accept") String accept, Context context);

        @Get("/custom/models/{modelId}/analyzeResults/{resultId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<Response<AnalyzeOperationResult>> getAnalyzeFormResult(@HostParam("endpoint") String endpoint,
            @HostParam("ApiVersion") String apiVersion, @PathParam("modelId") UUID modelId,
            @PathParam("resultId") UUID resultId, @HeaderParam("Accept") String accept, Context context);

        @Post("/custom/models/{modelId}/copy")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<ResponseBase<CopyCustomModelHeaders, Void>> copyCustomModel(@HostParam("endpoint") String endpoint,
            @HostParam("ApiVersion") String apiVersion, @PathParam("modelId") UUID modelId,
            @BodyParam("application/json") CopyRequest copyRequest, @HeaderParam("Accept") String accept,
            Context context);

        @Get("/custom/models/{modelId}/copyResults/{resultId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<Response<CopyOperationResult>> getCustomModelCopyResult(@HostParam("endpoint") String endpoint,
            @HostParam("ApiVersion") String apiVersion, @PathParam("modelId") UUID modelId,
            @PathParam("resultId") UUID resultId, @HeaderParam("Accept") String accept, Context context);

        @Post("/custom/models/copyAuthorization")
        @ExpectedResponses({ 201 })
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<ResponseBase<GenerateModelCopyAuthorizationHeaders, CopyAuthorizationResult>>
            generateModelCopyAuthorization(@HostParam("endpoint") String endpoint,
                @HostParam("ApiVersion") String apiVersion, @HeaderParam("Accept") String accept, Context context);

        @Post("/custom/models/compose")
        @ExpectedResponses({ 201 })
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<ResponseBase<ComposeCustomModelsAsyncHeaders, Void>> composeCustomModelsAsync(
            @HostParam("endpoint") String endpoint, @HostParam("ApiVersion") String apiVersion,
            @BodyParam("application/json") ComposeRequest composeRequest, @HeaderParam("Accept") String accept,
            Context context);

        @Post("/prebuilt/businessCard/analyze")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<ResponseBase<AnalyzeBusinessCardAsyncHeaders, Void>> analyzeBusinessCardAsync(
            @HostParam("endpoint") String endpoint, @HostParam("ApiVersion") String apiVersion,
            @QueryParam("includeTextDetails") Boolean includeTextDetails, @QueryParam("locale") Locale locale,
            @QueryParam("pages") String pages, @HeaderParam("Content-Type") ContentType contentType,
            @BodyParam("application/octet-stream") Flux<ByteBuffer> fileStream,
            @HeaderParam("Content-Length") Long contentLength, @HeaderParam("Accept") String accept, Context context);

        @Post("/prebuilt/businessCard/analyze")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<ResponseBase<AnalyzeBusinessCardAsyncHeaders, Void>> analyzeBusinessCardAsync(
            @HostParam("endpoint") String endpoint, @HostParam("ApiVersion") String apiVersion,
            @QueryParam("includeTextDetails") Boolean includeTextDetails, @QueryParam("locale") Locale locale,
            @QueryParam("pages") String pages, @HeaderParam("Content-Type") ContentType contentType,
            @BodyParam("application/octet-stream") BinaryData fileStream,
            @HeaderParam("Content-Length") Long contentLength, @HeaderParam("Accept") String accept, Context context);

        @Post("/prebuilt/businessCard/analyze")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<ResponseBase<AnalyzeBusinessCardAsyncHeaders, Void>> analyzeBusinessCardAsync(
            @HostParam("endpoint") String endpoint, @HostParam("ApiVersion") String apiVersion,
            @QueryParam("includeTextDetails") Boolean includeTextDetails, @QueryParam("locale") Locale locale,
            @QueryParam("pages") String pages, @BodyParam("application/json") SourcePath fileStream,
            @HeaderParam("Accept") String accept, Context context);

        @Get("/prebuilt/businessCard/analyzeResults/{resultId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<Response<AnalyzeOperationResult>> getAnalyzeBusinessCardResult(@HostParam("endpoint") String endpoint,
            @HostParam("ApiVersion") String apiVersion, @PathParam("resultId") UUID resultId,
            @HeaderParam("Accept") String accept, Context context);

        @Post("/prebuilt/invoice/analyze")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<ResponseBase<AnalyzeInvoiceAsyncHeaders, Void>> analyzeInvoiceAsync(@HostParam("endpoint") String endpoint,
            @HostParam("ApiVersion") String apiVersion, @QueryParam("includeTextDetails") Boolean includeTextDetails,
            @QueryParam("locale") Locale locale, @QueryParam("pages") String pages,
            @HeaderParam("Content-Type") ContentType contentType,
            @BodyParam("application/octet-stream") Flux<ByteBuffer> fileStream,
            @HeaderParam("Content-Length") Long contentLength, @HeaderParam("Accept") String accept, Context context);

        @Post("/prebuilt/invoice/analyze")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<ResponseBase<AnalyzeInvoiceAsyncHeaders, Void>> analyzeInvoiceAsync(@HostParam("endpoint") String endpoint,
            @HostParam("ApiVersion") String apiVersion, @QueryParam("includeTextDetails") Boolean includeTextDetails,
            @QueryParam("locale") Locale locale, @QueryParam("pages") String pages,
            @HeaderParam("Content-Type") ContentType contentType,
            @BodyParam("application/octet-stream") BinaryData fileStream,
            @HeaderParam("Content-Length") Long contentLength, @HeaderParam("Accept") String accept, Context context);

        @Post("/prebuilt/invoice/analyze")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<ResponseBase<AnalyzeInvoiceAsyncHeaders, Void>> analyzeInvoiceAsync(@HostParam("endpoint") String endpoint,
            @HostParam("ApiVersion") String apiVersion, @QueryParam("includeTextDetails") Boolean includeTextDetails,
            @QueryParam("locale") Locale locale, @QueryParam("pages") String pages,
            @BodyParam("application/json") SourcePath fileStream, @HeaderParam("Accept") String accept,
            Context context);

        @Get("/prebuilt/invoice/analyzeResults/{resultId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<Response<AnalyzeOperationResult>> getAnalyzeInvoiceResult(@HostParam("endpoint") String endpoint,
            @HostParam("ApiVersion") String apiVersion, @PathParam("resultId") UUID resultId,
            @HeaderParam("Accept") String accept, Context context);

        @Post("/prebuilt/idDocument/analyze")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<ResponseBase<AnalyzeIdDocumentAsyncHeaders, Void>> analyzeIdDocumentAsync(
            @HostParam("endpoint") String endpoint, @HostParam("ApiVersion") String apiVersion,
            @QueryParam("includeTextDetails") Boolean includeTextDetails, @QueryParam("pages") String pages,
            @HeaderParam("Content-Type") ContentType contentType,
            @BodyParam("application/octet-stream") Flux<ByteBuffer> fileStream,
            @HeaderParam("Content-Length") Long contentLength, @HeaderParam("Accept") String accept, Context context);

        @Post("/prebuilt/idDocument/analyze")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<ResponseBase<AnalyzeIdDocumentAsyncHeaders, Void>> analyzeIdDocumentAsync(
            @HostParam("endpoint") String endpoint, @HostParam("ApiVersion") String apiVersion,
            @QueryParam("includeTextDetails") Boolean includeTextDetails, @QueryParam("pages") String pages,
            @HeaderParam("Content-Type") ContentType contentType,
            @BodyParam("application/octet-stream") BinaryData fileStream,
            @HeaderParam("Content-Length") Long contentLength, @HeaderParam("Accept") String accept, Context context);

        @Post("/prebuilt/idDocument/analyze")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<ResponseBase<AnalyzeIdDocumentAsyncHeaders, Void>> analyzeIdDocumentAsync(
            @HostParam("endpoint") String endpoint, @HostParam("ApiVersion") String apiVersion,
            @QueryParam("includeTextDetails") Boolean includeTextDetails, @QueryParam("pages") String pages,
            @BodyParam("application/json") SourcePath fileStream, @HeaderParam("Accept") String accept,
            Context context);

        @Get("/prebuilt/idDocument/analyzeResults/{resultId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<Response<AnalyzeOperationResult>> getAnalyzeIdDocumentResult(@HostParam("endpoint") String endpoint,
            @HostParam("ApiVersion") String apiVersion, @PathParam("resultId") UUID resultId,
            @HeaderParam("Accept") String accept, Context context);

        @Post("/prebuilt/receipt/analyze")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<ResponseBase<AnalyzeReceiptAsyncHeaders, Void>> analyzeReceiptAsync(@HostParam("endpoint") String endpoint,
            @HostParam("ApiVersion") String apiVersion, @QueryParam("includeTextDetails") Boolean includeTextDetails,
            @QueryParam("locale") Locale locale, @QueryParam("pages") String pages,
            @HeaderParam("Content-Type") ContentType contentType,
            @BodyParam("application/octet-stream") Flux<ByteBuffer> fileStream,
            @HeaderParam("Content-Length") Long contentLength, @HeaderParam("Accept") String accept, Context context);

        @Post("/prebuilt/receipt/analyze")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<ResponseBase<AnalyzeReceiptAsyncHeaders, Void>> analyzeReceiptAsync(@HostParam("endpoint") String endpoint,
            @HostParam("ApiVersion") String apiVersion, @QueryParam("includeTextDetails") Boolean includeTextDetails,
            @QueryParam("locale") Locale locale, @QueryParam("pages") String pages,
            @HeaderParam("Content-Type") ContentType contentType,
            @BodyParam("application/octet-stream") BinaryData fileStream,
            @HeaderParam("Content-Length") Long contentLength, @HeaderParam("Accept") String accept, Context context);

        @Post("/prebuilt/receipt/analyze")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<ResponseBase<AnalyzeReceiptAsyncHeaders, Void>> analyzeReceiptAsync(@HostParam("endpoint") String endpoint,
            @HostParam("ApiVersion") String apiVersion, @QueryParam("includeTextDetails") Boolean includeTextDetails,
            @QueryParam("locale") Locale locale, @QueryParam("pages") String pages,
            @BodyParam("application/json") SourcePath fileStream, @HeaderParam("Accept") String accept,
            Context context);

        @Get("/prebuilt/receipt/analyzeResults/{resultId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<Response<AnalyzeOperationResult>> getAnalyzeReceiptResult(@HostParam("endpoint") String endpoint,
            @HostParam("ApiVersion") String apiVersion, @PathParam("resultId") UUID resultId,
            @HeaderParam("Accept") String accept, Context context);

        @Post("/layout/analyze")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<ResponseBase<AnalyzeLayoutAsyncHeaders, Void>> analyzeLayoutAsync(@HostParam("endpoint") String endpoint,
            @HostParam("ApiVersion") String apiVersion, @QueryParam("pages") String pages,
            @QueryParam("language") Language language, @QueryParam("readingOrder") ReadingOrder readingOrder,
            @HeaderParam("Content-Type") ContentType contentType,
            @BodyParam("application/octet-stream") Flux<ByteBuffer> fileStream,
            @HeaderParam("Content-Length") Long contentLength, @HeaderParam("Accept") String accept, Context context);

        @Post("/layout/analyze")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<ResponseBase<AnalyzeLayoutAsyncHeaders, Void>> analyzeLayoutAsync(@HostParam("endpoint") String endpoint,
            @HostParam("ApiVersion") String apiVersion, @QueryParam("pages") String pages,
            @QueryParam("language") Language language, @QueryParam("readingOrder") ReadingOrder readingOrder,
            @HeaderParam("Content-Type") ContentType contentType,
            @BodyParam("application/octet-stream") BinaryData fileStream,
            @HeaderParam("Content-Length") Long contentLength, @HeaderParam("Accept") String accept, Context context);

        @Post("/layout/analyze")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<ResponseBase<AnalyzeLayoutAsyncHeaders, Void>> analyzeLayoutAsync(@HostParam("endpoint") String endpoint,
            @HostParam("ApiVersion") String apiVersion, @QueryParam("pages") String pages,
            @QueryParam("language") Language language, @QueryParam("readingOrder") ReadingOrder readingOrder,
            @BodyParam("application/json") SourcePath fileStream, @HeaderParam("Accept") String accept,
            Context context);

        @Get("/layout/analyzeResults/{resultId}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<Response<AnalyzeOperationResult>> getAnalyzeLayoutResult(@HostParam("endpoint") String endpoint,
            @HostParam("ApiVersion") String apiVersion, @PathParam("resultId") UUID resultId,
            @HeaderParam("Accept") String accept, Context context);

        @Get("/custom/models")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<Response<Models>> listCustomModels(@HostParam("endpoint") String endpoint,
            @HostParam("ApiVersion") String apiVersion, @QueryParam("op") String op,
            @HeaderParam("Accept") String accept, Context context);

        @Get("/custom/models")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<Response<Models>> getCustomModels(@HostParam("endpoint") String endpoint,
            @HostParam("ApiVersion") String apiVersion, @QueryParam("op") String op,
            @HeaderParam("Accept") String accept, Context context);

        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<Response<Models>> listCustomModelsNext(@PathParam(value = "nextLink", encoded = true) String nextLink,
            @HostParam("endpoint") String endpoint, @HostParam("ApiVersion") String apiVersion,
            @HeaderParam("Accept") String accept, Context context);
    }

    /**
     * Train Custom Model
     * 
     * Create and train a custom model. The request must include a source parameter that is either an externally
     * accessible Azure storage blob container Uri (preferably a Shared Access Signature Uri) or valid path to a data
     * folder in a locally mounted drive. When local paths are specified, they must follow the Linux/Unix path format
     * and be an absolute path rooted to the input mount configuration setting value e.g., if '{Mounts:Input}'
     * configuration setting value is '/input' then a valid source path would be '/input/contosodataset'. All data to be
     * trained is expected to be under the source folder or sub folders under it. Models are trained using documents
     * that are of the following content type - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or
     * 'image/bmp'. Other type of content is ignored.
     * 
     * @param trainRequest Training request parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<TrainCustomModelAsyncHeaders, Void>>
        trainCustomModelAsyncWithResponseAsync(TrainRequest trainRequest) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.trainCustomModelAsync(this.getEndpoint(), this.getApiVersion(),
            trainRequest, accept, context));
    }

    /**
     * Train Custom Model
     * 
     * Create and train a custom model. The request must include a source parameter that is either an externally
     * accessible Azure storage blob container Uri (preferably a Shared Access Signature Uri) or valid path to a data
     * folder in a locally mounted drive. When local paths are specified, they must follow the Linux/Unix path format
     * and be an absolute path rooted to the input mount configuration setting value e.g., if '{Mounts:Input}'
     * configuration setting value is '/input' then a valid source path would be '/input/contosodataset'. All data to be
     * trained is expected to be under the source folder or sub folders under it. Models are trained using documents
     * that are of the following content type - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or
     * 'image/bmp'. Other type of content is ignored.
     * 
     * @param trainRequest Training request parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<TrainCustomModelAsyncHeaders, Void>>
        trainCustomModelAsyncWithResponseAsync(TrainRequest trainRequest, Context context) {
        final String accept = "application/json";
        return service.trainCustomModelAsync(this.getEndpoint(), this.getApiVersion(), trainRequest, accept, context);
    }

    /**
     * Train Custom Model
     * 
     * Create and train a custom model. The request must include a source parameter that is either an externally
     * accessible Azure storage blob container Uri (preferably a Shared Access Signature Uri) or valid path to a data
     * folder in a locally mounted drive. When local paths are specified, they must follow the Linux/Unix path format
     * and be an absolute path rooted to the input mount configuration setting value e.g., if '{Mounts:Input}'
     * configuration setting value is '/input' then a valid source path would be '/input/contosodataset'. All data to be
     * trained is expected to be under the source folder or sub folders under it. Models are trained using documents
     * that are of the following content type - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or
     * 'image/bmp'. Other type of content is ignored.
     * 
     * @param trainRequest Training request parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> trainCustomModelAsyncAsync(TrainRequest trainRequest) {
        return trainCustomModelAsyncWithResponseAsync(trainRequest).flatMap(ignored -> Mono.empty());
    }

    /**
     * Train Custom Model
     * 
     * Create and train a custom model. The request must include a source parameter that is either an externally
     * accessible Azure storage blob container Uri (preferably a Shared Access Signature Uri) or valid path to a data
     * folder in a locally mounted drive. When local paths are specified, they must follow the Linux/Unix path format
     * and be an absolute path rooted to the input mount configuration setting value e.g., if '{Mounts:Input}'
     * configuration setting value is '/input' then a valid source path would be '/input/contosodataset'. All data to be
     * trained is expected to be under the source folder or sub folders under it. Models are trained using documents
     * that are of the following content type - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or
     * 'image/bmp'. Other type of content is ignored.
     * 
     * @param trainRequest Training request parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> trainCustomModelAsyncAsync(TrainRequest trainRequest, Context context) {
        return trainCustomModelAsyncWithResponseAsync(trainRequest, context).flatMap(ignored -> Mono.empty());
    }

    /**
     * Train Custom Model
     * 
     * Create and train a custom model. The request must include a source parameter that is either an externally
     * accessible Azure storage blob container Uri (preferably a Shared Access Signature Uri) or valid path to a data
     * folder in a locally mounted drive. When local paths are specified, they must follow the Linux/Unix path format
     * and be an absolute path rooted to the input mount configuration setting value e.g., if '{Mounts:Input}'
     * configuration setting value is '/input' then a valid source path would be '/input/contosodataset'. All data to be
     * trained is expected to be under the source folder or sub folders under it. Models are trained using documents
     * that are of the following content type - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or
     * 'image/bmp'. Other type of content is ignored.
     * 
     * @param trainRequest Training request parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ResponseBase<TrainCustomModelAsyncHeaders, Void> trainCustomModelAsyncWithResponse(TrainRequest trainRequest,
        Context context) {
        return trainCustomModelAsyncWithResponseAsync(trainRequest, context).block();
    }

    /**
     * Train Custom Model
     * 
     * Create and train a custom model. The request must include a source parameter that is either an externally
     * accessible Azure storage blob container Uri (preferably a Shared Access Signature Uri) or valid path to a data
     * folder in a locally mounted drive. When local paths are specified, they must follow the Linux/Unix path format
     * and be an absolute path rooted to the input mount configuration setting value e.g., if '{Mounts:Input}'
     * configuration setting value is '/input' then a valid source path would be '/input/contosodataset'. All data to be
     * trained is expected to be under the source folder or sub folders under it. Models are trained using documents
     * that are of the following content type - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or
     * 'image/bmp'. Other type of content is ignored.
     * 
     * @param trainRequest Training request parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void trainCustomModelAsync(TrainRequest trainRequest) {
        trainCustomModelAsyncWithResponse(trainRequest, Context.NONE);
    }

    /**
     * Get Custom Model
     * 
     * Get detailed information about a custom model.
     * 
     * @param modelId Model identifier.
     * @param includeKeys Include list of extracted keys in model information.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return detailed information about a custom model along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Model>> getCustomModelWithResponseAsync(UUID modelId, Boolean includeKeys) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.getCustomModel(this.getEndpoint(), this.getApiVersion(), modelId,
            includeKeys, accept, context));
    }

    /**
     * Get Custom Model
     * 
     * Get detailed information about a custom model.
     * 
     * @param modelId Model identifier.
     * @param includeKeys Include list of extracted keys in model information.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return detailed information about a custom model along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Model>> getCustomModelWithResponseAsync(UUID modelId, Boolean includeKeys, Context context) {
        final String accept = "application/json";
        return service.getCustomModel(this.getEndpoint(), this.getApiVersion(), modelId, includeKeys, accept, context);
    }

    /**
     * Get Custom Model
     * 
     * Get detailed information about a custom model.
     * 
     * @param modelId Model identifier.
     * @param includeKeys Include list of extracted keys in model information.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return detailed information about a custom model on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Model> getCustomModelAsync(UUID modelId, Boolean includeKeys) {
        return getCustomModelWithResponseAsync(modelId, includeKeys).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get Custom Model
     * 
     * Get detailed information about a custom model.
     * 
     * @param modelId Model identifier.
     * @param includeKeys Include list of extracted keys in model information.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return detailed information about a custom model on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Model> getCustomModelAsync(UUID modelId, Boolean includeKeys, Context context) {
        return getCustomModelWithResponseAsync(modelId, includeKeys, context)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get Custom Model
     * 
     * Get detailed information about a custom model.
     * 
     * @param modelId Model identifier.
     * @param includeKeys Include list of extracted keys in model information.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return detailed information about a custom model along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Model> getCustomModelWithResponse(UUID modelId, Boolean includeKeys, Context context) {
        return getCustomModelWithResponseAsync(modelId, includeKeys, context).block();
    }

    /**
     * Get Custom Model
     * 
     * Get detailed information about a custom model.
     * 
     * @param modelId Model identifier.
     * @param includeKeys Include list of extracted keys in model information.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return detailed information about a custom model.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Model getCustomModel(UUID modelId, Boolean includeKeys) {
        return getCustomModelWithResponse(modelId, includeKeys, Context.NONE).getValue();
    }

    /**
     * Delete Custom Model
     * 
     * Mark model for deletion. Model artifacts will be permanently removed within a predetermined period.
     * 
     * @param modelId Model identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteCustomModelWithResponseAsync(UUID modelId) {
        final String accept = "application/json";
        return FluxUtil.withContext(
            context -> service.deleteCustomModel(this.getEndpoint(), this.getApiVersion(), modelId, accept, context));
    }

    /**
     * Delete Custom Model
     * 
     * Mark model for deletion. Model artifacts will be permanently removed within a predetermined period.
     * 
     * @param modelId Model identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteCustomModelWithResponseAsync(UUID modelId, Context context) {
        final String accept = "application/json";
        return service.deleteCustomModel(this.getEndpoint(), this.getApiVersion(), modelId, accept, context);
    }

    /**
     * Delete Custom Model
     * 
     * Mark model for deletion. Model artifacts will be permanently removed within a predetermined period.
     * 
     * @param modelId Model identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteCustomModelAsync(UUID modelId) {
        return deleteCustomModelWithResponseAsync(modelId).flatMap(ignored -> Mono.empty());
    }

    /**
     * Delete Custom Model
     * 
     * Mark model for deletion. Model artifacts will be permanently removed within a predetermined period.
     * 
     * @param modelId Model identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteCustomModelAsync(UUID modelId, Context context) {
        return deleteCustomModelWithResponseAsync(modelId, context).flatMap(ignored -> Mono.empty());
    }

    /**
     * Delete Custom Model
     * 
     * Mark model for deletion. Model artifacts will be permanently removed within a predetermined period.
     * 
     * @param modelId Model identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteCustomModelWithResponse(UUID modelId, Context context) {
        return deleteCustomModelWithResponseAsync(modelId, context).block();
    }

    /**
     * Delete Custom Model
     * 
     * Mark model for deletion. Model artifacts will be permanently removed within a predetermined period.
     * 
     * @param modelId Model identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteCustomModel(UUID modelId) {
        deleteCustomModelWithResponse(modelId, Context.NONE);
    }

    /**
     * Analyze Form
     * 
     * Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one of
     * the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri or local path) of the document to be
     * analyzed.
     * 
     * @param modelId Model identifier.
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeWithCustomModelHeaders, Void>> analyzeWithCustomModelWithResponseAsync(UUID modelId,
        ContentType contentType, Boolean includeTextDetails, List<String> pages, Flux<ByteBuffer> fileStream,
        Long contentLength) {
        final String accept = "application/json";
        String pagesConverted = (pages == null) ? null : pages.stream()
            .map(paramItemValue -> Objects.toString(paramItemValue, "")).collect(Collectors.joining(","));
        return FluxUtil.withContext(context -> service.analyzeWithCustomModel(this.getEndpoint(), this.getApiVersion(),
            modelId, includeTextDetails, pagesConverted, contentType, fileStream, contentLength, accept, context));
    }

    /**
     * Analyze Form
     * 
     * Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one of
     * the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri or local path) of the document to be
     * analyzed.
     * 
     * @param modelId Model identifier.
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeWithCustomModelHeaders, Void>> analyzeWithCustomModelWithResponseAsync(UUID modelId,
        ContentType contentType, Boolean includeTextDetails, List<String> pages, Flux<ByteBuffer> fileStream,
        Long contentLength, Context context) {
        final String accept = "application/json";
        String pagesConverted = (pages == null) ? null : pages.stream()
            .map(paramItemValue -> Objects.toString(paramItemValue, "")).collect(Collectors.joining(","));
        return service.analyzeWithCustomModel(this.getEndpoint(), this.getApiVersion(), modelId, includeTextDetails,
            pagesConverted, contentType, fileStream, contentLength, accept, context);
    }

    /**
     * Analyze Form
     * 
     * Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one of
     * the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri or local path) of the document to be
     * analyzed.
     * 
     * @param modelId Model identifier.
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeWithCustomModelAsync(UUID modelId, ContentType contentType, Boolean includeTextDetails,
        List<String> pages, Flux<ByteBuffer> fileStream, Long contentLength) {
        return analyzeWithCustomModelWithResponseAsync(modelId, contentType, includeTextDetails, pages, fileStream,
            contentLength).flatMap(ignored -> Mono.empty());
    }

    /**
     * Analyze Form
     * 
     * Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one of
     * the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri or local path) of the document to be
     * analyzed.
     * 
     * @param modelId Model identifier.
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeWithCustomModelAsync(UUID modelId, ContentType contentType, Boolean includeTextDetails,
        List<String> pages, Flux<ByteBuffer> fileStream, Long contentLength, Context context) {
        return analyzeWithCustomModelWithResponseAsync(modelId, contentType, includeTextDetails, pages, fileStream,
            contentLength, context).flatMap(ignored -> Mono.empty());
    }

    /**
     * Analyze Form
     * 
     * Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one of
     * the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri or local path) of the document to be
     * analyzed.
     * 
     * @param modelId Model identifier.
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ResponseBase<AnalyzeWithCustomModelHeaders, Void> analyzeWithCustomModelWithResponse(UUID modelId,
        ContentType contentType, Boolean includeTextDetails, List<String> pages, Flux<ByteBuffer> fileStream,
        Long contentLength, Context context) {
        return analyzeWithCustomModelWithResponseAsync(modelId, contentType, includeTextDetails, pages, fileStream,
            contentLength, context).block();
    }

    /**
     * Analyze Form
     * 
     * Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one of
     * the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri or local path) of the document to be
     * analyzed.
     * 
     * @param modelId Model identifier.
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void analyzeWithCustomModel(UUID modelId, ContentType contentType, Boolean includeTextDetails,
        List<String> pages, Flux<ByteBuffer> fileStream, Long contentLength) {
        analyzeWithCustomModelWithResponse(modelId, contentType, includeTextDetails, pages, fileStream, contentLength,
            Context.NONE);
    }

    /**
     * Analyze Form
     * 
     * Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one of
     * the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri or local path) of the document to be
     * analyzed.
     * 
     * @param modelId Model identifier.
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeWithCustomModelHeaders, Void>> analyzeWithCustomModelWithResponseAsync(UUID modelId,
        ContentType contentType, Boolean includeTextDetails, List<String> pages, BinaryData fileStream,
        Long contentLength) {
        final String accept = "application/json";
        String pagesConverted = (pages == null) ? null : pages.stream()
            .map(paramItemValue -> Objects.toString(paramItemValue, "")).collect(Collectors.joining(","));
        return FluxUtil.withContext(context -> service.analyzeWithCustomModel(this.getEndpoint(), this.getApiVersion(),
            modelId, includeTextDetails, pagesConverted, contentType, fileStream, contentLength, accept, context));
    }

    /**
     * Analyze Form
     * 
     * Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one of
     * the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri or local path) of the document to be
     * analyzed.
     * 
     * @param modelId Model identifier.
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeWithCustomModelHeaders, Void>> analyzeWithCustomModelWithResponseAsync(UUID modelId,
        ContentType contentType, Boolean includeTextDetails, List<String> pages, BinaryData fileStream,
        Long contentLength, Context context) {
        final String accept = "application/json";
        String pagesConverted = (pages == null) ? null : pages.stream()
            .map(paramItemValue -> Objects.toString(paramItemValue, "")).collect(Collectors.joining(","));
        return service.analyzeWithCustomModel(this.getEndpoint(), this.getApiVersion(), modelId, includeTextDetails,
            pagesConverted, contentType, fileStream, contentLength, accept, context);
    }

    /**
     * Analyze Form
     * 
     * Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one of
     * the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri or local path) of the document to be
     * analyzed.
     * 
     * @param modelId Model identifier.
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeWithCustomModelAsync(UUID modelId, ContentType contentType, Boolean includeTextDetails,
        List<String> pages, BinaryData fileStream, Long contentLength) {
        return analyzeWithCustomModelWithResponseAsync(modelId, contentType, includeTextDetails, pages, fileStream,
            contentLength).flatMap(ignored -> Mono.empty());
    }

    /**
     * Analyze Form
     * 
     * Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one of
     * the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri or local path) of the document to be
     * analyzed.
     * 
     * @param modelId Model identifier.
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeWithCustomModelAsync(UUID modelId, ContentType contentType, Boolean includeTextDetails,
        List<String> pages, BinaryData fileStream, Long contentLength, Context context) {
        return analyzeWithCustomModelWithResponseAsync(modelId, contentType, includeTextDetails, pages, fileStream,
            contentLength, context).flatMap(ignored -> Mono.empty());
    }

    /**
     * Analyze Form
     * 
     * Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one of
     * the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri or local path) of the document to be
     * analyzed.
     * 
     * @param modelId Model identifier.
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ResponseBase<AnalyzeWithCustomModelHeaders, Void> analyzeWithCustomModelWithResponse(UUID modelId,
        ContentType contentType, Boolean includeTextDetails, List<String> pages, BinaryData fileStream,
        Long contentLength, Context context) {
        return analyzeWithCustomModelWithResponseAsync(modelId, contentType, includeTextDetails, pages, fileStream,
            contentLength, context).block();
    }

    /**
     * Analyze Form
     * 
     * Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one of
     * the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri or local path) of the document to be
     * analyzed.
     * 
     * @param modelId Model identifier.
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void analyzeWithCustomModel(UUID modelId, ContentType contentType, Boolean includeTextDetails,
        List<String> pages, BinaryData fileStream, Long contentLength) {
        analyzeWithCustomModelWithResponse(modelId, contentType, includeTextDetails, pages, fileStream, contentLength,
            Context.NONE);
    }

    /**
     * Analyze Form
     * 
     * Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one of
     * the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri or local path) of the document to be
     * analyzed.
     * 
     * @param modelId Model identifier.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeWithCustomModelHeaders, Void>> analyzeWithCustomModelWithResponseAsync(UUID modelId,
        Boolean includeTextDetails, List<String> pages, SourcePath fileStream) {
        final String accept = "application/json";
        String pagesConverted = (pages == null) ? null : pages.stream()
            .map(paramItemValue -> Objects.toString(paramItemValue, "")).collect(Collectors.joining(","));
        return FluxUtil.withContext(context -> service.analyzeWithCustomModel(this.getEndpoint(), this.getApiVersion(),
            modelId, includeTextDetails, pagesConverted, fileStream, accept, context));
    }

    /**
     * Analyze Form
     * 
     * Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one of
     * the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri or local path) of the document to be
     * analyzed.
     * 
     * @param modelId Model identifier.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeWithCustomModelHeaders, Void>> analyzeWithCustomModelWithResponseAsync(UUID modelId,
        Boolean includeTextDetails, List<String> pages, SourcePath fileStream, Context context) {
        final String accept = "application/json";
        String pagesConverted = (pages == null) ? null : pages.stream()
            .map(paramItemValue -> Objects.toString(paramItemValue, "")).collect(Collectors.joining(","));
        return service.analyzeWithCustomModel(this.getEndpoint(), this.getApiVersion(), modelId, includeTextDetails,
            pagesConverted, fileStream, accept, context);
    }

    /**
     * Analyze Form
     * 
     * Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one of
     * the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri or local path) of the document to be
     * analyzed.
     * 
     * @param modelId Model identifier.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeWithCustomModelAsync(UUID modelId, Boolean includeTextDetails, List<String> pages,
        SourcePath fileStream) {
        return analyzeWithCustomModelWithResponseAsync(modelId, includeTextDetails, pages, fileStream)
            .flatMap(ignored -> Mono.empty());
    }

    /**
     * Analyze Form
     * 
     * Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one of
     * the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri or local path) of the document to be
     * analyzed.
     * 
     * @param modelId Model identifier.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeWithCustomModelAsync(UUID modelId, Boolean includeTextDetails, List<String> pages,
        SourcePath fileStream, Context context) {
        return analyzeWithCustomModelWithResponseAsync(modelId, includeTextDetails, pages, fileStream, context)
            .flatMap(ignored -> Mono.empty());
    }

    /**
     * Analyze Form
     * 
     * Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one of
     * the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri or local path) of the document to be
     * analyzed.
     * 
     * @param modelId Model identifier.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ResponseBase<AnalyzeWithCustomModelHeaders, Void> analyzeWithCustomModelWithResponse(UUID modelId,
        Boolean includeTextDetails, List<String> pages, SourcePath fileStream, Context context) {
        return analyzeWithCustomModelWithResponseAsync(modelId, includeTextDetails, pages, fileStream, context).block();
    }

    /**
     * Analyze Form
     * 
     * Extract key-value pairs, tables, and semantic values from a given document. The input document must be of one of
     * the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri or local path) of the document to be
     * analyzed.
     * 
     * @param modelId Model identifier.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void analyzeWithCustomModel(UUID modelId, Boolean includeTextDetails, List<String> pages,
        SourcePath fileStream) {
        analyzeWithCustomModelWithResponse(modelId, includeTextDetails, pages, fileStream, Context.NONE);
    }

    /**
     * Get Analyze Form Result
     * 
     * Obtain current status and the result of the analyze form operation.
     * 
     * @param modelId Model identifier.
     * @param resultId Analyze operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AnalyzeOperationResult>> getAnalyzeFormResultWithResponseAsync(UUID modelId, UUID resultId) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.getAnalyzeFormResult(this.getEndpoint(), this.getApiVersion(),
            modelId, resultId, accept, context));
    }

    /**
     * Get Analyze Form Result
     * 
     * Obtain current status and the result of the analyze form operation.
     * 
     * @param modelId Model identifier.
     * @param resultId Analyze operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AnalyzeOperationResult>> getAnalyzeFormResultWithResponseAsync(UUID modelId, UUID resultId,
        Context context) {
        final String accept = "application/json";
        return service.getAnalyzeFormResult(this.getEndpoint(), this.getApiVersion(), modelId, resultId, accept,
            context);
    }

    /**
     * Get Analyze Form Result
     * 
     * Obtain current status and the result of the analyze form operation.
     * 
     * @param modelId Model identifier.
     * @param resultId Analyze operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalyzeOperationResult> getAnalyzeFormResultAsync(UUID modelId, UUID resultId) {
        return getAnalyzeFormResultWithResponseAsync(modelId, resultId)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get Analyze Form Result
     * 
     * Obtain current status and the result of the analyze form operation.
     * 
     * @param modelId Model identifier.
     * @param resultId Analyze operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalyzeOperationResult> getAnalyzeFormResultAsync(UUID modelId, UUID resultId, Context context) {
        return getAnalyzeFormResultWithResponseAsync(modelId, resultId, context)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get Analyze Form Result
     * 
     * Obtain current status and the result of the analyze form operation.
     * 
     * @param modelId Model identifier.
     * @param resultId Analyze operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<AnalyzeOperationResult> getAnalyzeFormResultWithResponse(UUID modelId, UUID resultId,
        Context context) {
        return getAnalyzeFormResultWithResponseAsync(modelId, resultId, context).block();
    }

    /**
     * Get Analyze Form Result
     * 
     * Obtain current status and the result of the analyze form operation.
     * 
     * @param modelId Model identifier.
     * @param resultId Analyze operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public AnalyzeOperationResult getAnalyzeFormResult(UUID modelId, UUID resultId) {
        return getAnalyzeFormResultWithResponse(modelId, resultId, Context.NONE).getValue();
    }

    /**
     * Copy Custom Model
     * 
     * Copy custom model stored in this resource (the source) to user specified target Form Recognizer resource.
     * 
     * @param modelId Model identifier.
     * @param copyRequest Copy request parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<CopyCustomModelHeaders, Void>> copyCustomModelWithResponseAsync(UUID modelId,
        CopyRequest copyRequest) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.copyCustomModel(this.getEndpoint(), this.getApiVersion(),
            modelId, copyRequest, accept, context));
    }

    /**
     * Copy Custom Model
     * 
     * Copy custom model stored in this resource (the source) to user specified target Form Recognizer resource.
     * 
     * @param modelId Model identifier.
     * @param copyRequest Copy request parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<CopyCustomModelHeaders, Void>> copyCustomModelWithResponseAsync(UUID modelId,
        CopyRequest copyRequest, Context context) {
        final String accept = "application/json";
        return service.copyCustomModel(this.getEndpoint(), this.getApiVersion(), modelId, copyRequest, accept, context);
    }

    /**
     * Copy Custom Model
     * 
     * Copy custom model stored in this resource (the source) to user specified target Form Recognizer resource.
     * 
     * @param modelId Model identifier.
     * @param copyRequest Copy request parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> copyCustomModelAsync(UUID modelId, CopyRequest copyRequest) {
        return copyCustomModelWithResponseAsync(modelId, copyRequest).flatMap(ignored -> Mono.empty());
    }

    /**
     * Copy Custom Model
     * 
     * Copy custom model stored in this resource (the source) to user specified target Form Recognizer resource.
     * 
     * @param modelId Model identifier.
     * @param copyRequest Copy request parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> copyCustomModelAsync(UUID modelId, CopyRequest copyRequest, Context context) {
        return copyCustomModelWithResponseAsync(modelId, copyRequest, context).flatMap(ignored -> Mono.empty());
    }

    /**
     * Copy Custom Model
     * 
     * Copy custom model stored in this resource (the source) to user specified target Form Recognizer resource.
     * 
     * @param modelId Model identifier.
     * @param copyRequest Copy request parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ResponseBase<CopyCustomModelHeaders, Void> copyCustomModelWithResponse(UUID modelId, CopyRequest copyRequest,
        Context context) {
        return copyCustomModelWithResponseAsync(modelId, copyRequest, context).block();
    }

    /**
     * Copy Custom Model
     * 
     * Copy custom model stored in this resource (the source) to user specified target Form Recognizer resource.
     * 
     * @param modelId Model identifier.
     * @param copyRequest Copy request parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void copyCustomModel(UUID modelId, CopyRequest copyRequest) {
        copyCustomModelWithResponse(modelId, copyRequest, Context.NONE);
    }

    /**
     * Get Custom Model Copy Result
     * 
     * Obtain current status and the result of a custom model copy operation.
     * 
     * @param modelId Model identifier.
     * @param resultId Copy operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued copy operation along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<CopyOperationResult>> getCustomModelCopyResultWithResponseAsync(UUID modelId, UUID resultId) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.getCustomModelCopyResult(this.getEndpoint(),
            this.getApiVersion(), modelId, resultId, accept, context));
    }

    /**
     * Get Custom Model Copy Result
     * 
     * Obtain current status and the result of a custom model copy operation.
     * 
     * @param modelId Model identifier.
     * @param resultId Copy operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued copy operation along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<CopyOperationResult>> getCustomModelCopyResultWithResponseAsync(UUID modelId, UUID resultId,
        Context context) {
        final String accept = "application/json";
        return service.getCustomModelCopyResult(this.getEndpoint(), this.getApiVersion(), modelId, resultId, accept,
            context);
    }

    /**
     * Get Custom Model Copy Result
     * 
     * Obtain current status and the result of a custom model copy operation.
     * 
     * @param modelId Model identifier.
     * @param resultId Copy operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued copy operation on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<CopyOperationResult> getCustomModelCopyResultAsync(UUID modelId, UUID resultId) {
        return getCustomModelCopyResultWithResponseAsync(modelId, resultId)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get Custom Model Copy Result
     * 
     * Obtain current status and the result of a custom model copy operation.
     * 
     * @param modelId Model identifier.
     * @param resultId Copy operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued copy operation on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<CopyOperationResult> getCustomModelCopyResultAsync(UUID modelId, UUID resultId, Context context) {
        return getCustomModelCopyResultWithResponseAsync(modelId, resultId, context)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get Custom Model Copy Result
     * 
     * Obtain current status and the result of a custom model copy operation.
     * 
     * @param modelId Model identifier.
     * @param resultId Copy operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued copy operation along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<CopyOperationResult> getCustomModelCopyResultWithResponse(UUID modelId, UUID resultId,
        Context context) {
        return getCustomModelCopyResultWithResponseAsync(modelId, resultId, context).block();
    }

    /**
     * Get Custom Model Copy Result
     * 
     * Obtain current status and the result of a custom model copy operation.
     * 
     * @param modelId Model identifier.
     * @param resultId Copy operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued copy operation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public CopyOperationResult getCustomModelCopyResult(UUID modelId, UUID resultId) {
        return getCustomModelCopyResultWithResponse(modelId, resultId, Context.NONE).getValue();
    }

    /**
     * Generate Copy Authorization
     * 
     * Generate authorization to copy a model into the target Form Recognizer resource.
     * 
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return request parameter that contains authorization claims for copy operation along with {@link ResponseBase}
     * on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<GenerateModelCopyAuthorizationHeaders, CopyAuthorizationResult>>
        generateModelCopyAuthorizationWithResponseAsync() {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.generateModelCopyAuthorization(this.getEndpoint(),
            this.getApiVersion(), accept, context));
    }

    /**
     * Generate Copy Authorization
     * 
     * Generate authorization to copy a model into the target Form Recognizer resource.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return request parameter that contains authorization claims for copy operation along with {@link ResponseBase}
     * on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<GenerateModelCopyAuthorizationHeaders, CopyAuthorizationResult>>
        generateModelCopyAuthorizationWithResponseAsync(Context context) {
        final String accept = "application/json";
        return service.generateModelCopyAuthorization(this.getEndpoint(), this.getApiVersion(), accept, context);
    }

    /**
     * Generate Copy Authorization
     * 
     * Generate authorization to copy a model into the target Form Recognizer resource.
     * 
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return request parameter that contains authorization claims for copy operation on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<CopyAuthorizationResult> generateModelCopyAuthorizationAsync() {
        return generateModelCopyAuthorizationWithResponseAsync().flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Generate Copy Authorization
     * 
     * Generate authorization to copy a model into the target Form Recognizer resource.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return request parameter that contains authorization claims for copy operation on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<CopyAuthorizationResult> generateModelCopyAuthorizationAsync(Context context) {
        return generateModelCopyAuthorizationWithResponseAsync(context)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Generate Copy Authorization
     * 
     * Generate authorization to copy a model into the target Form Recognizer resource.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return request parameter that contains authorization claims for copy operation along with {@link ResponseBase}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ResponseBase<GenerateModelCopyAuthorizationHeaders, CopyAuthorizationResult>
        generateModelCopyAuthorizationWithResponse(Context context) {
        return generateModelCopyAuthorizationWithResponseAsync(context).block();
    }

    /**
     * Generate Copy Authorization
     * 
     * Generate authorization to copy a model into the target Form Recognizer resource.
     * 
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return request parameter that contains authorization claims for copy operation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public CopyAuthorizationResult generateModelCopyAuthorization() {
        return generateModelCopyAuthorizationWithResponse(Context.NONE).getValue();
    }

    /**
     * Compose trained with labels models into one composed model.
     * 
     * Compose request would include list of models ids.
     * It would validate what all models either trained with labels model or composed model.
     * It would validate limit of models put together.
     * 
     * @param composeRequest Compose models.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<ComposeCustomModelsAsyncHeaders, Void>>
        composeCustomModelsAsyncWithResponseAsync(ComposeRequest composeRequest) {
        final String accept = "application/json, text/json";
        return FluxUtil.withContext(context -> service.composeCustomModelsAsync(this.getEndpoint(),
            this.getApiVersion(), composeRequest, accept, context));
    }

    /**
     * Compose trained with labels models into one composed model.
     * 
     * Compose request would include list of models ids.
     * It would validate what all models either trained with labels model or composed model.
     * It would validate limit of models put together.
     * 
     * @param composeRequest Compose models.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<ComposeCustomModelsAsyncHeaders, Void>>
        composeCustomModelsAsyncWithResponseAsync(ComposeRequest composeRequest, Context context) {
        final String accept = "application/json, text/json";
        return service.composeCustomModelsAsync(this.getEndpoint(), this.getApiVersion(), composeRequest, accept,
            context);
    }

    /**
     * Compose trained with labels models into one composed model.
     * 
     * Compose request would include list of models ids.
     * It would validate what all models either trained with labels model or composed model.
     * It would validate limit of models put together.
     * 
     * @param composeRequest Compose models.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> composeCustomModelsAsyncAsync(ComposeRequest composeRequest) {
        return composeCustomModelsAsyncWithResponseAsync(composeRequest).flatMap(ignored -> Mono.empty());
    }

    /**
     * Compose trained with labels models into one composed model.
     * 
     * Compose request would include list of models ids.
     * It would validate what all models either trained with labels model or composed model.
     * It would validate limit of models put together.
     * 
     * @param composeRequest Compose models.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> composeCustomModelsAsyncAsync(ComposeRequest composeRequest, Context context) {
        return composeCustomModelsAsyncWithResponseAsync(composeRequest, context).flatMap(ignored -> Mono.empty());
    }

    /**
     * Compose trained with labels models into one composed model.
     * 
     * Compose request would include list of models ids.
     * It would validate what all models either trained with labels model or composed model.
     * It would validate limit of models put together.
     * 
     * @param composeRequest Compose models.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ResponseBase<ComposeCustomModelsAsyncHeaders, Void>
        composeCustomModelsAsyncWithResponse(ComposeRequest composeRequest, Context context) {
        return composeCustomModelsAsyncWithResponseAsync(composeRequest, context).block();
    }

    /**
     * Compose trained with labels models into one composed model.
     * 
     * Compose request would include list of models ids.
     * It would validate what all models either trained with labels model or composed model.
     * It would validate limit of models put together.
     * 
     * @param composeRequest Compose models.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void composeCustomModelsAsync(ComposeRequest composeRequest) {
        composeCustomModelsAsyncWithResponse(composeRequest, Context.NONE);
    }

    /**
     * Analyze Business Card
     * 
     * Extract field text and semantic values from a given business card document. The input document must be of one of
     * the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeBusinessCardAsyncHeaders, Void>> analyzeBusinessCardAsyncWithResponseAsync(
        ContentType contentType, Boolean includeTextDetails, Locale locale, List<String> pages,
        Flux<ByteBuffer> fileStream, Long contentLength) {
        final String accept = "application/json";
        String pagesConverted = (pages == null) ? null : pages.stream()
            .map(paramItemValue -> Objects.toString(paramItemValue, "")).collect(Collectors.joining(","));
        return FluxUtil
            .withContext(context -> service.analyzeBusinessCardAsync(this.getEndpoint(), this.getApiVersion(),
                includeTextDetails, locale, pagesConverted, contentType, fileStream, contentLength, accept, context));
    }

    /**
     * Analyze Business Card
     * 
     * Extract field text and semantic values from a given business card document. The input document must be of one of
     * the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeBusinessCardAsyncHeaders, Void>> analyzeBusinessCardAsyncWithResponseAsync(
        ContentType contentType, Boolean includeTextDetails, Locale locale, List<String> pages,
        Flux<ByteBuffer> fileStream, Long contentLength, Context context) {
        final String accept = "application/json";
        String pagesConverted = (pages == null) ? null : pages.stream()
            .map(paramItemValue -> Objects.toString(paramItemValue, "")).collect(Collectors.joining(","));
        return service.analyzeBusinessCardAsync(this.getEndpoint(), this.getApiVersion(), includeTextDetails, locale,
            pagesConverted, contentType, fileStream, contentLength, accept, context);
    }

    /**
     * Analyze Business Card
     * 
     * Extract field text and semantic values from a given business card document. The input document must be of one of
     * the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeBusinessCardAsyncAsync(ContentType contentType, Boolean includeTextDetails, Locale locale,
        List<String> pages, Flux<ByteBuffer> fileStream, Long contentLength) {
        return analyzeBusinessCardAsyncWithResponseAsync(contentType, includeTextDetails, locale, pages, fileStream,
            contentLength).flatMap(ignored -> Mono.empty());
    }

    /**
     * Analyze Business Card
     * 
     * Extract field text and semantic values from a given business card document. The input document must be of one of
     * the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeBusinessCardAsyncAsync(ContentType contentType, Boolean includeTextDetails, Locale locale,
        List<String> pages, Flux<ByteBuffer> fileStream, Long contentLength, Context context) {
        return analyzeBusinessCardAsyncWithResponseAsync(contentType, includeTextDetails, locale, pages, fileStream,
            contentLength, context).flatMap(ignored -> Mono.empty());
    }

    /**
     * Analyze Business Card
     * 
     * Extract field text and semantic values from a given business card document. The input document must be of one of
     * the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ResponseBase<AnalyzeBusinessCardAsyncHeaders, Void> analyzeBusinessCardAsyncWithResponse(
        ContentType contentType, Boolean includeTextDetails, Locale locale, List<String> pages,
        Flux<ByteBuffer> fileStream, Long contentLength, Context context) {
        return analyzeBusinessCardAsyncWithResponseAsync(contentType, includeTextDetails, locale, pages, fileStream,
            contentLength, context).block();
    }

    /**
     * Analyze Business Card
     * 
     * Extract field text and semantic values from a given business card document. The input document must be of one of
     * the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void analyzeBusinessCardAsync(ContentType contentType, Boolean includeTextDetails, Locale locale,
        List<String> pages, Flux<ByteBuffer> fileStream, Long contentLength) {
        analyzeBusinessCardAsyncWithResponse(contentType, includeTextDetails, locale, pages, fileStream, contentLength,
            Context.NONE);
    }

    /**
     * Analyze Business Card
     * 
     * Extract field text and semantic values from a given business card document. The input document must be of one of
     * the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeBusinessCardAsyncHeaders, Void>> analyzeBusinessCardAsyncWithResponseAsync(
        ContentType contentType, Boolean includeTextDetails, Locale locale, List<String> pages, BinaryData fileStream,
        Long contentLength) {
        final String accept = "application/json";
        String pagesConverted = (pages == null) ? null : pages.stream()
            .map(paramItemValue -> Objects.toString(paramItemValue, "")).collect(Collectors.joining(","));
        return FluxUtil
            .withContext(context -> service.analyzeBusinessCardAsync(this.getEndpoint(), this.getApiVersion(),
                includeTextDetails, locale, pagesConverted, contentType, fileStream, contentLength, accept, context));
    }

    /**
     * Analyze Business Card
     * 
     * Extract field text and semantic values from a given business card document. The input document must be of one of
     * the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeBusinessCardAsyncHeaders, Void>> analyzeBusinessCardAsyncWithResponseAsync(
        ContentType contentType, Boolean includeTextDetails, Locale locale, List<String> pages, BinaryData fileStream,
        Long contentLength, Context context) {
        final String accept = "application/json";
        String pagesConverted = (pages == null) ? null : pages.stream()
            .map(paramItemValue -> Objects.toString(paramItemValue, "")).collect(Collectors.joining(","));
        return service.analyzeBusinessCardAsync(this.getEndpoint(), this.getApiVersion(), includeTextDetails, locale,
            pagesConverted, contentType, fileStream, contentLength, accept, context);
    }

    /**
     * Analyze Business Card
     * 
     * Extract field text and semantic values from a given business card document. The input document must be of one of
     * the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeBusinessCardAsyncAsync(ContentType contentType, Boolean includeTextDetails, Locale locale,
        List<String> pages, BinaryData fileStream, Long contentLength) {
        return analyzeBusinessCardAsyncWithResponseAsync(contentType, includeTextDetails, locale, pages, fileStream,
            contentLength).flatMap(ignored -> Mono.empty());
    }

    /**
     * Analyze Business Card
     * 
     * Extract field text and semantic values from a given business card document. The input document must be of one of
     * the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeBusinessCardAsyncAsync(ContentType contentType, Boolean includeTextDetails, Locale locale,
        List<String> pages, BinaryData fileStream, Long contentLength, Context context) {
        return analyzeBusinessCardAsyncWithResponseAsync(contentType, includeTextDetails, locale, pages, fileStream,
            contentLength, context).flatMap(ignored -> Mono.empty());
    }

    /**
     * Analyze Business Card
     * 
     * Extract field text and semantic values from a given business card document. The input document must be of one of
     * the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ResponseBase<AnalyzeBusinessCardAsyncHeaders, Void> analyzeBusinessCardAsyncWithResponse(
        ContentType contentType, Boolean includeTextDetails, Locale locale, List<String> pages, BinaryData fileStream,
        Long contentLength, Context context) {
        return analyzeBusinessCardAsyncWithResponseAsync(contentType, includeTextDetails, locale, pages, fileStream,
            contentLength, context).block();
    }

    /**
     * Analyze Business Card
     * 
     * Extract field text and semantic values from a given business card document. The input document must be of one of
     * the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void analyzeBusinessCardAsync(ContentType contentType, Boolean includeTextDetails, Locale locale,
        List<String> pages, BinaryData fileStream, Long contentLength) {
        analyzeBusinessCardAsyncWithResponse(contentType, includeTextDetails, locale, pages, fileStream, contentLength,
            Context.NONE);
    }

    /**
     * Analyze Business Card
     * 
     * Extract field text and semantic values from a given business card document. The input document must be of one of
     * the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeBusinessCardAsyncHeaders, Void>> analyzeBusinessCardAsyncWithResponseAsync(
        Boolean includeTextDetails, Locale locale, List<String> pages, SourcePath fileStream) {
        final String accept = "application/json";
        String pagesConverted = (pages == null) ? null : pages.stream()
            .map(paramItemValue -> Objects.toString(paramItemValue, "")).collect(Collectors.joining(","));
        return FluxUtil.withContext(context -> service.analyzeBusinessCardAsync(this.getEndpoint(),
            this.getApiVersion(), includeTextDetails, locale, pagesConverted, fileStream, accept, context));
    }

    /**
     * Analyze Business Card
     * 
     * Extract field text and semantic values from a given business card document. The input document must be of one of
     * the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeBusinessCardAsyncHeaders, Void>> analyzeBusinessCardAsyncWithResponseAsync(
        Boolean includeTextDetails, Locale locale, List<String> pages, SourcePath fileStream, Context context) {
        final String accept = "application/json";
        String pagesConverted = (pages == null) ? null : pages.stream()
            .map(paramItemValue -> Objects.toString(paramItemValue, "")).collect(Collectors.joining(","));
        return service.analyzeBusinessCardAsync(this.getEndpoint(), this.getApiVersion(), includeTextDetails, locale,
            pagesConverted, fileStream, accept, context);
    }

    /**
     * Analyze Business Card
     * 
     * Extract field text and semantic values from a given business card document. The input document must be of one of
     * the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeBusinessCardAsyncAsync(Boolean includeTextDetails, Locale locale, List<String> pages,
        SourcePath fileStream) {
        return analyzeBusinessCardAsyncWithResponseAsync(includeTextDetails, locale, pages, fileStream)
            .flatMap(ignored -> Mono.empty());
    }

    /**
     * Analyze Business Card
     * 
     * Extract field text and semantic values from a given business card document. The input document must be of one of
     * the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeBusinessCardAsyncAsync(Boolean includeTextDetails, Locale locale, List<String> pages,
        SourcePath fileStream, Context context) {
        return analyzeBusinessCardAsyncWithResponseAsync(includeTextDetails, locale, pages, fileStream, context)
            .flatMap(ignored -> Mono.empty());
    }

    /**
     * Analyze Business Card
     * 
     * Extract field text and semantic values from a given business card document. The input document must be of one of
     * the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ResponseBase<AnalyzeBusinessCardAsyncHeaders, Void> analyzeBusinessCardAsyncWithResponse(
        Boolean includeTextDetails, Locale locale, List<String> pages, SourcePath fileStream, Context context) {
        return analyzeBusinessCardAsyncWithResponseAsync(includeTextDetails, locale, pages, fileStream, context)
            .block();
    }

    /**
     * Analyze Business Card
     * 
     * Extract field text and semantic values from a given business card document. The input document must be of one of
     * the supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void analyzeBusinessCardAsync(Boolean includeTextDetails, Locale locale, List<String> pages,
        SourcePath fileStream) {
        analyzeBusinessCardAsyncWithResponse(includeTextDetails, locale, pages, fileStream, Context.NONE);
    }

    /**
     * Get Analyze Business Card Result
     * 
     * Track the progress and obtain the result of the analyze business card operation.
     * 
     * @param resultId Analyze operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AnalyzeOperationResult>> getAnalyzeBusinessCardResultWithResponseAsync(UUID resultId) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.getAnalyzeBusinessCardResult(this.getEndpoint(),
            this.getApiVersion(), resultId, accept, context));
    }

    /**
     * Get Analyze Business Card Result
     * 
     * Track the progress and obtain the result of the analyze business card operation.
     * 
     * @param resultId Analyze operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AnalyzeOperationResult>> getAnalyzeBusinessCardResultWithResponseAsync(UUID resultId,
        Context context) {
        final String accept = "application/json";
        return service.getAnalyzeBusinessCardResult(this.getEndpoint(), this.getApiVersion(), resultId, accept,
            context);
    }

    /**
     * Get Analyze Business Card Result
     * 
     * Track the progress and obtain the result of the analyze business card operation.
     * 
     * @param resultId Analyze operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalyzeOperationResult> getAnalyzeBusinessCardResultAsync(UUID resultId) {
        return getAnalyzeBusinessCardResultWithResponseAsync(resultId).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get Analyze Business Card Result
     * 
     * Track the progress and obtain the result of the analyze business card operation.
     * 
     * @param resultId Analyze operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalyzeOperationResult> getAnalyzeBusinessCardResultAsync(UUID resultId, Context context) {
        return getAnalyzeBusinessCardResultWithResponseAsync(resultId, context)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get Analyze Business Card Result
     * 
     * Track the progress and obtain the result of the analyze business card operation.
     * 
     * @param resultId Analyze operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<AnalyzeOperationResult> getAnalyzeBusinessCardResultWithResponse(UUID resultId, Context context) {
        return getAnalyzeBusinessCardResultWithResponseAsync(resultId, context).block();
    }

    /**
     * Get Analyze Business Card Result
     * 
     * Track the progress and obtain the result of the analyze business card operation.
     * 
     * @param resultId Analyze operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public AnalyzeOperationResult getAnalyzeBusinessCardResult(UUID resultId) {
        return getAnalyzeBusinessCardResultWithResponse(resultId, Context.NONE).getValue();
    }

    /**
     * Analyze Invoice Document
     * 
     * Extract field text and semantic values from a given invoice document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeInvoiceAsyncHeaders, Void>> analyzeInvoiceAsyncWithResponseAsync(
        ContentType contentType, Boolean includeTextDetails, Locale locale, List<String> pages,
        Flux<ByteBuffer> fileStream, Long contentLength) {
        final String accept = "application/json";
        String pagesConverted = (pages == null) ? null : pages.stream()
            .map(paramItemValue -> Objects.toString(paramItemValue, "")).collect(Collectors.joining(","));
        return FluxUtil.withContext(context -> service.analyzeInvoiceAsync(this.getEndpoint(), this.getApiVersion(),
            includeTextDetails, locale, pagesConverted, contentType, fileStream, contentLength, accept, context));
    }

    /**
     * Analyze Invoice Document
     * 
     * Extract field text and semantic values from a given invoice document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeInvoiceAsyncHeaders, Void>> analyzeInvoiceAsyncWithResponseAsync(
        ContentType contentType, Boolean includeTextDetails, Locale locale, List<String> pages,
        Flux<ByteBuffer> fileStream, Long contentLength, Context context) {
        final String accept = "application/json";
        String pagesConverted = (pages == null) ? null : pages.stream()
            .map(paramItemValue -> Objects.toString(paramItemValue, "")).collect(Collectors.joining(","));
        return service.analyzeInvoiceAsync(this.getEndpoint(), this.getApiVersion(), includeTextDetails, locale,
            pagesConverted, contentType, fileStream, contentLength, accept, context);
    }

    /**
     * Analyze Invoice Document
     * 
     * Extract field text and semantic values from a given invoice document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeInvoiceAsyncAsync(ContentType contentType, Boolean includeTextDetails, Locale locale,
        List<String> pages, Flux<ByteBuffer> fileStream, Long contentLength) {
        return analyzeInvoiceAsyncWithResponseAsync(contentType, includeTextDetails, locale, pages, fileStream,
            contentLength).flatMap(ignored -> Mono.empty());
    }

    /**
     * Analyze Invoice Document
     * 
     * Extract field text and semantic values from a given invoice document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeInvoiceAsyncAsync(ContentType contentType, Boolean includeTextDetails, Locale locale,
        List<String> pages, Flux<ByteBuffer> fileStream, Long contentLength, Context context) {
        return analyzeInvoiceAsyncWithResponseAsync(contentType, includeTextDetails, locale, pages, fileStream,
            contentLength, context).flatMap(ignored -> Mono.empty());
    }

    /**
     * Analyze Invoice Document
     * 
     * Extract field text and semantic values from a given invoice document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ResponseBase<AnalyzeInvoiceAsyncHeaders, Void> analyzeInvoiceAsyncWithResponse(ContentType contentType,
        Boolean includeTextDetails, Locale locale, List<String> pages, Flux<ByteBuffer> fileStream, Long contentLength,
        Context context) {
        return analyzeInvoiceAsyncWithResponseAsync(contentType, includeTextDetails, locale, pages, fileStream,
            contentLength, context).block();
    }

    /**
     * Analyze Invoice Document
     * 
     * Extract field text and semantic values from a given invoice document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void analyzeInvoiceAsync(ContentType contentType, Boolean includeTextDetails, Locale locale,
        List<String> pages, Flux<ByteBuffer> fileStream, Long contentLength) {
        analyzeInvoiceAsyncWithResponse(contentType, includeTextDetails, locale, pages, fileStream, contentLength,
            Context.NONE);
    }

    /**
     * Analyze Invoice Document
     * 
     * Extract field text and semantic values from a given invoice document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeInvoiceAsyncHeaders, Void>> analyzeInvoiceAsyncWithResponseAsync(
        ContentType contentType, Boolean includeTextDetails, Locale locale, List<String> pages, BinaryData fileStream,
        Long contentLength) {
        final String accept = "application/json";
        String pagesConverted = (pages == null) ? null : pages.stream()
            .map(paramItemValue -> Objects.toString(paramItemValue, "")).collect(Collectors.joining(","));
        return FluxUtil.withContext(context -> service.analyzeInvoiceAsync(this.getEndpoint(), this.getApiVersion(),
            includeTextDetails, locale, pagesConverted, contentType, fileStream, contentLength, accept, context));
    }

    /**
     * Analyze Invoice Document
     * 
     * Extract field text and semantic values from a given invoice document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeInvoiceAsyncHeaders, Void>> analyzeInvoiceAsyncWithResponseAsync(
        ContentType contentType, Boolean includeTextDetails, Locale locale, List<String> pages, BinaryData fileStream,
        Long contentLength, Context context) {
        final String accept = "application/json";
        String pagesConverted = (pages == null) ? null : pages.stream()
            .map(paramItemValue -> Objects.toString(paramItemValue, "")).collect(Collectors.joining(","));
        return service.analyzeInvoiceAsync(this.getEndpoint(), this.getApiVersion(), includeTextDetails, locale,
            pagesConverted, contentType, fileStream, contentLength, accept, context);
    }

    /**
     * Analyze Invoice Document
     * 
     * Extract field text and semantic values from a given invoice document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeInvoiceAsyncAsync(ContentType contentType, Boolean includeTextDetails, Locale locale,
        List<String> pages, BinaryData fileStream, Long contentLength) {
        return analyzeInvoiceAsyncWithResponseAsync(contentType, includeTextDetails, locale, pages, fileStream,
            contentLength).flatMap(ignored -> Mono.empty());
    }

    /**
     * Analyze Invoice Document
     * 
     * Extract field text and semantic values from a given invoice document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeInvoiceAsyncAsync(ContentType contentType, Boolean includeTextDetails, Locale locale,
        List<String> pages, BinaryData fileStream, Long contentLength, Context context) {
        return analyzeInvoiceAsyncWithResponseAsync(contentType, includeTextDetails, locale, pages, fileStream,
            contentLength, context).flatMap(ignored -> Mono.empty());
    }

    /**
     * Analyze Invoice Document
     * 
     * Extract field text and semantic values from a given invoice document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ResponseBase<AnalyzeInvoiceAsyncHeaders, Void> analyzeInvoiceAsyncWithResponse(ContentType contentType,
        Boolean includeTextDetails, Locale locale, List<String> pages, BinaryData fileStream, Long contentLength,
        Context context) {
        return analyzeInvoiceAsyncWithResponseAsync(contentType, includeTextDetails, locale, pages, fileStream,
            contentLength, context).block();
    }

    /**
     * Analyze Invoice Document
     * 
     * Extract field text and semantic values from a given invoice document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void analyzeInvoiceAsync(ContentType contentType, Boolean includeTextDetails, Locale locale,
        List<String> pages, BinaryData fileStream, Long contentLength) {
        analyzeInvoiceAsyncWithResponse(contentType, includeTextDetails, locale, pages, fileStream, contentLength,
            Context.NONE);
    }

    /**
     * Analyze Invoice Document
     * 
     * Extract field text and semantic values from a given invoice document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeInvoiceAsyncHeaders, Void>> analyzeInvoiceAsyncWithResponseAsync(
        Boolean includeTextDetails, Locale locale, List<String> pages, SourcePath fileStream) {
        final String accept = "application/json";
        String pagesConverted = (pages == null) ? null : pages.stream()
            .map(paramItemValue -> Objects.toString(paramItemValue, "")).collect(Collectors.joining(","));
        return FluxUtil.withContext(context -> service.analyzeInvoiceAsync(this.getEndpoint(), this.getApiVersion(),
            includeTextDetails, locale, pagesConverted, fileStream, accept, context));
    }

    /**
     * Analyze Invoice Document
     * 
     * Extract field text and semantic values from a given invoice document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeInvoiceAsyncHeaders, Void>> analyzeInvoiceAsyncWithResponseAsync(
        Boolean includeTextDetails, Locale locale, List<String> pages, SourcePath fileStream, Context context) {
        final String accept = "application/json";
        String pagesConverted = (pages == null) ? null : pages.stream()
            .map(paramItemValue -> Objects.toString(paramItemValue, "")).collect(Collectors.joining(","));
        return service.analyzeInvoiceAsync(this.getEndpoint(), this.getApiVersion(), includeTextDetails, locale,
            pagesConverted, fileStream, accept, context);
    }

    /**
     * Analyze Invoice Document
     * 
     * Extract field text and semantic values from a given invoice document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeInvoiceAsyncAsync(Boolean includeTextDetails, Locale locale, List<String> pages,
        SourcePath fileStream) {
        return analyzeInvoiceAsyncWithResponseAsync(includeTextDetails, locale, pages, fileStream)
            .flatMap(ignored -> Mono.empty());
    }

    /**
     * Analyze Invoice Document
     * 
     * Extract field text and semantic values from a given invoice document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeInvoiceAsyncAsync(Boolean includeTextDetails, Locale locale, List<String> pages,
        SourcePath fileStream, Context context) {
        return analyzeInvoiceAsyncWithResponseAsync(includeTextDetails, locale, pages, fileStream, context)
            .flatMap(ignored -> Mono.empty());
    }

    /**
     * Analyze Invoice Document
     * 
     * Extract field text and semantic values from a given invoice document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ResponseBase<AnalyzeInvoiceAsyncHeaders, Void> analyzeInvoiceAsyncWithResponse(Boolean includeTextDetails,
        Locale locale, List<String> pages, SourcePath fileStream, Context context) {
        return analyzeInvoiceAsyncWithResponseAsync(includeTextDetails, locale, pages, fileStream, context).block();
    }

    /**
     * Analyze Invoice Document
     * 
     * Extract field text and semantic values from a given invoice document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void analyzeInvoiceAsync(Boolean includeTextDetails, Locale locale, List<String> pages,
        SourcePath fileStream) {
        analyzeInvoiceAsyncWithResponse(includeTextDetails, locale, pages, fileStream, Context.NONE);
    }

    /**
     * Get Analyze Invoice Result
     * 
     * Track the progress and obtain the result of the analyze invoice operation.
     * 
     * @param resultId Analyze operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AnalyzeOperationResult>> getAnalyzeInvoiceResultWithResponseAsync(UUID resultId) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.getAnalyzeInvoiceResult(this.getEndpoint(), this.getApiVersion(),
            resultId, accept, context));
    }

    /**
     * Get Analyze Invoice Result
     * 
     * Track the progress and obtain the result of the analyze invoice operation.
     * 
     * @param resultId Analyze operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AnalyzeOperationResult>> getAnalyzeInvoiceResultWithResponseAsync(UUID resultId,
        Context context) {
        final String accept = "application/json";
        return service.getAnalyzeInvoiceResult(this.getEndpoint(), this.getApiVersion(), resultId, accept, context);
    }

    /**
     * Get Analyze Invoice Result
     * 
     * Track the progress and obtain the result of the analyze invoice operation.
     * 
     * @param resultId Analyze operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalyzeOperationResult> getAnalyzeInvoiceResultAsync(UUID resultId) {
        return getAnalyzeInvoiceResultWithResponseAsync(resultId).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get Analyze Invoice Result
     * 
     * Track the progress and obtain the result of the analyze invoice operation.
     * 
     * @param resultId Analyze operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalyzeOperationResult> getAnalyzeInvoiceResultAsync(UUID resultId, Context context) {
        return getAnalyzeInvoiceResultWithResponseAsync(resultId, context)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get Analyze Invoice Result
     * 
     * Track the progress and obtain the result of the analyze invoice operation.
     * 
     * @param resultId Analyze operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<AnalyzeOperationResult> getAnalyzeInvoiceResultWithResponse(UUID resultId, Context context) {
        return getAnalyzeInvoiceResultWithResponseAsync(resultId, context).block();
    }

    /**
     * Get Analyze Invoice Result
     * 
     * Track the progress and obtain the result of the analyze invoice operation.
     * 
     * @param resultId Analyze operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public AnalyzeOperationResult getAnalyzeInvoiceResult(UUID resultId) {
        return getAnalyzeInvoiceResultWithResponse(resultId, Context.NONE).getValue();
    }

    /**
     * Analyze ID Document
     * 
     * Extract field text and semantic values from a given ID document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeIdDocumentAsyncHeaders, Void>> analyzeIdDocumentAsyncWithResponseAsync(
        ContentType contentType, Boolean includeTextDetails, List<String> pages, Flux<ByteBuffer> fileStream,
        Long contentLength) {
        final String accept = "application/json";
        String pagesConverted = (pages == null) ? null : pages.stream()
            .map(paramItemValue -> Objects.toString(paramItemValue, "")).collect(Collectors.joining(","));
        return FluxUtil.withContext(context -> service.analyzeIdDocumentAsync(this.getEndpoint(), this.getApiVersion(),
            includeTextDetails, pagesConverted, contentType, fileStream, contentLength, accept, context));
    }

    /**
     * Analyze ID Document
     * 
     * Extract field text and semantic values from a given ID document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeIdDocumentAsyncHeaders, Void>> analyzeIdDocumentAsyncWithResponseAsync(
        ContentType contentType, Boolean includeTextDetails, List<String> pages, Flux<ByteBuffer> fileStream,
        Long contentLength, Context context) {
        final String accept = "application/json";
        String pagesConverted = (pages == null) ? null : pages.stream()
            .map(paramItemValue -> Objects.toString(paramItemValue, "")).collect(Collectors.joining(","));
        return service.analyzeIdDocumentAsync(this.getEndpoint(), this.getApiVersion(), includeTextDetails,
            pagesConverted, contentType, fileStream, contentLength, accept, context);
    }

    /**
     * Analyze ID Document
     * 
     * Extract field text and semantic values from a given ID document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeIdDocumentAsyncAsync(ContentType contentType, Boolean includeTextDetails,
        List<String> pages, Flux<ByteBuffer> fileStream, Long contentLength) {
        return analyzeIdDocumentAsyncWithResponseAsync(contentType, includeTextDetails, pages, fileStream,
            contentLength).flatMap(ignored -> Mono.empty());
    }

    /**
     * Analyze ID Document
     * 
     * Extract field text and semantic values from a given ID document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeIdDocumentAsyncAsync(ContentType contentType, Boolean includeTextDetails,
        List<String> pages, Flux<ByteBuffer> fileStream, Long contentLength, Context context) {
        return analyzeIdDocumentAsyncWithResponseAsync(contentType, includeTextDetails, pages, fileStream,
            contentLength, context).flatMap(ignored -> Mono.empty());
    }

    /**
     * Analyze ID Document
     * 
     * Extract field text and semantic values from a given ID document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ResponseBase<AnalyzeIdDocumentAsyncHeaders, Void> analyzeIdDocumentAsyncWithResponse(ContentType contentType,
        Boolean includeTextDetails, List<String> pages, Flux<ByteBuffer> fileStream, Long contentLength,
        Context context) {
        return analyzeIdDocumentAsyncWithResponseAsync(contentType, includeTextDetails, pages, fileStream,
            contentLength, context).block();
    }

    /**
     * Analyze ID Document
     * 
     * Extract field text and semantic values from a given ID document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void analyzeIdDocumentAsync(ContentType contentType, Boolean includeTextDetails, List<String> pages,
        Flux<ByteBuffer> fileStream, Long contentLength) {
        analyzeIdDocumentAsyncWithResponse(contentType, includeTextDetails, pages, fileStream, contentLength,
            Context.NONE);
    }

    /**
     * Analyze ID Document
     * 
     * Extract field text and semantic values from a given ID document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeIdDocumentAsyncHeaders, Void>> analyzeIdDocumentAsyncWithResponseAsync(
        ContentType contentType, Boolean includeTextDetails, List<String> pages, BinaryData fileStream,
        Long contentLength) {
        final String accept = "application/json";
        String pagesConverted = (pages == null) ? null : pages.stream()
            .map(paramItemValue -> Objects.toString(paramItemValue, "")).collect(Collectors.joining(","));
        return FluxUtil.withContext(context -> service.analyzeIdDocumentAsync(this.getEndpoint(), this.getApiVersion(),
            includeTextDetails, pagesConverted, contentType, fileStream, contentLength, accept, context));
    }

    /**
     * Analyze ID Document
     * 
     * Extract field text and semantic values from a given ID document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeIdDocumentAsyncHeaders, Void>> analyzeIdDocumentAsyncWithResponseAsync(
        ContentType contentType, Boolean includeTextDetails, List<String> pages, BinaryData fileStream,
        Long contentLength, Context context) {
        final String accept = "application/json";
        String pagesConverted = (pages == null) ? null : pages.stream()
            .map(paramItemValue -> Objects.toString(paramItemValue, "")).collect(Collectors.joining(","));
        return service.analyzeIdDocumentAsync(this.getEndpoint(), this.getApiVersion(), includeTextDetails,
            pagesConverted, contentType, fileStream, contentLength, accept, context);
    }

    /**
     * Analyze ID Document
     * 
     * Extract field text and semantic values from a given ID document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeIdDocumentAsyncAsync(ContentType contentType, Boolean includeTextDetails,
        List<String> pages, BinaryData fileStream, Long contentLength) {
        return analyzeIdDocumentAsyncWithResponseAsync(contentType, includeTextDetails, pages, fileStream,
            contentLength).flatMap(ignored -> Mono.empty());
    }

    /**
     * Analyze ID Document
     * 
     * Extract field text and semantic values from a given ID document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeIdDocumentAsyncAsync(ContentType contentType, Boolean includeTextDetails,
        List<String> pages, BinaryData fileStream, Long contentLength, Context context) {
        return analyzeIdDocumentAsyncWithResponseAsync(contentType, includeTextDetails, pages, fileStream,
            contentLength, context).flatMap(ignored -> Mono.empty());
    }

    /**
     * Analyze ID Document
     * 
     * Extract field text and semantic values from a given ID document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ResponseBase<AnalyzeIdDocumentAsyncHeaders, Void> analyzeIdDocumentAsyncWithResponse(ContentType contentType,
        Boolean includeTextDetails, List<String> pages, BinaryData fileStream, Long contentLength, Context context) {
        return analyzeIdDocumentAsyncWithResponseAsync(contentType, includeTextDetails, pages, fileStream,
            contentLength, context).block();
    }

    /**
     * Analyze ID Document
     * 
     * Extract field text and semantic values from a given ID document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void analyzeIdDocumentAsync(ContentType contentType, Boolean includeTextDetails, List<String> pages,
        BinaryData fileStream, Long contentLength) {
        analyzeIdDocumentAsyncWithResponse(contentType, includeTextDetails, pages, fileStream, contentLength,
            Context.NONE);
    }

    /**
     * Analyze ID Document
     * 
     * Extract field text and semantic values from a given ID document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeIdDocumentAsyncHeaders, Void>>
        analyzeIdDocumentAsyncWithResponseAsync(Boolean includeTextDetails, List<String> pages, SourcePath fileStream) {
        final String accept = "application/json";
        String pagesConverted = (pages == null) ? null : pages.stream()
            .map(paramItemValue -> Objects.toString(paramItemValue, "")).collect(Collectors.joining(","));
        return FluxUtil.withContext(context -> service.analyzeIdDocumentAsync(this.getEndpoint(), this.getApiVersion(),
            includeTextDetails, pagesConverted, fileStream, accept, context));
    }

    /**
     * Analyze ID Document
     * 
     * Extract field text and semantic values from a given ID document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeIdDocumentAsyncHeaders, Void>> analyzeIdDocumentAsyncWithResponseAsync(
        Boolean includeTextDetails, List<String> pages, SourcePath fileStream, Context context) {
        final String accept = "application/json";
        String pagesConverted = (pages == null) ? null : pages.stream()
            .map(paramItemValue -> Objects.toString(paramItemValue, "")).collect(Collectors.joining(","));
        return service.analyzeIdDocumentAsync(this.getEndpoint(), this.getApiVersion(), includeTextDetails,
            pagesConverted, fileStream, accept, context);
    }

    /**
     * Analyze ID Document
     * 
     * Extract field text and semantic values from a given ID document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeIdDocumentAsyncAsync(Boolean includeTextDetails, List<String> pages,
        SourcePath fileStream) {
        return analyzeIdDocumentAsyncWithResponseAsync(includeTextDetails, pages, fileStream)
            .flatMap(ignored -> Mono.empty());
    }

    /**
     * Analyze ID Document
     * 
     * Extract field text and semantic values from a given ID document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeIdDocumentAsyncAsync(Boolean includeTextDetails, List<String> pages, SourcePath fileStream,
        Context context) {
        return analyzeIdDocumentAsyncWithResponseAsync(includeTextDetails, pages, fileStream, context)
            .flatMap(ignored -> Mono.empty());
    }

    /**
     * Analyze ID Document
     * 
     * Extract field text and semantic values from a given ID document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ResponseBase<AnalyzeIdDocumentAsyncHeaders, Void> analyzeIdDocumentAsyncWithResponse(
        Boolean includeTextDetails, List<String> pages, SourcePath fileStream, Context context) {
        return analyzeIdDocumentAsyncWithResponseAsync(includeTextDetails, pages, fileStream, context).block();
    }

    /**
     * Analyze ID Document
     * 
     * Extract field text and semantic values from a given ID document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param includeTextDetails Include text lines and element references in the result.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void analyzeIdDocumentAsync(Boolean includeTextDetails, List<String> pages, SourcePath fileStream) {
        analyzeIdDocumentAsyncWithResponse(includeTextDetails, pages, fileStream, Context.NONE);
    }

    /**
     * Get Analyze ID Document Result
     * 
     * Track the progress and obtain the result of the analyze ID operation.
     * 
     * @param resultId Analyze operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AnalyzeOperationResult>> getAnalyzeIdDocumentResultWithResponseAsync(UUID resultId) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.getAnalyzeIdDocumentResult(this.getEndpoint(),
            this.getApiVersion(), resultId, accept, context));
    }

    /**
     * Get Analyze ID Document Result
     * 
     * Track the progress and obtain the result of the analyze ID operation.
     * 
     * @param resultId Analyze operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AnalyzeOperationResult>> getAnalyzeIdDocumentResultWithResponseAsync(UUID resultId,
        Context context) {
        final String accept = "application/json";
        return service.getAnalyzeIdDocumentResult(this.getEndpoint(), this.getApiVersion(), resultId, accept, context);
    }

    /**
     * Get Analyze ID Document Result
     * 
     * Track the progress and obtain the result of the analyze ID operation.
     * 
     * @param resultId Analyze operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalyzeOperationResult> getAnalyzeIdDocumentResultAsync(UUID resultId) {
        return getAnalyzeIdDocumentResultWithResponseAsync(resultId).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get Analyze ID Document Result
     * 
     * Track the progress and obtain the result of the analyze ID operation.
     * 
     * @param resultId Analyze operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalyzeOperationResult> getAnalyzeIdDocumentResultAsync(UUID resultId, Context context) {
        return getAnalyzeIdDocumentResultWithResponseAsync(resultId, context)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get Analyze ID Document Result
     * 
     * Track the progress and obtain the result of the analyze ID operation.
     * 
     * @param resultId Analyze operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<AnalyzeOperationResult> getAnalyzeIdDocumentResultWithResponse(UUID resultId, Context context) {
        return getAnalyzeIdDocumentResultWithResponseAsync(resultId, context).block();
    }

    /**
     * Get Analyze ID Document Result
     * 
     * Track the progress and obtain the result of the analyze ID operation.
     * 
     * @param resultId Analyze operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public AnalyzeOperationResult getAnalyzeIdDocumentResult(UUID resultId) {
        return getAnalyzeIdDocumentResultWithResponse(resultId, Context.NONE).getValue();
    }

    /**
     * Analyze Receipt
     * 
     * Extract field text and semantic values from a given receipt document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeReceiptAsyncHeaders, Void>> analyzeReceiptAsyncWithResponseAsync(
        ContentType contentType, Boolean includeTextDetails, Locale locale, List<String> pages,
        Flux<ByteBuffer> fileStream, Long contentLength) {
        final String accept = "application/json";
        String pagesConverted = (pages == null) ? null : pages.stream()
            .map(paramItemValue -> Objects.toString(paramItemValue, "")).collect(Collectors.joining(","));
        return FluxUtil.withContext(context -> service.analyzeReceiptAsync(this.getEndpoint(), this.getApiVersion(),
            includeTextDetails, locale, pagesConverted, contentType, fileStream, contentLength, accept, context));
    }

    /**
     * Analyze Receipt
     * 
     * Extract field text and semantic values from a given receipt document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeReceiptAsyncHeaders, Void>> analyzeReceiptAsyncWithResponseAsync(
        ContentType contentType, Boolean includeTextDetails, Locale locale, List<String> pages,
        Flux<ByteBuffer> fileStream, Long contentLength, Context context) {
        final String accept = "application/json";
        String pagesConverted = (pages == null) ? null : pages.stream()
            .map(paramItemValue -> Objects.toString(paramItemValue, "")).collect(Collectors.joining(","));
        return service.analyzeReceiptAsync(this.getEndpoint(), this.getApiVersion(), includeTextDetails, locale,
            pagesConverted, contentType, fileStream, contentLength, accept, context);
    }

    /**
     * Analyze Receipt
     * 
     * Extract field text and semantic values from a given receipt document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeReceiptAsyncAsync(ContentType contentType, Boolean includeTextDetails, Locale locale,
        List<String> pages, Flux<ByteBuffer> fileStream, Long contentLength) {
        return analyzeReceiptAsyncWithResponseAsync(contentType, includeTextDetails, locale, pages, fileStream,
            contentLength).flatMap(ignored -> Mono.empty());
    }

    /**
     * Analyze Receipt
     * 
     * Extract field text and semantic values from a given receipt document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeReceiptAsyncAsync(ContentType contentType, Boolean includeTextDetails, Locale locale,
        List<String> pages, Flux<ByteBuffer> fileStream, Long contentLength, Context context) {
        return analyzeReceiptAsyncWithResponseAsync(contentType, includeTextDetails, locale, pages, fileStream,
            contentLength, context).flatMap(ignored -> Mono.empty());
    }

    /**
     * Analyze Receipt
     * 
     * Extract field text and semantic values from a given receipt document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ResponseBase<AnalyzeReceiptAsyncHeaders, Void> analyzeReceiptAsyncWithResponse(ContentType contentType,
        Boolean includeTextDetails, Locale locale, List<String> pages, Flux<ByteBuffer> fileStream, Long contentLength,
        Context context) {
        return analyzeReceiptAsyncWithResponseAsync(contentType, includeTextDetails, locale, pages, fileStream,
            contentLength, context).block();
    }

    /**
     * Analyze Receipt
     * 
     * Extract field text and semantic values from a given receipt document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void analyzeReceiptAsync(ContentType contentType, Boolean includeTextDetails, Locale locale,
        List<String> pages, Flux<ByteBuffer> fileStream, Long contentLength) {
        analyzeReceiptAsyncWithResponse(contentType, includeTextDetails, locale, pages, fileStream, contentLength,
            Context.NONE);
    }

    /**
     * Analyze Receipt
     * 
     * Extract field text and semantic values from a given receipt document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeReceiptAsyncHeaders, Void>> analyzeReceiptAsyncWithResponseAsync(
        ContentType contentType, Boolean includeTextDetails, Locale locale, List<String> pages, BinaryData fileStream,
        Long contentLength) {
        final String accept = "application/json";
        String pagesConverted = (pages == null) ? null : pages.stream()
            .map(paramItemValue -> Objects.toString(paramItemValue, "")).collect(Collectors.joining(","));
        return FluxUtil.withContext(context -> service.analyzeReceiptAsync(this.getEndpoint(), this.getApiVersion(),
            includeTextDetails, locale, pagesConverted, contentType, fileStream, contentLength, accept, context));
    }

    /**
     * Analyze Receipt
     * 
     * Extract field text and semantic values from a given receipt document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeReceiptAsyncHeaders, Void>> analyzeReceiptAsyncWithResponseAsync(
        ContentType contentType, Boolean includeTextDetails, Locale locale, List<String> pages, BinaryData fileStream,
        Long contentLength, Context context) {
        final String accept = "application/json";
        String pagesConverted = (pages == null) ? null : pages.stream()
            .map(paramItemValue -> Objects.toString(paramItemValue, "")).collect(Collectors.joining(","));
        return service.analyzeReceiptAsync(this.getEndpoint(), this.getApiVersion(), includeTextDetails, locale,
            pagesConverted, contentType, fileStream, contentLength, accept, context);
    }

    /**
     * Analyze Receipt
     * 
     * Extract field text and semantic values from a given receipt document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeReceiptAsyncAsync(ContentType contentType, Boolean includeTextDetails, Locale locale,
        List<String> pages, BinaryData fileStream, Long contentLength) {
        return analyzeReceiptAsyncWithResponseAsync(contentType, includeTextDetails, locale, pages, fileStream,
            contentLength).flatMap(ignored -> Mono.empty());
    }

    /**
     * Analyze Receipt
     * 
     * Extract field text and semantic values from a given receipt document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeReceiptAsyncAsync(ContentType contentType, Boolean includeTextDetails, Locale locale,
        List<String> pages, BinaryData fileStream, Long contentLength, Context context) {
        return analyzeReceiptAsyncWithResponseAsync(contentType, includeTextDetails, locale, pages, fileStream,
            contentLength, context).flatMap(ignored -> Mono.empty());
    }

    /**
     * Analyze Receipt
     * 
     * Extract field text and semantic values from a given receipt document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ResponseBase<AnalyzeReceiptAsyncHeaders, Void> analyzeReceiptAsyncWithResponse(ContentType contentType,
        Boolean includeTextDetails, Locale locale, List<String> pages, BinaryData fileStream, Long contentLength,
        Context context) {
        return analyzeReceiptAsyncWithResponseAsync(contentType, includeTextDetails, locale, pages, fileStream,
            contentLength, context).block();
    }

    /**
     * Analyze Receipt
     * 
     * Extract field text and semantic values from a given receipt document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void analyzeReceiptAsync(ContentType contentType, Boolean includeTextDetails, Locale locale,
        List<String> pages, BinaryData fileStream, Long contentLength) {
        analyzeReceiptAsyncWithResponse(contentType, includeTextDetails, locale, pages, fileStream, contentLength,
            Context.NONE);
    }

    /**
     * Analyze Receipt
     * 
     * Extract field text and semantic values from a given receipt document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeReceiptAsyncHeaders, Void>> analyzeReceiptAsyncWithResponseAsync(
        Boolean includeTextDetails, Locale locale, List<String> pages, SourcePath fileStream) {
        final String accept = "application/json";
        String pagesConverted = (pages == null) ? null : pages.stream()
            .map(paramItemValue -> Objects.toString(paramItemValue, "")).collect(Collectors.joining(","));
        return FluxUtil.withContext(context -> service.analyzeReceiptAsync(this.getEndpoint(), this.getApiVersion(),
            includeTextDetails, locale, pagesConverted, fileStream, accept, context));
    }

    /**
     * Analyze Receipt
     * 
     * Extract field text and semantic values from a given receipt document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeReceiptAsyncHeaders, Void>> analyzeReceiptAsyncWithResponseAsync(
        Boolean includeTextDetails, Locale locale, List<String> pages, SourcePath fileStream, Context context) {
        final String accept = "application/json";
        String pagesConverted = (pages == null) ? null : pages.stream()
            .map(paramItemValue -> Objects.toString(paramItemValue, "")).collect(Collectors.joining(","));
        return service.analyzeReceiptAsync(this.getEndpoint(), this.getApiVersion(), includeTextDetails, locale,
            pagesConverted, fileStream, accept, context);
    }

    /**
     * Analyze Receipt
     * 
     * Extract field text and semantic values from a given receipt document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeReceiptAsyncAsync(Boolean includeTextDetails, Locale locale, List<String> pages,
        SourcePath fileStream) {
        return analyzeReceiptAsyncWithResponseAsync(includeTextDetails, locale, pages, fileStream)
            .flatMap(ignored -> Mono.empty());
    }

    /**
     * Analyze Receipt
     * 
     * Extract field text and semantic values from a given receipt document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeReceiptAsyncAsync(Boolean includeTextDetails, Locale locale, List<String> pages,
        SourcePath fileStream, Context context) {
        return analyzeReceiptAsyncWithResponseAsync(includeTextDetails, locale, pages, fileStream, context)
            .flatMap(ignored -> Mono.empty());
    }

    /**
     * Analyze Receipt
     * 
     * Extract field text and semantic values from a given receipt document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ResponseBase<AnalyzeReceiptAsyncHeaders, Void> analyzeReceiptAsyncWithResponse(Boolean includeTextDetails,
        Locale locale, List<String> pages, SourcePath fileStream, Context context) {
        return analyzeReceiptAsyncWithResponseAsync(includeTextDetails, locale, pages, fileStream, context).block();
    }

    /**
     * Analyze Receipt
     * 
     * Extract field text and semantic values from a given receipt document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'.
     * Alternatively, use 'application/json' type to specify the location (Uri) of the document to be analyzed.
     * 
     * @param includeTextDetails Include text lines and element references in the result.
     * @param locale Locale of the input document. Supported locales include: en-AU, en-CA, en-GB, en-IN,
     * en-US(default).
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void analyzeReceiptAsync(Boolean includeTextDetails, Locale locale, List<String> pages,
        SourcePath fileStream) {
        analyzeReceiptAsyncWithResponse(includeTextDetails, locale, pages, fileStream, Context.NONE);
    }

    /**
     * Get Analyze Receipt Result
     * 
     * Track the progress and obtain the result of the analyze receipt operation.
     * 
     * @param resultId Analyze operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AnalyzeOperationResult>> getAnalyzeReceiptResultWithResponseAsync(UUID resultId) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.getAnalyzeReceiptResult(this.getEndpoint(), this.getApiVersion(),
            resultId, accept, context));
    }

    /**
     * Get Analyze Receipt Result
     * 
     * Track the progress and obtain the result of the analyze receipt operation.
     * 
     * @param resultId Analyze operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AnalyzeOperationResult>> getAnalyzeReceiptResultWithResponseAsync(UUID resultId,
        Context context) {
        final String accept = "application/json";
        return service.getAnalyzeReceiptResult(this.getEndpoint(), this.getApiVersion(), resultId, accept, context);
    }

    /**
     * Get Analyze Receipt Result
     * 
     * Track the progress and obtain the result of the analyze receipt operation.
     * 
     * @param resultId Analyze operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalyzeOperationResult> getAnalyzeReceiptResultAsync(UUID resultId) {
        return getAnalyzeReceiptResultWithResponseAsync(resultId).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get Analyze Receipt Result
     * 
     * Track the progress and obtain the result of the analyze receipt operation.
     * 
     * @param resultId Analyze operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalyzeOperationResult> getAnalyzeReceiptResultAsync(UUID resultId, Context context) {
        return getAnalyzeReceiptResultWithResponseAsync(resultId, context)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get Analyze Receipt Result
     * 
     * Track the progress and obtain the result of the analyze receipt operation.
     * 
     * @param resultId Analyze operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<AnalyzeOperationResult> getAnalyzeReceiptResultWithResponse(UUID resultId, Context context) {
        return getAnalyzeReceiptResultWithResponseAsync(resultId, context).block();
    }

    /**
     * Get Analyze Receipt Result
     * 
     * Track the progress and obtain the result of the analyze receipt operation.
     * 
     * @param resultId Analyze operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public AnalyzeOperationResult getAnalyzeReceiptResult(UUID resultId) {
        return getAnalyzeReceiptResultWithResponse(resultId, Context.NONE).getValue();
    }

    /**
     * Analyze Layout
     * 
     * Extract text and layout information from a given document. The input document must be of one of the supported
     * content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param language Currently, only Afrikaans (‘af’), Albanian (‘sq’), Asturian (‘ast’), Basque (‘eu’), Bislama
     * (‘bi’), Breton (‘br’), Catalan (‘ca’), Cebuano (‘ceb’), Chamorro (‘ch’), Cornish (‘kw’), Corsican (‘co’), Crimean
     * Tatar - Latin script(‘crh’), Czech (‘cs’), Danish (‘da’), Dutch (‘nl’), English ('en'), Estonian (‘et’), Fijian
     * (‘fj’), Filipino (‘fil’), Finnish (‘fi’), French (‘fr’), Friulian (‘fur’), Galician (‘gl’), German (‘de’),
     * Gilbertese (‘gil’), Greenlandic (‘kl’), Haitian Creole (‘ht’), Hani (‘hni’), Hmong Daw (‘mww’), Hungarian (‘hu’),
     * Indonesian (‘id’), Interlingua (‘ia’), Inuktitut (‘iu’), Irish (‘ga’), Italian (‘it’), Japanese (‘ja’), Javanese
     * (‘jv’), Kabuverdianu (‘kea’), Kachin (‘kac’), Kara-Kalpak (‘kaa’), Kashubian (‘csb’), Khasi (‘kha’), Korean
     * (‘ko’), Kurdish - Latin script (‘ku’), K’iche’ (‘quc’), Luxembourgish (‘lb’), Malay (‘ms’), Manx (‘gv’),
     * Neapolitan (‘nap’), Norwegian (‘no’), Occitan (‘oc’), Polish (‘pl’), Portuguese (‘pt’), Romansh (‘rm’), Scots
     * (‘sco’), Scottish Gaelic (‘gd’), simplified Chinese (‘zh-Hans’), Slovenian (‘sl’), Spanish (‘es’), Swahili
     * (‘sw’), Swedish (‘sv’), Tatar - Latin script (‘tt’), Tetum (‘tet’), traditional Chinese (‘zh-Hant’), Turkish
     * (‘tr’), Upper Sorbian (‘hsb’), Uzbek (‘uz’), Volapük (‘vo’), Walser (‘wae’), Western Frisian (‘fy’), Yucatec Maya
     * (‘yua’), Zhuang (‘za’) and Zulu (‘zu’) are supported (print – seventy-three languages and handwritten – English
     * only). Layout supports auto language identification and multi language documents, so only provide a language code
     * if you would like to force the documented to be processed as that specific language.
     * @param readingOrder Reading order algorithm to sort the text lines returned. Supported reading orders include:
     * basic(default), natural.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeLayoutAsyncHeaders, Void>> analyzeLayoutAsyncWithResponseAsync(
        ContentType contentType, List<String> pages, Language language, ReadingOrder readingOrder,
        Flux<ByteBuffer> fileStream, Long contentLength) {
        final String accept = "application/json";
        String pagesConverted = (pages == null) ? null : pages.stream()
            .map(paramItemValue -> Objects.toString(paramItemValue, "")).collect(Collectors.joining(","));
        return FluxUtil.withContext(context -> service.analyzeLayoutAsync(this.getEndpoint(), this.getApiVersion(),
            pagesConverted, language, readingOrder, contentType, fileStream, contentLength, accept, context));
    }

    /**
     * Analyze Layout
     * 
     * Extract text and layout information from a given document. The input document must be of one of the supported
     * content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param language Currently, only Afrikaans (‘af’), Albanian (‘sq’), Asturian (‘ast’), Basque (‘eu’), Bislama
     * (‘bi’), Breton (‘br’), Catalan (‘ca’), Cebuano (‘ceb’), Chamorro (‘ch’), Cornish (‘kw’), Corsican (‘co’), Crimean
     * Tatar - Latin script(‘crh’), Czech (‘cs’), Danish (‘da’), Dutch (‘nl’), English ('en'), Estonian (‘et’), Fijian
     * (‘fj’), Filipino (‘fil’), Finnish (‘fi’), French (‘fr’), Friulian (‘fur’), Galician (‘gl’), German (‘de’),
     * Gilbertese (‘gil’), Greenlandic (‘kl’), Haitian Creole (‘ht’), Hani (‘hni’), Hmong Daw (‘mww’), Hungarian (‘hu’),
     * Indonesian (‘id’), Interlingua (‘ia’), Inuktitut (‘iu’), Irish (‘ga’), Italian (‘it’), Japanese (‘ja’), Javanese
     * (‘jv’), Kabuverdianu (‘kea’), Kachin (‘kac’), Kara-Kalpak (‘kaa’), Kashubian (‘csb’), Khasi (‘kha’), Korean
     * (‘ko’), Kurdish - Latin script (‘ku’), K’iche’ (‘quc’), Luxembourgish (‘lb’), Malay (‘ms’), Manx (‘gv’),
     * Neapolitan (‘nap’), Norwegian (‘no’), Occitan (‘oc’), Polish (‘pl’), Portuguese (‘pt’), Romansh (‘rm’), Scots
     * (‘sco’), Scottish Gaelic (‘gd’), simplified Chinese (‘zh-Hans’), Slovenian (‘sl’), Spanish (‘es’), Swahili
     * (‘sw’), Swedish (‘sv’), Tatar - Latin script (‘tt’), Tetum (‘tet’), traditional Chinese (‘zh-Hant’), Turkish
     * (‘tr’), Upper Sorbian (‘hsb’), Uzbek (‘uz’), Volapük (‘vo’), Walser (‘wae’), Western Frisian (‘fy’), Yucatec Maya
     * (‘yua’), Zhuang (‘za’) and Zulu (‘zu’) are supported (print – seventy-three languages and handwritten – English
     * only). Layout supports auto language identification and multi language documents, so only provide a language code
     * if you would like to force the documented to be processed as that specific language.
     * @param readingOrder Reading order algorithm to sort the text lines returned. Supported reading orders include:
     * basic(default), natural.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeLayoutAsyncHeaders, Void>> analyzeLayoutAsyncWithResponseAsync(
        ContentType contentType, List<String> pages, Language language, ReadingOrder readingOrder,
        Flux<ByteBuffer> fileStream, Long contentLength, Context context) {
        final String accept = "application/json";
        String pagesConverted = (pages == null) ? null : pages.stream()
            .map(paramItemValue -> Objects.toString(paramItemValue, "")).collect(Collectors.joining(","));
        return service.analyzeLayoutAsync(this.getEndpoint(), this.getApiVersion(), pagesConverted, language,
            readingOrder, contentType, fileStream, contentLength, accept, context);
    }

    /**
     * Analyze Layout
     * 
     * Extract text and layout information from a given document. The input document must be of one of the supported
     * content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param language Currently, only Afrikaans (‘af’), Albanian (‘sq’), Asturian (‘ast’), Basque (‘eu’), Bislama
     * (‘bi’), Breton (‘br’), Catalan (‘ca’), Cebuano (‘ceb’), Chamorro (‘ch’), Cornish (‘kw’), Corsican (‘co’), Crimean
     * Tatar - Latin script(‘crh’), Czech (‘cs’), Danish (‘da’), Dutch (‘nl’), English ('en'), Estonian (‘et’), Fijian
     * (‘fj’), Filipino (‘fil’), Finnish (‘fi’), French (‘fr’), Friulian (‘fur’), Galician (‘gl’), German (‘de’),
     * Gilbertese (‘gil’), Greenlandic (‘kl’), Haitian Creole (‘ht’), Hani (‘hni’), Hmong Daw (‘mww’), Hungarian (‘hu’),
     * Indonesian (‘id’), Interlingua (‘ia’), Inuktitut (‘iu’), Irish (‘ga’), Italian (‘it’), Japanese (‘ja’), Javanese
     * (‘jv’), Kabuverdianu (‘kea’), Kachin (‘kac’), Kara-Kalpak (‘kaa’), Kashubian (‘csb’), Khasi (‘kha’), Korean
     * (‘ko’), Kurdish - Latin script (‘ku’), K’iche’ (‘quc’), Luxembourgish (‘lb’), Malay (‘ms’), Manx (‘gv’),
     * Neapolitan (‘nap’), Norwegian (‘no’), Occitan (‘oc’), Polish (‘pl’), Portuguese (‘pt’), Romansh (‘rm’), Scots
     * (‘sco’), Scottish Gaelic (‘gd’), simplified Chinese (‘zh-Hans’), Slovenian (‘sl’), Spanish (‘es’), Swahili
     * (‘sw’), Swedish (‘sv’), Tatar - Latin script (‘tt’), Tetum (‘tet’), traditional Chinese (‘zh-Hant’), Turkish
     * (‘tr’), Upper Sorbian (‘hsb’), Uzbek (‘uz’), Volapük (‘vo’), Walser (‘wae’), Western Frisian (‘fy’), Yucatec Maya
     * (‘yua’), Zhuang (‘za’) and Zulu (‘zu’) are supported (print – seventy-three languages and handwritten – English
     * only). Layout supports auto language identification and multi language documents, so only provide a language code
     * if you would like to force the documented to be processed as that specific language.
     * @param readingOrder Reading order algorithm to sort the text lines returned. Supported reading orders include:
     * basic(default), natural.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeLayoutAsyncAsync(ContentType contentType, List<String> pages, Language language,
        ReadingOrder readingOrder, Flux<ByteBuffer> fileStream, Long contentLength) {
        return analyzeLayoutAsyncWithResponseAsync(contentType, pages, language, readingOrder, fileStream,
            contentLength).flatMap(ignored -> Mono.empty());
    }

    /**
     * Analyze Layout
     * 
     * Extract text and layout information from a given document. The input document must be of one of the supported
     * content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param language Currently, only Afrikaans (‘af’), Albanian (‘sq’), Asturian (‘ast’), Basque (‘eu’), Bislama
     * (‘bi’), Breton (‘br’), Catalan (‘ca’), Cebuano (‘ceb’), Chamorro (‘ch’), Cornish (‘kw’), Corsican (‘co’), Crimean
     * Tatar - Latin script(‘crh’), Czech (‘cs’), Danish (‘da’), Dutch (‘nl’), English ('en'), Estonian (‘et’), Fijian
     * (‘fj’), Filipino (‘fil’), Finnish (‘fi’), French (‘fr’), Friulian (‘fur’), Galician (‘gl’), German (‘de’),
     * Gilbertese (‘gil’), Greenlandic (‘kl’), Haitian Creole (‘ht’), Hani (‘hni’), Hmong Daw (‘mww’), Hungarian (‘hu’),
     * Indonesian (‘id’), Interlingua (‘ia’), Inuktitut (‘iu’), Irish (‘ga’), Italian (‘it’), Japanese (‘ja’), Javanese
     * (‘jv’), Kabuverdianu (‘kea’), Kachin (‘kac’), Kara-Kalpak (‘kaa’), Kashubian (‘csb’), Khasi (‘kha’), Korean
     * (‘ko’), Kurdish - Latin script (‘ku’), K’iche’ (‘quc’), Luxembourgish (‘lb’), Malay (‘ms’), Manx (‘gv’),
     * Neapolitan (‘nap’), Norwegian (‘no’), Occitan (‘oc’), Polish (‘pl’), Portuguese (‘pt’), Romansh (‘rm’), Scots
     * (‘sco’), Scottish Gaelic (‘gd’), simplified Chinese (‘zh-Hans’), Slovenian (‘sl’), Spanish (‘es’), Swahili
     * (‘sw’), Swedish (‘sv’), Tatar - Latin script (‘tt’), Tetum (‘tet’), traditional Chinese (‘zh-Hant’), Turkish
     * (‘tr’), Upper Sorbian (‘hsb’), Uzbek (‘uz’), Volapük (‘vo’), Walser (‘wae’), Western Frisian (‘fy’), Yucatec Maya
     * (‘yua’), Zhuang (‘za’) and Zulu (‘zu’) are supported (print – seventy-three languages and handwritten – English
     * only). Layout supports auto language identification and multi language documents, so only provide a language code
     * if you would like to force the documented to be processed as that specific language.
     * @param readingOrder Reading order algorithm to sort the text lines returned. Supported reading orders include:
     * basic(default), natural.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeLayoutAsyncAsync(ContentType contentType, List<String> pages, Language language,
        ReadingOrder readingOrder, Flux<ByteBuffer> fileStream, Long contentLength, Context context) {
        return analyzeLayoutAsyncWithResponseAsync(contentType, pages, language, readingOrder, fileStream,
            contentLength, context).flatMap(ignored -> Mono.empty());
    }

    /**
     * Analyze Layout
     * 
     * Extract text and layout information from a given document. The input document must be of one of the supported
     * content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param language Currently, only Afrikaans (‘af’), Albanian (‘sq’), Asturian (‘ast’), Basque (‘eu’), Bislama
     * (‘bi’), Breton (‘br’), Catalan (‘ca’), Cebuano (‘ceb’), Chamorro (‘ch’), Cornish (‘kw’), Corsican (‘co’), Crimean
     * Tatar - Latin script(‘crh’), Czech (‘cs’), Danish (‘da’), Dutch (‘nl’), English ('en'), Estonian (‘et’), Fijian
     * (‘fj’), Filipino (‘fil’), Finnish (‘fi’), French (‘fr’), Friulian (‘fur’), Galician (‘gl’), German (‘de’),
     * Gilbertese (‘gil’), Greenlandic (‘kl’), Haitian Creole (‘ht’), Hani (‘hni’), Hmong Daw (‘mww’), Hungarian (‘hu’),
     * Indonesian (‘id’), Interlingua (‘ia’), Inuktitut (‘iu’), Irish (‘ga’), Italian (‘it’), Japanese (‘ja’), Javanese
     * (‘jv’), Kabuverdianu (‘kea’), Kachin (‘kac’), Kara-Kalpak (‘kaa’), Kashubian (‘csb’), Khasi (‘kha’), Korean
     * (‘ko’), Kurdish - Latin script (‘ku’), K’iche’ (‘quc’), Luxembourgish (‘lb’), Malay (‘ms’), Manx (‘gv’),
     * Neapolitan (‘nap’), Norwegian (‘no’), Occitan (‘oc’), Polish (‘pl’), Portuguese (‘pt’), Romansh (‘rm’), Scots
     * (‘sco’), Scottish Gaelic (‘gd’), simplified Chinese (‘zh-Hans’), Slovenian (‘sl’), Spanish (‘es’), Swahili
     * (‘sw’), Swedish (‘sv’), Tatar - Latin script (‘tt’), Tetum (‘tet’), traditional Chinese (‘zh-Hant’), Turkish
     * (‘tr’), Upper Sorbian (‘hsb’), Uzbek (‘uz’), Volapük (‘vo’), Walser (‘wae’), Western Frisian (‘fy’), Yucatec Maya
     * (‘yua’), Zhuang (‘za’) and Zulu (‘zu’) are supported (print – seventy-three languages and handwritten – English
     * only). Layout supports auto language identification and multi language documents, so only provide a language code
     * if you would like to force the documented to be processed as that specific language.
     * @param readingOrder Reading order algorithm to sort the text lines returned. Supported reading orders include:
     * basic(default), natural.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ResponseBase<AnalyzeLayoutAsyncHeaders, Void> analyzeLayoutAsyncWithResponse(ContentType contentType,
        List<String> pages, Language language, ReadingOrder readingOrder, Flux<ByteBuffer> fileStream,
        Long contentLength, Context context) {
        return analyzeLayoutAsyncWithResponseAsync(contentType, pages, language, readingOrder, fileStream,
            contentLength, context).block();
    }

    /**
     * Analyze Layout
     * 
     * Extract text and layout information from a given document. The input document must be of one of the supported
     * content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param language Currently, only Afrikaans (‘af’), Albanian (‘sq’), Asturian (‘ast’), Basque (‘eu’), Bislama
     * (‘bi’), Breton (‘br’), Catalan (‘ca’), Cebuano (‘ceb’), Chamorro (‘ch’), Cornish (‘kw’), Corsican (‘co’), Crimean
     * Tatar - Latin script(‘crh’), Czech (‘cs’), Danish (‘da’), Dutch (‘nl’), English ('en'), Estonian (‘et’), Fijian
     * (‘fj’), Filipino (‘fil’), Finnish (‘fi’), French (‘fr’), Friulian (‘fur’), Galician (‘gl’), German (‘de’),
     * Gilbertese (‘gil’), Greenlandic (‘kl’), Haitian Creole (‘ht’), Hani (‘hni’), Hmong Daw (‘mww’), Hungarian (‘hu’),
     * Indonesian (‘id’), Interlingua (‘ia’), Inuktitut (‘iu’), Irish (‘ga’), Italian (‘it’), Japanese (‘ja’), Javanese
     * (‘jv’), Kabuverdianu (‘kea’), Kachin (‘kac’), Kara-Kalpak (‘kaa’), Kashubian (‘csb’), Khasi (‘kha’), Korean
     * (‘ko’), Kurdish - Latin script (‘ku’), K’iche’ (‘quc’), Luxembourgish (‘lb’), Malay (‘ms’), Manx (‘gv’),
     * Neapolitan (‘nap’), Norwegian (‘no’), Occitan (‘oc’), Polish (‘pl’), Portuguese (‘pt’), Romansh (‘rm’), Scots
     * (‘sco’), Scottish Gaelic (‘gd’), simplified Chinese (‘zh-Hans’), Slovenian (‘sl’), Spanish (‘es’), Swahili
     * (‘sw’), Swedish (‘sv’), Tatar - Latin script (‘tt’), Tetum (‘tet’), traditional Chinese (‘zh-Hant’), Turkish
     * (‘tr’), Upper Sorbian (‘hsb’), Uzbek (‘uz’), Volapük (‘vo’), Walser (‘wae’), Western Frisian (‘fy’), Yucatec Maya
     * (‘yua’), Zhuang (‘za’) and Zulu (‘zu’) are supported (print – seventy-three languages and handwritten – English
     * only). Layout supports auto language identification and multi language documents, so only provide a language code
     * if you would like to force the documented to be processed as that specific language.
     * @param readingOrder Reading order algorithm to sort the text lines returned. Supported reading orders include:
     * basic(default), natural.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void analyzeLayoutAsync(ContentType contentType, List<String> pages, Language language,
        ReadingOrder readingOrder, Flux<ByteBuffer> fileStream, Long contentLength) {
        analyzeLayoutAsyncWithResponse(contentType, pages, language, readingOrder, fileStream, contentLength,
            Context.NONE);
    }

    /**
     * Analyze Layout
     * 
     * Extract text and layout information from a given document. The input document must be of one of the supported
     * content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param language Currently, only Afrikaans (‘af’), Albanian (‘sq’), Asturian (‘ast’), Basque (‘eu’), Bislama
     * (‘bi’), Breton (‘br’), Catalan (‘ca’), Cebuano (‘ceb’), Chamorro (‘ch’), Cornish (‘kw’), Corsican (‘co’), Crimean
     * Tatar - Latin script(‘crh’), Czech (‘cs’), Danish (‘da’), Dutch (‘nl’), English ('en'), Estonian (‘et’), Fijian
     * (‘fj’), Filipino (‘fil’), Finnish (‘fi’), French (‘fr’), Friulian (‘fur’), Galician (‘gl’), German (‘de’),
     * Gilbertese (‘gil’), Greenlandic (‘kl’), Haitian Creole (‘ht’), Hani (‘hni’), Hmong Daw (‘mww’), Hungarian (‘hu’),
     * Indonesian (‘id’), Interlingua (‘ia’), Inuktitut (‘iu’), Irish (‘ga’), Italian (‘it’), Japanese (‘ja’), Javanese
     * (‘jv’), Kabuverdianu (‘kea’), Kachin (‘kac’), Kara-Kalpak (‘kaa’), Kashubian (‘csb’), Khasi (‘kha’), Korean
     * (‘ko’), Kurdish - Latin script (‘ku’), K’iche’ (‘quc’), Luxembourgish (‘lb’), Malay (‘ms’), Manx (‘gv’),
     * Neapolitan (‘nap’), Norwegian (‘no’), Occitan (‘oc’), Polish (‘pl’), Portuguese (‘pt’), Romansh (‘rm’), Scots
     * (‘sco’), Scottish Gaelic (‘gd’), simplified Chinese (‘zh-Hans’), Slovenian (‘sl’), Spanish (‘es’), Swahili
     * (‘sw’), Swedish (‘sv’), Tatar - Latin script (‘tt’), Tetum (‘tet’), traditional Chinese (‘zh-Hant’), Turkish
     * (‘tr’), Upper Sorbian (‘hsb’), Uzbek (‘uz’), Volapük (‘vo’), Walser (‘wae’), Western Frisian (‘fy’), Yucatec Maya
     * (‘yua’), Zhuang (‘za’) and Zulu (‘zu’) are supported (print – seventy-three languages and handwritten – English
     * only). Layout supports auto language identification and multi language documents, so only provide a language code
     * if you would like to force the documented to be processed as that specific language.
     * @param readingOrder Reading order algorithm to sort the text lines returned. Supported reading orders include:
     * basic(default), natural.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeLayoutAsyncHeaders, Void>> analyzeLayoutAsyncWithResponseAsync(
        ContentType contentType, List<String> pages, Language language, ReadingOrder readingOrder,
        BinaryData fileStream, Long contentLength) {
        final String accept = "application/json";
        String pagesConverted = (pages == null) ? null : pages.stream()
            .map(paramItemValue -> Objects.toString(paramItemValue, "")).collect(Collectors.joining(","));
        return FluxUtil.withContext(context -> service.analyzeLayoutAsync(this.getEndpoint(), this.getApiVersion(),
            pagesConverted, language, readingOrder, contentType, fileStream, contentLength, accept, context));
    }

    /**
     * Analyze Layout
     * 
     * Extract text and layout information from a given document. The input document must be of one of the supported
     * content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param language Currently, only Afrikaans (‘af’), Albanian (‘sq’), Asturian (‘ast’), Basque (‘eu’), Bislama
     * (‘bi’), Breton (‘br’), Catalan (‘ca’), Cebuano (‘ceb’), Chamorro (‘ch’), Cornish (‘kw’), Corsican (‘co’), Crimean
     * Tatar - Latin script(‘crh’), Czech (‘cs’), Danish (‘da’), Dutch (‘nl’), English ('en'), Estonian (‘et’), Fijian
     * (‘fj’), Filipino (‘fil’), Finnish (‘fi’), French (‘fr’), Friulian (‘fur’), Galician (‘gl’), German (‘de’),
     * Gilbertese (‘gil’), Greenlandic (‘kl’), Haitian Creole (‘ht’), Hani (‘hni’), Hmong Daw (‘mww’), Hungarian (‘hu’),
     * Indonesian (‘id’), Interlingua (‘ia’), Inuktitut (‘iu’), Irish (‘ga’), Italian (‘it’), Japanese (‘ja’), Javanese
     * (‘jv’), Kabuverdianu (‘kea’), Kachin (‘kac’), Kara-Kalpak (‘kaa’), Kashubian (‘csb’), Khasi (‘kha’), Korean
     * (‘ko’), Kurdish - Latin script (‘ku’), K’iche’ (‘quc’), Luxembourgish (‘lb’), Malay (‘ms’), Manx (‘gv’),
     * Neapolitan (‘nap’), Norwegian (‘no’), Occitan (‘oc’), Polish (‘pl’), Portuguese (‘pt’), Romansh (‘rm’), Scots
     * (‘sco’), Scottish Gaelic (‘gd’), simplified Chinese (‘zh-Hans’), Slovenian (‘sl’), Spanish (‘es’), Swahili
     * (‘sw’), Swedish (‘sv’), Tatar - Latin script (‘tt’), Tetum (‘tet’), traditional Chinese (‘zh-Hant’), Turkish
     * (‘tr’), Upper Sorbian (‘hsb’), Uzbek (‘uz’), Volapük (‘vo’), Walser (‘wae’), Western Frisian (‘fy’), Yucatec Maya
     * (‘yua’), Zhuang (‘za’) and Zulu (‘zu’) are supported (print – seventy-three languages and handwritten – English
     * only). Layout supports auto language identification and multi language documents, so only provide a language code
     * if you would like to force the documented to be processed as that specific language.
     * @param readingOrder Reading order algorithm to sort the text lines returned. Supported reading orders include:
     * basic(default), natural.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeLayoutAsyncHeaders, Void>> analyzeLayoutAsyncWithResponseAsync(
        ContentType contentType, List<String> pages, Language language, ReadingOrder readingOrder,
        BinaryData fileStream, Long contentLength, Context context) {
        final String accept = "application/json";
        String pagesConverted = (pages == null) ? null : pages.stream()
            .map(paramItemValue -> Objects.toString(paramItemValue, "")).collect(Collectors.joining(","));
        return service.analyzeLayoutAsync(this.getEndpoint(), this.getApiVersion(), pagesConverted, language,
            readingOrder, contentType, fileStream, contentLength, accept, context);
    }

    /**
     * Analyze Layout
     * 
     * Extract text and layout information from a given document. The input document must be of one of the supported
     * content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param language Currently, only Afrikaans (‘af’), Albanian (‘sq’), Asturian (‘ast’), Basque (‘eu’), Bislama
     * (‘bi’), Breton (‘br’), Catalan (‘ca’), Cebuano (‘ceb’), Chamorro (‘ch’), Cornish (‘kw’), Corsican (‘co’), Crimean
     * Tatar - Latin script(‘crh’), Czech (‘cs’), Danish (‘da’), Dutch (‘nl’), English ('en'), Estonian (‘et’), Fijian
     * (‘fj’), Filipino (‘fil’), Finnish (‘fi’), French (‘fr’), Friulian (‘fur’), Galician (‘gl’), German (‘de’),
     * Gilbertese (‘gil’), Greenlandic (‘kl’), Haitian Creole (‘ht’), Hani (‘hni’), Hmong Daw (‘mww’), Hungarian (‘hu’),
     * Indonesian (‘id’), Interlingua (‘ia’), Inuktitut (‘iu’), Irish (‘ga’), Italian (‘it’), Japanese (‘ja’), Javanese
     * (‘jv’), Kabuverdianu (‘kea’), Kachin (‘kac’), Kara-Kalpak (‘kaa’), Kashubian (‘csb’), Khasi (‘kha’), Korean
     * (‘ko’), Kurdish - Latin script (‘ku’), K’iche’ (‘quc’), Luxembourgish (‘lb’), Malay (‘ms’), Manx (‘gv’),
     * Neapolitan (‘nap’), Norwegian (‘no’), Occitan (‘oc’), Polish (‘pl’), Portuguese (‘pt’), Romansh (‘rm’), Scots
     * (‘sco’), Scottish Gaelic (‘gd’), simplified Chinese (‘zh-Hans’), Slovenian (‘sl’), Spanish (‘es’), Swahili
     * (‘sw’), Swedish (‘sv’), Tatar - Latin script (‘tt’), Tetum (‘tet’), traditional Chinese (‘zh-Hant’), Turkish
     * (‘tr’), Upper Sorbian (‘hsb’), Uzbek (‘uz’), Volapük (‘vo’), Walser (‘wae’), Western Frisian (‘fy’), Yucatec Maya
     * (‘yua’), Zhuang (‘za’) and Zulu (‘zu’) are supported (print – seventy-three languages and handwritten – English
     * only). Layout supports auto language identification and multi language documents, so only provide a language code
     * if you would like to force the documented to be processed as that specific language.
     * @param readingOrder Reading order algorithm to sort the text lines returned. Supported reading orders include:
     * basic(default), natural.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeLayoutAsyncAsync(ContentType contentType, List<String> pages, Language language,
        ReadingOrder readingOrder, BinaryData fileStream, Long contentLength) {
        return analyzeLayoutAsyncWithResponseAsync(contentType, pages, language, readingOrder, fileStream,
            contentLength).flatMap(ignored -> Mono.empty());
    }

    /**
     * Analyze Layout
     * 
     * Extract text and layout information from a given document. The input document must be of one of the supported
     * content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param language Currently, only Afrikaans (‘af’), Albanian (‘sq’), Asturian (‘ast’), Basque (‘eu’), Bislama
     * (‘bi’), Breton (‘br’), Catalan (‘ca’), Cebuano (‘ceb’), Chamorro (‘ch’), Cornish (‘kw’), Corsican (‘co’), Crimean
     * Tatar - Latin script(‘crh’), Czech (‘cs’), Danish (‘da’), Dutch (‘nl’), English ('en'), Estonian (‘et’), Fijian
     * (‘fj’), Filipino (‘fil’), Finnish (‘fi’), French (‘fr’), Friulian (‘fur’), Galician (‘gl’), German (‘de’),
     * Gilbertese (‘gil’), Greenlandic (‘kl’), Haitian Creole (‘ht’), Hani (‘hni’), Hmong Daw (‘mww’), Hungarian (‘hu’),
     * Indonesian (‘id’), Interlingua (‘ia’), Inuktitut (‘iu’), Irish (‘ga’), Italian (‘it’), Japanese (‘ja’), Javanese
     * (‘jv’), Kabuverdianu (‘kea’), Kachin (‘kac’), Kara-Kalpak (‘kaa’), Kashubian (‘csb’), Khasi (‘kha’), Korean
     * (‘ko’), Kurdish - Latin script (‘ku’), K’iche’ (‘quc’), Luxembourgish (‘lb’), Malay (‘ms’), Manx (‘gv’),
     * Neapolitan (‘nap’), Norwegian (‘no’), Occitan (‘oc’), Polish (‘pl’), Portuguese (‘pt’), Romansh (‘rm’), Scots
     * (‘sco’), Scottish Gaelic (‘gd’), simplified Chinese (‘zh-Hans’), Slovenian (‘sl’), Spanish (‘es’), Swahili
     * (‘sw’), Swedish (‘sv’), Tatar - Latin script (‘tt’), Tetum (‘tet’), traditional Chinese (‘zh-Hant’), Turkish
     * (‘tr’), Upper Sorbian (‘hsb’), Uzbek (‘uz’), Volapük (‘vo’), Walser (‘wae’), Western Frisian (‘fy’), Yucatec Maya
     * (‘yua’), Zhuang (‘za’) and Zulu (‘zu’) are supported (print – seventy-three languages and handwritten – English
     * only). Layout supports auto language identification and multi language documents, so only provide a language code
     * if you would like to force the documented to be processed as that specific language.
     * @param readingOrder Reading order algorithm to sort the text lines returned. Supported reading orders include:
     * basic(default), natural.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeLayoutAsyncAsync(ContentType contentType, List<String> pages, Language language,
        ReadingOrder readingOrder, BinaryData fileStream, Long contentLength, Context context) {
        return analyzeLayoutAsyncWithResponseAsync(contentType, pages, language, readingOrder, fileStream,
            contentLength, context).flatMap(ignored -> Mono.empty());
    }

    /**
     * Analyze Layout
     * 
     * Extract text and layout information from a given document. The input document must be of one of the supported
     * content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param language Currently, only Afrikaans (‘af’), Albanian (‘sq’), Asturian (‘ast’), Basque (‘eu’), Bislama
     * (‘bi’), Breton (‘br’), Catalan (‘ca’), Cebuano (‘ceb’), Chamorro (‘ch’), Cornish (‘kw’), Corsican (‘co’), Crimean
     * Tatar - Latin script(‘crh’), Czech (‘cs’), Danish (‘da’), Dutch (‘nl’), English ('en'), Estonian (‘et’), Fijian
     * (‘fj’), Filipino (‘fil’), Finnish (‘fi’), French (‘fr’), Friulian (‘fur’), Galician (‘gl’), German (‘de’),
     * Gilbertese (‘gil’), Greenlandic (‘kl’), Haitian Creole (‘ht’), Hani (‘hni’), Hmong Daw (‘mww’), Hungarian (‘hu’),
     * Indonesian (‘id’), Interlingua (‘ia’), Inuktitut (‘iu’), Irish (‘ga’), Italian (‘it’), Japanese (‘ja’), Javanese
     * (‘jv’), Kabuverdianu (‘kea’), Kachin (‘kac’), Kara-Kalpak (‘kaa’), Kashubian (‘csb’), Khasi (‘kha’), Korean
     * (‘ko’), Kurdish - Latin script (‘ku’), K’iche’ (‘quc’), Luxembourgish (‘lb’), Malay (‘ms’), Manx (‘gv’),
     * Neapolitan (‘nap’), Norwegian (‘no’), Occitan (‘oc’), Polish (‘pl’), Portuguese (‘pt’), Romansh (‘rm’), Scots
     * (‘sco’), Scottish Gaelic (‘gd’), simplified Chinese (‘zh-Hans’), Slovenian (‘sl’), Spanish (‘es’), Swahili
     * (‘sw’), Swedish (‘sv’), Tatar - Latin script (‘tt’), Tetum (‘tet’), traditional Chinese (‘zh-Hant’), Turkish
     * (‘tr’), Upper Sorbian (‘hsb’), Uzbek (‘uz’), Volapük (‘vo’), Walser (‘wae’), Western Frisian (‘fy’), Yucatec Maya
     * (‘yua’), Zhuang (‘za’) and Zulu (‘zu’) are supported (print – seventy-three languages and handwritten – English
     * only). Layout supports auto language identification and multi language documents, so only provide a language code
     * if you would like to force the documented to be processed as that specific language.
     * @param readingOrder Reading order algorithm to sort the text lines returned. Supported reading orders include:
     * basic(default), natural.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ResponseBase<AnalyzeLayoutAsyncHeaders, Void> analyzeLayoutAsyncWithResponse(ContentType contentType,
        List<String> pages, Language language, ReadingOrder readingOrder, BinaryData fileStream, Long contentLength,
        Context context) {
        return analyzeLayoutAsyncWithResponseAsync(contentType, pages, language, readingOrder, fileStream,
            contentLength, context).block();
    }

    /**
     * Analyze Layout
     * 
     * Extract text and layout information from a given document. The input document must be of one of the supported
     * content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     * 
     * @param contentType Upload file type.
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param language Currently, only Afrikaans (‘af’), Albanian (‘sq’), Asturian (‘ast’), Basque (‘eu’), Bislama
     * (‘bi’), Breton (‘br’), Catalan (‘ca’), Cebuano (‘ceb’), Chamorro (‘ch’), Cornish (‘kw’), Corsican (‘co’), Crimean
     * Tatar - Latin script(‘crh’), Czech (‘cs’), Danish (‘da’), Dutch (‘nl’), English ('en'), Estonian (‘et’), Fijian
     * (‘fj’), Filipino (‘fil’), Finnish (‘fi’), French (‘fr’), Friulian (‘fur’), Galician (‘gl’), German (‘de’),
     * Gilbertese (‘gil’), Greenlandic (‘kl’), Haitian Creole (‘ht’), Hani (‘hni’), Hmong Daw (‘mww’), Hungarian (‘hu’),
     * Indonesian (‘id’), Interlingua (‘ia’), Inuktitut (‘iu’), Irish (‘ga’), Italian (‘it’), Japanese (‘ja’), Javanese
     * (‘jv’), Kabuverdianu (‘kea’), Kachin (‘kac’), Kara-Kalpak (‘kaa’), Kashubian (‘csb’), Khasi (‘kha’), Korean
     * (‘ko’), Kurdish - Latin script (‘ku’), K’iche’ (‘quc’), Luxembourgish (‘lb’), Malay (‘ms’), Manx (‘gv’),
     * Neapolitan (‘nap’), Norwegian (‘no’), Occitan (‘oc’), Polish (‘pl’), Portuguese (‘pt’), Romansh (‘rm’), Scots
     * (‘sco’), Scottish Gaelic (‘gd’), simplified Chinese (‘zh-Hans’), Slovenian (‘sl’), Spanish (‘es’), Swahili
     * (‘sw’), Swedish (‘sv’), Tatar - Latin script (‘tt’), Tetum (‘tet’), traditional Chinese (‘zh-Hant’), Turkish
     * (‘tr’), Upper Sorbian (‘hsb’), Uzbek (‘uz’), Volapük (‘vo’), Walser (‘wae’), Western Frisian (‘fy’), Yucatec Maya
     * (‘yua’), Zhuang (‘za’) and Zulu (‘zu’) are supported (print – seventy-three languages and handwritten – English
     * only). Layout supports auto language identification and multi language documents, so only provide a language code
     * if you would like to force the documented to be processed as that specific language.
     * @param readingOrder Reading order algorithm to sort the text lines returned. Supported reading orders include:
     * basic(default), natural.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param contentLength The Content-Length header for the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void analyzeLayoutAsync(ContentType contentType, List<String> pages, Language language,
        ReadingOrder readingOrder, BinaryData fileStream, Long contentLength) {
        analyzeLayoutAsyncWithResponse(contentType, pages, language, readingOrder, fileStream, contentLength,
            Context.NONE);
    }

    /**
     * Analyze Layout
     * 
     * Extract text and layout information from a given document. The input document must be of one of the supported
     * content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     * 
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param language Currently, only Afrikaans (‘af’), Albanian (‘sq’), Asturian (‘ast’), Basque (‘eu’), Bislama
     * (‘bi’), Breton (‘br’), Catalan (‘ca’), Cebuano (‘ceb’), Chamorro (‘ch’), Cornish (‘kw’), Corsican (‘co’), Crimean
     * Tatar - Latin script(‘crh’), Czech (‘cs’), Danish (‘da’), Dutch (‘nl’), English ('en'), Estonian (‘et’), Fijian
     * (‘fj’), Filipino (‘fil’), Finnish (‘fi’), French (‘fr’), Friulian (‘fur’), Galician (‘gl’), German (‘de’),
     * Gilbertese (‘gil’), Greenlandic (‘kl’), Haitian Creole (‘ht’), Hani (‘hni’), Hmong Daw (‘mww’), Hungarian (‘hu’),
     * Indonesian (‘id’), Interlingua (‘ia’), Inuktitut (‘iu’), Irish (‘ga’), Italian (‘it’), Japanese (‘ja’), Javanese
     * (‘jv’), Kabuverdianu (‘kea’), Kachin (‘kac’), Kara-Kalpak (‘kaa’), Kashubian (‘csb’), Khasi (‘kha’), Korean
     * (‘ko’), Kurdish - Latin script (‘ku’), K’iche’ (‘quc’), Luxembourgish (‘lb’), Malay (‘ms’), Manx (‘gv’),
     * Neapolitan (‘nap’), Norwegian (‘no’), Occitan (‘oc’), Polish (‘pl’), Portuguese (‘pt’), Romansh (‘rm’), Scots
     * (‘sco’), Scottish Gaelic (‘gd’), simplified Chinese (‘zh-Hans’), Slovenian (‘sl’), Spanish (‘es’), Swahili
     * (‘sw’), Swedish (‘sv’), Tatar - Latin script (‘tt’), Tetum (‘tet’), traditional Chinese (‘zh-Hant’), Turkish
     * (‘tr’), Upper Sorbian (‘hsb’), Uzbek (‘uz’), Volapük (‘vo’), Walser (‘wae’), Western Frisian (‘fy’), Yucatec Maya
     * (‘yua’), Zhuang (‘za’) and Zulu (‘zu’) are supported (print – seventy-three languages and handwritten – English
     * only). Layout supports auto language identification and multi language documents, so only provide a language code
     * if you would like to force the documented to be processed as that specific language.
     * @param readingOrder Reading order algorithm to sort the text lines returned. Supported reading orders include:
     * basic(default), natural.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeLayoutAsyncHeaders, Void>> analyzeLayoutAsyncWithResponseAsync(List<String> pages,
        Language language, ReadingOrder readingOrder, SourcePath fileStream) {
        final String accept = "application/json";
        String pagesConverted = (pages == null) ? null : pages.stream()
            .map(paramItemValue -> Objects.toString(paramItemValue, "")).collect(Collectors.joining(","));
        return FluxUtil.withContext(context -> service.analyzeLayoutAsync(this.getEndpoint(), this.getApiVersion(),
            pagesConverted, language, readingOrder, fileStream, accept, context));
    }

    /**
     * Analyze Layout
     * 
     * Extract text and layout information from a given document. The input document must be of one of the supported
     * content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     * 
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param language Currently, only Afrikaans (‘af’), Albanian (‘sq’), Asturian (‘ast’), Basque (‘eu’), Bislama
     * (‘bi’), Breton (‘br’), Catalan (‘ca’), Cebuano (‘ceb’), Chamorro (‘ch’), Cornish (‘kw’), Corsican (‘co’), Crimean
     * Tatar - Latin script(‘crh’), Czech (‘cs’), Danish (‘da’), Dutch (‘nl’), English ('en'), Estonian (‘et’), Fijian
     * (‘fj’), Filipino (‘fil’), Finnish (‘fi’), French (‘fr’), Friulian (‘fur’), Galician (‘gl’), German (‘de’),
     * Gilbertese (‘gil’), Greenlandic (‘kl’), Haitian Creole (‘ht’), Hani (‘hni’), Hmong Daw (‘mww’), Hungarian (‘hu’),
     * Indonesian (‘id’), Interlingua (‘ia’), Inuktitut (‘iu’), Irish (‘ga’), Italian (‘it’), Japanese (‘ja’), Javanese
     * (‘jv’), Kabuverdianu (‘kea’), Kachin (‘kac’), Kara-Kalpak (‘kaa’), Kashubian (‘csb’), Khasi (‘kha’), Korean
     * (‘ko’), Kurdish - Latin script (‘ku’), K’iche’ (‘quc’), Luxembourgish (‘lb’), Malay (‘ms’), Manx (‘gv’),
     * Neapolitan (‘nap’), Norwegian (‘no’), Occitan (‘oc’), Polish (‘pl’), Portuguese (‘pt’), Romansh (‘rm’), Scots
     * (‘sco’), Scottish Gaelic (‘gd’), simplified Chinese (‘zh-Hans’), Slovenian (‘sl’), Spanish (‘es’), Swahili
     * (‘sw’), Swedish (‘sv’), Tatar - Latin script (‘tt’), Tetum (‘tet’), traditional Chinese (‘zh-Hant’), Turkish
     * (‘tr’), Upper Sorbian (‘hsb’), Uzbek (‘uz’), Volapük (‘vo’), Walser (‘wae’), Western Frisian (‘fy’), Yucatec Maya
     * (‘yua’), Zhuang (‘za’) and Zulu (‘zu’) are supported (print – seventy-three languages and handwritten – English
     * only). Layout supports auto language identification and multi language documents, so only provide a language code
     * if you would like to force the documented to be processed as that specific language.
     * @param readingOrder Reading order algorithm to sort the text lines returned. Supported reading orders include:
     * basic(default), natural.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<AnalyzeLayoutAsyncHeaders, Void>> analyzeLayoutAsyncWithResponseAsync(List<String> pages,
        Language language, ReadingOrder readingOrder, SourcePath fileStream, Context context) {
        final String accept = "application/json";
        String pagesConverted = (pages == null) ? null : pages.stream()
            .map(paramItemValue -> Objects.toString(paramItemValue, "")).collect(Collectors.joining(","));
        return service.analyzeLayoutAsync(this.getEndpoint(), this.getApiVersion(), pagesConverted, language,
            readingOrder, fileStream, accept, context);
    }

    /**
     * Analyze Layout
     * 
     * Extract text and layout information from a given document. The input document must be of one of the supported
     * content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     * 
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param language Currently, only Afrikaans (‘af’), Albanian (‘sq’), Asturian (‘ast’), Basque (‘eu’), Bislama
     * (‘bi’), Breton (‘br’), Catalan (‘ca’), Cebuano (‘ceb’), Chamorro (‘ch’), Cornish (‘kw’), Corsican (‘co’), Crimean
     * Tatar - Latin script(‘crh’), Czech (‘cs’), Danish (‘da’), Dutch (‘nl’), English ('en'), Estonian (‘et’), Fijian
     * (‘fj’), Filipino (‘fil’), Finnish (‘fi’), French (‘fr’), Friulian (‘fur’), Galician (‘gl’), German (‘de’),
     * Gilbertese (‘gil’), Greenlandic (‘kl’), Haitian Creole (‘ht’), Hani (‘hni’), Hmong Daw (‘mww’), Hungarian (‘hu’),
     * Indonesian (‘id’), Interlingua (‘ia’), Inuktitut (‘iu’), Irish (‘ga’), Italian (‘it’), Japanese (‘ja’), Javanese
     * (‘jv’), Kabuverdianu (‘kea’), Kachin (‘kac’), Kara-Kalpak (‘kaa’), Kashubian (‘csb’), Khasi (‘kha’), Korean
     * (‘ko’), Kurdish - Latin script (‘ku’), K’iche’ (‘quc’), Luxembourgish (‘lb’), Malay (‘ms’), Manx (‘gv’),
     * Neapolitan (‘nap’), Norwegian (‘no’), Occitan (‘oc’), Polish (‘pl’), Portuguese (‘pt’), Romansh (‘rm’), Scots
     * (‘sco’), Scottish Gaelic (‘gd’), simplified Chinese (‘zh-Hans’), Slovenian (‘sl’), Spanish (‘es’), Swahili
     * (‘sw’), Swedish (‘sv’), Tatar - Latin script (‘tt’), Tetum (‘tet’), traditional Chinese (‘zh-Hant’), Turkish
     * (‘tr’), Upper Sorbian (‘hsb’), Uzbek (‘uz’), Volapük (‘vo’), Walser (‘wae’), Western Frisian (‘fy’), Yucatec Maya
     * (‘yua’), Zhuang (‘za’) and Zulu (‘zu’) are supported (print – seventy-three languages and handwritten – English
     * only). Layout supports auto language identification and multi language documents, so only provide a language code
     * if you would like to force the documented to be processed as that specific language.
     * @param readingOrder Reading order algorithm to sort the text lines returned. Supported reading orders include:
     * basic(default), natural.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeLayoutAsyncAsync(List<String> pages, Language language, ReadingOrder readingOrder,
        SourcePath fileStream) {
        return analyzeLayoutAsyncWithResponseAsync(pages, language, readingOrder, fileStream)
            .flatMap(ignored -> Mono.empty());
    }

    /**
     * Analyze Layout
     * 
     * Extract text and layout information from a given document. The input document must be of one of the supported
     * content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     * 
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param language Currently, only Afrikaans (‘af’), Albanian (‘sq’), Asturian (‘ast’), Basque (‘eu’), Bislama
     * (‘bi’), Breton (‘br’), Catalan (‘ca’), Cebuano (‘ceb’), Chamorro (‘ch’), Cornish (‘kw’), Corsican (‘co’), Crimean
     * Tatar - Latin script(‘crh’), Czech (‘cs’), Danish (‘da’), Dutch (‘nl’), English ('en'), Estonian (‘et’), Fijian
     * (‘fj’), Filipino (‘fil’), Finnish (‘fi’), French (‘fr’), Friulian (‘fur’), Galician (‘gl’), German (‘de’),
     * Gilbertese (‘gil’), Greenlandic (‘kl’), Haitian Creole (‘ht’), Hani (‘hni’), Hmong Daw (‘mww’), Hungarian (‘hu’),
     * Indonesian (‘id’), Interlingua (‘ia’), Inuktitut (‘iu’), Irish (‘ga’), Italian (‘it’), Japanese (‘ja’), Javanese
     * (‘jv’), Kabuverdianu (‘kea’), Kachin (‘kac’), Kara-Kalpak (‘kaa’), Kashubian (‘csb’), Khasi (‘kha’), Korean
     * (‘ko’), Kurdish - Latin script (‘ku’), K’iche’ (‘quc’), Luxembourgish (‘lb’), Malay (‘ms’), Manx (‘gv’),
     * Neapolitan (‘nap’), Norwegian (‘no’), Occitan (‘oc’), Polish (‘pl’), Portuguese (‘pt’), Romansh (‘rm’), Scots
     * (‘sco’), Scottish Gaelic (‘gd’), simplified Chinese (‘zh-Hans’), Slovenian (‘sl’), Spanish (‘es’), Swahili
     * (‘sw’), Swedish (‘sv’), Tatar - Latin script (‘tt’), Tetum (‘tet’), traditional Chinese (‘zh-Hant’), Turkish
     * (‘tr’), Upper Sorbian (‘hsb’), Uzbek (‘uz’), Volapük (‘vo’), Walser (‘wae’), Western Frisian (‘fy’), Yucatec Maya
     * (‘yua’), Zhuang (‘za’) and Zulu (‘zu’) are supported (print – seventy-three languages and handwritten – English
     * only). Layout supports auto language identification and multi language documents, so only provide a language code
     * if you would like to force the documented to be processed as that specific language.
     * @param readingOrder Reading order algorithm to sort the text lines returned. Supported reading orders include:
     * basic(default), natural.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> analyzeLayoutAsyncAsync(List<String> pages, Language language, ReadingOrder readingOrder,
        SourcePath fileStream, Context context) {
        return analyzeLayoutAsyncWithResponseAsync(pages, language, readingOrder, fileStream, context)
            .flatMap(ignored -> Mono.empty());
    }

    /**
     * Analyze Layout
     * 
     * Extract text and layout information from a given document. The input document must be of one of the supported
     * content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     * 
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param language Currently, only Afrikaans (‘af’), Albanian (‘sq’), Asturian (‘ast’), Basque (‘eu’), Bislama
     * (‘bi’), Breton (‘br’), Catalan (‘ca’), Cebuano (‘ceb’), Chamorro (‘ch’), Cornish (‘kw’), Corsican (‘co’), Crimean
     * Tatar - Latin script(‘crh’), Czech (‘cs’), Danish (‘da’), Dutch (‘nl’), English ('en'), Estonian (‘et’), Fijian
     * (‘fj’), Filipino (‘fil’), Finnish (‘fi’), French (‘fr’), Friulian (‘fur’), Galician (‘gl’), German (‘de’),
     * Gilbertese (‘gil’), Greenlandic (‘kl’), Haitian Creole (‘ht’), Hani (‘hni’), Hmong Daw (‘mww’), Hungarian (‘hu’),
     * Indonesian (‘id’), Interlingua (‘ia’), Inuktitut (‘iu’), Irish (‘ga’), Italian (‘it’), Japanese (‘ja’), Javanese
     * (‘jv’), Kabuverdianu (‘kea’), Kachin (‘kac’), Kara-Kalpak (‘kaa’), Kashubian (‘csb’), Khasi (‘kha’), Korean
     * (‘ko’), Kurdish - Latin script (‘ku’), K’iche’ (‘quc’), Luxembourgish (‘lb’), Malay (‘ms’), Manx (‘gv’),
     * Neapolitan (‘nap’), Norwegian (‘no’), Occitan (‘oc’), Polish (‘pl’), Portuguese (‘pt’), Romansh (‘rm’), Scots
     * (‘sco’), Scottish Gaelic (‘gd’), simplified Chinese (‘zh-Hans’), Slovenian (‘sl’), Spanish (‘es’), Swahili
     * (‘sw’), Swedish (‘sv’), Tatar - Latin script (‘tt’), Tetum (‘tet’), traditional Chinese (‘zh-Hant’), Turkish
     * (‘tr’), Upper Sorbian (‘hsb’), Uzbek (‘uz’), Volapük (‘vo’), Walser (‘wae’), Western Frisian (‘fy’), Yucatec Maya
     * (‘yua’), Zhuang (‘za’) and Zulu (‘zu’) are supported (print – seventy-three languages and handwritten – English
     * only). Layout supports auto language identification and multi language documents, so only provide a language code
     * if you would like to force the documented to be processed as that specific language.
     * @param readingOrder Reading order algorithm to sort the text lines returned. Supported reading orders include:
     * basic(default), natural.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ResponseBase<AnalyzeLayoutAsyncHeaders, Void> analyzeLayoutAsyncWithResponse(List<String> pages,
        Language language, ReadingOrder readingOrder, SourcePath fileStream, Context context) {
        return analyzeLayoutAsyncWithResponseAsync(pages, language, readingOrder, fileStream, context).block();
    }

    /**
     * Analyze Layout
     * 
     * Extract text and layout information from a given document. The input document must be of one of the supported
     * content types - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff' or 'image/bmp'. Alternatively, use
     * 'application/json' type to specify the location (Uri or local path) of the document to be analyzed.
     * 
     * @param pages Custom page numbers for multi-page documents(PDF/TIFF), input the number of the pages you want to
     * get OCR result. For a range of pages, use a hyphen. Separate each page or range with a comma.
     * @param language Currently, only Afrikaans (‘af’), Albanian (‘sq’), Asturian (‘ast’), Basque (‘eu’), Bislama
     * (‘bi’), Breton (‘br’), Catalan (‘ca’), Cebuano (‘ceb’), Chamorro (‘ch’), Cornish (‘kw’), Corsican (‘co’), Crimean
     * Tatar - Latin script(‘crh’), Czech (‘cs’), Danish (‘da’), Dutch (‘nl’), English ('en'), Estonian (‘et’), Fijian
     * (‘fj’), Filipino (‘fil’), Finnish (‘fi’), French (‘fr’), Friulian (‘fur’), Galician (‘gl’), German (‘de’),
     * Gilbertese (‘gil’), Greenlandic (‘kl’), Haitian Creole (‘ht’), Hani (‘hni’), Hmong Daw (‘mww’), Hungarian (‘hu’),
     * Indonesian (‘id’), Interlingua (‘ia’), Inuktitut (‘iu’), Irish (‘ga’), Italian (‘it’), Japanese (‘ja’), Javanese
     * (‘jv’), Kabuverdianu (‘kea’), Kachin (‘kac’), Kara-Kalpak (‘kaa’), Kashubian (‘csb’), Khasi (‘kha’), Korean
     * (‘ko’), Kurdish - Latin script (‘ku’), K’iche’ (‘quc’), Luxembourgish (‘lb’), Malay (‘ms’), Manx (‘gv’),
     * Neapolitan (‘nap’), Norwegian (‘no’), Occitan (‘oc’), Polish (‘pl’), Portuguese (‘pt’), Romansh (‘rm’), Scots
     * (‘sco’), Scottish Gaelic (‘gd’), simplified Chinese (‘zh-Hans’), Slovenian (‘sl’), Spanish (‘es’), Swahili
     * (‘sw’), Swedish (‘sv’), Tatar - Latin script (‘tt’), Tetum (‘tet’), traditional Chinese (‘zh-Hant’), Turkish
     * (‘tr’), Upper Sorbian (‘hsb’), Uzbek (‘uz’), Volapük (‘vo’), Walser (‘wae’), Western Frisian (‘fy’), Yucatec Maya
     * (‘yua’), Zhuang (‘za’) and Zulu (‘zu’) are supported (print – seventy-three languages and handwritten – English
     * only). Layout supports auto language identification and multi language documents, so only provide a language code
     * if you would like to force the documented to be processed as that specific language.
     * @param readingOrder Reading order algorithm to sort the text lines returned. Supported reading orders include:
     * basic(default), natural.
     * @param fileStream .json, .pdf, .jpg, .png, .tiff or .bmp type file stream.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void analyzeLayoutAsync(List<String> pages, Language language, ReadingOrder readingOrder,
        SourcePath fileStream) {
        analyzeLayoutAsyncWithResponse(pages, language, readingOrder, fileStream, Context.NONE);
    }

    /**
     * Get Analyze Layout Result
     * 
     * Track the progress and obtain the result of the analyze layout operation.
     * 
     * @param resultId Analyze operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AnalyzeOperationResult>> getAnalyzeLayoutResultWithResponseAsync(UUID resultId) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.getAnalyzeLayoutResult(this.getEndpoint(), this.getApiVersion(),
            resultId, accept, context));
    }

    /**
     * Get Analyze Layout Result
     * 
     * Track the progress and obtain the result of the analyze layout operation.
     * 
     * @param resultId Analyze operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<AnalyzeOperationResult>> getAnalyzeLayoutResultWithResponseAsync(UUID resultId,
        Context context) {
        final String accept = "application/json";
        return service.getAnalyzeLayoutResult(this.getEndpoint(), this.getApiVersion(), resultId, accept, context);
    }

    /**
     * Get Analyze Layout Result
     * 
     * Track the progress and obtain the result of the analyze layout operation.
     * 
     * @param resultId Analyze operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalyzeOperationResult> getAnalyzeLayoutResultAsync(UUID resultId) {
        return getAnalyzeLayoutResultWithResponseAsync(resultId).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get Analyze Layout Result
     * 
     * Track the progress and obtain the result of the analyze layout operation.
     * 
     * @param resultId Analyze operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AnalyzeOperationResult> getAnalyzeLayoutResultAsync(UUID resultId, Context context) {
        return getAnalyzeLayoutResultWithResponseAsync(resultId, context)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get Analyze Layout Result
     * 
     * Track the progress and obtain the result of the analyze layout operation.
     * 
     * @param resultId Analyze operation result identifier.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<AnalyzeOperationResult> getAnalyzeLayoutResultWithResponse(UUID resultId, Context context) {
        return getAnalyzeLayoutResultWithResponseAsync(resultId, context).block();
    }

    /**
     * Get Analyze Layout Result
     * 
     * Track the progress and obtain the result of the analyze layout operation.
     * 
     * @param resultId Analyze operation result identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return status and result of the queued analyze operation.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public AnalyzeOperationResult getAnalyzeLayoutResult(UUID resultId) {
        return getAnalyzeLayoutResultWithResponse(resultId, Context.NONE).getValue();
    }

    /**
     * List Custom Models
     * 
     * Get information about all custom models.
     * 
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about all custom models along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<ModelInfo>> listCustomModelsSinglePageAsync() {
        final String op = "full";
        final String accept = "application/json";
        return FluxUtil
            .withContext(
                context -> service.listCustomModels(this.getEndpoint(), this.getApiVersion(), op, accept, context))
            .map(res -> new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(),
                res.getValue().getModelList(), res.getValue().getNextLink(), null));
    }

    /**
     * List Custom Models
     * 
     * Get information about all custom models.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about all custom models along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<ModelInfo>> listCustomModelsSinglePageAsync(Context context) {
        final String op = "full";
        final String accept = "application/json";
        return service.listCustomModels(this.getEndpoint(), this.getApiVersion(), op, accept, context)
            .map(res -> new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(),
                res.getValue().getModelList(), res.getValue().getNextLink(), null));
    }

    /**
     * List Custom Models
     * 
     * Get information about all custom models.
     * 
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about all custom models as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<ModelInfo> listCustomModelsAsync() {
        return new PagedFlux<>(() -> listCustomModelsSinglePageAsync(),
            nextLink -> listCustomModelsNextSinglePageAsync(nextLink));
    }

    /**
     * List Custom Models
     * 
     * Get information about all custom models.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about all custom models as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<ModelInfo> listCustomModelsAsync(Context context) {
        return new PagedFlux<>(() -> listCustomModelsSinglePageAsync(context),
            nextLink -> listCustomModelsNextSinglePageAsync(nextLink, context));
    }

    /**
     * List Custom Models
     * 
     * Get information about all custom models.
     * 
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about all custom models along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<ModelInfo> listCustomModelsSinglePage() {
        return listCustomModelsSinglePageAsync().block();
    }

    /**
     * List Custom Models
     * 
     * Get information about all custom models.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about all custom models along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<ModelInfo> listCustomModelsSinglePage(Context context) {
        return listCustomModelsSinglePageAsync(context).block();
    }

    /**
     * List Custom Models
     * 
     * Get information about all custom models.
     * 
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about all custom models as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<ModelInfo> listCustomModels() {
        return new PagedIterable<>(listCustomModelsAsync());
    }

    /**
     * List Custom Models
     * 
     * Get information about all custom models.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about all custom models as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<ModelInfo> listCustomModels(Context context) {
        return new PagedIterable<>(listCustomModelsAsync(context));
    }

    /**
     * Get Custom Models
     * 
     * Get information about all custom models.
     * 
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about all custom models along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Models>> getCustomModelsWithResponseAsync() {
        final String op = "summary";
        final String accept = "application/json";
        return FluxUtil.withContext(
            context -> service.getCustomModels(this.getEndpoint(), this.getApiVersion(), op, accept, context));
    }

    /**
     * Get Custom Models
     * 
     * Get information about all custom models.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about all custom models along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Models>> getCustomModelsWithResponseAsync(Context context) {
        final String op = "summary";
        final String accept = "application/json";
        return service.getCustomModels(this.getEndpoint(), this.getApiVersion(), op, accept, context);
    }

    /**
     * Get Custom Models
     * 
     * Get information about all custom models.
     * 
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about all custom models on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Models> getCustomModelsAsync() {
        return getCustomModelsWithResponseAsync().flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get Custom Models
     * 
     * Get information about all custom models.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about all custom models on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Models> getCustomModelsAsync(Context context) {
        return getCustomModelsWithResponseAsync(context).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get Custom Models
     * 
     * Get information about all custom models.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about all custom models along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Models> getCustomModelsWithResponse(Context context) {
        return getCustomModelsWithResponseAsync(context).block();
    }

    /**
     * Get Custom Models
     * 
     * Get information about all custom models.
     * 
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return information about all custom models.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Models getCustomModels() {
        return getCustomModelsWithResponse(Context.NONE).getValue();
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items
     * 
     * The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response to the list custom models operation along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<ModelInfo>> listCustomModelsNextSinglePageAsync(String nextLink) {
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listCustomModelsNext(nextLink, this.getEndpoint(), this.getApiVersion(),
                accept, context))
            .map(res -> new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(),
                res.getValue().getModelList(), res.getValue().getNextLink(), null));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items
     * 
     * The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response to the list custom models operation along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<ModelInfo>> listCustomModelsNextSinglePageAsync(String nextLink, Context context) {
        final String accept = "application/json";
        return service.listCustomModelsNext(nextLink, this.getEndpoint(), this.getApiVersion(), accept, context)
            .map(res -> new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(),
                res.getValue().getModelList(), res.getValue().getNextLink(), null));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items
     * 
     * The nextLink parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response to the list custom models operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<ModelInfo> listCustomModelsNextSinglePage(String nextLink) {
        return listCustomModelsNextSinglePageAsync(nextLink).block();
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items
     * 
     * The nextLink parameter.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response to the list custom models operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PagedResponse<ModelInfo> listCustomModelsNextSinglePage(String nextLink, Context context) {
        return listCustomModelsNextSinglePageAsync(nextLink, context).block();
    }
}
