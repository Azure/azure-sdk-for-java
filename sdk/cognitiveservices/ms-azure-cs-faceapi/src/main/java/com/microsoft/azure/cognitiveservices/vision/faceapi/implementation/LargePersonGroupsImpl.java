/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.cognitiveservices.vision.faceapi.implementation;

import com.microsoft.azure.cognitiveservices.vision.faceapi.models.CreateLargePersonGroupsOptionalParameter;
import com.microsoft.azure.cognitiveservices.vision.faceapi.models.GetLargePersonGroupsOptionalParameter;
import com.microsoft.azure.cognitiveservices.vision.faceapi.models.UpdateLargePersonGroupsOptionalParameter;
import com.microsoft.azure.cognitiveservices.vision.faceapi.models.ListLargePersonGroupsOptionalParameter;
import retrofit2.Retrofit;
import com.microsoft.azure.cognitiveservices.vision.faceapi.LargePersonGroups;
import com.google.common.base.Joiner;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.cognitiveservices.vision.faceapi.models.APIErrorException;
import com.microsoft.azure.cognitiveservices.vision.faceapi.models.LargePersonGroup;
import com.microsoft.azure.cognitiveservices.vision.faceapi.models.MetaDataContract;
import com.microsoft.azure.cognitiveservices.vision.faceapi.models.NameAndUserDataContract;
import com.microsoft.azure.cognitiveservices.vision.faceapi.models.RecognitionModel;
import com.microsoft.azure.cognitiveservices.vision.faceapi.models.TrainingStatus;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import java.io.IOException;
import java.util.List;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.PATCH;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in LargePersonGroups.
 */
public class LargePersonGroupsImpl implements LargePersonGroups {
    /** The Retrofit service to perform REST calls. */
    private LargePersonGroupsService service;
    /** The service client containing this operation class. */
    private FaceAPIImpl client;

    /**
     * Initializes an instance of LargePersonGroupsImpl.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public LargePersonGroupsImpl(Retrofit retrofit, FaceAPIImpl client) {
        this.service = retrofit.create(LargePersonGroupsService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for LargePersonGroups to be
     * used by Retrofit to perform actually REST calls.
     */
    interface LargePersonGroupsService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.faceapi.LargePersonGroups create" })
        @PUT("largepersongroups/{largePersonGroupId}")
        Observable<Response<ResponseBody>> create(@Path("largePersonGroupId") String largePersonGroupId, @Header("accept-language") String acceptLanguage, @Body MetaDataContract bodyParameter, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.faceapi.LargePersonGroups delete" })
        @HTTP(path = "largepersongroups/{largePersonGroupId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> delete(@Path("largePersonGroupId") String largePersonGroupId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.faceapi.LargePersonGroups get" })
        @GET("largepersongroups/{largePersonGroupId}")
        Observable<Response<ResponseBody>> get(@Path("largePersonGroupId") String largePersonGroupId, @Query("returnRecognitionModel") Boolean returnRecognitionModel, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.faceapi.LargePersonGroups update" })
        @PATCH("largepersongroups/{largePersonGroupId}")
        Observable<Response<ResponseBody>> update(@Path("largePersonGroupId") String largePersonGroupId, @Header("accept-language") String acceptLanguage, @Body NameAndUserDataContract bodyParameter, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.faceapi.LargePersonGroups getTrainingStatus" })
        @GET("largepersongroups/{largePersonGroupId}/training")
        Observable<Response<ResponseBody>> getTrainingStatus(@Path("largePersonGroupId") String largePersonGroupId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.faceapi.LargePersonGroups list" })
        @GET("largepersongroups")
        Observable<Response<ResponseBody>> list(@Query("start") String start, @Query("top") Integer top, @Query("returnRecognitionModel") Boolean returnRecognitionModel, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.faceapi.LargePersonGroups train" })
        @POST("largepersongroups/{largePersonGroupId}/train")
        Observable<Response<ResponseBody>> train(@Path("largePersonGroupId") String largePersonGroupId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

    }


    /**
     * Create a new large person group with user-specified largePersonGroupId, name, an optional userData and recognitionModel.
     &lt;br /&gt; A large person group is the container of the uploaded person data, including face recognition feature, and up to 1,000,000
     people.
     &lt;br /&gt; After creation, use [LargePersonGroup Person - Create](https://docs.microsoft.com/rest/api/cognitiveservices/face/largepersongroupperson/create) to add person into the group, and call [LargePersonGroup - Train](https://docs.microsoft.com/rest/api/cognitiveservices/face/largepersongroup/train) to get this group ready for [Face - Identify](https://docs.microsoft.com/rest/api/cognitiveservices/face/face/identify).
     &lt;br /&gt; No image will be stored. Only the person's extracted face features and userData will be stored on server until [LargePersonGroup Person - Delete](https://docs.microsoft.com/rest/api/cognitiveservices/face/largepersongroupperson/delete) or [LargePersonGroup - Delete](https://docs.microsoft.com/rest/api/cognitiveservices/face/largepersongroup/delete) is called.
     &lt;br/&gt;'recognitionModel' should be specified to associate with this large person group. The default value for 'recognitionModel' is 'recognition_01', if the latest model needed, please explicitly specify the model you need in this parameter. New faces that are added to an existing large person group will use the recognition model that's already associated with the collection. Existing face features in a large person group can't be updated to features extracted by another version of recognition model.
     * 'recognition_01': The default recognition model for [LargePersonGroup - Create](https://docs.microsoft.com/rest/api/cognitiveservices/face/largepersongroup/create). All those large person groups created before 2019 March are bonded with this recognition model.
     * 'recognition_02': Recognition model released in 2019 March. 'recognition_02' is recommended since its overall accuracy is improved compared with 'recognition_01'.
     Large person group quota:
     * Free-tier subscription quota: 1,000 large person groups.
     * S0-tier subscription quota: 1,000,000 large person groups.
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @param createOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void create(String largePersonGroupId, CreateLargePersonGroupsOptionalParameter createOptionalParameter) {
        createWithServiceResponseAsync(largePersonGroupId, createOptionalParameter).toBlocking().single().body();
    }

    /**
     * Create a new large person group with user-specified largePersonGroupId, name, an optional userData and recognitionModel.
     &lt;br /&gt; A large person group is the container of the uploaded person data, including face recognition feature, and up to 1,000,000
     people.
     &lt;br /&gt; After creation, use [LargePersonGroup Person - Create](https://docs.microsoft.com/rest/api/cognitiveservices/face/largepersongroupperson/create) to add person into the group, and call [LargePersonGroup - Train](https://docs.microsoft.com/rest/api/cognitiveservices/face/largepersongroup/train) to get this group ready for [Face - Identify](https://docs.microsoft.com/rest/api/cognitiveservices/face/face/identify).
     &lt;br /&gt; No image will be stored. Only the person's extracted face features and userData will be stored on server until [LargePersonGroup Person - Delete](https://docs.microsoft.com/rest/api/cognitiveservices/face/largepersongroupperson/delete) or [LargePersonGroup - Delete](https://docs.microsoft.com/rest/api/cognitiveservices/face/largepersongroup/delete) is called.
     &lt;br/&gt;'recognitionModel' should be specified to associate with this large person group. The default value for 'recognitionModel' is 'recognition_01', if the latest model needed, please explicitly specify the model you need in this parameter. New faces that are added to an existing large person group will use the recognition model that's already associated with the collection. Existing face features in a large person group can't be updated to features extracted by another version of recognition model.
     * 'recognition_01': The default recognition model for [LargePersonGroup - Create](https://docs.microsoft.com/rest/api/cognitiveservices/face/largepersongroup/create). All those large person groups created before 2019 March are bonded with this recognition model.
     * 'recognition_02': Recognition model released in 2019 March. 'recognition_02' is recommended since its overall accuracy is improved compared with 'recognition_01'.
     Large person group quota:
     * Free-tier subscription quota: 1,000 large person groups.
     * S0-tier subscription quota: 1,000,000 large person groups.
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @param createOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> createAsync(String largePersonGroupId, CreateLargePersonGroupsOptionalParameter createOptionalParameter, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(createWithServiceResponseAsync(largePersonGroupId, createOptionalParameter), serviceCallback);
    }

    /**
     * Create a new large person group with user-specified largePersonGroupId, name, an optional userData and recognitionModel.
     &lt;br /&gt; A large person group is the container of the uploaded person data, including face recognition feature, and up to 1,000,000
     people.
     &lt;br /&gt; After creation, use [LargePersonGroup Person - Create](https://docs.microsoft.com/rest/api/cognitiveservices/face/largepersongroupperson/create) to add person into the group, and call [LargePersonGroup - Train](https://docs.microsoft.com/rest/api/cognitiveservices/face/largepersongroup/train) to get this group ready for [Face - Identify](https://docs.microsoft.com/rest/api/cognitiveservices/face/face/identify).
     &lt;br /&gt; No image will be stored. Only the person's extracted face features and userData will be stored on server until [LargePersonGroup Person - Delete](https://docs.microsoft.com/rest/api/cognitiveservices/face/largepersongroupperson/delete) or [LargePersonGroup - Delete](https://docs.microsoft.com/rest/api/cognitiveservices/face/largepersongroup/delete) is called.
     &lt;br/&gt;'recognitionModel' should be specified to associate with this large person group. The default value for 'recognitionModel' is 'recognition_01', if the latest model needed, please explicitly specify the model you need in this parameter. New faces that are added to an existing large person group will use the recognition model that's already associated with the collection. Existing face features in a large person group can't be updated to features extracted by another version of recognition model.
     * 'recognition_01': The default recognition model for [LargePersonGroup - Create](https://docs.microsoft.com/rest/api/cognitiveservices/face/largepersongroup/create). All those large person groups created before 2019 March are bonded with this recognition model.
     * 'recognition_02': Recognition model released in 2019 March. 'recognition_02' is recommended since its overall accuracy is improved compared with 'recognition_01'.
     Large person group quota:
     * Free-tier subscription quota: 1,000 large person groups.
     * S0-tier subscription quota: 1,000,000 large person groups.
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @param createOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> createAsync(String largePersonGroupId, CreateLargePersonGroupsOptionalParameter createOptionalParameter) {
        return createWithServiceResponseAsync(largePersonGroupId, createOptionalParameter).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Create a new large person group with user-specified largePersonGroupId, name, an optional userData and recognitionModel.
     &lt;br /&gt; A large person group is the container of the uploaded person data, including face recognition feature, and up to 1,000,000
     people.
     &lt;br /&gt; After creation, use [LargePersonGroup Person - Create](https://docs.microsoft.com/rest/api/cognitiveservices/face/largepersongroupperson/create) to add person into the group, and call [LargePersonGroup - Train](https://docs.microsoft.com/rest/api/cognitiveservices/face/largepersongroup/train) to get this group ready for [Face - Identify](https://docs.microsoft.com/rest/api/cognitiveservices/face/face/identify).
     &lt;br /&gt; No image will be stored. Only the person's extracted face features and userData will be stored on server until [LargePersonGroup Person - Delete](https://docs.microsoft.com/rest/api/cognitiveservices/face/largepersongroupperson/delete) or [LargePersonGroup - Delete](https://docs.microsoft.com/rest/api/cognitiveservices/face/largepersongroup/delete) is called.
     &lt;br/&gt;'recognitionModel' should be specified to associate with this large person group. The default value for 'recognitionModel' is 'recognition_01', if the latest model needed, please explicitly specify the model you need in this parameter. New faces that are added to an existing large person group will use the recognition model that's already associated with the collection. Existing face features in a large person group can't be updated to features extracted by another version of recognition model.
     * 'recognition_01': The default recognition model for [LargePersonGroup - Create](https://docs.microsoft.com/rest/api/cognitiveservices/face/largepersongroup/create). All those large person groups created before 2019 March are bonded with this recognition model.
     * 'recognition_02': Recognition model released in 2019 March. 'recognition_02' is recommended since its overall accuracy is improved compared with 'recognition_01'.
     Large person group quota:
     * Free-tier subscription quota: 1,000 large person groups.
     * S0-tier subscription quota: 1,000,000 large person groups.
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @param createOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> createWithServiceResponseAsync(String largePersonGroupId, CreateLargePersonGroupsOptionalParameter createOptionalParameter) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (largePersonGroupId == null) {
            throw new IllegalArgumentException("Parameter largePersonGroupId is required and cannot be null.");
        }
        final String name = createOptionalParameter != null ? createOptionalParameter.name() : null;
        final String userData = createOptionalParameter != null ? createOptionalParameter.userData() : null;
        final RecognitionModel recognitionModel = createOptionalParameter != null ? createOptionalParameter.recognitionModel() : null;

        return createWithServiceResponseAsync(largePersonGroupId, name, userData, recognitionModel);
    }

    /**
     * Create a new large person group with user-specified largePersonGroupId, name, an optional userData and recognitionModel.
     &lt;br /&gt; A large person group is the container of the uploaded person data, including face recognition feature, and up to 1,000,000
     people.
     &lt;br /&gt; After creation, use [LargePersonGroup Person - Create](https://docs.microsoft.com/rest/api/cognitiveservices/face/largepersongroupperson/create) to add person into the group, and call [LargePersonGroup - Train](https://docs.microsoft.com/rest/api/cognitiveservices/face/largepersongroup/train) to get this group ready for [Face - Identify](https://docs.microsoft.com/rest/api/cognitiveservices/face/face/identify).
     &lt;br /&gt; No image will be stored. Only the person's extracted face features and userData will be stored on server until [LargePersonGroup Person - Delete](https://docs.microsoft.com/rest/api/cognitiveservices/face/largepersongroupperson/delete) or [LargePersonGroup - Delete](https://docs.microsoft.com/rest/api/cognitiveservices/face/largepersongroup/delete) is called.
     &lt;br/&gt;'recognitionModel' should be specified to associate with this large person group. The default value for 'recognitionModel' is 'recognition_01', if the latest model needed, please explicitly specify the model you need in this parameter. New faces that are added to an existing large person group will use the recognition model that's already associated with the collection. Existing face features in a large person group can't be updated to features extracted by another version of recognition model.
     * 'recognition_01': The default recognition model for [LargePersonGroup - Create](https://docs.microsoft.com/rest/api/cognitiveservices/face/largepersongroup/create). All those large person groups created before 2019 March are bonded with this recognition model.
     * 'recognition_02': Recognition model released in 2019 March. 'recognition_02' is recommended since its overall accuracy is improved compared with 'recognition_01'.
     Large person group quota:
     * Free-tier subscription quota: 1,000 large person groups.
     * S0-tier subscription quota: 1,000,000 large person groups.
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @param name User defined name, maximum length is 128.
     * @param userData User specified data. Length should not exceed 16KB.
     * @param recognitionModel Possible values include: 'recognition_01', 'recognition_02'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> createWithServiceResponseAsync(String largePersonGroupId, String name, String userData, RecognitionModel recognitionModel) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (largePersonGroupId == null) {
            throw new IllegalArgumentException("Parameter largePersonGroupId is required and cannot be null.");
        }
        MetaDataContract bodyParameter = new MetaDataContract();
        bodyParameter.withName(name);
        bodyParameter.withUserData(userData);
        bodyParameter.withRecognitionModel(recognitionModel);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.create(largePersonGroupId, this.client.acceptLanguage(), bodyParameter, parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = createDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> createDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }

    @Override
    public LargePersonGroupsCreateParameters create() {
        return new LargePersonGroupsCreateParameters(this);
    }

    /**
     * Internal class implementing LargePersonGroupsCreateDefinition.
     */
    class LargePersonGroupsCreateParameters implements LargePersonGroupsCreateDefinition {
        private LargePersonGroupsImpl parent;
        private String largePersonGroupId;
        private String name;
        private String userData;
        private RecognitionModel recognitionModel;

        /**
         * Constructor.
         * @param parent the parent object.
         */
        LargePersonGroupsCreateParameters(LargePersonGroupsImpl parent) {
            this.parent = parent;
        }

        @Override
        public LargePersonGroupsCreateParameters withLargePersonGroupId(String largePersonGroupId) {
            this.largePersonGroupId = largePersonGroupId;
            return this;
        }

        @Override
        public LargePersonGroupsCreateParameters withName(String name) {
            this.name = name;
            return this;
        }

        @Override
        public LargePersonGroupsCreateParameters withUserData(String userData) {
            this.userData = userData;
            return this;
        }

        @Override
        public LargePersonGroupsCreateParameters withRecognitionModel(RecognitionModel recognitionModel) {
            this.recognitionModel = recognitionModel;
            return this;
        }

        @Override
        public void execute() {
        createWithServiceResponseAsync(largePersonGroupId, name, userData, recognitionModel).toBlocking().single().body();
    }

        @Override
        public Observable<Void> executeAsync() {
            return createWithServiceResponseAsync(largePersonGroupId, name, userData, recognitionModel).map(new Func1<ServiceResponse<Void>, Void>() {
                @Override
                public Void call(ServiceResponse<Void> response) {
                    return response.body();
                }
            });
        }
    }

    /**
     * Delete an existing large person group. Persisted face features of all people in the large person group will also be deleted.
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void delete(String largePersonGroupId) {
        deleteWithServiceResponseAsync(largePersonGroupId).toBlocking().single().body();
    }

    /**
     * Delete an existing large person group. Persisted face features of all people in the large person group will also be deleted.
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteAsync(String largePersonGroupId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteWithServiceResponseAsync(largePersonGroupId), serviceCallback);
    }

    /**
     * Delete an existing large person group. Persisted face features of all people in the large person group will also be deleted.
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteAsync(String largePersonGroupId) {
        return deleteWithServiceResponseAsync(largePersonGroupId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete an existing large person group. Persisted face features of all people in the large person group will also be deleted.
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteWithServiceResponseAsync(String largePersonGroupId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (largePersonGroupId == null) {
            throw new IllegalArgumentException("Parameter largePersonGroupId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.delete(largePersonGroupId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }


    /**
     * Retrieve the information of a large person group, including its name, userData and recognitionModel. This API returns large person group information only, use [LargePersonGroup Person - List](https://docs.microsoft.com/rest/api/cognitiveservices/face/largepersongroupperson/list) instead to retrieve person information under the large person group.
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @param getOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the LargePersonGroup object if successful.
     */
    public LargePersonGroup get(String largePersonGroupId, GetLargePersonGroupsOptionalParameter getOptionalParameter) {
        return getWithServiceResponseAsync(largePersonGroupId, getOptionalParameter).toBlocking().single().body();
    }

    /**
     * Retrieve the information of a large person group, including its name, userData and recognitionModel. This API returns large person group information only, use [LargePersonGroup Person - List](https://docs.microsoft.com/rest/api/cognitiveservices/face/largepersongroupperson/list) instead to retrieve person information under the large person group.
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @param getOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<LargePersonGroup> getAsync(String largePersonGroupId, GetLargePersonGroupsOptionalParameter getOptionalParameter, final ServiceCallback<LargePersonGroup> serviceCallback) {
        return ServiceFuture.fromResponse(getWithServiceResponseAsync(largePersonGroupId, getOptionalParameter), serviceCallback);
    }

    /**
     * Retrieve the information of a large person group, including its name, userData and recognitionModel. This API returns large person group information only, use [LargePersonGroup Person - List](https://docs.microsoft.com/rest/api/cognitiveservices/face/largepersongroupperson/list) instead to retrieve person information under the large person group.
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @param getOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the LargePersonGroup object
     */
    public Observable<LargePersonGroup> getAsync(String largePersonGroupId, GetLargePersonGroupsOptionalParameter getOptionalParameter) {
        return getWithServiceResponseAsync(largePersonGroupId, getOptionalParameter).map(new Func1<ServiceResponse<LargePersonGroup>, LargePersonGroup>() {
            @Override
            public LargePersonGroup call(ServiceResponse<LargePersonGroup> response) {
                return response.body();
            }
        });
    }

    /**
     * Retrieve the information of a large person group, including its name, userData and recognitionModel. This API returns large person group information only, use [LargePersonGroup Person - List](https://docs.microsoft.com/rest/api/cognitiveservices/face/largepersongroupperson/list) instead to retrieve person information under the large person group.
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @param getOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the LargePersonGroup object
     */
    public Observable<ServiceResponse<LargePersonGroup>> getWithServiceResponseAsync(String largePersonGroupId, GetLargePersonGroupsOptionalParameter getOptionalParameter) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (largePersonGroupId == null) {
            throw new IllegalArgumentException("Parameter largePersonGroupId is required and cannot be null.");
        }
        final Boolean returnRecognitionModel = getOptionalParameter != null ? getOptionalParameter.returnRecognitionModel() : null;

        return getWithServiceResponseAsync(largePersonGroupId, returnRecognitionModel);
    }

    /**
     * Retrieve the information of a large person group, including its name, userData and recognitionModel. This API returns large person group information only, use [LargePersonGroup Person - List](https://docs.microsoft.com/rest/api/cognitiveservices/face/largepersongroupperson/list) instead to retrieve person information under the large person group.
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @param returnRecognitionModel A value indicating whether the operation should return 'recognitionModel' in response.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the LargePersonGroup object
     */
    public Observable<ServiceResponse<LargePersonGroup>> getWithServiceResponseAsync(String largePersonGroupId, Boolean returnRecognitionModel) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (largePersonGroupId == null) {
            throw new IllegalArgumentException("Parameter largePersonGroupId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.get(largePersonGroupId, returnRecognitionModel, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<LargePersonGroup>>>() {
                @Override
                public Observable<ServiceResponse<LargePersonGroup>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<LargePersonGroup> clientResponse = getDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<LargePersonGroup> getDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<LargePersonGroup, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<LargePersonGroup>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }

    @Override
    public LargePersonGroupsGetParameters get() {
        return new LargePersonGroupsGetParameters(this);
    }

    /**
     * Internal class implementing LargePersonGroupsGetDefinition.
     */
    class LargePersonGroupsGetParameters implements LargePersonGroupsGetDefinition {
        private LargePersonGroupsImpl parent;
        private String largePersonGroupId;
        private Boolean returnRecognitionModel;

        /**
         * Constructor.
         * @param parent the parent object.
         */
        LargePersonGroupsGetParameters(LargePersonGroupsImpl parent) {
            this.parent = parent;
        }

        @Override
        public LargePersonGroupsGetParameters withLargePersonGroupId(String largePersonGroupId) {
            this.largePersonGroupId = largePersonGroupId;
            return this;
        }

        @Override
        public LargePersonGroupsGetParameters withReturnRecognitionModel(Boolean returnRecognitionModel) {
            this.returnRecognitionModel = returnRecognitionModel;
            return this;
        }

        @Override
        public LargePersonGroup execute() {
        return getWithServiceResponseAsync(largePersonGroupId, returnRecognitionModel).toBlocking().single().body();
    }

        @Override
        public Observable<LargePersonGroup> executeAsync() {
            return getWithServiceResponseAsync(largePersonGroupId, returnRecognitionModel).map(new Func1<ServiceResponse<LargePersonGroup>, LargePersonGroup>() {
                @Override
                public LargePersonGroup call(ServiceResponse<LargePersonGroup> response) {
                    return response.body();
                }
            });
        }
    }


    /**
     * Update an existing large person group's display name and userData. The properties which does not appear in request body will not be updated.
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @param updateOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void update(String largePersonGroupId, UpdateLargePersonGroupsOptionalParameter updateOptionalParameter) {
        updateWithServiceResponseAsync(largePersonGroupId, updateOptionalParameter).toBlocking().single().body();
    }

    /**
     * Update an existing large person group's display name and userData. The properties which does not appear in request body will not be updated.
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @param updateOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> updateAsync(String largePersonGroupId, UpdateLargePersonGroupsOptionalParameter updateOptionalParameter, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(updateWithServiceResponseAsync(largePersonGroupId, updateOptionalParameter), serviceCallback);
    }

    /**
     * Update an existing large person group's display name and userData. The properties which does not appear in request body will not be updated.
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @param updateOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> updateAsync(String largePersonGroupId, UpdateLargePersonGroupsOptionalParameter updateOptionalParameter) {
        return updateWithServiceResponseAsync(largePersonGroupId, updateOptionalParameter).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Update an existing large person group's display name and userData. The properties which does not appear in request body will not be updated.
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @param updateOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> updateWithServiceResponseAsync(String largePersonGroupId, UpdateLargePersonGroupsOptionalParameter updateOptionalParameter) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (largePersonGroupId == null) {
            throw new IllegalArgumentException("Parameter largePersonGroupId is required and cannot be null.");
        }
        final String name = updateOptionalParameter != null ? updateOptionalParameter.name() : null;
        final String userData = updateOptionalParameter != null ? updateOptionalParameter.userData() : null;

        return updateWithServiceResponseAsync(largePersonGroupId, name, userData);
    }

    /**
     * Update an existing large person group's display name and userData. The properties which does not appear in request body will not be updated.
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @param name User defined name, maximum length is 128.
     * @param userData User specified data. Length should not exceed 16KB.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> updateWithServiceResponseAsync(String largePersonGroupId, String name, String userData) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (largePersonGroupId == null) {
            throw new IllegalArgumentException("Parameter largePersonGroupId is required and cannot be null.");
        }
        NameAndUserDataContract bodyParameter = new NameAndUserDataContract();
        bodyParameter.withName(name);
        bodyParameter.withUserData(userData);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.update(largePersonGroupId, this.client.acceptLanguage(), bodyParameter, parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = updateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> updateDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }

    @Override
    public LargePersonGroupsUpdateParameters update() {
        return new LargePersonGroupsUpdateParameters(this);
    }

    /**
     * Internal class implementing LargePersonGroupsUpdateDefinition.
     */
    class LargePersonGroupsUpdateParameters implements LargePersonGroupsUpdateDefinition {
        private LargePersonGroupsImpl parent;
        private String largePersonGroupId;
        private String name;
        private String userData;

        /**
         * Constructor.
         * @param parent the parent object.
         */
        LargePersonGroupsUpdateParameters(LargePersonGroupsImpl parent) {
            this.parent = parent;
        }

        @Override
        public LargePersonGroupsUpdateParameters withLargePersonGroupId(String largePersonGroupId) {
            this.largePersonGroupId = largePersonGroupId;
            return this;
        }

        @Override
        public LargePersonGroupsUpdateParameters withName(String name) {
            this.name = name;
            return this;
        }

        @Override
        public LargePersonGroupsUpdateParameters withUserData(String userData) {
            this.userData = userData;
            return this;
        }

        @Override
        public void execute() {
        updateWithServiceResponseAsync(largePersonGroupId, name, userData).toBlocking().single().body();
    }

        @Override
        public Observable<Void> executeAsync() {
            return updateWithServiceResponseAsync(largePersonGroupId, name, userData).map(new Func1<ServiceResponse<Void>, Void>() {
                @Override
                public Void call(ServiceResponse<Void> response) {
                    return response.body();
                }
            });
        }
    }

    /**
     * Retrieve the training status of a large person group (completed or ongoing).
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TrainingStatus object if successful.
     */
    public TrainingStatus getTrainingStatus(String largePersonGroupId) {
        return getTrainingStatusWithServiceResponseAsync(largePersonGroupId).toBlocking().single().body();
    }

    /**
     * Retrieve the training status of a large person group (completed or ongoing).
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TrainingStatus> getTrainingStatusAsync(String largePersonGroupId, final ServiceCallback<TrainingStatus> serviceCallback) {
        return ServiceFuture.fromResponse(getTrainingStatusWithServiceResponseAsync(largePersonGroupId), serviceCallback);
    }

    /**
     * Retrieve the training status of a large person group (completed or ongoing).
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TrainingStatus object
     */
    public Observable<TrainingStatus> getTrainingStatusAsync(String largePersonGroupId) {
        return getTrainingStatusWithServiceResponseAsync(largePersonGroupId).map(new Func1<ServiceResponse<TrainingStatus>, TrainingStatus>() {
            @Override
            public TrainingStatus call(ServiceResponse<TrainingStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Retrieve the training status of a large person group (completed or ongoing).
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TrainingStatus object
     */
    public Observable<ServiceResponse<TrainingStatus>> getTrainingStatusWithServiceResponseAsync(String largePersonGroupId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (largePersonGroupId == null) {
            throw new IllegalArgumentException("Parameter largePersonGroupId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.getTrainingStatus(largePersonGroupId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<TrainingStatus>>>() {
                @Override
                public Observable<ServiceResponse<TrainingStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<TrainingStatus> clientResponse = getTrainingStatusDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<TrainingStatus> getTrainingStatusDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<TrainingStatus, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<TrainingStatus>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }


    /**
     * List all existing large person groups largePersonGroupId, name, userData and recognitionModel.&lt;br /&gt;
     * Large person groups are stored in alphabetical order of largePersonGroupId.
     * "start" parameter (string, optional) is a user-provided largePersonGroupId value that returned entries have larger ids by string comparison. "start" set to empty to indicate return from the first item.
     * "top" parameter (int, optional) specifies the number of entries to return. A maximal of 1000 entries can be returned in one call. To fetch more, you can specify "start" with the last returned entrys Id of the current call.
     &lt;br /&gt;
     For example, total 5 large person groups: "group1", ..., "group5".
     &lt;br /&gt; "start=&amp;top=" will return all 5 groups.
     &lt;br /&gt; "start=&amp;top=2" will return "group1", "group2".
     &lt;br /&gt; "start=group2&amp;top=3" will return "group3", "group4", "group5".
     *
     * @param listOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;LargePersonGroup&gt; object if successful.
     */
    public List<LargePersonGroup> list(ListLargePersonGroupsOptionalParameter listOptionalParameter) {
        return listWithServiceResponseAsync(listOptionalParameter).toBlocking().single().body();
    }

    /**
     * List all existing large person groups largePersonGroupId, name, userData and recognitionModel.&lt;br /&gt;
     * Large person groups are stored in alphabetical order of largePersonGroupId.
     * "start" parameter (string, optional) is a user-provided largePersonGroupId value that returned entries have larger ids by string comparison. "start" set to empty to indicate return from the first item.
     * "top" parameter (int, optional) specifies the number of entries to return. A maximal of 1000 entries can be returned in one call. To fetch more, you can specify "start" with the last returned entrys Id of the current call.
     &lt;br /&gt;
     For example, total 5 large person groups: "group1", ..., "group5".
     &lt;br /&gt; "start=&amp;top=" will return all 5 groups.
     &lt;br /&gt; "start=&amp;top=2" will return "group1", "group2".
     &lt;br /&gt; "start=group2&amp;top=3" will return "group3", "group4", "group5".
     *
     * @param listOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<LargePersonGroup>> listAsync(ListLargePersonGroupsOptionalParameter listOptionalParameter, final ServiceCallback<List<LargePersonGroup>> serviceCallback) {
        return ServiceFuture.fromResponse(listWithServiceResponseAsync(listOptionalParameter), serviceCallback);
    }

    /**
     * List all existing large person groups largePersonGroupId, name, userData and recognitionModel.&lt;br /&gt;
     * Large person groups are stored in alphabetical order of largePersonGroupId.
     * "start" parameter (string, optional) is a user-provided largePersonGroupId value that returned entries have larger ids by string comparison. "start" set to empty to indicate return from the first item.
     * "top" parameter (int, optional) specifies the number of entries to return. A maximal of 1000 entries can be returned in one call. To fetch more, you can specify "start" with the last returned entrys Id of the current call.
     &lt;br /&gt;
     For example, total 5 large person groups: "group1", ..., "group5".
     &lt;br /&gt; "start=&amp;top=" will return all 5 groups.
     &lt;br /&gt; "start=&amp;top=2" will return "group1", "group2".
     &lt;br /&gt; "start=group2&amp;top=3" will return "group3", "group4", "group5".
     *
     * @param listOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;LargePersonGroup&gt; object
     */
    public Observable<List<LargePersonGroup>> listAsync(ListLargePersonGroupsOptionalParameter listOptionalParameter) {
        return listWithServiceResponseAsync(listOptionalParameter).map(new Func1<ServiceResponse<List<LargePersonGroup>>, List<LargePersonGroup>>() {
            @Override
            public List<LargePersonGroup> call(ServiceResponse<List<LargePersonGroup>> response) {
                return response.body();
            }
        });
    }

    /**
     * List all existing large person groups largePersonGroupId, name, userData and recognitionModel.&lt;br /&gt;
     * Large person groups are stored in alphabetical order of largePersonGroupId.
     * "start" parameter (string, optional) is a user-provided largePersonGroupId value that returned entries have larger ids by string comparison. "start" set to empty to indicate return from the first item.
     * "top" parameter (int, optional) specifies the number of entries to return. A maximal of 1000 entries can be returned in one call. To fetch more, you can specify "start" with the last returned entrys Id of the current call.
     &lt;br /&gt;
     For example, total 5 large person groups: "group1", ..., "group5".
     &lt;br /&gt; "start=&amp;top=" will return all 5 groups.
     &lt;br /&gt; "start=&amp;top=2" will return "group1", "group2".
     &lt;br /&gt; "start=group2&amp;top=3" will return "group3", "group4", "group5".
     *
     * @param listOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;LargePersonGroup&gt; object
     */
    public Observable<ServiceResponse<List<LargePersonGroup>>> listWithServiceResponseAsync(ListLargePersonGroupsOptionalParameter listOptionalParameter) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        final String start = listOptionalParameter != null ? listOptionalParameter.start() : null;
        final Integer top = listOptionalParameter != null ? listOptionalParameter.top() : null;
        final Boolean returnRecognitionModel = listOptionalParameter != null ? listOptionalParameter.returnRecognitionModel() : null;

        return listWithServiceResponseAsync(start, top, returnRecognitionModel);
    }

    /**
     * List all existing large person groups largePersonGroupId, name, userData and recognitionModel.&lt;br /&gt;
     * Large person groups are stored in alphabetical order of largePersonGroupId.
     * "start" parameter (string, optional) is a user-provided largePersonGroupId value that returned entries have larger ids by string comparison. "start" set to empty to indicate return from the first item.
     * "top" parameter (int, optional) specifies the number of entries to return. A maximal of 1000 entries can be returned in one call. To fetch more, you can specify "start" with the last returned entrys Id of the current call.
     &lt;br /&gt;
     For example, total 5 large person groups: "group1", ..., "group5".
     &lt;br /&gt; "start=&amp;top=" will return all 5 groups.
     &lt;br /&gt; "start=&amp;top=2" will return "group1", "group2".
     &lt;br /&gt; "start=group2&amp;top=3" will return "group3", "group4", "group5".
     *
     * @param start List large person groups from the least largePersonGroupId greater than the "start".
     * @param top The number of large person groups to list.
     * @param returnRecognitionModel A value indicating whether the operation should return 'recognitionModel' in response.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;LargePersonGroup&gt; object
     */
    public Observable<ServiceResponse<List<LargePersonGroup>>> listWithServiceResponseAsync(String start, Integer top, Boolean returnRecognitionModel) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.list(start, top, returnRecognitionModel, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<LargePersonGroup>>>>() {
                @Override
                public Observable<ServiceResponse<List<LargePersonGroup>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<LargePersonGroup>> clientResponse = listDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<LargePersonGroup>> listDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<LargePersonGroup>, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<LargePersonGroup>>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }

    @Override
    public LargePersonGroupsListParameters list() {
        return new LargePersonGroupsListParameters(this);
    }

    /**
     * Internal class implementing LargePersonGroupsListDefinition.
     */
    class LargePersonGroupsListParameters implements LargePersonGroupsListDefinition {
        private LargePersonGroupsImpl parent;
        private String start;
        private Integer top;
        private Boolean returnRecognitionModel;

        /**
         * Constructor.
         * @param parent the parent object.
         */
        LargePersonGroupsListParameters(LargePersonGroupsImpl parent) {
            this.parent = parent;
        }

        @Override
        public LargePersonGroupsListParameters withStart(String start) {
            this.start = start;
            return this;
        }

        @Override
        public LargePersonGroupsListParameters withTop(Integer top) {
            this.top = top;
            return this;
        }

        @Override
        public LargePersonGroupsListParameters withReturnRecognitionModel(Boolean returnRecognitionModel) {
            this.returnRecognitionModel = returnRecognitionModel;
            return this;
        }

        @Override
        public List<LargePersonGroup> execute() {
        return listWithServiceResponseAsync(start, top, returnRecognitionModel).toBlocking().single().body();
    }

        @Override
        public Observable<List<LargePersonGroup>> executeAsync() {
            return listWithServiceResponseAsync(start, top, returnRecognitionModel).map(new Func1<ServiceResponse<List<LargePersonGroup>>, List<LargePersonGroup>>() {
                @Override
                public List<LargePersonGroup> call(ServiceResponse<List<LargePersonGroup>> response) {
                    return response.body();
                }
            });
        }
    }

    /**
     * Queue a large person group training task, the training task may not be started immediately.
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void train(String largePersonGroupId) {
        trainWithServiceResponseAsync(largePersonGroupId).toBlocking().single().body();
    }

    /**
     * Queue a large person group training task, the training task may not be started immediately.
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> trainAsync(String largePersonGroupId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(trainWithServiceResponseAsync(largePersonGroupId), serviceCallback);
    }

    /**
     * Queue a large person group training task, the training task may not be started immediately.
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> trainAsync(String largePersonGroupId) {
        return trainWithServiceResponseAsync(largePersonGroupId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Queue a large person group training task, the training task may not be started immediately.
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> trainWithServiceResponseAsync(String largePersonGroupId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (largePersonGroupId == null) {
            throw new IllegalArgumentException("Parameter largePersonGroupId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.train(largePersonGroupId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = trainDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> trainDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }

}
