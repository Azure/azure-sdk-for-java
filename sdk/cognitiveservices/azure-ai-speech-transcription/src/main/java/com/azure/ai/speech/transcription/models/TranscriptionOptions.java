// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.
package com.azure.ai.speech.transcription.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.annotation.Generated;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;
import java.util.Map;

/**
 * Metadata for a transcription request.
 */
@Fluent
public final class TranscriptionOptions implements JsonSerializable<TranscriptionOptions> {

    /*
     * The URL of the audio to be transcribed. The audio must be shorter than 2 hours in audio duration and smaller than
     * 250 MB in size. If both Audio and AudioUrl are provided, Audio is used.
     */
    @Generated
    private String audioUrl;

    /*
     * A list of possible locales for the transcription. If not specified, the locale of the speech in the audio is
     * detected automatically from all supported locales.
     */
    @Generated
    private List<String> locales;

    /*
     * Mode of profanity filtering.
     */
    @Generated
    private ProfanityFilterMode profanityFilterMode;

    /**
     * Creates an instance of TranscriptionOptions class.
     */
    @Generated
    public TranscriptionOptions() {
    }

    /**
     * Get the audioUrl property: The URL of the audio to be transcribed. The audio must be shorter than 2 hours in
     * audio duration and smaller than 250 MB in size. If both Audio and AudioUrl are provided, Audio is used.
     *
     * @return the audioUrl value.
     */
    @Generated
    public String getAudioUrl() {
        return this.audioUrl;
    }

    /**
     * Get the locales property: A list of possible locales for the transcription. If not specified, the locale of the
     * speech in the audio is detected automatically from all supported locales.
     *
     * @return the locales value.
     */
    @Generated
    public List<String> getLocales() {
        return this.locales;
    }

    /**
     * Set the locales property: A list of possible locales for the transcription. If not specified, the locale of the
     * speech in the audio is detected automatically from all supported locales.
     *
     * @param locales the locales value to set.
     * @return the TranscriptionOptions object itself.
     */
    @Generated
    public TranscriptionOptions setLocales(List<String> locales) {
        this.locales = locales;
        return this;
    }

    /**
     * Get the profanityFilterMode property: Mode of profanity filtering.
     *
     * @return the profanityFilterMode value.
     */
    @Generated
    public ProfanityFilterMode getProfanityFilterMode() {
        return this.profanityFilterMode;
    }

    /**
     * Set the profanityFilterMode property: Mode of profanity filtering.
     *
     * @param profanityFilterMode the profanityFilterMode value to set.
     * @return the TranscriptionOptions object itself.
     */
    @Generated
    public TranscriptionOptions setProfanityFilterMode(ProfanityFilterMode profanityFilterMode) {
        this.profanityFilterMode = profanityFilterMode;
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Generated
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("audioUrl", this.audioUrl);
        jsonWriter.writeArrayField("locales", this.locales, (writer, element) -> writer.writeString(element));
        jsonWriter.writeMapField("models", this.localeModelMapping, (writer, element) -> writer.writeString(element));
        jsonWriter.writeStringField("profanityFilterMode",
            this.profanityFilterMode == null ? null : this.profanityFilterMode.toString());
        jsonWriter.writeJsonField("diarization", this.diarizationOptions);
        jsonWriter.writeArrayField("channels", this.activeChannels, (writer, element) -> writer.writeInt(element));
        jsonWriter.writeJsonField("enhancedMode", this.enhancedModeOptions);
        jsonWriter.writeJsonField("phraseList", this.phraseListOptions);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of TranscriptionOptions from the JsonReader.
     *
     * @param jsonReader The JsonReader being read.
     * @return An instance of TranscriptionOptions if the JsonReader was pointing to an instance of it, or null if it
     * was pointing to JSON null.
     * @throws IOException If an error occurs while reading the TranscriptionOptions.
     */
    @Generated
    public static TranscriptionOptions fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            TranscriptionOptions deserializedTranscriptionOptions = new TranscriptionOptions();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();
                if ("audioUrl".equals(fieldName)) {
                    deserializedTranscriptionOptions.audioUrl = reader.getString();
                } else if ("locales".equals(fieldName)) {
                    List<String> locales = reader.readArray(reader1 -> reader1.getString());
                    deserializedTranscriptionOptions.locales = locales;
                } else if ("models".equals(fieldName)) {
                    Map<String, String> localeModelMapping = reader.readMap(reader1 -> reader1.getString());
                    deserializedTranscriptionOptions.localeModelMapping = localeModelMapping;
                } else if ("profanityFilterMode".equals(fieldName)) {
                    deserializedTranscriptionOptions.profanityFilterMode
                        = ProfanityFilterMode.fromString(reader.getString());
                } else if ("diarization".equals(fieldName)) {
                    deserializedTranscriptionOptions.diarizationOptions
                        = TranscriptionDiarizationOptions.fromJson(reader);
                } else if ("channels".equals(fieldName)) {
                    List<Integer> activeChannels = reader.readArray(reader1 -> reader1.getInt());
                    deserializedTranscriptionOptions.activeChannels = activeChannels;
                } else if ("enhancedMode".equals(fieldName)) {
                    deserializedTranscriptionOptions.enhancedModeOptions = EnhancedModeOptions.fromJson(reader);
                } else if ("phraseList".equals(fieldName)) {
                    deserializedTranscriptionOptions.phraseListOptions = PhraseListOptions.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }
            return deserializedTranscriptionOptions;
        });
    }

    /*
     * Mode of diarization.
     */
    @Generated
    private TranscriptionDiarizationOptions diarizationOptions;

    /*
     * The 0-based indices of the channels to be transcribed separately. If not specified, multiple channels are merged
     * and transcribed jointly. Only up to two channels are supported.
     */
    @Generated
    private List<Integer> activeChannels;

    /**
     * Get the diarizationOptions property: Mode of diarization.
     *
     * @return the diarizationOptions value.
     */
    @Generated
    public TranscriptionDiarizationOptions getDiarizationOptions() {
        return this.diarizationOptions;
    }

    /**
     * Set the diarizationOptions property: Mode of diarization.
     *
     * @param diarizationOptions the diarizationOptions value to set.
     * @return the TranscriptionOptions object itself.
     */
    @Generated
    public TranscriptionOptions setDiarizationOptions(TranscriptionDiarizationOptions diarizationOptions) {
        this.diarizationOptions = diarizationOptions;
        return this;
    }

    /**
     * Get the activeChannels property: The 0-based indices of the channels to be transcribed separately. If not
     * specified, multiple channels are merged and transcribed jointly. Only up to two channels are supported.
     *
     * @return the activeChannels value.
     */
    @Generated
    public List<Integer> getActiveChannels() {
        return this.activeChannels;
    }

    /**
     * Set the activeChannels property: The 0-based indices of the channels to be transcribed separately. If not
     * specified, multiple channels are merged and transcribed jointly. Only up to two channels are supported.
     *
     * @param activeChannels the activeChannels value to set.
     * @return the TranscriptionOptions object itself.
     */
    @Generated
    public TranscriptionOptions setActiveChannels(List<Integer> activeChannels) {
        this.activeChannels = activeChannels;
        return this;
    }

    /*
     * Enhanced mode properties.
     */
    @Generated
    private EnhancedModeOptions enhancedModeOptions;

    /*
     * Phrase list properties.
     */
    @Generated
    private PhraseListOptions phraseListOptions;

    /**
     * Get the enhancedModeOptions property: Enhanced mode properties.
     *
     * @return the enhancedModeOptions value.
     */
    @Generated
    public EnhancedModeOptions getEnhancedModeOptions() {
        return this.enhancedModeOptions;
    }

    /**
     * Set the enhancedModeOptions property: Enhanced mode properties.
     *
     * @param enhancedModeOptions the enhancedModeOptions value to set.
     * @return the TranscriptionOptions object itself.
     */
    @Generated
    public TranscriptionOptions setEnhancedModeOptions(EnhancedModeOptions enhancedModeOptions) {
        this.enhancedModeOptions = enhancedModeOptions;
        return this;
    }

    /**
     * Get the phraseListOptions property: Phrase list properties.
     *
     * @return the phraseListOptions value.
     */
    @Generated
    public PhraseListOptions getPhraseListOptions() {
        return this.phraseListOptions;
    }

    /**
     * Set the phraseListOptions property: Phrase list properties.
     *
     * @param phraseListOptions the phraseListOptions value to set.
     * @return the TranscriptionOptions object itself.
     */
    @Generated
    public TranscriptionOptions setPhraseListOptions(PhraseListOptions phraseListOptions) {
        this.phraseListOptions = phraseListOptions;
        return this;
    }

    /*
     * Maps some or all candidate locales to a model URI to be used for transcription. If no mapping is given, the
     * default model for the locale is used.
     */
    @Generated
    private Map<String, String> localeModelMapping;

    /**
     * Get the localeModelMapping property: Maps some or all candidate locales to a model URI to be used for
     * transcription. If no mapping is given, the default model for the locale is used.
     *
     * @return the localeModelMapping value.
     */
    @Generated
    public Map<String, String> getLocaleModelMapping() {
        return this.localeModelMapping;
    }

    /**
     * Set the localeModelMapping property: Maps some or all candidate locales to a model URI to be used for
     * transcription. If no mapping is given, the default model for the locale is used.
     *
     * @param localeModelMapping the localeModelMapping value to set.
     * @return the TranscriptionOptions object itself.
     */
    @Generated
    public TranscriptionOptions setLocaleModelMapping(Map<String, String> localeModelMapping) {
        this.localeModelMapping = localeModelMapping;
        return this;
    }

    // BEGIN: Manual customization - AudioFileDetails field and constructors
    @SuppressWarnings("unused")
    private AudioFileDetails audioFileDetails;

    /**
     * Creates an instance of TranscriptionOptions class with audio file details.
     *
     * @param fileDetails the audio file details
     */
    public TranscriptionOptions(AudioFileDetails fileDetails) {
        this.audioFileDetails = fileDetails;
    }

    /**
     * Creates an instance of TranscriptionOptions class with audio URL.
     * MANUAL EDIT: This constructor is manually added and preserved via partial-update.
     * TypeSpec emitter filters constructors for schema-defined fields during code generation.
     *
     * @param audioUrl the URL of the audio to be transcribed
     */
    public TranscriptionOptions(String audioUrl) {
        this.audioUrl = audioUrl;
    }

    /**
     * Set the audioUrl property: The URL of the audio to be transcribed. The audio must be shorter than 2 hours in
     * audio duration and smaller than 250 MB in size. If both Audio and AudioUrl are provided, Audio is used.
     *
     * @param audioUrl the audioUrl value to set.
     * @return the TranscriptionOptions object itself.
     */
    @Generated
    private TranscriptionOptions setAudioUrl(String audioUrl) {
        this.audioUrl = audioUrl;
        return this;
    }
}
