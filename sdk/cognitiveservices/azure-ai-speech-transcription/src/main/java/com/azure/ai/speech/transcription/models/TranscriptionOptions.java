// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.ai.speech.transcription.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.annotation.Generated;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;
import java.util.Map;

/**
 * Metadata for a transcription request.
 *
 * <p><strong>Code Samples</strong></p>
 *
 * <!-- src_embed com.azure.ai.speech.transcription.transcriptionoptions.advanced -->
 * <pre>
 * byte[] audioData = Files.readAllBytes&#40;Paths.get&#40;&quot;path&#47;to&#47;audio.wav&quot;&#41;&#41;;
 *
 * AudioFileDetails audioFileDetails = new AudioFileDetails&#40;BinaryData.fromBytes&#40;audioData&#41;&#41;
 *     .setFilename&#40;&quot;audio.wav&quot;&#41;;
 *
 * &#47;&#47; Configure advanced options
 * TranscriptionOptions options = new TranscriptionOptions&#40;&#41;
 *     .setLocales&#40;java.util.Arrays.asList&#40;&quot;en-US&quot;, &quot;es-ES&quot;&#41;&#41;  &#47;&#47; Specify candidate locales
 *     .setProfanityFilterMode&#40;ProfanityFilterMode.MASKED&#41;     &#47;&#47; Mask profanity
 *     .setDiarization&#40;new TranscriptionDiarizationOptions&#40;&#41;   &#47;&#47; Enable speaker diarization
 *         .setEnabled&#40;true&#41;
 *         .setMaxSpeakers&#40;5&#41;&#41;;
 *
 * TranscribeRequestContent requestContent = new TranscribeRequestContent&#40;&#41;
 *     .setAudio&#40;audioFileDetails&#41;
 *     .setOptions&#40;options&#41;;
 *
 * TranscriptionResult result = client.transcribe&#40;requestContent&#41;;
 *
 * &#47;&#47; Access detailed results
 * result.getPhrases&#40;&#41;.forEach&#40;phrase -&gt; &#123;
 *     System.out.println&#40;&quot;Speaker &quot; + phrase.getSpeaker&#40;&#41; + &quot;: &quot; + phrase.getText&#40;&#41;&#41;;
 *     System.out.println&#40;&quot;Confidence: &quot; + phrase.getConfidence&#40;&#41;&#41;;
 *     System.out.println&#40;&quot;Offset: &quot; + phrase.getOffsetMilliseconds&#40;&#41; + &quot;ms&quot;&#41;;
 * &#125;&#41;;
 * </pre>
 * <!-- end com.azure.ai.speech.transcription.transcriptionoptions.advanced -->
 */
@Fluent
public final class TranscriptionOptions implements JsonSerializable<TranscriptionOptions> {
    /*
     * The URL of the audio to be transcribed. The audio must be shorter than 2 hours in audio duration and smaller than
     * 250 MB in size. If both Audio and AudioUrl are provided, Audio is used.
     */
    @Generated
    private String audioUrl;

    /*
     * A list of possible locales for the transcription. If not specified, the locale of the speech in the audio is
     * detected automatically from all supported locales.
     */
    @Generated
    private List<String> locales;

    /*
     * Maps some or all candidate locales to a model URI to be used for transcription. If no mapping is given, the
     * default model for the locale is used.
     */
    @Generated
    private Map<String, String> models;

    /*
     * Mode of profanity filtering.
     */
    @Generated
    private ProfanityFilterMode profanityFilterMode;

    /*
     * Mode of diarization.
     */
    @Generated
    private TranscriptionDiarizationOptions diarization;

    /*
     * The 0-based indices of the channels to be transcribed separately. If not specified, multiple channels are merged
     * and transcribed jointly. Only up to two channels are supported.
     */
    @Generated
    private List<Integer> channels;

    /*
     * Enhanced mode properties.
     */
    @Generated
    private EnhancedModeProperties enhancedMode;

    /*
     * Phrase list properties.
     */
    @Generated
    private PhraseListProperties phraseList;

    /**
     * Creates an instance of TranscriptionOptions class.
     */
    @Generated
    public TranscriptionOptions() {
    }

    /**
     * Get the audioUrl property: The URL of the audio to be transcribed. The audio must be shorter than 2 hours in
     * audio duration and smaller than 250 MB in size. If both Audio and AudioUrl are provided, Audio is used.
     *
     * @return the audioUrl value.
     */
    @Generated
    public String getAudioUrl() {
        return this.audioUrl;
    }

    /**
     * Set the audioUrl property: The URL of the audio to be transcribed. The audio must be shorter than 2 hours in
     * audio duration and smaller than 250 MB in size. If both Audio and AudioUrl are provided, Audio is used.
     *
     * @param audioUrl the audioUrl value to set.
     * @return the TranscriptionOptions object itself.
     */
    @Generated
    public TranscriptionOptions setAudioUrl(String audioUrl) {
        this.audioUrl = audioUrl;
        return this;
    }

    /**
     * Get the locales property: A list of possible locales for the transcription. If not specified, the locale of the
     * speech in the audio is detected automatically from all supported locales.
     *
     * @return the locales value.
     */
    @Generated
    public List<String> getLocales() {
        return this.locales;
    }

    /**
     * Set the locales property: A list of possible locales for the transcription. If not specified, the locale of the
     * speech in the audio is detected automatically from all supported locales.
     *
     * @param locales the locales value to set.
     * @return the TranscriptionOptions object itself.
     */
    @Generated
    public TranscriptionOptions setLocales(List<String> locales) {
        this.locales = locales;
        return this;
    }

    /**
     * Get the models property: Maps some or all candidate locales to a model URI to be used for transcription. If no
     * mapping is given, the default model for the locale is used.
     *
     * @return the models value.
     */
    @Generated
    public Map<String, String> getModels() {
        return this.models;
    }

    /**
     * Set the models property: Maps some or all candidate locales to a model URI to be used for transcription. If no
     * mapping is given, the default model for the locale is used.
     *
     * @param models the models value to set.
     * @return the TranscriptionOptions object itself.
     */
    @Generated
    public TranscriptionOptions setModels(Map<String, String> models) {
        this.models = models;
        return this;
    }

    /**
     * Get the profanityFilterMode property: Mode of profanity filtering.
     *
     * @return the profanityFilterMode value.
     */
    @Generated
    public ProfanityFilterMode getProfanityFilterMode() {
        return this.profanityFilterMode;
    }

    /**
     * Set the profanityFilterMode property: Mode of profanity filtering.
     *
     * @param profanityFilterMode the profanityFilterMode value to set.
     * @return the TranscriptionOptions object itself.
     */
    @Generated
    public TranscriptionOptions setProfanityFilterMode(ProfanityFilterMode profanityFilterMode) {
        this.profanityFilterMode = profanityFilterMode;
        return this;
    }

    /**
     * Get the diarization property: Mode of diarization.
     *
     * @return the diarization value.
     */
    @Generated
    public TranscriptionDiarizationOptions getDiarization() {
        return this.diarization;
    }

    /**
     * Set the diarization property: Mode of diarization.
     *
     * @param diarization the diarization value to set.
     * @return the TranscriptionOptions object itself.
     */
    @Generated
    public TranscriptionOptions setDiarization(TranscriptionDiarizationOptions diarization) {
        this.diarization = diarization;
        return this;
    }

    /**
     * Get the channels property: The 0-based indices of the channels to be transcribed separately. If not specified,
     * multiple channels are merged and transcribed jointly. Only up to two channels are supported.
     *
     * @return the channels value.
     */
    @Generated
    public List<Integer> getChannels() {
        return this.channels;
    }

    /**
     * Set the channels property: The 0-based indices of the channels to be transcribed separately. If not specified,
     * multiple channels are merged and transcribed jointly. Only up to two channels are supported.
     *
     * @param channels the channels value to set.
     * @return the TranscriptionOptions object itself.
     */
    @Generated
    public TranscriptionOptions setChannels(List<Integer> channels) {
        this.channels = channels;
        return this;
    }

    /**
     * Get the enhancedMode property: Enhanced mode properties.
     *
     * @return the enhancedMode value.
     */
    @Generated
    public EnhancedModeProperties getEnhancedMode() {
        return this.enhancedMode;
    }

    /**
     * Set the enhancedMode property: Enhanced mode properties.
     *
     * @param enhancedMode the enhancedMode value to set.
     * @return the TranscriptionOptions object itself.
     */
    @Generated
    public TranscriptionOptions setEnhancedMode(EnhancedModeProperties enhancedMode) {
        this.enhancedMode = enhancedMode;
        return this;
    }

    /**
     * Get the phraseList property: Phrase list properties.
     *
     * @return the phraseList value.
     */
    @Generated
    public PhraseListProperties getPhraseList() {
        return this.phraseList;
    }

    /**
     * Set the phraseList property: Phrase list properties.
     *
     * @param phraseList the phraseList value to set.
     * @return the TranscriptionOptions object itself.
     */
    @Generated
    public TranscriptionOptions setPhraseList(PhraseListProperties phraseList) {
        this.phraseList = phraseList;
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Generated
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("audioUrl", this.audioUrl);
        jsonWriter.writeArrayField("locales", this.locales, (writer, element) -> writer.writeString(element));
        jsonWriter.writeMapField("models", this.models, (writer, element) -> writer.writeString(element));
        jsonWriter.writeStringField("profanityFilterMode",
            this.profanityFilterMode == null ? null : this.profanityFilterMode.toString());
        jsonWriter.writeJsonField("diarization", this.diarization);
        jsonWriter.writeArrayField("channels", this.channels, (writer, element) -> writer.writeInt(element));
        jsonWriter.writeJsonField("enhancedMode", this.enhancedMode);
        jsonWriter.writeJsonField("phraseList", this.phraseList);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of TranscriptionOptions from the JsonReader.
     *
     * @param jsonReader The JsonReader being read.
     * @return An instance of TranscriptionOptions if the JsonReader was pointing to an instance of it, or null if it
     * was pointing to JSON null.
     * @throws IOException If an error occurs while reading the TranscriptionOptions.
     */
    @Generated
    public static TranscriptionOptions fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            TranscriptionOptions deserializedTranscriptionOptions = new TranscriptionOptions();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("audioUrl".equals(fieldName)) {
                    deserializedTranscriptionOptions.audioUrl = reader.getString();
                } else if ("locales".equals(fieldName)) {
                    List<String> locales = reader.readArray(reader1 -> reader1.getString());
                    deserializedTranscriptionOptions.locales = locales;
                } else if ("models".equals(fieldName)) {
                    Map<String, String> models = reader.readMap(reader1 -> reader1.getString());
                    deserializedTranscriptionOptions.models = models;
                } else if ("profanityFilterMode".equals(fieldName)) {
                    deserializedTranscriptionOptions.profanityFilterMode
                        = ProfanityFilterMode.fromString(reader.getString());
                } else if ("diarization".equals(fieldName)) {
                    deserializedTranscriptionOptions.diarization = TranscriptionDiarizationOptions.fromJson(reader);
                } else if ("channels".equals(fieldName)) {
                    List<Integer> channels = reader.readArray(reader1 -> reader1.getInt());
                    deserializedTranscriptionOptions.channels = channels;
                } else if ("enhancedMode".equals(fieldName)) {
                    deserializedTranscriptionOptions.enhancedMode = EnhancedModeProperties.fromJson(reader);
                } else if ("phraseList".equals(fieldName)) {
                    deserializedTranscriptionOptions.phraseList = PhraseListProperties.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedTranscriptionOptions;
        });
    }
}
