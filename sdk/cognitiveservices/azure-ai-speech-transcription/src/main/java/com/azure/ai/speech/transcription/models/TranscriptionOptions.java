// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.
package com.azure.ai.speech.transcription.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.annotation.Generated;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;
import java.util.Map;

/**
 * Metadata for a transcription request.
 */
@Fluent
public final class TranscriptionOptions implements JsonSerializable<TranscriptionOptions> {

    /*
     * The URL of the audio to be transcribed. The audio must be shorter than 2 hours in audio duration and smaller than
     * 250 MB in size. If both Audio and AudioUrl are provided, Audio is used.
     */
    @Generated
    private String audioUrl;

    /*
     * A list of possible locales for the transcription. If not specified, the locale of the speech in the audio is
     * detected automatically from all supported locales.
     */
    @Generated
    private List<String> locales;

    /*
     * Maps some or all candidate locales to a model URI to be used for transcription. If no mapping is given, the
     * default model for the locale is used.
     */
    @Generated
    private Map<String, String> models;

    /*
     * Mode of profanity filtering.
     */
    @Generated
    private ProfanityFilterMode profanityFilterMode;

    /*
     * Enhanced mode properties.
     */
    @Generated
    private EnhancedModeProperties enhancedMode;

    /*
     * Phrase list properties.
     */
    @Generated
    private PhraseListProperties phraseList;

    /**
     * Creates an instance of TranscriptionOptions class.
     */
    @Generated
    public TranscriptionOptions() {
    }

    /**
     * Get the audioUrl property: The URL of the audio to be transcribed. The audio must be shorter than 2 hours in
     * audio duration and smaller than 250 MB in size. If both Audio and AudioUrl are provided, Audio is used.
     *
     * @return the audioUrl value.
     */
    @Generated
    public String getAudioUrl() {
        return this.audioUrl;
    }

    /**
     * Set the audioUrl property: The URL of the audio to be transcribed. The audio must be shorter than 2 hours in
     * audio duration and smaller than 250 MB in size. If both Audio and AudioUrl are provided, Audio is used.
     *
     * @param audioUrl the audioUrl value to set.
     * @return the TranscriptionOptions object itself.
     */
    @Generated
    public TranscriptionOptions setAudioUrl(String audioUrl) {
        this.audioUrl = audioUrl;
        return this;
    }

    /**
     * Get the locales property: A list of possible locales for the transcription. If not specified, the locale of the
     * speech in the audio is detected automatically from all supported locales.
     *
     * @return the locales value.
     */
    @Generated
    public List<String> getLocales() {
        return this.locales;
    }

    /**
     * Set the locales property: A list of possible locales for the transcription. If not specified, the locale of the
     * speech in the audio is detected automatically from all supported locales.
     *
     * @param locales the locales value to set.
     * @return the TranscriptionOptions object itself.
     */
    @Generated
    public TranscriptionOptions setLocales(List<String> locales) {
        this.locales = locales;
        return this;
    }

    /**
     * Get the models property: Maps some or all candidate locales to a model URI to be used for transcription. If no
     * mapping is given, the default model for the locale is used.
     *
     * @return the models value.
     */
    @Generated
    public Map<String, String> getModels() {
        return this.models;
    }

    /**
     * Set the models property: Maps some or all candidate locales to a model URI to be used for transcription. If no
     * mapping is given, the default model for the locale is used.
     *
     * @param models the models value to set.
     * @return the TranscriptionOptions object itself.
     */
    @Generated
    public TranscriptionOptions setModels(Map<String, String> models) {
        this.models = models;
        return this;
    }

    /**
     * Get the profanityFilterMode property: Mode of profanity filtering.
     *
     * @return the profanityFilterMode value.
     */
    @Generated
    public ProfanityFilterMode getProfanityFilterMode() {
        return this.profanityFilterMode;
    }

    /**
     * Set the profanityFilterMode property: Mode of profanity filtering.
     *
     * @param profanityFilterMode the profanityFilterMode value to set.
     * @return the TranscriptionOptions object itself.
     */
    @Generated
    public TranscriptionOptions setProfanityFilterMode(ProfanityFilterMode profanityFilterMode) {
        this.profanityFilterMode = profanityFilterMode;
        return this;
    }

    /**
     * Get the enhancedMode property: Enhanced mode properties.
     *
     * @return the enhancedMode value.
     */
    @Generated
    public EnhancedModeProperties getEnhancedMode() {
        return this.enhancedMode;
    }

    /**
     * Set the enhancedMode property: Enhanced mode properties.
     *
     * @param enhancedMode the enhancedMode value to set.
     * @return the TranscriptionOptions object itself.
     */
    @Generated
    public TranscriptionOptions setEnhancedMode(EnhancedModeProperties enhancedMode) {
        this.enhancedMode = enhancedMode;
        return this;
    }

    /**
     * Get the phraseList property: Phrase list properties.
     *
     * @return the phraseList value.
     */
    @Generated
    public PhraseListProperties getPhraseList() {
        return this.phraseList;
    }

    /**
     * Set the phraseList property: Phrase list properties.
     *
     * @param phraseList the phraseList value to set.
     * @return the TranscriptionOptions object itself.
     */
    @Generated
    public TranscriptionOptions setPhraseList(PhraseListProperties phraseList) {
        this.phraseList = phraseList;
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Generated
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("audioUrl", this.audioUrl);
        jsonWriter.writeArrayField("locales", this.locales, (writer, element) -> writer.writeString(element));
        jsonWriter.writeMapField("models", this.models, (writer, element) -> writer.writeString(element));
        jsonWriter.writeStringField("profanityFilterMode",
            this.profanityFilterMode == null ? null : this.profanityFilterMode.toString());
        jsonWriter.writeJsonField("diarization", this.diarizationOptions);
        jsonWriter.writeArrayField("channels", this.activeChannels, (writer, element) -> writer.writeInt(element));
        jsonWriter.writeJsonField("enhancedMode", this.enhancedMode);
        jsonWriter.writeJsonField("phraseList", this.phraseList);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of TranscriptionOptions from the JsonReader.
     *
     * @param jsonReader The JsonReader being read.
     * @return An instance of TranscriptionOptions if the JsonReader was pointing to an instance of it, or null if it
     * was pointing to JSON null.
     * @throws IOException If an error occurs while reading the TranscriptionOptions.
     */
    @Generated
    public static TranscriptionOptions fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            TranscriptionOptions deserializedTranscriptionOptions = new TranscriptionOptions();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();
                if ("audioUrl".equals(fieldName)) {
                    deserializedTranscriptionOptions.audioUrl = reader.getString();
                } else if ("locales".equals(fieldName)) {
                    List<String> locales = reader.readArray(reader1 -> reader1.getString());
                    deserializedTranscriptionOptions.locales = locales;
                } else if ("models".equals(fieldName)) {
                    Map<String, String> models = reader.readMap(reader1 -> reader1.getString());
                    deserializedTranscriptionOptions.models = models;
                } else if ("profanityFilterMode".equals(fieldName)) {
                    deserializedTranscriptionOptions.profanityFilterMode
                        = ProfanityFilterMode.fromString(reader.getString());
                } else if ("diarization".equals(fieldName)) {
                    deserializedTranscriptionOptions.diarizationOptions
                        = TranscriptionDiarizationOptions.fromJson(reader);
                } else if ("channels".equals(fieldName)) {
                    List<Integer> activeChannels = reader.readArray(reader1 -> reader1.getInt());
                    deserializedTranscriptionOptions.activeChannels = activeChannels;
                } else if ("enhancedMode".equals(fieldName)) {
                    deserializedTranscriptionOptions.enhancedMode = EnhancedModeProperties.fromJson(reader);
                } else if ("phraseList".equals(fieldName)) {
                    deserializedTranscriptionOptions.phraseList = PhraseListProperties.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }
            return deserializedTranscriptionOptions;
        });
    }

    /*
     * Mode of diarization.
     */
    @Generated
    private TranscriptionDiarizationOptions diarizationOptions;

    /*
     * The 0-based indices of the channels to be transcribed separately. If not specified, multiple channels are merged
     * and transcribed jointly. Only up to two channels are supported.
     */
    @Generated
    private List<Integer> activeChannels;

    /**
     * Get the diarizationOptions property: Mode of diarization.
     *
     * @return the diarizationOptions value.
     */
    @Generated
    public TranscriptionDiarizationOptions getDiarizationOptions() {
        return this.diarizationOptions;
    }

    /**
     * Set the diarizationOptions property: Mode of diarization.
     *
     * @param diarizationOptions the diarizationOptions value to set.
     * @return the TranscriptionOptions object itself.
     */
    @Generated
    public TranscriptionOptions setDiarizationOptions(TranscriptionDiarizationOptions diarizationOptions) {
        this.diarizationOptions = diarizationOptions;
        return this;
    }

    /**
     * Get the activeChannels property: The 0-based indices of the channels to be transcribed separately. If not
     * specified, multiple channels are merged and transcribed jointly. Only up to two channels are supported.
     *
     * @return the activeChannels value.
     */
    @Generated
    public List<Integer> getActiveChannels() {
        return this.activeChannels;
    }

    /**
     * Set the activeChannels property: The 0-based indices of the channels to be transcribed separately. If not
     * specified, multiple channels are merged and transcribed jointly. Only up to two channels are supported.
     *
     * @param activeChannels the activeChannels value to set.
     * @return the TranscriptionOptions object itself.
     */
    @Generated
    public TranscriptionOptions setActiveChannels(List<Integer> activeChannels) {
        this.activeChannels = activeChannels;
        return this;
    }
}
