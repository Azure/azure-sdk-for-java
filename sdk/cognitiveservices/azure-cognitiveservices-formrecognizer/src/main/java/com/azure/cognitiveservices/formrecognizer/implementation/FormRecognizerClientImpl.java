// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.cognitiveservices.formrecognizer.implementation;

import com.azure.cognitiveservices.formrecognizer.FormRecognizerServiceVersion;
import com.azure.core.annotation.BodyParam;
import com.azure.core.annotation.Delete;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.Post;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.exception.HttpResponseException;
import com.azure.core.http.HttpPipeline;
import com.azure.core.http.HttpPipelineBuilder;
import com.azure.core.http.policy.CookiePolicy;
import com.azure.core.http.policy.RetryPolicy;
import com.azure.core.http.policy.UserAgentPolicy;
import com.azure.core.http.rest.PagedFlux;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.PagedResponse;
import com.azure.core.http.rest.PagedResponseBase;
import com.azure.core.http.rest.RequestOptions;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.util.BinaryData;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import com.azure.core.util.polling.DefaultPollingStrategy;
import com.azure.core.util.polling.PollerFlux;
import com.azure.core.util.polling.SyncPoller;
import com.azure.core.util.serializer.JacksonAdapter;
import com.azure.core.util.serializer.SerializerAdapter;
import com.azure.core.util.serializer.TypeReference;
import java.time.Duration;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import reactor.core.publisher.Mono;

/** Initializes a new instance of the FormRecognizerClient type. */
public final class FormRecognizerClientImpl {
    /** The proxy service used to perform REST calls. */
    private final FormRecognizerClientService service;

    /**
     * Supported Cognitive Services endpoints (protocol and hostname, for example:
     * https://westus2.api.cognitive.microsoft.com).
     */
    private final String endpoint;

    /**
     * Gets Supported Cognitive Services endpoints (protocol and hostname, for example:
     * https://westus2.api.cognitive.microsoft.com).
     *
     * @return the endpoint value.
     */
    public String getEndpoint() {
        return this.endpoint;
    }

    /** Service version. */
    private final FormRecognizerServiceVersion serviceVersion;

    /**
     * Gets Service version.
     *
     * @return the serviceVersion value.
     */
    public FormRecognizerServiceVersion getServiceVersion() {
        return this.serviceVersion;
    }

    /** The HTTP pipeline to send requests through. */
    private final HttpPipeline httpPipeline;

    /**
     * Gets The HTTP pipeline to send requests through.
     *
     * @return the httpPipeline value.
     */
    public HttpPipeline getHttpPipeline() {
        return this.httpPipeline;
    }

    /** The serializer to serialize an object into a string. */
    private final SerializerAdapter serializerAdapter;

    /**
     * Gets The serializer to serialize an object into a string.
     *
     * @return the serializerAdapter value.
     */
    public SerializerAdapter getSerializerAdapter() {
        return this.serializerAdapter;
    }

    /**
     * Initializes an instance of FormRecognizerClient client.
     *
     * @param endpoint Supported Cognitive Services endpoints (protocol and hostname, for example:
     *     https://westus2.api.cognitive.microsoft.com).
     * @param serviceVersion Service version.
     */
    public FormRecognizerClientImpl(String endpoint, FormRecognizerServiceVersion serviceVersion) {
        this(
                new HttpPipelineBuilder()
                        .policies(new UserAgentPolicy(), new RetryPolicy(), new CookiePolicy())
                        .build(),
                JacksonAdapter.createDefaultSerializerAdapter(),
                endpoint,
                serviceVersion);
    }

    /**
     * Initializes an instance of FormRecognizerClient client.
     *
     * @param httpPipeline The HTTP pipeline to send requests through.
     * @param endpoint Supported Cognitive Services endpoints (protocol and hostname, for example:
     *     https://westus2.api.cognitive.microsoft.com).
     * @param serviceVersion Service version.
     */
    public FormRecognizerClientImpl(
            HttpPipeline httpPipeline, String endpoint, FormRecognizerServiceVersion serviceVersion) {
        this(httpPipeline, JacksonAdapter.createDefaultSerializerAdapter(), endpoint, serviceVersion);
    }

    /**
     * Initializes an instance of FormRecognizerClient client.
     *
     * @param httpPipeline The HTTP pipeline to send requests through.
     * @param serializerAdapter The serializer to serialize an object into a string.
     * @param endpoint Supported Cognitive Services endpoints (protocol and hostname, for example:
     *     https://westus2.api.cognitive.microsoft.com).
     * @param serviceVersion Service version.
     */
    public FormRecognizerClientImpl(
            HttpPipeline httpPipeline,
            SerializerAdapter serializerAdapter,
            String endpoint,
            FormRecognizerServiceVersion serviceVersion) {
        this.httpPipeline = httpPipeline;
        this.serializerAdapter = serializerAdapter;
        this.endpoint = endpoint;
        this.serviceVersion = serviceVersion;
        this.service =
                RestProxy.create(FormRecognizerClientService.class, this.httpPipeline, this.getSerializerAdapter());
    }

    /**
     * The interface defining all the services for FormRecognizerClient to be used by the proxy service to perform REST
     * calls.
     */
    @Host("{endpoint}/formrecognizer")
    @ServiceInterface(name = "FormRecognizerClient")
    private interface FormRecognizerClientService {
        @Post("/documentModels/{modelId}:analyze")
        @ExpectedResponses({202})
        Mono<Response<Void>> analyzeDocument(
                @HostParam("endpoint") String endpoint,
                @PathParam("modelId") String modelId,
                @QueryParam("api-version") String apiVersion,
                RequestOptions requestOptions,
                Context context);

        @Get("/documentModels/{modelId}/analyzeResults/{resultId}")
        @ExpectedResponses({200})
        Mono<Response<BinaryData>> getAnalyzeDocumentResult(
                @HostParam("endpoint") String endpoint,
                @PathParam("modelId") String modelId,
                @PathParam("resultId") String resultId,
                @QueryParam("api-version") String apiVersion,
                RequestOptions requestOptions,
                Context context);

        @Post("/documentModels:build")
        @ExpectedResponses({202})
        Mono<Response<Void>> buildDocumentModel(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @BodyParam("application/json") BinaryData buildRequest,
                RequestOptions requestOptions,
                Context context);

        @Post("/documentModels:compose")
        @ExpectedResponses({202})
        Mono<Response<Void>> composeDocumentModel(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @BodyParam("application/json") BinaryData composeRequest,
                RequestOptions requestOptions,
                Context context);

        @Post("/documentModels:authorizeCopy")
        @ExpectedResponses({200})
        Mono<Response<BinaryData>> authorizeCopyDocumentModel(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @BodyParam("application/json") BinaryData authorizeCopyRequest,
                RequestOptions requestOptions,
                Context context);

        @Post("/documentModels/{modelId}:copyTo")
        @ExpectedResponses({202})
        Mono<Response<Void>> copyDocumentModelTo(
                @HostParam("endpoint") String endpoint,
                @PathParam("modelId") String modelId,
                @QueryParam("api-version") String apiVersion,
                @BodyParam("application/json") BinaryData copyToRequest,
                RequestOptions requestOptions,
                Context context);

        @Get("/operations")
        @ExpectedResponses({200})
        Mono<Response<BinaryData>> getOperations(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                RequestOptions requestOptions,
                Context context);

        @Get("/operations/{operationId}")
        @ExpectedResponses({200})
        Mono<Response<BinaryData>> getOperation(
                @HostParam("endpoint") String endpoint,
                @PathParam("operationId") String operationId,
                @QueryParam("api-version") String apiVersion,
                RequestOptions requestOptions,
                Context context);

        @Get("/documentModels")
        @ExpectedResponses({200})
        Mono<Response<BinaryData>> getModels(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                RequestOptions requestOptions,
                Context context);

        @Get("/documentModels/{modelId}")
        @ExpectedResponses({200})
        Mono<Response<BinaryData>> getModel(
                @HostParam("endpoint") String endpoint,
                @PathParam("modelId") String modelId,
                @QueryParam("api-version") String apiVersion,
                RequestOptions requestOptions,
                Context context);

        @Delete("/documentModels/{modelId}")
        @ExpectedResponses({204})
        Mono<Response<Void>> deleteModel(
                @HostParam("endpoint") String endpoint,
                @PathParam("modelId") String modelId,
                @QueryParam("api-version") String apiVersion,
                RequestOptions requestOptions,
                Context context);

        @Get("/info")
        @ExpectedResponses({200})
        Mono<Response<BinaryData>> getInfo(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                RequestOptions requestOptions,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        Mono<Response<BinaryData>> getOperationsNext(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                RequestOptions requestOptions,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        Mono<Response<BinaryData>> getModelsNext(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                RequestOptions requestOptions,
                Context context);
    }

    /**
     * Analyzes document with model.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>pages</td><td>String</td><td>No</td><td>List of 1-based page numbers to analyze.  Ex. "1-3,5,7-9"</td></tr>
     *     <tr><td>locale</td><td>String</td><td>No</td><td>Locale hint for text recognition and document analysis.  Value may contain only the language code (ex. "en", "fr") or BCP 47 language tag (ex. "en-US").</td></tr>
     *     <tr><td>stringIndexType</td><td>String</td><td>No</td><td>Method used to compute string offset and length.</td></tr>
     *     <tr><td>api-version</td><td>String</td><td>Yes</td><td>Api Version</td></tr>
     * </table>
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>Content-Type</td><td>String</td><td>Yes</td><td>Upload file type</td></tr>
     *     <tr><td>Content-Length</td><td>String</td><td>No</td><td>The contentLength parameter</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * Flux<ByteBuffer>
     * }</pre>
     *
     * @param modelId Unique model name.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> analyzeDocumentWithResponseAsync(String modelId, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                context ->
                        service.analyzeDocument(
                                this.getEndpoint(),
                                modelId,
                                this.getServiceVersion().getVersion(),
                                requestOptions,
                                context));
    }

    /**
     * Analyzes document with model.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>pages</td><td>String</td><td>No</td><td>List of 1-based page numbers to analyze.  Ex. "1-3,5,7-9"</td></tr>
     *     <tr><td>locale</td><td>String</td><td>No</td><td>Locale hint for text recognition and document analysis.  Value may contain only the language code (ex. "en", "fr") or BCP 47 language tag (ex. "en-US").</td></tr>
     *     <tr><td>stringIndexType</td><td>String</td><td>No</td><td>Method used to compute string offset and length.</td></tr>
     *     <tr><td>api-version</td><td>String</td><td>Yes</td><td>Api Version</td></tr>
     * </table>
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>Content-Type</td><td>String</td><td>Yes</td><td>Upload file type</td></tr>
     *     <tr><td>Content-Length</td><td>String</td><td>No</td><td>The contentLength parameter</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * Flux<ByteBuffer>
     * }</pre>
     *
     * @param modelId Unique model name.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> analyzeDocumentWithResponseAsync(
            String modelId, RequestOptions requestOptions, Context context) {
        return service.analyzeDocument(
                this.getEndpoint(), modelId, this.getServiceVersion().getVersion(), requestOptions, context);
    }

    /**
     * Analyzes document with model.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>pages</td><td>String</td><td>No</td><td>List of 1-based page numbers to analyze.  Ex. "1-3,5,7-9"</td></tr>
     *     <tr><td>locale</td><td>String</td><td>No</td><td>Locale hint for text recognition and document analysis.  Value may contain only the language code (ex. "en", "fr") or BCP 47 language tag (ex. "en-US").</td></tr>
     *     <tr><td>stringIndexType</td><td>String</td><td>No</td><td>Method used to compute string offset and length.</td></tr>
     *     <tr><td>api-version</td><td>String</td><td>Yes</td><td>Api Version</td></tr>
     * </table>
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>Content-Type</td><td>String</td><td>Yes</td><td>Upload file type</td></tr>
     *     <tr><td>Content-Length</td><td>String</td><td>No</td><td>The contentLength parameter</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * Flux<ByteBuffer>
     * }</pre>
     *
     * @param modelId Unique model name.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginAnalyzeDocumentAsync(String modelId, RequestOptions requestOptions) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () -> this.analyzeDocumentWithResponseAsync(modelId, requestOptions),
                new DefaultPollingStrategy<>(this.getHttpPipeline()),
                new TypeReferenceBinaryData(),
                new TypeReferenceBinaryData());
    }

    /**
     * Analyzes document with model.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>pages</td><td>String</td><td>No</td><td>List of 1-based page numbers to analyze.  Ex. "1-3,5,7-9"</td></tr>
     *     <tr><td>locale</td><td>String</td><td>No</td><td>Locale hint for text recognition and document analysis.  Value may contain only the language code (ex. "en", "fr") or BCP 47 language tag (ex. "en-US").</td></tr>
     *     <tr><td>stringIndexType</td><td>String</td><td>No</td><td>Method used to compute string offset and length.</td></tr>
     *     <tr><td>api-version</td><td>String</td><td>Yes</td><td>Api Version</td></tr>
     * </table>
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>Content-Type</td><td>String</td><td>Yes</td><td>Upload file type</td></tr>
     *     <tr><td>Content-Length</td><td>String</td><td>No</td><td>The contentLength parameter</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * Flux<ByteBuffer>
     * }</pre>
     *
     * @param modelId Unique model name.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginAnalyzeDocumentAsync(
            String modelId, RequestOptions requestOptions, Context context) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () -> this.analyzeDocumentWithResponseAsync(modelId, requestOptions, context),
                new DefaultPollingStrategy<>(this.getHttpPipeline()),
                new TypeReferenceBinaryData(),
                new TypeReferenceBinaryData());
    }

    /**
     * Analyzes document with model.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>pages</td><td>String</td><td>No</td><td>List of 1-based page numbers to analyze.  Ex. "1-3,5,7-9"</td></tr>
     *     <tr><td>locale</td><td>String</td><td>No</td><td>Locale hint for text recognition and document analysis.  Value may contain only the language code (ex. "en", "fr") or BCP 47 language tag (ex. "en-US").</td></tr>
     *     <tr><td>stringIndexType</td><td>String</td><td>No</td><td>Method used to compute string offset and length.</td></tr>
     *     <tr><td>api-version</td><td>String</td><td>Yes</td><td>Api Version</td></tr>
     * </table>
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>Content-Type</td><td>String</td><td>Yes</td><td>Upload file type</td></tr>
     *     <tr><td>Content-Length</td><td>String</td><td>No</td><td>The contentLength parameter</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * Flux<ByteBuffer>
     * }</pre>
     *
     * @param modelId Unique model name.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginAnalyzeDocument(String modelId, RequestOptions requestOptions) {
        return this.beginAnalyzeDocumentAsync(modelId, requestOptions).getSyncPoller();
    }

    /**
     * Gets the result of document analysis.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>api-version</td><td>String</td><td>Yes</td><td>Api Version</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     status: String(notStarted/running/failed/succeeded)
     *     createdDateTime: String
     *     lastUpdatedDateTime: String
     *     error: {
     *         code: String
     *         message: String
     *         target: String
     *         details: [
     *             (recursive schema, see above)
     *         ]
     *         innererror: {
     *             code: String
     *             message: String
     *             innererror: (recursive schema, see innererror above)
     *         }
     *     }
     *     analyzeResult: {
     *         apiVersion: String(2022-01-30-preview)
     *         modelId: String
     *         stringIndexType: String(textElements/unicodeCodePoint/utf16CodeUnit)
     *         content: String
     *         pages: [
     *             {
     *                 pageNumber: int
     *                 angle: float
     *                 width: float
     *                 height: float
     *                 unit: String(pixel/inch)
     *                 spans: [
     *                     {
     *                         offset: int
     *                         length: int
     *                     }
     *                 ]
     *                 words: [
     *                     {
     *                         content: String
     *                         boundingBox: [
     *                             float
     *                         ]
     *                         span: (recursive schema, see span above)
     *                         confidence: float
     *                     }
     *                 ]
     *                 selectionMarks: [
     *                     {
     *                         state: String(selected/unselected)
     *                         boundingBox: [
     *                             float
     *                         ]
     *                         span: (recursive schema, see span above)
     *                         confidence: float
     *                     }
     *                 ]
     *                 lines: [
     *                     {
     *                         content: String
     *                         boundingBox: [
     *                             float
     *                         ]
     *                         spans: [
     *                             (recursive schema, see above)
     *                         ]
     *                     }
     *                 ]
     *             }
     *         ]
     *         tables: [
     *             {
     *                 rowCount: int
     *                 columnCount: int
     *                 cells: [
     *                     {
     *                         kind: String(content/rowHeader/columnHeader/stubHead/description)
     *                         rowIndex: int
     *                         columnIndex: int
     *                         rowSpan: Integer
     *                         columnSpan: Integer
     *                         content: String
     *                         boundingRegions: [
     *                             {
     *                                 pageNumber: int
     *                                 boundingBox: [
     *                                     float
     *                                 ]
     *                             }
     *                         ]
     *                         spans: [
     *                             (recursive schema, see above)
     *                         ]
     *                     }
     *                 ]
     *                 boundingRegions: [
     *                     (recursive schema, see above)
     *                 ]
     *                 spans: [
     *                     (recursive schema, see above)
     *                 ]
     *             }
     *         ]
     *         keyValuePairs: [
     *             {
     *                 key: {
     *                     content: String
     *                     boundingRegions: [
     *                         (recursive schema, see above)
     *                     ]
     *                     spans: [
     *                         (recursive schema, see above)
     *                     ]
     *                 }
     *                 value: (recursive schema, see value above)
     *                 confidence: float
     *             }
     *         ]
     *         entities: [
     *             {
     *                 category: String
     *                 subCategory: String
     *                 content: String
     *                 boundingRegions: [
     *                     (recursive schema, see above)
     *                 ]
     *                 spans: [
     *                     (recursive schema, see above)
     *                 ]
     *                 confidence: float
     *             }
     *         ]
     *         styles: [
     *             {
     *                 isHandwritten: Boolean
     *                 spans: [
     *                     (recursive schema, see above)
     *                 ]
     *                 confidence: float
     *             }
     *         ]
     *         languages: [
     *             {
     *                 languageCode: String
     *                 spans: [
     *                     (recursive schema, see above)
     *                 ]
     *                 confidence: float
     *             }
     *         ]
     *         documents: [
     *             {
     *                 docType: String
     *                 boundingRegions: [
     *                     (recursive schema, see above)
     *                 ]
     *                 spans: [
     *                     (recursive schema, see above)
     *                 ]
     *                 fields: {
     *                     String: {
     *                         type: String(string/date/time/phoneNumber/number/integer/selectionMark/countryRegion/signature/array/object/currency)
     *                         valueString: String
     *                         valueDate: String
     *                         valueTime: String
     *                         valuePhoneNumber: String
     *                         valueNumber: Float
     *                         valueInteger: Long
     *                         valueSelectionMark: String(selected/unselected)
     *                         valueSignature: String(signed/unsigned)
     *                         valueCountryRegion: String
     *                         valueArray: [
     *                             (recursive schema, see above)
     *                         ]
     *                         valueObject: {
     *                             String: (recursive schema, see String above)
     *                         }
     *                         valueCurrency: {
     *                             amount: double
     *                             currencySymbol: String
     *                         }
     *                         content: String
     *                         boundingRegions: [
     *                             (recursive schema, see above)
     *                         ]
     *                         spans: [
     *                             (recursive schema, see above)
     *                         ]
     *                         confidence: Float
     *                     }
     *                 }
     *                 confidence: float
     *             }
     *         ]
     *     }
     * }
     * }</pre>
     *
     * @param modelId Unique model name.
     * @param resultId Analyze operation result ID.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return the result of document analysis along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getAnalyzeDocumentResultWithResponseAsync(
            String modelId, String resultId, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                context ->
                        service.getAnalyzeDocumentResult(
                                this.getEndpoint(),
                                modelId,
                                resultId,
                                this.getServiceVersion().getVersion(),
                                requestOptions,
                                context));
    }

    /**
     * Gets the result of document analysis.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>api-version</td><td>String</td><td>Yes</td><td>Api Version</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     status: String(notStarted/running/failed/succeeded)
     *     createdDateTime: String
     *     lastUpdatedDateTime: String
     *     error: {
     *         code: String
     *         message: String
     *         target: String
     *         details: [
     *             (recursive schema, see above)
     *         ]
     *         innererror: {
     *             code: String
     *             message: String
     *             innererror: (recursive schema, see innererror above)
     *         }
     *     }
     *     analyzeResult: {
     *         apiVersion: String(2022-01-30-preview)
     *         modelId: String
     *         stringIndexType: String(textElements/unicodeCodePoint/utf16CodeUnit)
     *         content: String
     *         pages: [
     *             {
     *                 pageNumber: int
     *                 angle: float
     *                 width: float
     *                 height: float
     *                 unit: String(pixel/inch)
     *                 spans: [
     *                     {
     *                         offset: int
     *                         length: int
     *                     }
     *                 ]
     *                 words: [
     *                     {
     *                         content: String
     *                         boundingBox: [
     *                             float
     *                         ]
     *                         span: (recursive schema, see span above)
     *                         confidence: float
     *                     }
     *                 ]
     *                 selectionMarks: [
     *                     {
     *                         state: String(selected/unselected)
     *                         boundingBox: [
     *                             float
     *                         ]
     *                         span: (recursive schema, see span above)
     *                         confidence: float
     *                     }
     *                 ]
     *                 lines: [
     *                     {
     *                         content: String
     *                         boundingBox: [
     *                             float
     *                         ]
     *                         spans: [
     *                             (recursive schema, see above)
     *                         ]
     *                     }
     *                 ]
     *             }
     *         ]
     *         tables: [
     *             {
     *                 rowCount: int
     *                 columnCount: int
     *                 cells: [
     *                     {
     *                         kind: String(content/rowHeader/columnHeader/stubHead/description)
     *                         rowIndex: int
     *                         columnIndex: int
     *                         rowSpan: Integer
     *                         columnSpan: Integer
     *                         content: String
     *                         boundingRegions: [
     *                             {
     *                                 pageNumber: int
     *                                 boundingBox: [
     *                                     float
     *                                 ]
     *                             }
     *                         ]
     *                         spans: [
     *                             (recursive schema, see above)
     *                         ]
     *                     }
     *                 ]
     *                 boundingRegions: [
     *                     (recursive schema, see above)
     *                 ]
     *                 spans: [
     *                     (recursive schema, see above)
     *                 ]
     *             }
     *         ]
     *         keyValuePairs: [
     *             {
     *                 key: {
     *                     content: String
     *                     boundingRegions: [
     *                         (recursive schema, see above)
     *                     ]
     *                     spans: [
     *                         (recursive schema, see above)
     *                     ]
     *                 }
     *                 value: (recursive schema, see value above)
     *                 confidence: float
     *             }
     *         ]
     *         entities: [
     *             {
     *                 category: String
     *                 subCategory: String
     *                 content: String
     *                 boundingRegions: [
     *                     (recursive schema, see above)
     *                 ]
     *                 spans: [
     *                     (recursive schema, see above)
     *                 ]
     *                 confidence: float
     *             }
     *         ]
     *         styles: [
     *             {
     *                 isHandwritten: Boolean
     *                 spans: [
     *                     (recursive schema, see above)
     *                 ]
     *                 confidence: float
     *             }
     *         ]
     *         languages: [
     *             {
     *                 languageCode: String
     *                 spans: [
     *                     (recursive schema, see above)
     *                 ]
     *                 confidence: float
     *             }
     *         ]
     *         documents: [
     *             {
     *                 docType: String
     *                 boundingRegions: [
     *                     (recursive schema, see above)
     *                 ]
     *                 spans: [
     *                     (recursive schema, see above)
     *                 ]
     *                 fields: {
     *                     String: {
     *                         type: String(string/date/time/phoneNumber/number/integer/selectionMark/countryRegion/signature/array/object/currency)
     *                         valueString: String
     *                         valueDate: String
     *                         valueTime: String
     *                         valuePhoneNumber: String
     *                         valueNumber: Float
     *                         valueInteger: Long
     *                         valueSelectionMark: String(selected/unselected)
     *                         valueSignature: String(signed/unsigned)
     *                         valueCountryRegion: String
     *                         valueArray: [
     *                             (recursive schema, see above)
     *                         ]
     *                         valueObject: {
     *                             String: (recursive schema, see String above)
     *                         }
     *                         valueCurrency: {
     *                             amount: double
     *                             currencySymbol: String
     *                         }
     *                         content: String
     *                         boundingRegions: [
     *                             (recursive schema, see above)
     *                         ]
     *                         spans: [
     *                             (recursive schema, see above)
     *                         ]
     *                         confidence: Float
     *                     }
     *                 }
     *                 confidence: float
     *             }
     *         ]
     *     }
     * }
     * }</pre>
     *
     * @param modelId Unique model name.
     * @param resultId Analyze operation result ID.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return the result of document analysis along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getAnalyzeDocumentResultWithResponseAsync(
            String modelId, String resultId, RequestOptions requestOptions, Context context) {
        return service.getAnalyzeDocumentResult(
                this.getEndpoint(), modelId, resultId, this.getServiceVersion().getVersion(), requestOptions, context);
    }

    /**
     * Gets the result of document analysis.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>api-version</td><td>String</td><td>Yes</td><td>Api Version</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     status: String(notStarted/running/failed/succeeded)
     *     createdDateTime: String
     *     lastUpdatedDateTime: String
     *     error: {
     *         code: String
     *         message: String
     *         target: String
     *         details: [
     *             (recursive schema, see above)
     *         ]
     *         innererror: {
     *             code: String
     *             message: String
     *             innererror: (recursive schema, see innererror above)
     *         }
     *     }
     *     analyzeResult: {
     *         apiVersion: String(2022-01-30-preview)
     *         modelId: String
     *         stringIndexType: String(textElements/unicodeCodePoint/utf16CodeUnit)
     *         content: String
     *         pages: [
     *             {
     *                 pageNumber: int
     *                 angle: float
     *                 width: float
     *                 height: float
     *                 unit: String(pixel/inch)
     *                 spans: [
     *                     {
     *                         offset: int
     *                         length: int
     *                     }
     *                 ]
     *                 words: [
     *                     {
     *                         content: String
     *                         boundingBox: [
     *                             float
     *                         ]
     *                         span: (recursive schema, see span above)
     *                         confidence: float
     *                     }
     *                 ]
     *                 selectionMarks: [
     *                     {
     *                         state: String(selected/unselected)
     *                         boundingBox: [
     *                             float
     *                         ]
     *                         span: (recursive schema, see span above)
     *                         confidence: float
     *                     }
     *                 ]
     *                 lines: [
     *                     {
     *                         content: String
     *                         boundingBox: [
     *                             float
     *                         ]
     *                         spans: [
     *                             (recursive schema, see above)
     *                         ]
     *                     }
     *                 ]
     *             }
     *         ]
     *         tables: [
     *             {
     *                 rowCount: int
     *                 columnCount: int
     *                 cells: [
     *                     {
     *                         kind: String(content/rowHeader/columnHeader/stubHead/description)
     *                         rowIndex: int
     *                         columnIndex: int
     *                         rowSpan: Integer
     *                         columnSpan: Integer
     *                         content: String
     *                         boundingRegions: [
     *                             {
     *                                 pageNumber: int
     *                                 boundingBox: [
     *                                     float
     *                                 ]
     *                             }
     *                         ]
     *                         spans: [
     *                             (recursive schema, see above)
     *                         ]
     *                     }
     *                 ]
     *                 boundingRegions: [
     *                     (recursive schema, see above)
     *                 ]
     *                 spans: [
     *                     (recursive schema, see above)
     *                 ]
     *             }
     *         ]
     *         keyValuePairs: [
     *             {
     *                 key: {
     *                     content: String
     *                     boundingRegions: [
     *                         (recursive schema, see above)
     *                     ]
     *                     spans: [
     *                         (recursive schema, see above)
     *                     ]
     *                 }
     *                 value: (recursive schema, see value above)
     *                 confidence: float
     *             }
     *         ]
     *         entities: [
     *             {
     *                 category: String
     *                 subCategory: String
     *                 content: String
     *                 boundingRegions: [
     *                     (recursive schema, see above)
     *                 ]
     *                 spans: [
     *                     (recursive schema, see above)
     *                 ]
     *                 confidence: float
     *             }
     *         ]
     *         styles: [
     *             {
     *                 isHandwritten: Boolean
     *                 spans: [
     *                     (recursive schema, see above)
     *                 ]
     *                 confidence: float
     *             }
     *         ]
     *         languages: [
     *             {
     *                 languageCode: String
     *                 spans: [
     *                     (recursive schema, see above)
     *                 ]
     *                 confidence: float
     *             }
     *         ]
     *         documents: [
     *             {
     *                 docType: String
     *                 boundingRegions: [
     *                     (recursive schema, see above)
     *                 ]
     *                 spans: [
     *                     (recursive schema, see above)
     *                 ]
     *                 fields: {
     *                     String: {
     *                         type: String(string/date/time/phoneNumber/number/integer/selectionMark/countryRegion/signature/array/object/currency)
     *                         valueString: String
     *                         valueDate: String
     *                         valueTime: String
     *                         valuePhoneNumber: String
     *                         valueNumber: Float
     *                         valueInteger: Long
     *                         valueSelectionMark: String(selected/unselected)
     *                         valueSignature: String(signed/unsigned)
     *                         valueCountryRegion: String
     *                         valueArray: [
     *                             (recursive schema, see above)
     *                         ]
     *                         valueObject: {
     *                             String: (recursive schema, see String above)
     *                         }
     *                         valueCurrency: {
     *                             amount: double
     *                             currencySymbol: String
     *                         }
     *                         content: String
     *                         boundingRegions: [
     *                             (recursive schema, see above)
     *                         ]
     *                         spans: [
     *                             (recursive schema, see above)
     *                         ]
     *                         confidence: Float
     *                     }
     *                 }
     *                 confidence: float
     *             }
     *         ]
     *     }
     * }
     * }</pre>
     *
     * @param modelId Unique model name.
     * @param resultId Analyze operation result ID.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return the result of document analysis along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getAnalyzeDocumentResultWithResponse(
            String modelId, String resultId, RequestOptions requestOptions) {
        return getAnalyzeDocumentResultWithResponseAsync(modelId, resultId, requestOptions).block();
    }

    /**
     * Builds a custom document analysis model.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>api-version</td><td>String</td><td>Yes</td><td>Api Version</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     modelId: String
     *     description: String
     *     buildMode: String(template/neural)
     *     azureBlobSource: {
     *         containerUrl: String
     *         prefix: String
     *     }
     *     tags: {
     *         String: String
     *     }
     * }
     * }</pre>
     *
     * @param buildRequest Building request parameters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> buildDocumentModelWithResponseAsync(
            BinaryData buildRequest, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                context ->
                        service.buildDocumentModel(
                                this.getEndpoint(),
                                this.getServiceVersion().getVersion(),
                                buildRequest,
                                requestOptions,
                                context));
    }

    /**
     * Builds a custom document analysis model.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>api-version</td><td>String</td><td>Yes</td><td>Api Version</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     modelId: String
     *     description: String
     *     buildMode: String(template/neural)
     *     azureBlobSource: {
     *         containerUrl: String
     *         prefix: String
     *     }
     *     tags: {
     *         String: String
     *     }
     * }
     * }</pre>
     *
     * @param buildRequest Building request parameters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> buildDocumentModelWithResponseAsync(
            BinaryData buildRequest, RequestOptions requestOptions, Context context) {
        return service.buildDocumentModel(
                this.getEndpoint(), this.getServiceVersion().getVersion(), buildRequest, requestOptions, context);
    }

    /**
     * Builds a custom document analysis model.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>api-version</td><td>String</td><td>Yes</td><td>Api Version</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     modelId: String
     *     description: String
     *     buildMode: String(template/neural)
     *     azureBlobSource: {
     *         containerUrl: String
     *         prefix: String
     *     }
     *     tags: {
     *         String: String
     *     }
     * }
     * }</pre>
     *
     * @param buildRequest Building request parameters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginBuildDocumentModelAsync(
            BinaryData buildRequest, RequestOptions requestOptions) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () -> this.buildDocumentModelWithResponseAsync(buildRequest, requestOptions),
                new DefaultPollingStrategy<>(this.getHttpPipeline()),
                new TypeReferenceBinaryData(),
                new TypeReferenceBinaryData());
    }

    /**
     * Builds a custom document analysis model.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>api-version</td><td>String</td><td>Yes</td><td>Api Version</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     modelId: String
     *     description: String
     *     buildMode: String(template/neural)
     *     azureBlobSource: {
     *         containerUrl: String
     *         prefix: String
     *     }
     *     tags: {
     *         String: String
     *     }
     * }
     * }</pre>
     *
     * @param buildRequest Building request parameters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginBuildDocumentModelAsync(
            BinaryData buildRequest, RequestOptions requestOptions, Context context) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () -> this.buildDocumentModelWithResponseAsync(buildRequest, requestOptions, context),
                new DefaultPollingStrategy<>(this.getHttpPipeline()),
                new TypeReferenceBinaryData(),
                new TypeReferenceBinaryData());
    }

    /**
     * Builds a custom document analysis model.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>api-version</td><td>String</td><td>Yes</td><td>Api Version</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     modelId: String
     *     description: String
     *     buildMode: String(template/neural)
     *     azureBlobSource: {
     *         containerUrl: String
     *         prefix: String
     *     }
     *     tags: {
     *         String: String
     *     }
     * }
     * }</pre>
     *
     * @param buildRequest Building request parameters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginBuildDocumentModel(
            BinaryData buildRequest, RequestOptions requestOptions) {
        return this.beginBuildDocumentModelAsync(buildRequest, requestOptions).getSyncPoller();
    }

    /**
     * Creates a new model from document types of existing models.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>api-version</td><td>String</td><td>Yes</td><td>Api Version</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     modelId: String
     *     description: String
     *     componentModels: [
     *         {
     *             modelId: String
     *         }
     *     ]
     *     tags: {
     *         String: String
     *     }
     * }
     * }</pre>
     *
     * @param composeRequest Compose request parameters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> composeDocumentModelWithResponseAsync(
            BinaryData composeRequest, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                context ->
                        service.composeDocumentModel(
                                this.getEndpoint(),
                                this.getServiceVersion().getVersion(),
                                composeRequest,
                                requestOptions,
                                context));
    }

    /**
     * Creates a new model from document types of existing models.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>api-version</td><td>String</td><td>Yes</td><td>Api Version</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     modelId: String
     *     description: String
     *     componentModels: [
     *         {
     *             modelId: String
     *         }
     *     ]
     *     tags: {
     *         String: String
     *     }
     * }
     * }</pre>
     *
     * @param composeRequest Compose request parameters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> composeDocumentModelWithResponseAsync(
            BinaryData composeRequest, RequestOptions requestOptions, Context context) {
        return service.composeDocumentModel(
                this.getEndpoint(), this.getServiceVersion().getVersion(), composeRequest, requestOptions, context);
    }

    /**
     * Creates a new model from document types of existing models.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>api-version</td><td>String</td><td>Yes</td><td>Api Version</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     modelId: String
     *     description: String
     *     componentModels: [
     *         {
     *             modelId: String
     *         }
     *     ]
     *     tags: {
     *         String: String
     *     }
     * }
     * }</pre>
     *
     * @param composeRequest Compose request parameters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginComposeDocumentModelAsync(
            BinaryData composeRequest, RequestOptions requestOptions) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () -> this.composeDocumentModelWithResponseAsync(composeRequest, requestOptions),
                new DefaultPollingStrategy<>(this.getHttpPipeline()),
                new TypeReferenceBinaryData(),
                new TypeReferenceBinaryData());
    }

    /**
     * Creates a new model from document types of existing models.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>api-version</td><td>String</td><td>Yes</td><td>Api Version</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     modelId: String
     *     description: String
     *     componentModels: [
     *         {
     *             modelId: String
     *         }
     *     ]
     *     tags: {
     *         String: String
     *     }
     * }
     * }</pre>
     *
     * @param composeRequest Compose request parameters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginComposeDocumentModelAsync(
            BinaryData composeRequest, RequestOptions requestOptions, Context context) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () -> this.composeDocumentModelWithResponseAsync(composeRequest, requestOptions, context),
                new DefaultPollingStrategy<>(this.getHttpPipeline()),
                new TypeReferenceBinaryData(),
                new TypeReferenceBinaryData());
    }

    /**
     * Creates a new model from document types of existing models.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>api-version</td><td>String</td><td>Yes</td><td>Api Version</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     modelId: String
     *     description: String
     *     componentModels: [
     *         {
     *             modelId: String
     *         }
     *     ]
     *     tags: {
     *         String: String
     *     }
     * }
     * }</pre>
     *
     * @param composeRequest Compose request parameters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginComposeDocumentModel(
            BinaryData composeRequest, RequestOptions requestOptions) {
        return this.beginComposeDocumentModelAsync(composeRequest, requestOptions).getSyncPoller();
    }

    /**
     * Generates authorization to copy a model to this location with specified modelId and optional description.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>api-version</td><td>String</td><td>Yes</td><td>Api Version</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     modelId: String
     *     description: String
     *     tags: {
     *         String: String
     *     }
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     targetResourceId: String
     *     targetResourceRegion: String
     *     targetModelId: String
     *     targetModelLocation: String
     *     accessToken: String
     *     expirationDateTime: String
     * }
     * }</pre>
     *
     * @param authorizeCopyRequest Authorize copy request parameters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return authorization to copy a model to the specified target resource and modelId along with {@link Response} on
     *     successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> authorizeCopyDocumentModelWithResponseAsync(
            BinaryData authorizeCopyRequest, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                context ->
                        service.authorizeCopyDocumentModel(
                                this.getEndpoint(),
                                this.getServiceVersion().getVersion(),
                                authorizeCopyRequest,
                                requestOptions,
                                context));
    }

    /**
     * Generates authorization to copy a model to this location with specified modelId and optional description.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>api-version</td><td>String</td><td>Yes</td><td>Api Version</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     modelId: String
     *     description: String
     *     tags: {
     *         String: String
     *     }
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     targetResourceId: String
     *     targetResourceRegion: String
     *     targetModelId: String
     *     targetModelLocation: String
     *     accessToken: String
     *     expirationDateTime: String
     * }
     * }</pre>
     *
     * @param authorizeCopyRequest Authorize copy request parameters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return authorization to copy a model to the specified target resource and modelId along with {@link Response} on
     *     successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> authorizeCopyDocumentModelWithResponseAsync(
            BinaryData authorizeCopyRequest, RequestOptions requestOptions, Context context) {
        return service.authorizeCopyDocumentModel(
                this.getEndpoint(),
                this.getServiceVersion().getVersion(),
                authorizeCopyRequest,
                requestOptions,
                context);
    }

    /**
     * Generates authorization to copy a model to this location with specified modelId and optional description.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>api-version</td><td>String</td><td>Yes</td><td>Api Version</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     modelId: String
     *     description: String
     *     tags: {
     *         String: String
     *     }
     * }
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     targetResourceId: String
     *     targetResourceRegion: String
     *     targetModelId: String
     *     targetModelLocation: String
     *     accessToken: String
     *     expirationDateTime: String
     * }
     * }</pre>
     *
     * @param authorizeCopyRequest Authorize copy request parameters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return authorization to copy a model to the specified target resource and modelId along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> authorizeCopyDocumentModelWithResponse(
            BinaryData authorizeCopyRequest, RequestOptions requestOptions) {
        return authorizeCopyDocumentModelWithResponseAsync(authorizeCopyRequest, requestOptions).block();
    }

    /**
     * Copies model to the target resource, region, and modelId.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>api-version</td><td>String</td><td>Yes</td><td>Api Version</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     targetResourceId: String
     *     targetResourceRegion: String
     *     targetModelId: String
     *     targetModelLocation: String
     *     accessToken: String
     *     expirationDateTime: String
     * }
     * }</pre>
     *
     * @param modelId Unique model name.
     * @param copyToRequest Copy to request parameters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> copyDocumentModelToWithResponseAsync(
            String modelId, BinaryData copyToRequest, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                context ->
                        service.copyDocumentModelTo(
                                this.getEndpoint(),
                                modelId,
                                this.getServiceVersion().getVersion(),
                                copyToRequest,
                                requestOptions,
                                context));
    }

    /**
     * Copies model to the target resource, region, and modelId.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>api-version</td><td>String</td><td>Yes</td><td>Api Version</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     targetResourceId: String
     *     targetResourceRegion: String
     *     targetModelId: String
     *     targetModelLocation: String
     *     accessToken: String
     *     expirationDateTime: String
     * }
     * }</pre>
     *
     * @param modelId Unique model name.
     * @param copyToRequest Copy to request parameters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> copyDocumentModelToWithResponseAsync(
            String modelId, BinaryData copyToRequest, RequestOptions requestOptions, Context context) {
        return service.copyDocumentModelTo(
                this.getEndpoint(),
                modelId,
                this.getServiceVersion().getVersion(),
                copyToRequest,
                requestOptions,
                context);
    }

    /**
     * Copies model to the target resource, region, and modelId.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>api-version</td><td>String</td><td>Yes</td><td>Api Version</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     targetResourceId: String
     *     targetResourceRegion: String
     *     targetModelId: String
     *     targetModelLocation: String
     *     accessToken: String
     *     expirationDateTime: String
     * }
     * }</pre>
     *
     * @param modelId Unique model name.
     * @param copyToRequest Copy to request parameters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginCopyDocumentModelToAsync(
            String modelId, BinaryData copyToRequest, RequestOptions requestOptions) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () -> this.copyDocumentModelToWithResponseAsync(modelId, copyToRequest, requestOptions),
                new DefaultPollingStrategy<>(this.getHttpPipeline()),
                new TypeReferenceBinaryData(),
                new TypeReferenceBinaryData());
    }

    /**
     * Copies model to the target resource, region, and modelId.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>api-version</td><td>String</td><td>Yes</td><td>Api Version</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     targetResourceId: String
     *     targetResourceRegion: String
     *     targetModelId: String
     *     targetModelLocation: String
     *     accessToken: String
     *     expirationDateTime: String
     * }
     * }</pre>
     *
     * @param modelId Unique model name.
     * @param copyToRequest Copy to request parameters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginCopyDocumentModelToAsync(
            String modelId, BinaryData copyToRequest, RequestOptions requestOptions, Context context) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () -> this.copyDocumentModelToWithResponseAsync(modelId, copyToRequest, requestOptions, context),
                new DefaultPollingStrategy<>(this.getHttpPipeline()),
                new TypeReferenceBinaryData(),
                new TypeReferenceBinaryData());
    }

    /**
     * Copies model to the target resource, region, and modelId.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>api-version</td><td>String</td><td>Yes</td><td>Api Version</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     targetResourceId: String
     *     targetResourceRegion: String
     *     targetModelId: String
     *     targetModelLocation: String
     *     accessToken: String
     *     expirationDateTime: String
     * }
     * }</pre>
     *
     * @param modelId Unique model name.
     * @param copyToRequest Copy to request parameters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginCopyDocumentModelTo(
            String modelId, BinaryData copyToRequest, RequestOptions requestOptions) {
        return this.beginCopyDocumentModelToAsync(modelId, copyToRequest, requestOptions).getSyncPoller();
    }

    /**
     * Lists all operations.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>api-version</td><td>String</td><td>Yes</td><td>Api Version</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             operationId: String
     *             status: String(notStarted/running/failed/succeeded/canceled)
     *             percentCompleted: Integer
     *             createdDateTime: String
     *             lastUpdatedDateTime: String
     *             kind: String(documentModelBuild/documentModelCompose/documentModelCopyTo)
     *             resourceLocation: String
     *             apiVersion: String
     *             tags: {
     *                 String: String
     *             }
     *         }
     *     ]
     *     nextLink: String
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return list Operations response object along with {@link PagedResponse} on successful completion of {@link
     *     Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getOperationsSinglePageAsync(RequestOptions requestOptions) {
        return FluxUtil.withContext(
                        context ->
                                service.getOperations(
                                        this.getEndpoint(),
                                        this.getServiceVersion().getVersion(),
                                        requestOptions,
                                        context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "nextLink"),
                                        null));
    }

    /**
     * Lists all operations.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>api-version</td><td>String</td><td>Yes</td><td>Api Version</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             operationId: String
     *             status: String(notStarted/running/failed/succeeded/canceled)
     *             percentCompleted: Integer
     *             createdDateTime: String
     *             lastUpdatedDateTime: String
     *             kind: String(documentModelBuild/documentModelCompose/documentModelCopyTo)
     *             resourceLocation: String
     *             apiVersion: String
     *             tags: {
     *                 String: String
     *             }
     *         }
     *     ]
     *     nextLink: String
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return list Operations response object along with {@link PagedResponse} on successful completion of {@link
     *     Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getOperationsSinglePageAsync(
            RequestOptions requestOptions, Context context) {
        return service.getOperations(this.getEndpoint(), this.getServiceVersion().getVersion(), requestOptions, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "nextLink"),
                                        null));
    }

    /**
     * Lists all operations.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>api-version</td><td>String</td><td>Yes</td><td>Api Version</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             operationId: String
     *             status: String(notStarted/running/failed/succeeded/canceled)
     *             percentCompleted: Integer
     *             createdDateTime: String
     *             lastUpdatedDateTime: String
     *             kind: String(documentModelBuild/documentModelCompose/documentModelCopyTo)
     *             resourceLocation: String
     *             apiVersion: String
     *             tags: {
     *                 String: String
     *             }
     *         }
     *     ]
     *     nextLink: String
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return list Operations response object as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> getOperationsAsync(RequestOptions requestOptions) {
        return new PagedFlux<>(
                () -> getOperationsSinglePageAsync(requestOptions),
                nextLink -> getOperationsNextSinglePageAsync(nextLink, null));
    }

    /**
     * Lists all operations.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>api-version</td><td>String</td><td>Yes</td><td>Api Version</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             operationId: String
     *             status: String(notStarted/running/failed/succeeded/canceled)
     *             percentCompleted: Integer
     *             createdDateTime: String
     *             lastUpdatedDateTime: String
     *             kind: String(documentModelBuild/documentModelCompose/documentModelCopyTo)
     *             resourceLocation: String
     *             apiVersion: String
     *             tags: {
     *                 String: String
     *             }
     *         }
     *     ]
     *     nextLink: String
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return list Operations response object as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> getOperationsAsync(RequestOptions requestOptions, Context context) {
        return new PagedFlux<>(
                () -> getOperationsSinglePageAsync(requestOptions, context),
                nextLink -> getOperationsNextSinglePageAsync(nextLink, null, context));
    }

    /**
     * Lists all operations.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>api-version</td><td>String</td><td>Yes</td><td>Api Version</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             operationId: String
     *             status: String(notStarted/running/failed/succeeded/canceled)
     *             percentCompleted: Integer
     *             createdDateTime: String
     *             lastUpdatedDateTime: String
     *             kind: String(documentModelBuild/documentModelCompose/documentModelCopyTo)
     *             resourceLocation: String
     *             apiVersion: String
     *             tags: {
     *                 String: String
     *             }
     *         }
     *     ]
     *     nextLink: String
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return list Operations response object as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> getOperations(RequestOptions requestOptions) {
        return new PagedIterable<>(getOperationsAsync(requestOptions));
    }

    /**
     * Gets operation info.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>api-version</td><td>String</td><td>Yes</td><td>Api Version</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     operationId: String
     *     status: String(notStarted/running/failed/succeeded/canceled)
     *     percentCompleted: Integer
     *     createdDateTime: String
     *     lastUpdatedDateTime: String
     *     kind: String(documentModelBuild/documentModelCompose/documentModelCopyTo)
     *     resourceLocation: String
     *     apiVersion: String
     *     tags: {
     *         String: String
     *     }
     *     error: {
     *         code: String
     *         message: String
     *         target: String
     *         details: [
     *             (recursive schema, see above)
     *         ]
     *         innererror: {
     *             code: String
     *             message: String
     *             innererror: (recursive schema, see innererror above)
     *         }
     *     }
     *     result: Object
     * }
     * }</pre>
     *
     * @param operationId Unique operation ID.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return operation info along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getOperationWithResponseAsync(String operationId, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                context ->
                        service.getOperation(
                                this.getEndpoint(),
                                operationId,
                                this.getServiceVersion().getVersion(),
                                requestOptions,
                                context));
    }

    /**
     * Gets operation info.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>api-version</td><td>String</td><td>Yes</td><td>Api Version</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     operationId: String
     *     status: String(notStarted/running/failed/succeeded/canceled)
     *     percentCompleted: Integer
     *     createdDateTime: String
     *     lastUpdatedDateTime: String
     *     kind: String(documentModelBuild/documentModelCompose/documentModelCopyTo)
     *     resourceLocation: String
     *     apiVersion: String
     *     tags: {
     *         String: String
     *     }
     *     error: {
     *         code: String
     *         message: String
     *         target: String
     *         details: [
     *             (recursive schema, see above)
     *         ]
     *         innererror: {
     *             code: String
     *             message: String
     *             innererror: (recursive schema, see innererror above)
     *         }
     *     }
     *     result: Object
     * }
     * }</pre>
     *
     * @param operationId Unique operation ID.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return operation info along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getOperationWithResponseAsync(
            String operationId, RequestOptions requestOptions, Context context) {
        return service.getOperation(
                this.getEndpoint(), operationId, this.getServiceVersion().getVersion(), requestOptions, context);
    }

    /**
     * Gets operation info.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>api-version</td><td>String</td><td>Yes</td><td>Api Version</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     operationId: String
     *     status: String(notStarted/running/failed/succeeded/canceled)
     *     percentCompleted: Integer
     *     createdDateTime: String
     *     lastUpdatedDateTime: String
     *     kind: String(documentModelBuild/documentModelCompose/documentModelCopyTo)
     *     resourceLocation: String
     *     apiVersion: String
     *     tags: {
     *         String: String
     *     }
     *     error: {
     *         code: String
     *         message: String
     *         target: String
     *         details: [
     *             (recursive schema, see above)
     *         ]
     *         innererror: {
     *             code: String
     *             message: String
     *             innererror: (recursive schema, see innererror above)
     *         }
     *     }
     *     result: Object
     * }
     * }</pre>
     *
     * @param operationId Unique operation ID.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return operation info along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getOperationWithResponse(String operationId, RequestOptions requestOptions) {
        return getOperationWithResponseAsync(operationId, requestOptions).block();
    }

    /**
     * List all models.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>api-version</td><td>String</td><td>Yes</td><td>Api Version</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             modelId: String
     *             description: String
     *             createdDateTime: String
     *             apiVersion: String
     *             tags: {
     *                 String: String
     *             }
     *         }
     *     ]
     *     nextLink: String
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return list Models response object along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getModelsSinglePageAsync(RequestOptions requestOptions) {
        return FluxUtil.withContext(
                        context ->
                                service.getModels(
                                        this.getEndpoint(),
                                        this.getServiceVersion().getVersion(),
                                        requestOptions,
                                        context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "nextLink"),
                                        null));
    }

    /**
     * List all models.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>api-version</td><td>String</td><td>Yes</td><td>Api Version</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             modelId: String
     *             description: String
     *             createdDateTime: String
     *             apiVersion: String
     *             tags: {
     *                 String: String
     *             }
     *         }
     *     ]
     *     nextLink: String
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return list Models response object along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getModelsSinglePageAsync(RequestOptions requestOptions, Context context) {
        return service.getModels(this.getEndpoint(), this.getServiceVersion().getVersion(), requestOptions, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "nextLink"),
                                        null));
    }

    /**
     * List all models.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>api-version</td><td>String</td><td>Yes</td><td>Api Version</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             modelId: String
     *             description: String
     *             createdDateTime: String
     *             apiVersion: String
     *             tags: {
     *                 String: String
     *             }
     *         }
     *     ]
     *     nextLink: String
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return list Models response object as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> getModelsAsync(RequestOptions requestOptions) {
        return new PagedFlux<>(
                () -> getModelsSinglePageAsync(requestOptions),
                nextLink -> getModelsNextSinglePageAsync(nextLink, null));
    }

    /**
     * List all models.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>api-version</td><td>String</td><td>Yes</td><td>Api Version</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             modelId: String
     *             description: String
     *             createdDateTime: String
     *             apiVersion: String
     *             tags: {
     *                 String: String
     *             }
     *         }
     *     ]
     *     nextLink: String
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return list Models response object as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> getModelsAsync(RequestOptions requestOptions, Context context) {
        return new PagedFlux<>(
                () -> getModelsSinglePageAsync(requestOptions, context),
                nextLink -> getModelsNextSinglePageAsync(nextLink, null, context));
    }

    /**
     * List all models.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>api-version</td><td>String</td><td>Yes</td><td>Api Version</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             modelId: String
     *             description: String
     *             createdDateTime: String
     *             apiVersion: String
     *             tags: {
     *                 String: String
     *             }
     *         }
     *     ]
     *     nextLink: String
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return list Models response object as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> getModels(RequestOptions requestOptions) {
        return new PagedIterable<>(getModelsAsync(requestOptions));
    }

    /**
     * Gets detailed model information.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>api-version</td><td>String</td><td>Yes</td><td>Api Version</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     modelId: String
     *     description: String
     *     createdDateTime: String
     *     apiVersion: String
     *     tags: {
     *         String: String
     *     }
     *     docTypes: {
     *         String: {
     *             description: String
     *             buildMode: String(template/neural)
     *             fieldSchema: {
     *                 String: {
     *                     type: String(string/date/time/phoneNumber/number/integer/selectionMark/countryRegion/signature/array/object/currency)
     *                     description: String
     *                     example: String
     *                     items: (recursive schema, see items above)
     *                     properties: {
     *                         String: (recursive schema, see String above)
     *                     }
     *                 }
     *             }
     *             fieldConfidence: {
     *                 String: float
     *             }
     *         }
     *     }
     * }
     * }</pre>
     *
     * @param modelId Unique model name.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return detailed model information along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getModelWithResponseAsync(String modelId, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                context ->
                        service.getModel(
                                this.getEndpoint(),
                                modelId,
                                this.getServiceVersion().getVersion(),
                                requestOptions,
                                context));
    }

    /**
     * Gets detailed model information.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>api-version</td><td>String</td><td>Yes</td><td>Api Version</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     modelId: String
     *     description: String
     *     createdDateTime: String
     *     apiVersion: String
     *     tags: {
     *         String: String
     *     }
     *     docTypes: {
     *         String: {
     *             description: String
     *             buildMode: String(template/neural)
     *             fieldSchema: {
     *                 String: {
     *                     type: String(string/date/time/phoneNumber/number/integer/selectionMark/countryRegion/signature/array/object/currency)
     *                     description: String
     *                     example: String
     *                     items: (recursive schema, see items above)
     *                     properties: {
     *                         String: (recursive schema, see String above)
     *                     }
     *                 }
     *             }
     *             fieldConfidence: {
     *                 String: float
     *             }
     *         }
     *     }
     * }
     * }</pre>
     *
     * @param modelId Unique model name.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return detailed model information along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getModelWithResponseAsync(
            String modelId, RequestOptions requestOptions, Context context) {
        return service.getModel(
                this.getEndpoint(), modelId, this.getServiceVersion().getVersion(), requestOptions, context);
    }

    /**
     * Gets detailed model information.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>api-version</td><td>String</td><td>Yes</td><td>Api Version</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     modelId: String
     *     description: String
     *     createdDateTime: String
     *     apiVersion: String
     *     tags: {
     *         String: String
     *     }
     *     docTypes: {
     *         String: {
     *             description: String
     *             buildMode: String(template/neural)
     *             fieldSchema: {
     *                 String: {
     *                     type: String(string/date/time/phoneNumber/number/integer/selectionMark/countryRegion/signature/array/object/currency)
     *                     description: String
     *                     example: String
     *                     items: (recursive schema, see items above)
     *                     properties: {
     *                         String: (recursive schema, see String above)
     *                     }
     *                 }
     *             }
     *             fieldConfidence: {
     *                 String: float
     *             }
     *         }
     *     }
     * }
     * }</pre>
     *
     * @param modelId Unique model name.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return detailed model information along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getModelWithResponse(String modelId, RequestOptions requestOptions) {
        return getModelWithResponseAsync(modelId, requestOptions).block();
    }

    /**
     * Deletes model.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>api-version</td><td>String</td><td>Yes</td><td>Api Version</td></tr>
     * </table>
     *
     * @param modelId Unique model name.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteModelWithResponseAsync(String modelId, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                context ->
                        service.deleteModel(
                                this.getEndpoint(),
                                modelId,
                                this.getServiceVersion().getVersion(),
                                requestOptions,
                                context));
    }

    /**
     * Deletes model.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>api-version</td><td>String</td><td>Yes</td><td>Api Version</td></tr>
     * </table>
     *
     * @param modelId Unique model name.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteModelWithResponseAsync(
            String modelId, RequestOptions requestOptions, Context context) {
        return service.deleteModel(
                this.getEndpoint(), modelId, this.getServiceVersion().getVersion(), requestOptions, context);
    }

    /**
     * Deletes model.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>api-version</td><td>String</td><td>Yes</td><td>Api Version</td></tr>
     * </table>
     *
     * @param modelId Unique model name.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return the {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteModelWithResponse(String modelId, RequestOptions requestOptions) {
        return deleteModelWithResponseAsync(modelId, requestOptions).block();
    }

    /**
     * Return basic info about the current resource.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>api-version</td><td>String</td><td>Yes</td><td>Api Version</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     customDocumentModels: {
     *         count: int
     *         limit: int
     *     }
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return general information regarding the current resource along with {@link Response} on successful completion
     *     of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getInfoWithResponseAsync(RequestOptions requestOptions) {
        return FluxUtil.withContext(
                context ->
                        service.getInfo(
                                this.getEndpoint(), this.getServiceVersion().getVersion(), requestOptions, context));
    }

    /**
     * Return basic info about the current resource.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>api-version</td><td>String</td><td>Yes</td><td>Api Version</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     customDocumentModels: {
     *         count: int
     *         limit: int
     *     }
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return general information regarding the current resource along with {@link Response} on successful completion
     *     of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getInfoWithResponseAsync(RequestOptions requestOptions, Context context) {
        return service.getInfo(this.getEndpoint(), this.getServiceVersion().getVersion(), requestOptions, context);
    }

    /**
     * Return basic info about the current resource.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>api-version</td><td>String</td><td>Yes</td><td>Api Version</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     customDocumentModels: {
     *         count: int
     *         limit: int
     *     }
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return general information regarding the current resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getInfoWithResponse(RequestOptions requestOptions) {
        return getInfoWithResponseAsync(requestOptions).block();
    }

    /**
     * Get the next page of items.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             operationId: String
     *             status: String(notStarted/running/failed/succeeded/canceled)
     *             percentCompleted: Integer
     *             createdDateTime: String
     *             lastUpdatedDateTime: String
     *             kind: String(documentModelBuild/documentModelCompose/documentModelCopyTo)
     *             resourceLocation: String
     *             apiVersion: String
     *             tags: {
     *                 String: String
     *             }
     *         }
     *     ]
     *     nextLink: String
     * }
     * }</pre>
     *
     * @param nextLink The nextLink parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return list Operations response object along with {@link PagedResponse} on successful completion of {@link
     *     Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getOperationsNextSinglePageAsync(
            String nextLink, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                        context -> service.getOperationsNext(nextLink, this.getEndpoint(), requestOptions, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "nextLink"),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             operationId: String
     *             status: String(notStarted/running/failed/succeeded/canceled)
     *             percentCompleted: Integer
     *             createdDateTime: String
     *             lastUpdatedDateTime: String
     *             kind: String(documentModelBuild/documentModelCompose/documentModelCopyTo)
     *             resourceLocation: String
     *             apiVersion: String
     *             tags: {
     *                 String: String
     *             }
     *         }
     *     ]
     *     nextLink: String
     * }
     * }</pre>
     *
     * @param nextLink The nextLink parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return list Operations response object along with {@link PagedResponse} on successful completion of {@link
     *     Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getOperationsNextSinglePageAsync(
            String nextLink, RequestOptions requestOptions, Context context) {
        return service.getOperationsNext(nextLink, this.getEndpoint(), requestOptions, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "nextLink"),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             modelId: String
     *             description: String
     *             createdDateTime: String
     *             apiVersion: String
     *             tags: {
     *                 String: String
     *             }
     *         }
     *     ]
     *     nextLink: String
     * }
     * }</pre>
     *
     * @param nextLink The nextLink parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return list Models response object along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getModelsNextSinglePageAsync(
            String nextLink, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                        context -> service.getModelsNext(nextLink, this.getEndpoint(), requestOptions, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "nextLink"),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             modelId: String
     *             description: String
     *             createdDateTime: String
     *             apiVersion: String
     *             tags: {
     *                 String: String
     *             }
     *         }
     *     ]
     *     nextLink: String
     * }
     * }</pre>
     *
     * @param nextLink The nextLink parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @return list Models response object along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getModelsNextSinglePageAsync(
            String nextLink, RequestOptions requestOptions, Context context) {
        return service.getModelsNext(nextLink, this.getEndpoint(), requestOptions, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "nextLink"),
                                        null));
    }

    private static final class TypeReferenceBinaryData extends TypeReference<BinaryData> {
        // empty
    }

    private List<BinaryData> getValues(BinaryData binaryData, String path) {
        try {
            Map<?, ?> obj = binaryData.toObject(Map.class);
            List<?> values = (List<?>) obj.get(path);
            return values.stream().map(BinaryData::fromObject).collect(Collectors.toList());
        } catch (RuntimeException e) {
            return null;
        }
    }

    private String getNextLink(BinaryData binaryData, String path) {
        try {
            Map<?, ?> obj = binaryData.toObject(Map.class);
            return (String) obj.get(path);
        } catch (RuntimeException e) {
            return null;
        }
    }
}
