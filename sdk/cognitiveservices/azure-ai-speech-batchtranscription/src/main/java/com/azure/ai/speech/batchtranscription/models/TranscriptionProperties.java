// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.ai.speech.batchtranscription.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.annotation.Generated;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;

/**
 * TranscriptionProperties.
 */
@Fluent
public final class TranscriptionProperties implements JsonSerializable<TranscriptionProperties> {
    /*
     * A value indicating whether word level timestamps are requested. The default value is false.
     */
    @Generated
    private Boolean wordLevelTimestampsEnabled;

    /*
     * A value indicating whether word level timestamps for the display form are requested. The default value is false.
     */
    @Generated
    private Boolean displayFormWordLevelTimestampsEnabled;

    /*
     * The duration in milliseconds of the transcription.
     * Durations larger than 2^53-1 are not supported to ensure compatibility with JavaScript integers.
     */
    @Generated
    private Integer durationMilliseconds;

    /*
     * A collection of the requested channel numbers. In the default case, the channels 0 and 1 are considered.
     */
    @Generated
    private List<Integer> channels;

    /*
     * The requested destination container.
     * 
     * Remarks
     * 
     * When a destination container is used in combination with a timeToLive, the metadata of a transcription will be
     * deleted normally, but the data stored in the destination container, including transcription results, will remain
     * untouched, because no delete permissions are required for this container.
     * 
     * To support automatic cleanup, either configure blob lifetimes on the container, or use
     * "Bring your own Storage (BYOS)" instead of destinationContainerUrl, where blobs can be cleaned up.
     */
    @Generated
    private String destinationContainerUrl;

    /*
     * The mode used for punctuation.
     */
    @Generated
    private PunctuationMode punctuationMode;

    /*
     * Mode of profanity filtering.
     */
    @Generated
    private ProfanityFilterMode profanityFilterMode;

    /*
     * How long the transcription will be kept in the system after it has completed. Once the transcription reaches the
     * time to live after completion(successful or failed) it will be automatically deleted.
     * 
     * Note: When using BYOS (bring your own storage), the result files on the customer owned storage account will also
     * be deleted.Use either destinationContainerUrl to specify a separate container for result files which will not be
     * deleted when the timeToLive expires, or retrieve the result files through the API and store them as needed.
     * 
     * The shortest supported duration is 6 hours, the longest supported duration is 31 days. 2 days (48 hours) is the
     * recommended default value when data is consumed directly.
     */
    @Generated
    private final int timeToLiveHours;

    /*
     * EntityError
     */
    @Generated
    private EntityError error;

    /*
     * Speaker Identification
     */
    @Generated
    private DiarizationProperties diarization;

    /*
     * LanguageIdentificationProperties
     */
    @Generated
    private LanguageIdentificationProperties languageIdentification;

    /**
     * Creates an instance of TranscriptionProperties class.
     * 
     * @param timeToLiveHours the timeToLiveHours value to set.
     */
    @Generated
    public TranscriptionProperties(int timeToLiveHours) {
        this.timeToLiveHours = timeToLiveHours;
    }

    /**
     * Get the wordLevelTimestampsEnabled property: A value indicating whether word level timestamps are requested. The
     * default value is false.
     * 
     * @return the wordLevelTimestampsEnabled value.
     */
    @Generated
    public Boolean isWordLevelTimestampsEnabled() {
        return this.wordLevelTimestampsEnabled;
    }

    /**
     * Set the wordLevelTimestampsEnabled property: A value indicating whether word level timestamps are requested. The
     * default value is false.
     * 
     * @param wordLevelTimestampsEnabled the wordLevelTimestampsEnabled value to set.
     * @return the TranscriptionProperties object itself.
     */
    @Generated
    public TranscriptionProperties setWordLevelTimestampsEnabled(Boolean wordLevelTimestampsEnabled) {
        this.wordLevelTimestampsEnabled = wordLevelTimestampsEnabled;
        return this;
    }

    /**
     * Get the displayFormWordLevelTimestampsEnabled property: A value indicating whether word level timestamps for the
     * display form are requested. The default value is false.
     * 
     * @return the displayFormWordLevelTimestampsEnabled value.
     */
    @Generated
    public Boolean isDisplayFormWordLevelTimestampsEnabled() {
        return this.displayFormWordLevelTimestampsEnabled;
    }

    /**
     * Set the displayFormWordLevelTimestampsEnabled property: A value indicating whether word level timestamps for the
     * display form are requested. The default value is false.
     * 
     * @param displayFormWordLevelTimestampsEnabled the displayFormWordLevelTimestampsEnabled value to set.
     * @return the TranscriptionProperties object itself.
     */
    @Generated
    public TranscriptionProperties
        setDisplayFormWordLevelTimestampsEnabled(Boolean displayFormWordLevelTimestampsEnabled) {
        this.displayFormWordLevelTimestampsEnabled = displayFormWordLevelTimestampsEnabled;
        return this;
    }

    /**
     * Get the durationMilliseconds property: The duration in milliseconds of the transcription.
     * Durations larger than 2^53-1 are not supported to ensure compatibility with JavaScript integers.
     * 
     * @return the durationMilliseconds value.
     */
    @Generated
    public Integer getDurationMilliseconds() {
        return this.durationMilliseconds;
    }

    /**
     * Get the channels property: A collection of the requested channel numbers. In the default case, the channels 0 and
     * 1 are considered.
     * 
     * @return the channels value.
     */
    @Generated
    public List<Integer> getChannels() {
        return this.channels;
    }

    /**
     * Set the channels property: A collection of the requested channel numbers. In the default case, the channels 0 and
     * 1 are considered.
     * 
     * @param channels the channels value to set.
     * @return the TranscriptionProperties object itself.
     */
    @Generated
    public TranscriptionProperties setChannels(List<Integer> channels) {
        this.channels = channels;
        return this;
    }

    /**
     * Get the destinationContainerUrl property: The requested destination container.
     * 
     * Remarks
     * 
     * When a destination container is used in combination with a timeToLive, the metadata of a transcription will be
     * deleted normally, but the data stored in the destination container, including transcription results, will remain
     * untouched, because no delete permissions are required for this container.
     * 
     * To support automatic cleanup, either configure blob lifetimes on the container, or use "Bring your own Storage
     * (BYOS)" instead of destinationContainerUrl, where blobs can be cleaned up.
     * 
     * @return the destinationContainerUrl value.
     */
    @Generated
    public String getDestinationContainerUrl() {
        return this.destinationContainerUrl;
    }

    /**
     * Set the destinationContainerUrl property: The requested destination container.
     * 
     * Remarks
     * 
     * When a destination container is used in combination with a timeToLive, the metadata of a transcription will be
     * deleted normally, but the data stored in the destination container, including transcription results, will remain
     * untouched, because no delete permissions are required for this container.
     * 
     * To support automatic cleanup, either configure blob lifetimes on the container, or use "Bring your own Storage
     * (BYOS)" instead of destinationContainerUrl, where blobs can be cleaned up.
     * 
     * @param destinationContainerUrl the destinationContainerUrl value to set.
     * @return the TranscriptionProperties object itself.
     */
    @Generated
    public TranscriptionProperties setDestinationContainerUrl(String destinationContainerUrl) {
        this.destinationContainerUrl = destinationContainerUrl;
        return this;
    }

    /**
     * Get the punctuationMode property: The mode used for punctuation.
     * 
     * @return the punctuationMode value.
     */
    @Generated
    public PunctuationMode getPunctuationMode() {
        return this.punctuationMode;
    }

    /**
     * Set the punctuationMode property: The mode used for punctuation.
     * 
     * @param punctuationMode the punctuationMode value to set.
     * @return the TranscriptionProperties object itself.
     */
    @Generated
    public TranscriptionProperties setPunctuationMode(PunctuationMode punctuationMode) {
        this.punctuationMode = punctuationMode;
        return this;
    }

    /**
     * Get the profanityFilterMode property: Mode of profanity filtering.
     * 
     * @return the profanityFilterMode value.
     */
    @Generated
    public ProfanityFilterMode getProfanityFilterMode() {
        return this.profanityFilterMode;
    }

    /**
     * Set the profanityFilterMode property: Mode of profanity filtering.
     * 
     * @param profanityFilterMode the profanityFilterMode value to set.
     * @return the TranscriptionProperties object itself.
     */
    @Generated
    public TranscriptionProperties setProfanityFilterMode(ProfanityFilterMode profanityFilterMode) {
        this.profanityFilterMode = profanityFilterMode;
        return this;
    }

    /**
     * Get the timeToLiveHours property: How long the transcription will be kept in the system after it has completed.
     * Once the transcription reaches the time to live after completion(successful or failed) it will be automatically
     * deleted.
     * 
     * Note: When using BYOS (bring your own storage), the result files on the customer owned storage account will also
     * be deleted.Use either destinationContainerUrl to specify a separate container for result files which will not be
     * deleted when the timeToLive expires, or retrieve the result files through the API and store them as needed.
     * 
     * The shortest supported duration is 6 hours, the longest supported duration is 31 days. 2 days (48 hours) is the
     * recommended default value when data is consumed directly.
     * 
     * @return the timeToLiveHours value.
     */
    @Generated
    public int getTimeToLiveHours() {
        return this.timeToLiveHours;
    }

    /**
     * Get the error property: EntityError.
     * 
     * @return the error value.
     */
    @Generated
    public EntityError getError() {
        return this.error;
    }

    /**
     * Set the error property: EntityError.
     * 
     * @param error the error value to set.
     * @return the TranscriptionProperties object itself.
     */
    @Generated
    public TranscriptionProperties setError(EntityError error) {
        this.error = error;
        return this;
    }

    /**
     * Get the diarization property: Speaker Identification.
     * 
     * @return the diarization value.
     */
    @Generated
    public DiarizationProperties getDiarization() {
        return this.diarization;
    }

    /**
     * Set the diarization property: Speaker Identification.
     * 
     * @param diarization the diarization value to set.
     * @return the TranscriptionProperties object itself.
     */
    @Generated
    public TranscriptionProperties setDiarization(DiarizationProperties diarization) {
        this.diarization = diarization;
        return this;
    }

    /**
     * Get the languageIdentification property: LanguageIdentificationProperties.
     * 
     * @return the languageIdentification value.
     */
    @Generated
    public LanguageIdentificationProperties getLanguageIdentification() {
        return this.languageIdentification;
    }

    /**
     * Set the languageIdentification property: LanguageIdentificationProperties.
     * 
     * @param languageIdentification the languageIdentification value to set.
     * @return the TranscriptionProperties object itself.
     */
    @Generated
    public TranscriptionProperties setLanguageIdentification(LanguageIdentificationProperties languageIdentification) {
        this.languageIdentification = languageIdentification;
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Generated
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeIntField("timeToLiveHours", this.timeToLiveHours);
        jsonWriter.writeBooleanField("wordLevelTimestampsEnabled", this.wordLevelTimestampsEnabled);
        jsonWriter.writeBooleanField("displayFormWordLevelTimestampsEnabled",
            this.displayFormWordLevelTimestampsEnabled);
        jsonWriter.writeArrayField("channels", this.channels, (writer, element) -> writer.writeInt(element));
        jsonWriter.writeStringField("destinationContainerUrl", this.destinationContainerUrl);
        jsonWriter.writeStringField("punctuationMode",
            this.punctuationMode == null ? null : this.punctuationMode.toString());
        jsonWriter.writeStringField("profanityFilterMode",
            this.profanityFilterMode == null ? null : this.profanityFilterMode.toString());
        jsonWriter.writeJsonField("error", this.error);
        jsonWriter.writeJsonField("diarization", this.diarization);
        jsonWriter.writeJsonField("languageIdentification", this.languageIdentification);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of TranscriptionProperties from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of TranscriptionProperties if the JsonReader was pointing to an instance of it, or null if it
     * was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the TranscriptionProperties.
     */
    @Generated
    public static TranscriptionProperties fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            int timeToLiveHours = 0;
            Boolean wordLevelTimestampsEnabled = null;
            Boolean displayFormWordLevelTimestampsEnabled = null;
            Integer durationMilliseconds = null;
            List<Integer> channels = null;
            String destinationContainerUrl = null;
            PunctuationMode punctuationMode = null;
            ProfanityFilterMode profanityFilterMode = null;
            EntityError error = null;
            DiarizationProperties diarization = null;
            LanguageIdentificationProperties languageIdentification = null;
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("timeToLiveHours".equals(fieldName)) {
                    timeToLiveHours = reader.getInt();
                } else if ("wordLevelTimestampsEnabled".equals(fieldName)) {
                    wordLevelTimestampsEnabled = reader.getNullable(JsonReader::getBoolean);
                } else if ("displayFormWordLevelTimestampsEnabled".equals(fieldName)) {
                    displayFormWordLevelTimestampsEnabled = reader.getNullable(JsonReader::getBoolean);
                } else if ("durationMilliseconds".equals(fieldName)) {
                    durationMilliseconds = reader.getNullable(JsonReader::getInt);
                } else if ("channels".equals(fieldName)) {
                    channels = reader.readArray(reader1 -> reader1.getInt());
                } else if ("destinationContainerUrl".equals(fieldName)) {
                    destinationContainerUrl = reader.getString();
                } else if ("punctuationMode".equals(fieldName)) {
                    punctuationMode = PunctuationMode.fromString(reader.getString());
                } else if ("profanityFilterMode".equals(fieldName)) {
                    profanityFilterMode = ProfanityFilterMode.fromString(reader.getString());
                } else if ("error".equals(fieldName)) {
                    error = EntityError.fromJson(reader);
                } else if ("diarization".equals(fieldName)) {
                    diarization = DiarizationProperties.fromJson(reader);
                } else if ("languageIdentification".equals(fieldName)) {
                    languageIdentification = LanguageIdentificationProperties.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }
            TranscriptionProperties deserializedTranscriptionProperties = new TranscriptionProperties(timeToLiveHours);
            deserializedTranscriptionProperties.wordLevelTimestampsEnabled = wordLevelTimestampsEnabled;
            deserializedTranscriptionProperties.displayFormWordLevelTimestampsEnabled
                = displayFormWordLevelTimestampsEnabled;
            deserializedTranscriptionProperties.durationMilliseconds = durationMilliseconds;
            deserializedTranscriptionProperties.channels = channels;
            deserializedTranscriptionProperties.destinationContainerUrl = destinationContainerUrl;
            deserializedTranscriptionProperties.punctuationMode = punctuationMode;
            deserializedTranscriptionProperties.profanityFilterMode = profanityFilterMode;
            deserializedTranscriptionProperties.error = error;
            deserializedTranscriptionProperties.diarization = diarization;
            deserializedTranscriptionProperties.languageIdentification = languageIdentification;

            return deserializedTranscriptionProperties;
        });
    }
}
