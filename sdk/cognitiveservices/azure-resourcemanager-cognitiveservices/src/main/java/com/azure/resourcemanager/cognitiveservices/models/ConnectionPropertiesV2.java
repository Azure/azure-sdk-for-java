// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.cognitiveservices.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.CoreUtils;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.Map;

/**
 * Connection property base schema.
 */
@Fluent
public class ConnectionPropertiesV2 implements JsonSerializable<ConnectionPropertiesV2> {
    /*
     * Authentication type of the connection target
     */
    private ConnectionAuthType authType = ConnectionAuthType.fromString("ConnectionPropertiesV2");

    /*
     * Category of the connection
     */
    private ConnectionCategory category;

    /*
     * The createdByWorkspaceArmId property.
     */
    private String createdByWorkspaceArmId;

    /*
     * Provides the error message if the connection fails
     */
    private String error;

    /*
     * The expiryTime property.
     */
    private OffsetDateTime expiryTime;

    /*
     * Group based on connection category
     */
    private ConnectionGroup group;

    /*
     * The isSharedToAll property.
     */
    private Boolean isSharedToAll;

    /*
     * Store user metadata for this connection
     */
    private Map<String, String> metadata;

    /*
     * Specifies how private endpoints are used with this connection: 'Required', 'NotRequired', or 'NotApplicable'.
     */
    private ManagedPERequirement peRequirement;

    /*
     * Specifies the status of private endpoints for this connection: 'Inactive', 'Active', or 'NotApplicable'.
     */
    private ManagedPEStatus peStatus;

    /*
     * The sharedUserList property.
     */
    private List<String> sharedUserList;

    /*
     * The connection URL to be used.
     */
    private String target;

    /*
     * The useWorkspaceManagedIdentity property.
     */
    private Boolean useWorkspaceManagedIdentity;

    /**
     * Creates an instance of ConnectionPropertiesV2 class.
     */
    public ConnectionPropertiesV2() {
    }

    /**
     * Get the authType property: Authentication type of the connection target.
     * 
     * @return the authType value.
     */
    public ConnectionAuthType authType() {
        return this.authType;
    }

    /**
     * Get the category property: Category of the connection.
     * 
     * @return the category value.
     */
    public ConnectionCategory category() {
        return this.category;
    }

    /**
     * Set the category property: Category of the connection.
     * 
     * @param category the category value to set.
     * @return the ConnectionPropertiesV2 object itself.
     */
    public ConnectionPropertiesV2 withCategory(ConnectionCategory category) {
        this.category = category;
        return this;
    }

    /**
     * Get the createdByWorkspaceArmId property: The createdByWorkspaceArmId property.
     * 
     * @return the createdByWorkspaceArmId value.
     */
    public String createdByWorkspaceArmId() {
        return this.createdByWorkspaceArmId;
    }

    /**
     * Set the createdByWorkspaceArmId property: The createdByWorkspaceArmId property.
     * 
     * @param createdByWorkspaceArmId the createdByWorkspaceArmId value to set.
     * @return the ConnectionPropertiesV2 object itself.
     */
    ConnectionPropertiesV2 withCreatedByWorkspaceArmId(String createdByWorkspaceArmId) {
        this.createdByWorkspaceArmId = createdByWorkspaceArmId;
        return this;
    }

    /**
     * Get the error property: Provides the error message if the connection fails.
     * 
     * @return the error value.
     */
    public String error() {
        return this.error;
    }

    /**
     * Set the error property: Provides the error message if the connection fails.
     * 
     * @param error the error value to set.
     * @return the ConnectionPropertiesV2 object itself.
     */
    public ConnectionPropertiesV2 withError(String error) {
        this.error = error;
        return this;
    }

    /**
     * Get the expiryTime property: The expiryTime property.
     * 
     * @return the expiryTime value.
     */
    public OffsetDateTime expiryTime() {
        return this.expiryTime;
    }

    /**
     * Set the expiryTime property: The expiryTime property.
     * 
     * @param expiryTime the expiryTime value to set.
     * @return the ConnectionPropertiesV2 object itself.
     */
    public ConnectionPropertiesV2 withExpiryTime(OffsetDateTime expiryTime) {
        this.expiryTime = expiryTime;
        return this;
    }

    /**
     * Get the group property: Group based on connection category.
     * 
     * @return the group value.
     */
    public ConnectionGroup group() {
        return this.group;
    }

    /**
     * Set the group property: Group based on connection category.
     * 
     * @param group the group value to set.
     * @return the ConnectionPropertiesV2 object itself.
     */
    ConnectionPropertiesV2 withGroup(ConnectionGroup group) {
        this.group = group;
        return this;
    }

    /**
     * Get the isSharedToAll property: The isSharedToAll property.
     * 
     * @return the isSharedToAll value.
     */
    public Boolean isSharedToAll() {
        return this.isSharedToAll;
    }

    /**
     * Set the isSharedToAll property: The isSharedToAll property.
     * 
     * @param isSharedToAll the isSharedToAll value to set.
     * @return the ConnectionPropertiesV2 object itself.
     */
    public ConnectionPropertiesV2 withIsSharedToAll(Boolean isSharedToAll) {
        this.isSharedToAll = isSharedToAll;
        return this;
    }

    /**
     * Get the metadata property: Store user metadata for this connection.
     * 
     * @return the metadata value.
     */
    public Map<String, String> metadata() {
        return this.metadata;
    }

    /**
     * Set the metadata property: Store user metadata for this connection.
     * 
     * @param metadata the metadata value to set.
     * @return the ConnectionPropertiesV2 object itself.
     */
    public ConnectionPropertiesV2 withMetadata(Map<String, String> metadata) {
        this.metadata = metadata;
        return this;
    }

    /**
     * Get the peRequirement property: Specifies how private endpoints are used with this connection: 'Required',
     * 'NotRequired', or 'NotApplicable'.
     * 
     * @return the peRequirement value.
     */
    public ManagedPERequirement peRequirement() {
        return this.peRequirement;
    }

    /**
     * Set the peRequirement property: Specifies how private endpoints are used with this connection: 'Required',
     * 'NotRequired', or 'NotApplicable'.
     * 
     * @param peRequirement the peRequirement value to set.
     * @return the ConnectionPropertiesV2 object itself.
     */
    public ConnectionPropertiesV2 withPeRequirement(ManagedPERequirement peRequirement) {
        this.peRequirement = peRequirement;
        return this;
    }

    /**
     * Get the peStatus property: Specifies the status of private endpoints for this connection: 'Inactive', 'Active',
     * or 'NotApplicable'.
     * 
     * @return the peStatus value.
     */
    public ManagedPEStatus peStatus() {
        return this.peStatus;
    }

    /**
     * Set the peStatus property: Specifies the status of private endpoints for this connection: 'Inactive', 'Active',
     * or 'NotApplicable'.
     * 
     * @param peStatus the peStatus value to set.
     * @return the ConnectionPropertiesV2 object itself.
     */
    public ConnectionPropertiesV2 withPeStatus(ManagedPEStatus peStatus) {
        this.peStatus = peStatus;
        return this;
    }

    /**
     * Get the sharedUserList property: The sharedUserList property.
     * 
     * @return the sharedUserList value.
     */
    public List<String> sharedUserList() {
        return this.sharedUserList;
    }

    /**
     * Set the sharedUserList property: The sharedUserList property.
     * 
     * @param sharedUserList the sharedUserList value to set.
     * @return the ConnectionPropertiesV2 object itself.
     */
    public ConnectionPropertiesV2 withSharedUserList(List<String> sharedUserList) {
        this.sharedUserList = sharedUserList;
        return this;
    }

    /**
     * Get the target property: The connection URL to be used.
     * 
     * @return the target value.
     */
    public String target() {
        return this.target;
    }

    /**
     * Set the target property: The connection URL to be used.
     * 
     * @param target the target value to set.
     * @return the ConnectionPropertiesV2 object itself.
     */
    public ConnectionPropertiesV2 withTarget(String target) {
        this.target = target;
        return this;
    }

    /**
     * Get the useWorkspaceManagedIdentity property: The useWorkspaceManagedIdentity property.
     * 
     * @return the useWorkspaceManagedIdentity value.
     */
    public Boolean useWorkspaceManagedIdentity() {
        return this.useWorkspaceManagedIdentity;
    }

    /**
     * Set the useWorkspaceManagedIdentity property: The useWorkspaceManagedIdentity property.
     * 
     * @param useWorkspaceManagedIdentity the useWorkspaceManagedIdentity value to set.
     * @return the ConnectionPropertiesV2 object itself.
     */
    public ConnectionPropertiesV2 withUseWorkspaceManagedIdentity(Boolean useWorkspaceManagedIdentity) {
        this.useWorkspaceManagedIdentity = useWorkspaceManagedIdentity;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("authType", this.authType == null ? null : this.authType.toString());
        jsonWriter.writeStringField("category", this.category == null ? null : this.category.toString());
        jsonWriter.writeStringField("error", this.error);
        jsonWriter.writeStringField("expiryTime",
            this.expiryTime == null ? null : DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(this.expiryTime));
        jsonWriter.writeBooleanField("isSharedToAll", this.isSharedToAll);
        jsonWriter.writeMapField("metadata", this.metadata, (writer, element) -> writer.writeString(element));
        jsonWriter.writeStringField("peRequirement", this.peRequirement == null ? null : this.peRequirement.toString());
        jsonWriter.writeStringField("peStatus", this.peStatus == null ? null : this.peStatus.toString());
        jsonWriter.writeArrayField("sharedUserList", this.sharedUserList,
            (writer, element) -> writer.writeString(element));
        jsonWriter.writeStringField("target", this.target);
        jsonWriter.writeBooleanField("useWorkspaceManagedIdentity", this.useWorkspaceManagedIdentity);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of ConnectionPropertiesV2 from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of ConnectionPropertiesV2 if the JsonReader was pointing to an instance of it, or null if it
     * was pointing to JSON null.
     * @throws IOException If an error occurs while reading the ConnectionPropertiesV2.
     */
    public static ConnectionPropertiesV2 fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            String discriminatorValue = null;
            try (JsonReader readerToUse = reader.bufferObject()) {
                readerToUse.nextToken(); // Prepare for reading
                while (readerToUse.nextToken() != JsonToken.END_OBJECT) {
                    String fieldName = readerToUse.getFieldName();
                    readerToUse.nextToken();
                    if ("authType".equals(fieldName)) {
                        discriminatorValue = readerToUse.getString();
                        break;
                    } else {
                        readerToUse.skipChildren();
                    }
                }
                // Use the discriminator value to determine which subtype should be deserialized.
                if ("PAT".equals(discriminatorValue)) {
                    return PatAuthTypeConnectionProperties.fromJson(readerToUse.reset());
                } else if ("ManagedIdentity".equals(discriminatorValue)) {
                    return ManagedIdentityAuthTypeConnectionProperties.fromJson(readerToUse.reset());
                } else if ("UsernamePassword".equals(discriminatorValue)) {
                    return UsernamePasswordAuthTypeConnectionProperties.fromJson(readerToUse.reset());
                } else if ("None".equals(discriminatorValue)) {
                    return NoneAuthTypeConnectionProperties.fromJson(readerToUse.reset());
                } else if ("SAS".equals(discriminatorValue)) {
                    return SasAuthTypeConnectionProperties.fromJson(readerToUse.reset());
                } else if ("AccountKey".equals(discriminatorValue)) {
                    return AccountKeyAuthTypeConnectionProperties.fromJson(readerToUse.reset());
                } else if ("ServicePrincipal".equals(discriminatorValue)) {
                    return ServicePrincipalAuthTypeConnectionProperties.fromJson(readerToUse.reset());
                } else if ("AccessKey".equals(discriminatorValue)) {
                    return AccessKeyAuthTypeConnectionProperties.fromJson(readerToUse.reset());
                } else if ("ApiKey".equals(discriminatorValue)) {
                    return ApiKeyAuthConnectionProperties.fromJson(readerToUse.reset());
                } else if ("CustomKeys".equals(discriminatorValue)) {
                    return CustomKeysConnectionProperties.fromJson(readerToUse.reset());
                } else if ("OAuth2".equals(discriminatorValue)) {
                    return OAuth2AuthTypeConnectionProperties.fromJson(readerToUse.reset());
                } else if ("AAD".equals(discriminatorValue)) {
                    return AadAuthTypeConnectionProperties.fromJson(readerToUse.reset());
                } else {
                    return fromJsonKnownDiscriminator(readerToUse.reset());
                }
            }
        });
    }

    static ConnectionPropertiesV2 fromJsonKnownDiscriminator(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            ConnectionPropertiesV2 deserializedConnectionPropertiesV2 = new ConnectionPropertiesV2();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("authType".equals(fieldName)) {
                    deserializedConnectionPropertiesV2.authType = ConnectionAuthType.fromString(reader.getString());
                } else if ("category".equals(fieldName)) {
                    deserializedConnectionPropertiesV2.category = ConnectionCategory.fromString(reader.getString());
                } else if ("createdByWorkspaceArmId".equals(fieldName)) {
                    deserializedConnectionPropertiesV2.createdByWorkspaceArmId = reader.getString();
                } else if ("error".equals(fieldName)) {
                    deserializedConnectionPropertiesV2.error = reader.getString();
                } else if ("expiryTime".equals(fieldName)) {
                    deserializedConnectionPropertiesV2.expiryTime = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("group".equals(fieldName)) {
                    deserializedConnectionPropertiesV2.group = ConnectionGroup.fromString(reader.getString());
                } else if ("isSharedToAll".equals(fieldName)) {
                    deserializedConnectionPropertiesV2.isSharedToAll = reader.getNullable(JsonReader::getBoolean);
                } else if ("metadata".equals(fieldName)) {
                    Map<String, String> metadata = reader.readMap(reader1 -> reader1.getString());
                    deserializedConnectionPropertiesV2.metadata = metadata;
                } else if ("peRequirement".equals(fieldName)) {
                    deserializedConnectionPropertiesV2.peRequirement
                        = ManagedPERequirement.fromString(reader.getString());
                } else if ("peStatus".equals(fieldName)) {
                    deserializedConnectionPropertiesV2.peStatus = ManagedPEStatus.fromString(reader.getString());
                } else if ("sharedUserList".equals(fieldName)) {
                    List<String> sharedUserList = reader.readArray(reader1 -> reader1.getString());
                    deserializedConnectionPropertiesV2.sharedUserList = sharedUserList;
                } else if ("target".equals(fieldName)) {
                    deserializedConnectionPropertiesV2.target = reader.getString();
                } else if ("useWorkspaceManagedIdentity".equals(fieldName)) {
                    deserializedConnectionPropertiesV2.useWorkspaceManagedIdentity
                        = reader.getNullable(JsonReader::getBoolean);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedConnectionPropertiesV2;
        });
    }
}
