/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.cognitiveservices.language.luis.authoring.implementation;

import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.AddIntentOptionalParameter;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.ListIntentsOptionalParameter;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.ListEntitiesOptionalParameter;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.ListHierarchicalEntitiesOptionalParameter;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.ListCompositeEntitiesOptionalParameter;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.ListClosedListsOptionalParameter;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.ListPrebuiltsOptionalParameter;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.ListModelsOptionalParameter;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.ExamplesMethodOptionalParameter;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.UpdateIntentOptionalParameter;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.DeleteIntentOptionalParameter;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.UpdateHierarchicalEntityOptionalParameter;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.PatchClosedListOptionalParameter;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.ListIntentSuggestionsOptionalParameter;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.ListEntitySuggestionsOptionalParameter;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.AddCustomPrebuiltDomainModelsOptionalParameter;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.UpdateHierarchicalEntityChildOptionalParameter;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.AddCompositeEntityChildOptionalParameter;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.ListRegexEntityInfosOptionalParameter;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.ListPatternAnyEntityInfosOptionalParameter;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.CreateEntityRoleOptionalParameter;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.CreatePrebuiltEntityRoleOptionalParameter;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.CreateClosedListEntityRoleOptionalParameter;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.CreateRegexEntityRoleOptionalParameter;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.CreateCompositeEntityRoleOptionalParameter;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.CreatePatternAnyEntityRoleOptionalParameter;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.CreateHierarchicalEntityRoleOptionalParameter;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.CreateCustomPrebuiltEntityRoleOptionalParameter;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.AddExplicitListItemOptionalParameter;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.UpdateEntityRoleOptionalParameter;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.UpdatePrebuiltEntityRoleOptionalParameter;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.UpdateClosedListEntityRoleOptionalParameter;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.UpdateRegexEntityRoleOptionalParameter;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.UpdateCompositeEntityRoleOptionalParameter;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.UpdatePatternAnyEntityRoleOptionalParameter;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.UpdateHierarchicalEntityRoleOptionalParameter;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.UpdateCustomPrebuiltEntityRoleOptionalParameter;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.UpdateExplicitListItemOptionalParameter;
import retrofit2.Retrofit;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.Models;
import com.google.common.base.Joiner;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.AvailablePrebuiltEntityModel;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.ChildEntityModelCreateObject;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.ClosedListEntityExtractor;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.ClosedListModelCreateObject;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.ClosedListModelPatchObject;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.ClosedListModelUpdateObject;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.CompositeChildModelCreateObject;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.CompositeEntityExtractor;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.CompositeEntityModel;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.CustomPrebuiltModel;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.EntitiesSuggestionExample;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.EntityExtractor;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.EntityModelCreateObject;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.EntityModelUpdateObject;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.EntityRole;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.EntityRoleCreateObject;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.EntityRoleUpdateObject;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.ErrorResponseException;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.ExplicitListItem;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.ExplicitListItemCreateObject;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.ExplicitListItemUpdateObject;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.HierarchicalChildEntity;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.HierarchicalChildModelUpdateObject;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.HierarchicalEntityExtractor;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.IntentClassifier;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.IntentsSuggestionExample;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.LabelTextObject;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.ModelCreateObject;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.ModelFeatureInformation;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.ModelInfoResponse;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.ModelUpdateObject;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.NDepthEntityExtractor;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.OperationStatus;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.PatternAnyEntityExtractor;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.PatternAnyModelCreateObject;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.PatternAnyModelUpdateObject;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.PrebuiltDomainCreateBaseObject;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.PrebuiltDomainModelCreateObject;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.PrebuiltEntityExtractor;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.RegexEntityExtractor;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.RegexModelCreateObject;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.RegexModelUpdateObject;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.WordListBaseUpdateObject;
import com.microsoft.azure.cognitiveservices.language.luis.authoring.models.WordListObject;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.List;
import java.util.UUID;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.PATCH;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in Models.
 */
public class ModelsImpl implements Models {
    /** The Retrofit service to perform REST calls. */
    private ModelsService service;
    /** The service client containing this operation class. */
    private LUISAuthoringClientImpl client;

    /**
     * Initializes an instance of ModelsImpl.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public ModelsImpl(Retrofit retrofit, LUISAuthoringClientImpl client) {
        this.service = retrofit.create(ModelsService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for Models to be
     * used by Retrofit to perform actually REST calls.
     */
    interface ModelsService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models addIntent" })
        @POST("apps/{appId}/versions/{versionId}/intents")
        Observable<Response<ResponseBody>> addIntent(@Path("appId") UUID appId, @Path("versionId") String versionId, @Header("accept-language") String acceptLanguage, @Body ModelCreateObject intentCreateObject, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models listIntents" })
        @GET("apps/{appId}/versions/{versionId}/intents")
        Observable<Response<ResponseBody>> listIntents(@Path("appId") UUID appId, @Path("versionId") String versionId, @Query("skip") Integer skip, @Query("take") Integer take, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models addEntity" })
        @POST("apps/{appId}/versions/{versionId}/entities")
        Observable<Response<ResponseBody>> addEntity(@Path("appId") UUID appId, @Path("versionId") String versionId, @Body EntityModelCreateObject entityModelCreateObject, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models listEntities" })
        @GET("apps/{appId}/versions/{versionId}/entities")
        Observable<Response<ResponseBody>> listEntities(@Path("appId") UUID appId, @Path("versionId") String versionId, @Query("skip") Integer skip, @Query("take") Integer take, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models listHierarchicalEntities" })
        @GET("apps/{appId}/versions/{versionId}/hierarchicalentities")
        Observable<Response<ResponseBody>> listHierarchicalEntities(@Path("appId") UUID appId, @Path("versionId") String versionId, @Query("skip") Integer skip, @Query("take") Integer take, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models listCompositeEntities" })
        @GET("apps/{appId}/versions/{versionId}/compositeentities")
        Observable<Response<ResponseBody>> listCompositeEntities(@Path("appId") UUID appId, @Path("versionId") String versionId, @Query("skip") Integer skip, @Query("take") Integer take, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models listClosedLists" })
        @GET("apps/{appId}/versions/{versionId}/closedlists")
        Observable<Response<ResponseBody>> listClosedLists(@Path("appId") UUID appId, @Path("versionId") String versionId, @Query("skip") Integer skip, @Query("take") Integer take, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models addClosedList" })
        @POST("apps/{appId}/versions/{versionId}/closedlists")
        Observable<Response<ResponseBody>> addClosedList(@Path("appId") UUID appId, @Path("versionId") String versionId, @Body ClosedListModelCreateObject closedListModelCreateObject, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models addPrebuilt" })
        @POST("apps/{appId}/versions/{versionId}/prebuilts")
        Observable<Response<ResponseBody>> addPrebuilt(@Path("appId") UUID appId, @Path("versionId") String versionId, @Body List<String> prebuiltExtractorNames, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models listPrebuilts" })
        @GET("apps/{appId}/versions/{versionId}/prebuilts")
        Observable<Response<ResponseBody>> listPrebuilts(@Path("appId") UUID appId, @Path("versionId") String versionId, @Query("skip") Integer skip, @Query("take") Integer take, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models listPrebuiltEntities" })
        @GET("apps/{appId}/versions/{versionId}/listprebuilts")
        Observable<Response<ResponseBody>> listPrebuiltEntities(@Path("appId") UUID appId, @Path("versionId") String versionId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models listModels" })
        @GET("apps/{appId}/versions/{versionId}/models")
        Observable<Response<ResponseBody>> listModels(@Path("appId") UUID appId, @Path("versionId") String versionId, @Query("skip") Integer skip, @Query("take") Integer take, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models examplesMethod" })
        @GET("apps/{appId}/versions/{versionId}/models/{modelId}/examples")
        Observable<Response<ResponseBody>> examplesMethod(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("modelId") String modelId, @Query("skip") Integer skip, @Query("take") Integer take, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models getIntent" })
        @GET("apps/{appId}/versions/{versionId}/intents/{intentId}")
        Observable<Response<ResponseBody>> getIntent(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("intentId") UUID intentId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models updateIntent" })
        @PUT("apps/{appId}/versions/{versionId}/intents/{intentId}")
        Observable<Response<ResponseBody>> updateIntent(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("intentId") UUID intentId, @Header("accept-language") String acceptLanguage, @Body ModelUpdateObject modelUpdateObject, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models deleteIntent" })
        @HTTP(path = "apps/{appId}/versions/{versionId}/intents/{intentId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteIntent(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("intentId") UUID intentId, @Query("deleteUtterances") Boolean deleteUtterances, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models getEntity" })
        @GET("apps/{appId}/versions/{versionId}/entities/{entityId}")
        Observable<Response<ResponseBody>> getEntity(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("entityId") UUID entityId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models deleteEntity" })
        @HTTP(path = "apps/{appId}/versions/{versionId}/entities/{entityId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteEntity(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("entityId") UUID entityId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models updateEntityChild" })
        @PATCH("apps/{appId}/versions/{versionId}/entities/{entityId}")
        Observable<Response<ResponseBody>> updateEntityChild(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("entityId") UUID entityId, @Body EntityModelUpdateObject entityModelUpdateObject, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models getIntentFeatures" })
        @GET("apps/{appId}/versions/{versionId}/intents/{intentId}/features")
        Observable<Response<ResponseBody>> getIntentFeatures(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("intentId") UUID intentId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models replaceIntentFeatures" })
        @PUT("apps/{appId}/versions/{versionId}/intents/{intentId}/features")
        Observable<Response<ResponseBody>> replaceIntentFeatures(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("intentId") UUID intentId, @Body List<ModelFeatureInformation> featureRelationsUpdateObject, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models deleteIntentFeature" })
        @HTTP(path = "apps/{appId}/versions/{versionId}/intents/{intentId}/features", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteIntentFeature(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("intentId") UUID intentId, @Body ModelFeatureInformation featureRelationDeleteObject, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models getEntityFeatures" })
        @GET("apps/{appId}/versions/{versionId}/entities/{entityId}/features")
        Observable<Response<ResponseBody>> getEntityFeatures(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("entityId") UUID entityId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models replaceEntityFeatures" })
        @PUT("apps/{appId}/versions/{versionId}/entities/{entityId}/features")
        Observable<Response<ResponseBody>> replaceEntityFeatures(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("entityId") UUID entityId, @Body List<ModelFeatureInformation> featureRelationsUpdateObject, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models deleteEntityFeature" })
        @HTTP(path = "apps/{appId}/versions/{versionId}/entities/{entityId}/features", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteEntityFeature(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("entityId") UUID entityId, @Body ModelFeatureInformation featureRelationDeleteObject, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models getHierarchicalEntity" })
        @GET("apps/{appId}/versions/{versionId}/hierarchicalentities/{hEntityId}")
        Observable<Response<ResponseBody>> getHierarchicalEntity(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("hEntityId") UUID hEntityId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models updateHierarchicalEntity" })
        @PATCH("apps/{appId}/versions/{versionId}/hierarchicalentities/{hEntityId}")
        Observable<Response<ResponseBody>> updateHierarchicalEntity(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("hEntityId") UUID hEntityId, @Header("accept-language") String acceptLanguage, @Body ModelUpdateObject modelUpdateObject, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models deleteHierarchicalEntity" })
        @HTTP(path = "apps/{appId}/versions/{versionId}/hierarchicalentities/{hEntityId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteHierarchicalEntity(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("hEntityId") UUID hEntityId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models getCompositeEntity" })
        @GET("apps/{appId}/versions/{versionId}/compositeentities/{cEntityId}")
        Observable<Response<ResponseBody>> getCompositeEntity(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("cEntityId") UUID cEntityId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models updateCompositeEntity" })
        @PUT("apps/{appId}/versions/{versionId}/compositeentities/{cEntityId}")
        Observable<Response<ResponseBody>> updateCompositeEntity(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("cEntityId") UUID cEntityId, @Body CompositeEntityModel compositeModelUpdateObject, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models deleteCompositeEntity" })
        @HTTP(path = "apps/{appId}/versions/{versionId}/compositeentities/{cEntityId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteCompositeEntity(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("cEntityId") UUID cEntityId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models getClosedList" })
        @GET("apps/{appId}/versions/{versionId}/closedlists/{clEntityId}")
        Observable<Response<ResponseBody>> getClosedList(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("clEntityId") UUID clEntityId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models updateClosedList" })
        @PUT("apps/{appId}/versions/{versionId}/closedlists/{clEntityId}")
        Observable<Response<ResponseBody>> updateClosedList(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("clEntityId") UUID clEntityId, @Body ClosedListModelUpdateObject closedListModelUpdateObject, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models patchClosedList" })
        @PATCH("apps/{appId}/versions/{versionId}/closedlists/{clEntityId}")
        Observable<Response<ResponseBody>> patchClosedList(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("clEntityId") UUID clEntityId, @Header("accept-language") String acceptLanguage, @Body ClosedListModelPatchObject closedListModelPatchObject, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models deleteClosedList" })
        @HTTP(path = "apps/{appId}/versions/{versionId}/closedlists/{clEntityId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteClosedList(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("clEntityId") UUID clEntityId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models getPrebuilt" })
        @GET("apps/{appId}/versions/{versionId}/prebuilts/{prebuiltId}")
        Observable<Response<ResponseBody>> getPrebuilt(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("prebuiltId") UUID prebuiltId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models deletePrebuilt" })
        @HTTP(path = "apps/{appId}/versions/{versionId}/prebuilts/{prebuiltId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deletePrebuilt(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("prebuiltId") UUID prebuiltId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models deleteSubList" })
        @HTTP(path = "apps/{appId}/versions/{versionId}/closedlists/{clEntityId}/sublists/{subListId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteSubList(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("clEntityId") UUID clEntityId, @Path("subListId") long subListId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models updateSubList" })
        @PUT("apps/{appId}/versions/{versionId}/closedlists/{clEntityId}/sublists/{subListId}")
        Observable<Response<ResponseBody>> updateSubList(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("clEntityId") UUID clEntityId, @Path("subListId") long subListId, @Body WordListBaseUpdateObject wordListBaseUpdateObject, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models listIntentSuggestions" })
        @GET("apps/{appId}/versions/{versionId}/intents/{intentId}/suggest")
        Observable<Response<ResponseBody>> listIntentSuggestions(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("intentId") UUID intentId, @Query("take") Integer take, @Query("enableNestedChildren") Boolean enableNestedChildren, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models listEntitySuggestions" })
        @GET("apps/{appId}/versions/{versionId}/entities/{entityId}/suggest")
        Observable<Response<ResponseBody>> listEntitySuggestions(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("entityId") UUID entityId, @Query("take") Integer take, @Query("enableNestedChildren") Boolean enableNestedChildren, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models addSubList" })
        @POST("apps/{appId}/versions/{versionId}/closedlists/{clEntityId}/sublists")
        Observable<Response<ResponseBody>> addSubList(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("clEntityId") UUID clEntityId, @Body WordListObject wordListCreateObject, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models addCustomPrebuiltDomain" })
        @POST("apps/{appId}/versions/{versionId}/customprebuiltdomains")
        Observable<Response<ResponseBody>> addCustomPrebuiltDomain(@Path("appId") UUID appId, @Path("versionId") String versionId, @Header("accept-language") String acceptLanguage, @Body PrebuiltDomainCreateBaseObject prebuiltDomainObject, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models addCustomPrebuiltIntent" })
        @POST("apps/{appId}/versions/{versionId}/customprebuiltintents")
        Observable<Response<ResponseBody>> addCustomPrebuiltIntent(@Path("appId") UUID appId, @Path("versionId") String versionId, @Body PrebuiltDomainModelCreateObject prebuiltDomainModelCreateObject, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models listCustomPrebuiltIntents" })
        @GET("apps/{appId}/versions/{versionId}/customprebuiltintents")
        Observable<Response<ResponseBody>> listCustomPrebuiltIntents(@Path("appId") UUID appId, @Path("versionId") String versionId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models addCustomPrebuiltEntity" })
        @POST("apps/{appId}/versions/{versionId}/customprebuiltentities")
        Observable<Response<ResponseBody>> addCustomPrebuiltEntity(@Path("appId") UUID appId, @Path("versionId") String versionId, @Body PrebuiltDomainModelCreateObject prebuiltDomainModelCreateObject, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models listCustomPrebuiltEntities" })
        @GET("apps/{appId}/versions/{versionId}/customprebuiltentities")
        Observable<Response<ResponseBody>> listCustomPrebuiltEntities(@Path("appId") UUID appId, @Path("versionId") String versionId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models listCustomPrebuiltModels" })
        @GET("apps/{appId}/versions/{versionId}/customprebuiltmodels")
        Observable<Response<ResponseBody>> listCustomPrebuiltModels(@Path("appId") UUID appId, @Path("versionId") String versionId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models deleteCustomPrebuiltDomain" })
        @HTTP(path = "apps/{appId}/versions/{versionId}/customprebuiltdomains/{domainName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteCustomPrebuiltDomain(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("domainName") String domainName, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models addEntityChild" })
        @POST("apps/{appId}/versions/{versionId}/entities/{entityId}/children")
        Observable<Response<ResponseBody>> addEntityChild(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("entityId") UUID entityId, @Body ChildEntityModelCreateObject childEntityModelCreateObject, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models getHierarchicalEntityChild" })
        @GET("apps/{appId}/versions/{versionId}/hierarchicalentities/{hEntityId}/children/{hChildId}")
        Observable<Response<ResponseBody>> getHierarchicalEntityChild(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("hEntityId") UUID hEntityId, @Path("hChildId") UUID hChildId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models updateHierarchicalEntityChild" })
        @PATCH("apps/{appId}/versions/{versionId}/hierarchicalentities/{hEntityId}/children/{hChildId}")
        Observable<Response<ResponseBody>> updateHierarchicalEntityChild(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("hEntityId") UUID hEntityId, @Path("hChildId") UUID hChildId, @Header("accept-language") String acceptLanguage, @Body HierarchicalChildModelUpdateObject hierarchicalChildModelUpdateObject, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models deleteHierarchicalEntityChild" })
        @HTTP(path = "apps/{appId}/versions/{versionId}/hierarchicalentities/{hEntityId}/children/{hChildId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteHierarchicalEntityChild(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("hEntityId") UUID hEntityId, @Path("hChildId") UUID hChildId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models addCompositeEntityChild" })
        @POST("apps/{appId}/versions/{versionId}/compositeentities/{cEntityId}/children")
        Observable<Response<ResponseBody>> addCompositeEntityChild(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("cEntityId") UUID cEntityId, @Header("accept-language") String acceptLanguage, @Body CompositeChildModelCreateObject compositeChildModelCreateObject, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models deleteCompositeEntityChild" })
        @HTTP(path = "apps/{appId}/versions/{versionId}/compositeentities/{cEntityId}/children/{cChildId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteCompositeEntityChild(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("cEntityId") UUID cEntityId, @Path("cChildId") UUID cChildId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models listRegexEntityInfos" })
        @GET("apps/{appId}/versions/{versionId}/regexentities")
        Observable<Response<ResponseBody>> listRegexEntityInfos(@Path("appId") UUID appId, @Path("versionId") String versionId, @Query("skip") Integer skip, @Query("take") Integer take, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models createRegexEntityModel" })
        @POST("apps/{appId}/versions/{versionId}/regexentities")
        Observable<Response<ResponseBody>> createRegexEntityModel(@Path("appId") UUID appId, @Path("versionId") String versionId, @Body RegexModelCreateObject regexEntityExtractorCreateObj, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models listPatternAnyEntityInfos" })
        @GET("apps/{appId}/versions/{versionId}/patternanyentities")
        Observable<Response<ResponseBody>> listPatternAnyEntityInfos(@Path("appId") UUID appId, @Path("versionId") String versionId, @Query("skip") Integer skip, @Query("take") Integer take, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models createPatternAnyEntityModel" })
        @POST("apps/{appId}/versions/{versionId}/patternanyentities")
        Observable<Response<ResponseBody>> createPatternAnyEntityModel(@Path("appId") UUID appId, @Path("versionId") String versionId, @Body PatternAnyModelCreateObject extractorCreateObject, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models listEntityRoles" })
        @GET("apps/{appId}/versions/{versionId}/entities/{entityId}/roles")
        Observable<Response<ResponseBody>> listEntityRoles(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("entityId") UUID entityId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models createEntityRole" })
        @POST("apps/{appId}/versions/{versionId}/entities/{entityId}/roles")
        Observable<Response<ResponseBody>> createEntityRole(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("entityId") UUID entityId, @Header("accept-language") String acceptLanguage, @Body EntityRoleCreateObject entityRoleCreateObject, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models listPrebuiltEntityRoles" })
        @GET("apps/{appId}/versions/{versionId}/prebuilts/{entityId}/roles")
        Observable<Response<ResponseBody>> listPrebuiltEntityRoles(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("entityId") UUID entityId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models createPrebuiltEntityRole" })
        @POST("apps/{appId}/versions/{versionId}/prebuilts/{entityId}/roles")
        Observable<Response<ResponseBody>> createPrebuiltEntityRole(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("entityId") UUID entityId, @Header("accept-language") String acceptLanguage, @Body EntityRoleCreateObject entityRoleCreateObject, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models listClosedListEntityRoles" })
        @GET("apps/{appId}/versions/{versionId}/closedlists/{entityId}/roles")
        Observable<Response<ResponseBody>> listClosedListEntityRoles(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("entityId") UUID entityId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models createClosedListEntityRole" })
        @POST("apps/{appId}/versions/{versionId}/closedlists/{entityId}/roles")
        Observable<Response<ResponseBody>> createClosedListEntityRole(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("entityId") UUID entityId, @Header("accept-language") String acceptLanguage, @Body EntityRoleCreateObject entityRoleCreateObject, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models listRegexEntityRoles" })
        @GET("apps/{appId}/versions/{versionId}/regexentities/{entityId}/roles")
        Observable<Response<ResponseBody>> listRegexEntityRoles(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("entityId") UUID entityId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models createRegexEntityRole" })
        @POST("apps/{appId}/versions/{versionId}/regexentities/{entityId}/roles")
        Observable<Response<ResponseBody>> createRegexEntityRole(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("entityId") UUID entityId, @Header("accept-language") String acceptLanguage, @Body EntityRoleCreateObject entityRoleCreateObject, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models listCompositeEntityRoles" })
        @GET("apps/{appId}/versions/{versionId}/compositeentities/{cEntityId}/roles")
        Observable<Response<ResponseBody>> listCompositeEntityRoles(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("cEntityId") UUID cEntityId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models createCompositeEntityRole" })
        @POST("apps/{appId}/versions/{versionId}/compositeentities/{cEntityId}/roles")
        Observable<Response<ResponseBody>> createCompositeEntityRole(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("cEntityId") UUID cEntityId, @Header("accept-language") String acceptLanguage, @Body EntityRoleCreateObject entityRoleCreateObject, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models listPatternAnyEntityRoles" })
        @GET("apps/{appId}/versions/{versionId}/patternanyentities/{entityId}/roles")
        Observable<Response<ResponseBody>> listPatternAnyEntityRoles(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("entityId") UUID entityId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models createPatternAnyEntityRole" })
        @POST("apps/{appId}/versions/{versionId}/patternanyentities/{entityId}/roles")
        Observable<Response<ResponseBody>> createPatternAnyEntityRole(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("entityId") UUID entityId, @Header("accept-language") String acceptLanguage, @Body EntityRoleCreateObject entityRoleCreateObject, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models listHierarchicalEntityRoles" })
        @GET("apps/{appId}/versions/{versionId}/hierarchicalentities/{hEntityId}/roles")
        Observable<Response<ResponseBody>> listHierarchicalEntityRoles(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("hEntityId") UUID hEntityId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models createHierarchicalEntityRole" })
        @POST("apps/{appId}/versions/{versionId}/hierarchicalentities/{hEntityId}/roles")
        Observable<Response<ResponseBody>> createHierarchicalEntityRole(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("hEntityId") UUID hEntityId, @Header("accept-language") String acceptLanguage, @Body EntityRoleCreateObject entityRoleCreateObject, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models listCustomPrebuiltEntityRoles" })
        @GET("apps/{appId}/versions/{versionId}/customprebuiltentities/{entityId}/roles")
        Observable<Response<ResponseBody>> listCustomPrebuiltEntityRoles(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("entityId") UUID entityId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models createCustomPrebuiltEntityRole" })
        @POST("apps/{appId}/versions/{versionId}/customprebuiltentities/{entityId}/roles")
        Observable<Response<ResponseBody>> createCustomPrebuiltEntityRole(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("entityId") UUID entityId, @Header("accept-language") String acceptLanguage, @Body EntityRoleCreateObject entityRoleCreateObject, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models getExplicitList" })
        @GET("apps/{appId}/versions/{versionId}/patternanyentities/{entityId}/explicitlist")
        Observable<Response<ResponseBody>> getExplicitList(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("entityId") UUID entityId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models addExplicitListItem" })
        @POST("apps/{appId}/versions/{versionId}/patternanyentities/{entityId}/explicitlist")
        Observable<Response<ResponseBody>> addExplicitListItem(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("entityId") UUID entityId, @Header("accept-language") String acceptLanguage, @Body ExplicitListItemCreateObject item, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models getRegexEntityEntityInfo" })
        @GET("apps/{appId}/versions/{versionId}/regexentities/{regexEntityId}")
        Observable<Response<ResponseBody>> getRegexEntityEntityInfo(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("regexEntityId") UUID regexEntityId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models updateRegexEntityModel" })
        @PUT("apps/{appId}/versions/{versionId}/regexentities/{regexEntityId}")
        Observable<Response<ResponseBody>> updateRegexEntityModel(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("regexEntityId") UUID regexEntityId, @Body RegexModelUpdateObject regexEntityUpdateObject, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models deleteRegexEntityModel" })
        @HTTP(path = "apps/{appId}/versions/{versionId}/regexentities/{regexEntityId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteRegexEntityModel(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("regexEntityId") UUID regexEntityId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models getPatternAnyEntityInfo" })
        @GET("apps/{appId}/versions/{versionId}/patternanyentities/{entityId}")
        Observable<Response<ResponseBody>> getPatternAnyEntityInfo(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("entityId") UUID entityId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models updatePatternAnyEntityModel" })
        @PUT("apps/{appId}/versions/{versionId}/patternanyentities/{entityId}")
        Observable<Response<ResponseBody>> updatePatternAnyEntityModel(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("entityId") UUID entityId, @Body PatternAnyModelUpdateObject patternAnyUpdateObject, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models deletePatternAnyEntityModel" })
        @HTTP(path = "apps/{appId}/versions/{versionId}/patternanyentities/{entityId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deletePatternAnyEntityModel(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("entityId") UUID entityId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models getEntityRole" })
        @GET("apps/{appId}/versions/{versionId}/entities/{entityId}/roles/{roleId}")
        Observable<Response<ResponseBody>> getEntityRole(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("entityId") UUID entityId, @Path("roleId") UUID roleId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models updateEntityRole" })
        @PUT("apps/{appId}/versions/{versionId}/entities/{entityId}/roles/{roleId}")
        Observable<Response<ResponseBody>> updateEntityRole(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("entityId") UUID entityId, @Path("roleId") UUID roleId, @Header("accept-language") String acceptLanguage, @Body EntityRoleUpdateObject entityRoleUpdateObject, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models deleteEntityRole" })
        @HTTP(path = "apps/{appId}/versions/{versionId}/entities/{entityId}/roles/{roleId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteEntityRole(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("entityId") UUID entityId, @Path("roleId") UUID roleId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models getPrebuiltEntityRole" })
        @GET("apps/{appId}/versions/{versionId}/prebuilts/{entityId}/roles/{roleId}")
        Observable<Response<ResponseBody>> getPrebuiltEntityRole(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("entityId") UUID entityId, @Path("roleId") UUID roleId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models updatePrebuiltEntityRole" })
        @PUT("apps/{appId}/versions/{versionId}/prebuilts/{entityId}/roles/{roleId}")
        Observable<Response<ResponseBody>> updatePrebuiltEntityRole(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("entityId") UUID entityId, @Path("roleId") UUID roleId, @Header("accept-language") String acceptLanguage, @Body EntityRoleUpdateObject entityRoleUpdateObject, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models deletePrebuiltEntityRole" })
        @HTTP(path = "apps/{appId}/versions/{versionId}/prebuilts/{entityId}/roles/{roleId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deletePrebuiltEntityRole(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("entityId") UUID entityId, @Path("roleId") UUID roleId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models getClosedListEntityRole" })
        @GET("apps/{appId}/versions/{versionId}/closedlists/{entityId}/roles/{roleId}")
        Observable<Response<ResponseBody>> getClosedListEntityRole(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("entityId") UUID entityId, @Path("roleId") UUID roleId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models updateClosedListEntityRole" })
        @PUT("apps/{appId}/versions/{versionId}/closedlists/{entityId}/roles/{roleId}")
        Observable<Response<ResponseBody>> updateClosedListEntityRole(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("entityId") UUID entityId, @Path("roleId") UUID roleId, @Header("accept-language") String acceptLanguage, @Body EntityRoleUpdateObject entityRoleUpdateObject, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models deleteClosedListEntityRole" })
        @HTTP(path = "apps/{appId}/versions/{versionId}/closedlists/{entityId}/roles/{roleId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteClosedListEntityRole(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("entityId") UUID entityId, @Path("roleId") UUID roleId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models getRegexEntityRole" })
        @GET("apps/{appId}/versions/{versionId}/regexentities/{entityId}/roles/{roleId}")
        Observable<Response<ResponseBody>> getRegexEntityRole(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("entityId") UUID entityId, @Path("roleId") UUID roleId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models updateRegexEntityRole" })
        @PUT("apps/{appId}/versions/{versionId}/regexentities/{entityId}/roles/{roleId}")
        Observable<Response<ResponseBody>> updateRegexEntityRole(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("entityId") UUID entityId, @Path("roleId") UUID roleId, @Header("accept-language") String acceptLanguage, @Body EntityRoleUpdateObject entityRoleUpdateObject, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models deleteRegexEntityRole" })
        @HTTP(path = "apps/{appId}/versions/{versionId}/regexentities/{entityId}/roles/{roleId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteRegexEntityRole(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("entityId") UUID entityId, @Path("roleId") UUID roleId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models getCompositeEntityRole" })
        @GET("apps/{appId}/versions/{versionId}/compositeentities/{cEntityId}/roles/{roleId}")
        Observable<Response<ResponseBody>> getCompositeEntityRole(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("cEntityId") UUID cEntityId, @Path("roleId") UUID roleId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models updateCompositeEntityRole" })
        @PUT("apps/{appId}/versions/{versionId}/compositeentities/{cEntityId}/roles/{roleId}")
        Observable<Response<ResponseBody>> updateCompositeEntityRole(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("cEntityId") UUID cEntityId, @Path("roleId") UUID roleId, @Header("accept-language") String acceptLanguage, @Body EntityRoleUpdateObject entityRoleUpdateObject, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models deleteCompositeEntityRole" })
        @HTTP(path = "apps/{appId}/versions/{versionId}/compositeentities/{cEntityId}/roles/{roleId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteCompositeEntityRole(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("cEntityId") UUID cEntityId, @Path("roleId") UUID roleId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models getPatternAnyEntityRole" })
        @GET("apps/{appId}/versions/{versionId}/patternanyentities/{entityId}/roles/{roleId}")
        Observable<Response<ResponseBody>> getPatternAnyEntityRole(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("entityId") UUID entityId, @Path("roleId") UUID roleId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models updatePatternAnyEntityRole" })
        @PUT("apps/{appId}/versions/{versionId}/patternanyentities/{entityId}/roles/{roleId}")
        Observable<Response<ResponseBody>> updatePatternAnyEntityRole(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("entityId") UUID entityId, @Path("roleId") UUID roleId, @Header("accept-language") String acceptLanguage, @Body EntityRoleUpdateObject entityRoleUpdateObject, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models deletePatternAnyEntityRole" })
        @HTTP(path = "apps/{appId}/versions/{versionId}/patternanyentities/{entityId}/roles/{roleId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deletePatternAnyEntityRole(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("entityId") UUID entityId, @Path("roleId") UUID roleId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models getHierarchicalEntityRole" })
        @GET("apps/{appId}/versions/{versionId}/hierarchicalentities/{hEntityId}/roles/{roleId}")
        Observable<Response<ResponseBody>> getHierarchicalEntityRole(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("hEntityId") UUID hEntityId, @Path("roleId") UUID roleId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models updateHierarchicalEntityRole" })
        @PUT("apps/{appId}/versions/{versionId}/hierarchicalentities/{hEntityId}/roles/{roleId}")
        Observable<Response<ResponseBody>> updateHierarchicalEntityRole(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("hEntityId") UUID hEntityId, @Path("roleId") UUID roleId, @Header("accept-language") String acceptLanguage, @Body EntityRoleUpdateObject entityRoleUpdateObject, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models deleteHierarchicalEntityRole" })
        @HTTP(path = "apps/{appId}/versions/{versionId}/hierarchicalentities/{hEntityId}/roles/{roleId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteHierarchicalEntityRole(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("hEntityId") UUID hEntityId, @Path("roleId") UUID roleId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models getCustomEntityRole" })
        @GET("apps/{appId}/versions/{versionId}/customprebuiltentities/{entityId}/roles/{roleId}")
        Observable<Response<ResponseBody>> getCustomEntityRole(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("entityId") UUID entityId, @Path("roleId") UUID roleId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models updateCustomPrebuiltEntityRole" })
        @PUT("apps/{appId}/versions/{versionId}/customprebuiltentities/{entityId}/roles/{roleId}")
        Observable<Response<ResponseBody>> updateCustomPrebuiltEntityRole(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("entityId") UUID entityId, @Path("roleId") UUID roleId, @Header("accept-language") String acceptLanguage, @Body EntityRoleUpdateObject entityRoleUpdateObject, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models deleteCustomEntityRole" })
        @HTTP(path = "apps/{appId}/versions/{versionId}/customprebuiltentities/{entityId}/roles/{roleId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteCustomEntityRole(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("entityId") UUID entityId, @Path("roleId") UUID roleId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models getExplicitListItem" })
        @GET("apps/{appId}/versions/{versionId}/patternanyentities/{entityId}/explicitlist/{itemId}")
        Observable<Response<ResponseBody>> getExplicitListItem(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("entityId") UUID entityId, @Path("itemId") long itemId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models updateExplicitListItem" })
        @PUT("apps/{appId}/versions/{versionId}/patternanyentities/{entityId}/explicitlist/{itemId}")
        Observable<Response<ResponseBody>> updateExplicitListItem(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("entityId") UUID entityId, @Path("itemId") long itemId, @Header("accept-language") String acceptLanguage, @Body ExplicitListItemUpdateObject item, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.authoring.Models deleteExplicitListItem" })
        @HTTP(path = "apps/{appId}/versions/{versionId}/patternanyentities/{entityId}/explicitlist/{itemId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteExplicitListItem(@Path("appId") UUID appId, @Path("versionId") String versionId, @Path("entityId") UUID entityId, @Path("itemId") long itemId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

    }


    /**
     * Adds an intent to a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param addIntentOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UUID object if successful.
     */
    public UUID addIntent(UUID appId, String versionId, AddIntentOptionalParameter addIntentOptionalParameter) {
        return addIntentWithServiceResponseAsync(appId, versionId, addIntentOptionalParameter).toBlocking().single().body();
    }

    /**
     * Adds an intent to a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param addIntentOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UUID> addIntentAsync(UUID appId, String versionId, AddIntentOptionalParameter addIntentOptionalParameter, final ServiceCallback<UUID> serviceCallback) {
        return ServiceFuture.fromResponse(addIntentWithServiceResponseAsync(appId, versionId, addIntentOptionalParameter), serviceCallback);
    }

    /**
     * Adds an intent to a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param addIntentOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UUID object
     */
    public Observable<UUID> addIntentAsync(UUID appId, String versionId, AddIntentOptionalParameter addIntentOptionalParameter) {
        return addIntentWithServiceResponseAsync(appId, versionId, addIntentOptionalParameter).map(new Func1<ServiceResponse<UUID>, UUID>() {
            @Override
            public UUID call(ServiceResponse<UUID> response) {
                return response.body();
            }
        });
    }

    /**
     * Adds an intent to a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param addIntentOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UUID object
     */
    public Observable<ServiceResponse<UUID>> addIntentWithServiceResponseAsync(UUID appId, String versionId, AddIntentOptionalParameter addIntentOptionalParameter) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        final String name = addIntentOptionalParameter != null ? addIntentOptionalParameter.name() : null;

        return addIntentWithServiceResponseAsync(appId, versionId, name);
    }

    /**
     * Adds an intent to a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param name Name of the new entity extractor.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UUID object
     */
    public Observable<ServiceResponse<UUID>> addIntentWithServiceResponseAsync(UUID appId, String versionId, String name) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        ModelCreateObject intentCreateObject = new ModelCreateObject();
        intentCreateObject.withName(name);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.addIntent(appId, versionId, this.client.acceptLanguage(), intentCreateObject, parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UUID>>>() {
                @Override
                public Observable<ServiceResponse<UUID>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UUID> clientResponse = addIntentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<UUID> addIntentDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<UUID, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(201, new TypeToken<UUID>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    @Override
    public ModelsAddIntentParameters addIntent() {
        return new ModelsAddIntentParameters(this);
    }

    /**
     * Internal class implementing ModelsAddIntentDefinition.
     */
    class ModelsAddIntentParameters implements ModelsAddIntentDefinition {
        private ModelsImpl parent;
        private UUID appId;
        private String versionId;
        private String name;

        /**
         * Constructor.
         * @param parent the parent object.
         */
        ModelsAddIntentParameters(ModelsImpl parent) {
            this.parent = parent;
        }

        @Override
        public ModelsAddIntentParameters withAppId(UUID appId) {
            this.appId = appId;
            return this;
        }

        @Override
        public ModelsAddIntentParameters withVersionId(String versionId) {
            this.versionId = versionId;
            return this;
        }

        @Override
        public ModelsAddIntentParameters withName(String name) {
            this.name = name;
            return this;
        }

        @Override
        public UUID execute() {
        return addIntentWithServiceResponseAsync(appId, versionId, name).toBlocking().single().body();
    }

        @Override
        public Observable<UUID> executeAsync() {
            return addIntentWithServiceResponseAsync(appId, versionId, name).map(new Func1<ServiceResponse<UUID>, UUID>() {
                @Override
                public UUID call(ServiceResponse<UUID> response) {
                    return response.body();
                }
            });
        }
    }


    /**
     * Gets information about the intent models in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param listIntentsOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;IntentClassifier&gt; object if successful.
     */
    public List<IntentClassifier> listIntents(UUID appId, String versionId, ListIntentsOptionalParameter listIntentsOptionalParameter) {
        return listIntentsWithServiceResponseAsync(appId, versionId, listIntentsOptionalParameter).toBlocking().single().body();
    }

    /**
     * Gets information about the intent models in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param listIntentsOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<IntentClassifier>> listIntentsAsync(UUID appId, String versionId, ListIntentsOptionalParameter listIntentsOptionalParameter, final ServiceCallback<List<IntentClassifier>> serviceCallback) {
        return ServiceFuture.fromResponse(listIntentsWithServiceResponseAsync(appId, versionId, listIntentsOptionalParameter), serviceCallback);
    }

    /**
     * Gets information about the intent models in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param listIntentsOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;IntentClassifier&gt; object
     */
    public Observable<List<IntentClassifier>> listIntentsAsync(UUID appId, String versionId, ListIntentsOptionalParameter listIntentsOptionalParameter) {
        return listIntentsWithServiceResponseAsync(appId, versionId, listIntentsOptionalParameter).map(new Func1<ServiceResponse<List<IntentClassifier>>, List<IntentClassifier>>() {
            @Override
            public List<IntentClassifier> call(ServiceResponse<List<IntentClassifier>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets information about the intent models in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param listIntentsOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;IntentClassifier&gt; object
     */
    public Observable<ServiceResponse<List<IntentClassifier>>> listIntentsWithServiceResponseAsync(UUID appId, String versionId, ListIntentsOptionalParameter listIntentsOptionalParameter) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        final Integer skip = listIntentsOptionalParameter != null ? listIntentsOptionalParameter.skip() : null;
        final Integer take = listIntentsOptionalParameter != null ? listIntentsOptionalParameter.take() : null;

        return listIntentsWithServiceResponseAsync(appId, versionId, skip, take);
    }

    /**
     * Gets information about the intent models in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param skip The number of entries to skip. Default value is 0.
     * @param take The number of entries to return. Maximum page size is 500. Default is 100.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;IntentClassifier&gt; object
     */
    public Observable<ServiceResponse<List<IntentClassifier>>> listIntentsWithServiceResponseAsync(UUID appId, String versionId, Integer skip, Integer take) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.listIntents(appId, versionId, skip, take, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<IntentClassifier>>>>() {
                @Override
                public Observable<ServiceResponse<List<IntentClassifier>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<IntentClassifier>> clientResponse = listIntentsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<IntentClassifier>> listIntentsDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<IntentClassifier>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<IntentClassifier>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    @Override
    public ModelsListIntentsParameters listIntents() {
        return new ModelsListIntentsParameters(this);
    }

    /**
     * Internal class implementing ModelsListIntentsDefinition.
     */
    class ModelsListIntentsParameters implements ModelsListIntentsDefinition {
        private ModelsImpl parent;
        private UUID appId;
        private String versionId;
        private Integer skip;
        private Integer take;

        /**
         * Constructor.
         * @param parent the parent object.
         */
        ModelsListIntentsParameters(ModelsImpl parent) {
            this.parent = parent;
        }

        @Override
        public ModelsListIntentsParameters withAppId(UUID appId) {
            this.appId = appId;
            return this;
        }

        @Override
        public ModelsListIntentsParameters withVersionId(String versionId) {
            this.versionId = versionId;
            return this;
        }

        @Override
        public ModelsListIntentsParameters withSkip(Integer skip) {
            this.skip = skip;
            return this;
        }

        @Override
        public ModelsListIntentsParameters withTake(Integer take) {
            this.take = take;
            return this;
        }

        @Override
        public List<IntentClassifier> execute() {
        return listIntentsWithServiceResponseAsync(appId, versionId, skip, take).toBlocking().single().body();
    }

        @Override
        public Observable<List<IntentClassifier>> executeAsync() {
            return listIntentsWithServiceResponseAsync(appId, versionId, skip, take).map(new Func1<ServiceResponse<List<IntentClassifier>>, List<IntentClassifier>>() {
                @Override
                public List<IntentClassifier> call(ServiceResponse<List<IntentClassifier>> response) {
                    return response.body();
                }
            });
        }
    }

    /**
     * Adds an entity extractor to a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityModelCreateObject A model object containing the name of the new entity extractor and its children.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UUID object if successful.
     */
    public UUID addEntity(UUID appId, String versionId, EntityModelCreateObject entityModelCreateObject) {
        return addEntityWithServiceResponseAsync(appId, versionId, entityModelCreateObject).toBlocking().single().body();
    }

    /**
     * Adds an entity extractor to a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityModelCreateObject A model object containing the name of the new entity extractor and its children.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UUID> addEntityAsync(UUID appId, String versionId, EntityModelCreateObject entityModelCreateObject, final ServiceCallback<UUID> serviceCallback) {
        return ServiceFuture.fromResponse(addEntityWithServiceResponseAsync(appId, versionId, entityModelCreateObject), serviceCallback);
    }

    /**
     * Adds an entity extractor to a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityModelCreateObject A model object containing the name of the new entity extractor and its children.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UUID object
     */
    public Observable<UUID> addEntityAsync(UUID appId, String versionId, EntityModelCreateObject entityModelCreateObject) {
        return addEntityWithServiceResponseAsync(appId, versionId, entityModelCreateObject).map(new Func1<ServiceResponse<UUID>, UUID>() {
            @Override
            public UUID call(ServiceResponse<UUID> response) {
                return response.body();
            }
        });
    }

    /**
     * Adds an entity extractor to a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityModelCreateObject A model object containing the name of the new entity extractor and its children.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UUID object
     */
    public Observable<ServiceResponse<UUID>> addEntityWithServiceResponseAsync(UUID appId, String versionId, EntityModelCreateObject entityModelCreateObject) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityModelCreateObject == null) {
            throw new IllegalArgumentException("Parameter entityModelCreateObject is required and cannot be null.");
        }
        Validator.validate(entityModelCreateObject);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.addEntity(appId, versionId, entityModelCreateObject, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UUID>>>() {
                @Override
                public Observable<ServiceResponse<UUID>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UUID> clientResponse = addEntityDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<UUID> addEntityDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<UUID, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(201, new TypeToken<UUID>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }


    /**
     * Gets information about all the simple entity models in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param listEntitiesOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;NDepthEntityExtractor&gt; object if successful.
     */
    public List<NDepthEntityExtractor> listEntities(UUID appId, String versionId, ListEntitiesOptionalParameter listEntitiesOptionalParameter) {
        return listEntitiesWithServiceResponseAsync(appId, versionId, listEntitiesOptionalParameter).toBlocking().single().body();
    }

    /**
     * Gets information about all the simple entity models in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param listEntitiesOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<NDepthEntityExtractor>> listEntitiesAsync(UUID appId, String versionId, ListEntitiesOptionalParameter listEntitiesOptionalParameter, final ServiceCallback<List<NDepthEntityExtractor>> serviceCallback) {
        return ServiceFuture.fromResponse(listEntitiesWithServiceResponseAsync(appId, versionId, listEntitiesOptionalParameter), serviceCallback);
    }

    /**
     * Gets information about all the simple entity models in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param listEntitiesOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;NDepthEntityExtractor&gt; object
     */
    public Observable<List<NDepthEntityExtractor>> listEntitiesAsync(UUID appId, String versionId, ListEntitiesOptionalParameter listEntitiesOptionalParameter) {
        return listEntitiesWithServiceResponseAsync(appId, versionId, listEntitiesOptionalParameter).map(new Func1<ServiceResponse<List<NDepthEntityExtractor>>, List<NDepthEntityExtractor>>() {
            @Override
            public List<NDepthEntityExtractor> call(ServiceResponse<List<NDepthEntityExtractor>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets information about all the simple entity models in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param listEntitiesOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;NDepthEntityExtractor&gt; object
     */
    public Observable<ServiceResponse<List<NDepthEntityExtractor>>> listEntitiesWithServiceResponseAsync(UUID appId, String versionId, ListEntitiesOptionalParameter listEntitiesOptionalParameter) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        final Integer skip = listEntitiesOptionalParameter != null ? listEntitiesOptionalParameter.skip() : null;
        final Integer take = listEntitiesOptionalParameter != null ? listEntitiesOptionalParameter.take() : null;

        return listEntitiesWithServiceResponseAsync(appId, versionId, skip, take);
    }

    /**
     * Gets information about all the simple entity models in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param skip The number of entries to skip. Default value is 0.
     * @param take The number of entries to return. Maximum page size is 500. Default is 100.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;NDepthEntityExtractor&gt; object
     */
    public Observable<ServiceResponse<List<NDepthEntityExtractor>>> listEntitiesWithServiceResponseAsync(UUID appId, String versionId, Integer skip, Integer take) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.listEntities(appId, versionId, skip, take, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<NDepthEntityExtractor>>>>() {
                @Override
                public Observable<ServiceResponse<List<NDepthEntityExtractor>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<NDepthEntityExtractor>> clientResponse = listEntitiesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<NDepthEntityExtractor>> listEntitiesDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<NDepthEntityExtractor>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<NDepthEntityExtractor>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    @Override
    public ModelsListEntitiesParameters listEntities() {
        return new ModelsListEntitiesParameters(this);
    }

    /**
     * Internal class implementing ModelsListEntitiesDefinition.
     */
    class ModelsListEntitiesParameters implements ModelsListEntitiesDefinition {
        private ModelsImpl parent;
        private UUID appId;
        private String versionId;
        private Integer skip;
        private Integer take;

        /**
         * Constructor.
         * @param parent the parent object.
         */
        ModelsListEntitiesParameters(ModelsImpl parent) {
            this.parent = parent;
        }

        @Override
        public ModelsListEntitiesParameters withAppId(UUID appId) {
            this.appId = appId;
            return this;
        }

        @Override
        public ModelsListEntitiesParameters withVersionId(String versionId) {
            this.versionId = versionId;
            return this;
        }

        @Override
        public ModelsListEntitiesParameters withSkip(Integer skip) {
            this.skip = skip;
            return this;
        }

        @Override
        public ModelsListEntitiesParameters withTake(Integer take) {
            this.take = take;
            return this;
        }

        @Override
        public List<NDepthEntityExtractor> execute() {
        return listEntitiesWithServiceResponseAsync(appId, versionId, skip, take).toBlocking().single().body();
    }

        @Override
        public Observable<List<NDepthEntityExtractor>> executeAsync() {
            return listEntitiesWithServiceResponseAsync(appId, versionId, skip, take).map(new Func1<ServiceResponse<List<NDepthEntityExtractor>>, List<NDepthEntityExtractor>>() {
                @Override
                public List<NDepthEntityExtractor> call(ServiceResponse<List<NDepthEntityExtractor>> response) {
                    return response.body();
                }
            });
        }
    }


    /**
     * Gets information about all the hierarchical entity models in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param listHierarchicalEntitiesOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;HierarchicalEntityExtractor&gt; object if successful.
     */
    public List<HierarchicalEntityExtractor> listHierarchicalEntities(UUID appId, String versionId, ListHierarchicalEntitiesOptionalParameter listHierarchicalEntitiesOptionalParameter) {
        return listHierarchicalEntitiesWithServiceResponseAsync(appId, versionId, listHierarchicalEntitiesOptionalParameter).toBlocking().single().body();
    }

    /**
     * Gets information about all the hierarchical entity models in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param listHierarchicalEntitiesOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<HierarchicalEntityExtractor>> listHierarchicalEntitiesAsync(UUID appId, String versionId, ListHierarchicalEntitiesOptionalParameter listHierarchicalEntitiesOptionalParameter, final ServiceCallback<List<HierarchicalEntityExtractor>> serviceCallback) {
        return ServiceFuture.fromResponse(listHierarchicalEntitiesWithServiceResponseAsync(appId, versionId, listHierarchicalEntitiesOptionalParameter), serviceCallback);
    }

    /**
     * Gets information about all the hierarchical entity models in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param listHierarchicalEntitiesOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;HierarchicalEntityExtractor&gt; object
     */
    public Observable<List<HierarchicalEntityExtractor>> listHierarchicalEntitiesAsync(UUID appId, String versionId, ListHierarchicalEntitiesOptionalParameter listHierarchicalEntitiesOptionalParameter) {
        return listHierarchicalEntitiesWithServiceResponseAsync(appId, versionId, listHierarchicalEntitiesOptionalParameter).map(new Func1<ServiceResponse<List<HierarchicalEntityExtractor>>, List<HierarchicalEntityExtractor>>() {
            @Override
            public List<HierarchicalEntityExtractor> call(ServiceResponse<List<HierarchicalEntityExtractor>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets information about all the hierarchical entity models in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param listHierarchicalEntitiesOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;HierarchicalEntityExtractor&gt; object
     */
    public Observable<ServiceResponse<List<HierarchicalEntityExtractor>>> listHierarchicalEntitiesWithServiceResponseAsync(UUID appId, String versionId, ListHierarchicalEntitiesOptionalParameter listHierarchicalEntitiesOptionalParameter) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        final Integer skip = listHierarchicalEntitiesOptionalParameter != null ? listHierarchicalEntitiesOptionalParameter.skip() : null;
        final Integer take = listHierarchicalEntitiesOptionalParameter != null ? listHierarchicalEntitiesOptionalParameter.take() : null;

        return listHierarchicalEntitiesWithServiceResponseAsync(appId, versionId, skip, take);
    }

    /**
     * Gets information about all the hierarchical entity models in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param skip The number of entries to skip. Default value is 0.
     * @param take The number of entries to return. Maximum page size is 500. Default is 100.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;HierarchicalEntityExtractor&gt; object
     */
    public Observable<ServiceResponse<List<HierarchicalEntityExtractor>>> listHierarchicalEntitiesWithServiceResponseAsync(UUID appId, String versionId, Integer skip, Integer take) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.listHierarchicalEntities(appId, versionId, skip, take, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<HierarchicalEntityExtractor>>>>() {
                @Override
                public Observable<ServiceResponse<List<HierarchicalEntityExtractor>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<HierarchicalEntityExtractor>> clientResponse = listHierarchicalEntitiesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<HierarchicalEntityExtractor>> listHierarchicalEntitiesDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<HierarchicalEntityExtractor>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<HierarchicalEntityExtractor>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    @Override
    public ModelsListHierarchicalEntitiesParameters listHierarchicalEntities() {
        return new ModelsListHierarchicalEntitiesParameters(this);
    }

    /**
     * Internal class implementing ModelsListHierarchicalEntitiesDefinition.
     */
    class ModelsListHierarchicalEntitiesParameters implements ModelsListHierarchicalEntitiesDefinition {
        private ModelsImpl parent;
        private UUID appId;
        private String versionId;
        private Integer skip;
        private Integer take;

        /**
         * Constructor.
         * @param parent the parent object.
         */
        ModelsListHierarchicalEntitiesParameters(ModelsImpl parent) {
            this.parent = parent;
        }

        @Override
        public ModelsListHierarchicalEntitiesParameters withAppId(UUID appId) {
            this.appId = appId;
            return this;
        }

        @Override
        public ModelsListHierarchicalEntitiesParameters withVersionId(String versionId) {
            this.versionId = versionId;
            return this;
        }

        @Override
        public ModelsListHierarchicalEntitiesParameters withSkip(Integer skip) {
            this.skip = skip;
            return this;
        }

        @Override
        public ModelsListHierarchicalEntitiesParameters withTake(Integer take) {
            this.take = take;
            return this;
        }

        @Override
        public List<HierarchicalEntityExtractor> execute() {
        return listHierarchicalEntitiesWithServiceResponseAsync(appId, versionId, skip, take).toBlocking().single().body();
    }

        @Override
        public Observable<List<HierarchicalEntityExtractor>> executeAsync() {
            return listHierarchicalEntitiesWithServiceResponseAsync(appId, versionId, skip, take).map(new Func1<ServiceResponse<List<HierarchicalEntityExtractor>>, List<HierarchicalEntityExtractor>>() {
                @Override
                public List<HierarchicalEntityExtractor> call(ServiceResponse<List<HierarchicalEntityExtractor>> response) {
                    return response.body();
                }
            });
        }
    }


    /**
     * Gets information about all the composite entity models in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param listCompositeEntitiesOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;CompositeEntityExtractor&gt; object if successful.
     */
    public List<CompositeEntityExtractor> listCompositeEntities(UUID appId, String versionId, ListCompositeEntitiesOptionalParameter listCompositeEntitiesOptionalParameter) {
        return listCompositeEntitiesWithServiceResponseAsync(appId, versionId, listCompositeEntitiesOptionalParameter).toBlocking().single().body();
    }

    /**
     * Gets information about all the composite entity models in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param listCompositeEntitiesOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<CompositeEntityExtractor>> listCompositeEntitiesAsync(UUID appId, String versionId, ListCompositeEntitiesOptionalParameter listCompositeEntitiesOptionalParameter, final ServiceCallback<List<CompositeEntityExtractor>> serviceCallback) {
        return ServiceFuture.fromResponse(listCompositeEntitiesWithServiceResponseAsync(appId, versionId, listCompositeEntitiesOptionalParameter), serviceCallback);
    }

    /**
     * Gets information about all the composite entity models in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param listCompositeEntitiesOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;CompositeEntityExtractor&gt; object
     */
    public Observable<List<CompositeEntityExtractor>> listCompositeEntitiesAsync(UUID appId, String versionId, ListCompositeEntitiesOptionalParameter listCompositeEntitiesOptionalParameter) {
        return listCompositeEntitiesWithServiceResponseAsync(appId, versionId, listCompositeEntitiesOptionalParameter).map(new Func1<ServiceResponse<List<CompositeEntityExtractor>>, List<CompositeEntityExtractor>>() {
            @Override
            public List<CompositeEntityExtractor> call(ServiceResponse<List<CompositeEntityExtractor>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets information about all the composite entity models in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param listCompositeEntitiesOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;CompositeEntityExtractor&gt; object
     */
    public Observable<ServiceResponse<List<CompositeEntityExtractor>>> listCompositeEntitiesWithServiceResponseAsync(UUID appId, String versionId, ListCompositeEntitiesOptionalParameter listCompositeEntitiesOptionalParameter) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        final Integer skip = listCompositeEntitiesOptionalParameter != null ? listCompositeEntitiesOptionalParameter.skip() : null;
        final Integer take = listCompositeEntitiesOptionalParameter != null ? listCompositeEntitiesOptionalParameter.take() : null;

        return listCompositeEntitiesWithServiceResponseAsync(appId, versionId, skip, take);
    }

    /**
     * Gets information about all the composite entity models in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param skip The number of entries to skip. Default value is 0.
     * @param take The number of entries to return. Maximum page size is 500. Default is 100.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;CompositeEntityExtractor&gt; object
     */
    public Observable<ServiceResponse<List<CompositeEntityExtractor>>> listCompositeEntitiesWithServiceResponseAsync(UUID appId, String versionId, Integer skip, Integer take) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.listCompositeEntities(appId, versionId, skip, take, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<CompositeEntityExtractor>>>>() {
                @Override
                public Observable<ServiceResponse<List<CompositeEntityExtractor>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<CompositeEntityExtractor>> clientResponse = listCompositeEntitiesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<CompositeEntityExtractor>> listCompositeEntitiesDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<CompositeEntityExtractor>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<CompositeEntityExtractor>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    @Override
    public ModelsListCompositeEntitiesParameters listCompositeEntities() {
        return new ModelsListCompositeEntitiesParameters(this);
    }

    /**
     * Internal class implementing ModelsListCompositeEntitiesDefinition.
     */
    class ModelsListCompositeEntitiesParameters implements ModelsListCompositeEntitiesDefinition {
        private ModelsImpl parent;
        private UUID appId;
        private String versionId;
        private Integer skip;
        private Integer take;

        /**
         * Constructor.
         * @param parent the parent object.
         */
        ModelsListCompositeEntitiesParameters(ModelsImpl parent) {
            this.parent = parent;
        }

        @Override
        public ModelsListCompositeEntitiesParameters withAppId(UUID appId) {
            this.appId = appId;
            return this;
        }

        @Override
        public ModelsListCompositeEntitiesParameters withVersionId(String versionId) {
            this.versionId = versionId;
            return this;
        }

        @Override
        public ModelsListCompositeEntitiesParameters withSkip(Integer skip) {
            this.skip = skip;
            return this;
        }

        @Override
        public ModelsListCompositeEntitiesParameters withTake(Integer take) {
            this.take = take;
            return this;
        }

        @Override
        public List<CompositeEntityExtractor> execute() {
        return listCompositeEntitiesWithServiceResponseAsync(appId, versionId, skip, take).toBlocking().single().body();
    }

        @Override
        public Observable<List<CompositeEntityExtractor>> executeAsync() {
            return listCompositeEntitiesWithServiceResponseAsync(appId, versionId, skip, take).map(new Func1<ServiceResponse<List<CompositeEntityExtractor>>, List<CompositeEntityExtractor>>() {
                @Override
                public List<CompositeEntityExtractor> call(ServiceResponse<List<CompositeEntityExtractor>> response) {
                    return response.body();
                }
            });
        }
    }


    /**
     * Gets information about all the list entity models in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param listClosedListsOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ClosedListEntityExtractor&gt; object if successful.
     */
    public List<ClosedListEntityExtractor> listClosedLists(UUID appId, String versionId, ListClosedListsOptionalParameter listClosedListsOptionalParameter) {
        return listClosedListsWithServiceResponseAsync(appId, versionId, listClosedListsOptionalParameter).toBlocking().single().body();
    }

    /**
     * Gets information about all the list entity models in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param listClosedListsOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ClosedListEntityExtractor>> listClosedListsAsync(UUID appId, String versionId, ListClosedListsOptionalParameter listClosedListsOptionalParameter, final ServiceCallback<List<ClosedListEntityExtractor>> serviceCallback) {
        return ServiceFuture.fromResponse(listClosedListsWithServiceResponseAsync(appId, versionId, listClosedListsOptionalParameter), serviceCallback);
    }

    /**
     * Gets information about all the list entity models in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param listClosedListsOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ClosedListEntityExtractor&gt; object
     */
    public Observable<List<ClosedListEntityExtractor>> listClosedListsAsync(UUID appId, String versionId, ListClosedListsOptionalParameter listClosedListsOptionalParameter) {
        return listClosedListsWithServiceResponseAsync(appId, versionId, listClosedListsOptionalParameter).map(new Func1<ServiceResponse<List<ClosedListEntityExtractor>>, List<ClosedListEntityExtractor>>() {
            @Override
            public List<ClosedListEntityExtractor> call(ServiceResponse<List<ClosedListEntityExtractor>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets information about all the list entity models in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param listClosedListsOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ClosedListEntityExtractor&gt; object
     */
    public Observable<ServiceResponse<List<ClosedListEntityExtractor>>> listClosedListsWithServiceResponseAsync(UUID appId, String versionId, ListClosedListsOptionalParameter listClosedListsOptionalParameter) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        final Integer skip = listClosedListsOptionalParameter != null ? listClosedListsOptionalParameter.skip() : null;
        final Integer take = listClosedListsOptionalParameter != null ? listClosedListsOptionalParameter.take() : null;

        return listClosedListsWithServiceResponseAsync(appId, versionId, skip, take);
    }

    /**
     * Gets information about all the list entity models in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param skip The number of entries to skip. Default value is 0.
     * @param take The number of entries to return. Maximum page size is 500. Default is 100.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ClosedListEntityExtractor&gt; object
     */
    public Observable<ServiceResponse<List<ClosedListEntityExtractor>>> listClosedListsWithServiceResponseAsync(UUID appId, String versionId, Integer skip, Integer take) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.listClosedLists(appId, versionId, skip, take, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ClosedListEntityExtractor>>>>() {
                @Override
                public Observable<ServiceResponse<List<ClosedListEntityExtractor>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<ClosedListEntityExtractor>> clientResponse = listClosedListsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<ClosedListEntityExtractor>> listClosedListsDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<ClosedListEntityExtractor>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<ClosedListEntityExtractor>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    @Override
    public ModelsListClosedListsParameters listClosedLists() {
        return new ModelsListClosedListsParameters(this);
    }

    /**
     * Internal class implementing ModelsListClosedListsDefinition.
     */
    class ModelsListClosedListsParameters implements ModelsListClosedListsDefinition {
        private ModelsImpl parent;
        private UUID appId;
        private String versionId;
        private Integer skip;
        private Integer take;

        /**
         * Constructor.
         * @param parent the parent object.
         */
        ModelsListClosedListsParameters(ModelsImpl parent) {
            this.parent = parent;
        }

        @Override
        public ModelsListClosedListsParameters withAppId(UUID appId) {
            this.appId = appId;
            return this;
        }

        @Override
        public ModelsListClosedListsParameters withVersionId(String versionId) {
            this.versionId = versionId;
            return this;
        }

        @Override
        public ModelsListClosedListsParameters withSkip(Integer skip) {
            this.skip = skip;
            return this;
        }

        @Override
        public ModelsListClosedListsParameters withTake(Integer take) {
            this.take = take;
            return this;
        }

        @Override
        public List<ClosedListEntityExtractor> execute() {
        return listClosedListsWithServiceResponseAsync(appId, versionId, skip, take).toBlocking().single().body();
    }

        @Override
        public Observable<List<ClosedListEntityExtractor>> executeAsync() {
            return listClosedListsWithServiceResponseAsync(appId, versionId, skip, take).map(new Func1<ServiceResponse<List<ClosedListEntityExtractor>>, List<ClosedListEntityExtractor>>() {
                @Override
                public List<ClosedListEntityExtractor> call(ServiceResponse<List<ClosedListEntityExtractor>> response) {
                    return response.body();
                }
            });
        }
    }

    /**
     * Adds a list entity model to a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param closedListModelCreateObject A model containing the name and words for the new list entity extractor.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UUID object if successful.
     */
    public UUID addClosedList(UUID appId, String versionId, ClosedListModelCreateObject closedListModelCreateObject) {
        return addClosedListWithServiceResponseAsync(appId, versionId, closedListModelCreateObject).toBlocking().single().body();
    }

    /**
     * Adds a list entity model to a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param closedListModelCreateObject A model containing the name and words for the new list entity extractor.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UUID> addClosedListAsync(UUID appId, String versionId, ClosedListModelCreateObject closedListModelCreateObject, final ServiceCallback<UUID> serviceCallback) {
        return ServiceFuture.fromResponse(addClosedListWithServiceResponseAsync(appId, versionId, closedListModelCreateObject), serviceCallback);
    }

    /**
     * Adds a list entity model to a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param closedListModelCreateObject A model containing the name and words for the new list entity extractor.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UUID object
     */
    public Observable<UUID> addClosedListAsync(UUID appId, String versionId, ClosedListModelCreateObject closedListModelCreateObject) {
        return addClosedListWithServiceResponseAsync(appId, versionId, closedListModelCreateObject).map(new Func1<ServiceResponse<UUID>, UUID>() {
            @Override
            public UUID call(ServiceResponse<UUID> response) {
                return response.body();
            }
        });
    }

    /**
     * Adds a list entity model to a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param closedListModelCreateObject A model containing the name and words for the new list entity extractor.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UUID object
     */
    public Observable<ServiceResponse<UUID>> addClosedListWithServiceResponseAsync(UUID appId, String versionId, ClosedListModelCreateObject closedListModelCreateObject) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (closedListModelCreateObject == null) {
            throw new IllegalArgumentException("Parameter closedListModelCreateObject is required and cannot be null.");
        }
        Validator.validate(closedListModelCreateObject);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.addClosedList(appId, versionId, closedListModelCreateObject, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UUID>>>() {
                @Override
                public Observable<ServiceResponse<UUID>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UUID> clientResponse = addClosedListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<UUID> addClosedListDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<UUID, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(201, new TypeToken<UUID>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Adds a list of prebuilt entities to a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param prebuiltExtractorNames An array of prebuilt entity extractor names.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;PrebuiltEntityExtractor&gt; object if successful.
     */
    public List<PrebuiltEntityExtractor> addPrebuilt(UUID appId, String versionId, List<String> prebuiltExtractorNames) {
        return addPrebuiltWithServiceResponseAsync(appId, versionId, prebuiltExtractorNames).toBlocking().single().body();
    }

    /**
     * Adds a list of prebuilt entities to a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param prebuiltExtractorNames An array of prebuilt entity extractor names.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<PrebuiltEntityExtractor>> addPrebuiltAsync(UUID appId, String versionId, List<String> prebuiltExtractorNames, final ServiceCallback<List<PrebuiltEntityExtractor>> serviceCallback) {
        return ServiceFuture.fromResponse(addPrebuiltWithServiceResponseAsync(appId, versionId, prebuiltExtractorNames), serviceCallback);
    }

    /**
     * Adds a list of prebuilt entities to a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param prebuiltExtractorNames An array of prebuilt entity extractor names.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PrebuiltEntityExtractor&gt; object
     */
    public Observable<List<PrebuiltEntityExtractor>> addPrebuiltAsync(UUID appId, String versionId, List<String> prebuiltExtractorNames) {
        return addPrebuiltWithServiceResponseAsync(appId, versionId, prebuiltExtractorNames).map(new Func1<ServiceResponse<List<PrebuiltEntityExtractor>>, List<PrebuiltEntityExtractor>>() {
            @Override
            public List<PrebuiltEntityExtractor> call(ServiceResponse<List<PrebuiltEntityExtractor>> response) {
                return response.body();
            }
        });
    }

    /**
     * Adds a list of prebuilt entities to a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param prebuiltExtractorNames An array of prebuilt entity extractor names.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PrebuiltEntityExtractor&gt; object
     */
    public Observable<ServiceResponse<List<PrebuiltEntityExtractor>>> addPrebuiltWithServiceResponseAsync(UUID appId, String versionId, List<String> prebuiltExtractorNames) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (prebuiltExtractorNames == null) {
            throw new IllegalArgumentException("Parameter prebuiltExtractorNames is required and cannot be null.");
        }
        Validator.validate(prebuiltExtractorNames);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.addPrebuilt(appId, versionId, prebuiltExtractorNames, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<PrebuiltEntityExtractor>>>>() {
                @Override
                public Observable<ServiceResponse<List<PrebuiltEntityExtractor>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<PrebuiltEntityExtractor>> clientResponse = addPrebuiltDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<PrebuiltEntityExtractor>> addPrebuiltDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<PrebuiltEntityExtractor>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(201, new TypeToken<List<PrebuiltEntityExtractor>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }


    /**
     * Gets information about all the prebuilt entities in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param listPrebuiltsOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;PrebuiltEntityExtractor&gt; object if successful.
     */
    public List<PrebuiltEntityExtractor> listPrebuilts(UUID appId, String versionId, ListPrebuiltsOptionalParameter listPrebuiltsOptionalParameter) {
        return listPrebuiltsWithServiceResponseAsync(appId, versionId, listPrebuiltsOptionalParameter).toBlocking().single().body();
    }

    /**
     * Gets information about all the prebuilt entities in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param listPrebuiltsOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<PrebuiltEntityExtractor>> listPrebuiltsAsync(UUID appId, String versionId, ListPrebuiltsOptionalParameter listPrebuiltsOptionalParameter, final ServiceCallback<List<PrebuiltEntityExtractor>> serviceCallback) {
        return ServiceFuture.fromResponse(listPrebuiltsWithServiceResponseAsync(appId, versionId, listPrebuiltsOptionalParameter), serviceCallback);
    }

    /**
     * Gets information about all the prebuilt entities in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param listPrebuiltsOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PrebuiltEntityExtractor&gt; object
     */
    public Observable<List<PrebuiltEntityExtractor>> listPrebuiltsAsync(UUID appId, String versionId, ListPrebuiltsOptionalParameter listPrebuiltsOptionalParameter) {
        return listPrebuiltsWithServiceResponseAsync(appId, versionId, listPrebuiltsOptionalParameter).map(new Func1<ServiceResponse<List<PrebuiltEntityExtractor>>, List<PrebuiltEntityExtractor>>() {
            @Override
            public List<PrebuiltEntityExtractor> call(ServiceResponse<List<PrebuiltEntityExtractor>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets information about all the prebuilt entities in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param listPrebuiltsOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PrebuiltEntityExtractor&gt; object
     */
    public Observable<ServiceResponse<List<PrebuiltEntityExtractor>>> listPrebuiltsWithServiceResponseAsync(UUID appId, String versionId, ListPrebuiltsOptionalParameter listPrebuiltsOptionalParameter) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        final Integer skip = listPrebuiltsOptionalParameter != null ? listPrebuiltsOptionalParameter.skip() : null;
        final Integer take = listPrebuiltsOptionalParameter != null ? listPrebuiltsOptionalParameter.take() : null;

        return listPrebuiltsWithServiceResponseAsync(appId, versionId, skip, take);
    }

    /**
     * Gets information about all the prebuilt entities in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param skip The number of entries to skip. Default value is 0.
     * @param take The number of entries to return. Maximum page size is 500. Default is 100.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PrebuiltEntityExtractor&gt; object
     */
    public Observable<ServiceResponse<List<PrebuiltEntityExtractor>>> listPrebuiltsWithServiceResponseAsync(UUID appId, String versionId, Integer skip, Integer take) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.listPrebuilts(appId, versionId, skip, take, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<PrebuiltEntityExtractor>>>>() {
                @Override
                public Observable<ServiceResponse<List<PrebuiltEntityExtractor>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<PrebuiltEntityExtractor>> clientResponse = listPrebuiltsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<PrebuiltEntityExtractor>> listPrebuiltsDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<PrebuiltEntityExtractor>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<PrebuiltEntityExtractor>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    @Override
    public ModelsListPrebuiltsParameters listPrebuilts() {
        return new ModelsListPrebuiltsParameters(this);
    }

    /**
     * Internal class implementing ModelsListPrebuiltsDefinition.
     */
    class ModelsListPrebuiltsParameters implements ModelsListPrebuiltsDefinition {
        private ModelsImpl parent;
        private UUID appId;
        private String versionId;
        private Integer skip;
        private Integer take;

        /**
         * Constructor.
         * @param parent the parent object.
         */
        ModelsListPrebuiltsParameters(ModelsImpl parent) {
            this.parent = parent;
        }

        @Override
        public ModelsListPrebuiltsParameters withAppId(UUID appId) {
            this.appId = appId;
            return this;
        }

        @Override
        public ModelsListPrebuiltsParameters withVersionId(String versionId) {
            this.versionId = versionId;
            return this;
        }

        @Override
        public ModelsListPrebuiltsParameters withSkip(Integer skip) {
            this.skip = skip;
            return this;
        }

        @Override
        public ModelsListPrebuiltsParameters withTake(Integer take) {
            this.take = take;
            return this;
        }

        @Override
        public List<PrebuiltEntityExtractor> execute() {
        return listPrebuiltsWithServiceResponseAsync(appId, versionId, skip, take).toBlocking().single().body();
    }

        @Override
        public Observable<List<PrebuiltEntityExtractor>> executeAsync() {
            return listPrebuiltsWithServiceResponseAsync(appId, versionId, skip, take).map(new Func1<ServiceResponse<List<PrebuiltEntityExtractor>>, List<PrebuiltEntityExtractor>>() {
                @Override
                public List<PrebuiltEntityExtractor> call(ServiceResponse<List<PrebuiltEntityExtractor>> response) {
                    return response.body();
                }
            });
        }
    }

    /**
     * Gets all the available prebuilt entities in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;AvailablePrebuiltEntityModel&gt; object if successful.
     */
    public List<AvailablePrebuiltEntityModel> listPrebuiltEntities(UUID appId, String versionId) {
        return listPrebuiltEntitiesWithServiceResponseAsync(appId, versionId).toBlocking().single().body();
    }

    /**
     * Gets all the available prebuilt entities in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<AvailablePrebuiltEntityModel>> listPrebuiltEntitiesAsync(UUID appId, String versionId, final ServiceCallback<List<AvailablePrebuiltEntityModel>> serviceCallback) {
        return ServiceFuture.fromResponse(listPrebuiltEntitiesWithServiceResponseAsync(appId, versionId), serviceCallback);
    }

    /**
     * Gets all the available prebuilt entities in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;AvailablePrebuiltEntityModel&gt; object
     */
    public Observable<List<AvailablePrebuiltEntityModel>> listPrebuiltEntitiesAsync(UUID appId, String versionId) {
        return listPrebuiltEntitiesWithServiceResponseAsync(appId, versionId).map(new Func1<ServiceResponse<List<AvailablePrebuiltEntityModel>>, List<AvailablePrebuiltEntityModel>>() {
            @Override
            public List<AvailablePrebuiltEntityModel> call(ServiceResponse<List<AvailablePrebuiltEntityModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets all the available prebuilt entities in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;AvailablePrebuiltEntityModel&gt; object
     */
    public Observable<ServiceResponse<List<AvailablePrebuiltEntityModel>>> listPrebuiltEntitiesWithServiceResponseAsync(UUID appId, String versionId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.listPrebuiltEntities(appId, versionId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<AvailablePrebuiltEntityModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<AvailablePrebuiltEntityModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<AvailablePrebuiltEntityModel>> clientResponse = listPrebuiltEntitiesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<AvailablePrebuiltEntityModel>> listPrebuiltEntitiesDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<AvailablePrebuiltEntityModel>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<AvailablePrebuiltEntityModel>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }


    /**
     * Gets information about all the intent and entity models in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param listModelsOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ModelInfoResponse&gt; object if successful.
     */
    public List<ModelInfoResponse> listModels(UUID appId, String versionId, ListModelsOptionalParameter listModelsOptionalParameter) {
        return listModelsWithServiceResponseAsync(appId, versionId, listModelsOptionalParameter).toBlocking().single().body();
    }

    /**
     * Gets information about all the intent and entity models in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param listModelsOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ModelInfoResponse>> listModelsAsync(UUID appId, String versionId, ListModelsOptionalParameter listModelsOptionalParameter, final ServiceCallback<List<ModelInfoResponse>> serviceCallback) {
        return ServiceFuture.fromResponse(listModelsWithServiceResponseAsync(appId, versionId, listModelsOptionalParameter), serviceCallback);
    }

    /**
     * Gets information about all the intent and entity models in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param listModelsOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ModelInfoResponse&gt; object
     */
    public Observable<List<ModelInfoResponse>> listModelsAsync(UUID appId, String versionId, ListModelsOptionalParameter listModelsOptionalParameter) {
        return listModelsWithServiceResponseAsync(appId, versionId, listModelsOptionalParameter).map(new Func1<ServiceResponse<List<ModelInfoResponse>>, List<ModelInfoResponse>>() {
            @Override
            public List<ModelInfoResponse> call(ServiceResponse<List<ModelInfoResponse>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets information about all the intent and entity models in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param listModelsOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ModelInfoResponse&gt; object
     */
    public Observable<ServiceResponse<List<ModelInfoResponse>>> listModelsWithServiceResponseAsync(UUID appId, String versionId, ListModelsOptionalParameter listModelsOptionalParameter) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        final Integer skip = listModelsOptionalParameter != null ? listModelsOptionalParameter.skip() : null;
        final Integer take = listModelsOptionalParameter != null ? listModelsOptionalParameter.take() : null;

        return listModelsWithServiceResponseAsync(appId, versionId, skip, take);
    }

    /**
     * Gets information about all the intent and entity models in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param skip The number of entries to skip. Default value is 0.
     * @param take The number of entries to return. Maximum page size is 500. Default is 100.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ModelInfoResponse&gt; object
     */
    public Observable<ServiceResponse<List<ModelInfoResponse>>> listModelsWithServiceResponseAsync(UUID appId, String versionId, Integer skip, Integer take) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.listModels(appId, versionId, skip, take, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ModelInfoResponse>>>>() {
                @Override
                public Observable<ServiceResponse<List<ModelInfoResponse>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<ModelInfoResponse>> clientResponse = listModelsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<ModelInfoResponse>> listModelsDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<ModelInfoResponse>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<ModelInfoResponse>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    @Override
    public ModelsListModelsParameters listModels() {
        return new ModelsListModelsParameters(this);
    }

    /**
     * Internal class implementing ModelsListModelsDefinition.
     */
    class ModelsListModelsParameters implements ModelsListModelsDefinition {
        private ModelsImpl parent;
        private UUID appId;
        private String versionId;
        private Integer skip;
        private Integer take;

        /**
         * Constructor.
         * @param parent the parent object.
         */
        ModelsListModelsParameters(ModelsImpl parent) {
            this.parent = parent;
        }

        @Override
        public ModelsListModelsParameters withAppId(UUID appId) {
            this.appId = appId;
            return this;
        }

        @Override
        public ModelsListModelsParameters withVersionId(String versionId) {
            this.versionId = versionId;
            return this;
        }

        @Override
        public ModelsListModelsParameters withSkip(Integer skip) {
            this.skip = skip;
            return this;
        }

        @Override
        public ModelsListModelsParameters withTake(Integer take) {
            this.take = take;
            return this;
        }

        @Override
        public List<ModelInfoResponse> execute() {
        return listModelsWithServiceResponseAsync(appId, versionId, skip, take).toBlocking().single().body();
    }

        @Override
        public Observable<List<ModelInfoResponse>> executeAsync() {
            return listModelsWithServiceResponseAsync(appId, versionId, skip, take).map(new Func1<ServiceResponse<List<ModelInfoResponse>>, List<ModelInfoResponse>>() {
                @Override
                public List<ModelInfoResponse> call(ServiceResponse<List<ModelInfoResponse>> response) {
                    return response.body();
                }
            });
        }
    }


    /**
     * Gets the example utterances for the given intent or entity model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param modelId The ID (GUID) of the model.
     * @param examplesMethodOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;LabelTextObject&gt; object if successful.
     */
    public List<LabelTextObject> examplesMethod(UUID appId, String versionId, String modelId, ExamplesMethodOptionalParameter examplesMethodOptionalParameter) {
        return examplesMethodWithServiceResponseAsync(appId, versionId, modelId, examplesMethodOptionalParameter).toBlocking().single().body();
    }

    /**
     * Gets the example utterances for the given intent or entity model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param modelId The ID (GUID) of the model.
     * @param examplesMethodOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<LabelTextObject>> examplesMethodAsync(UUID appId, String versionId, String modelId, ExamplesMethodOptionalParameter examplesMethodOptionalParameter, final ServiceCallback<List<LabelTextObject>> serviceCallback) {
        return ServiceFuture.fromResponse(examplesMethodWithServiceResponseAsync(appId, versionId, modelId, examplesMethodOptionalParameter), serviceCallback);
    }

    /**
     * Gets the example utterances for the given intent or entity model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param modelId The ID (GUID) of the model.
     * @param examplesMethodOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;LabelTextObject&gt; object
     */
    public Observable<List<LabelTextObject>> examplesMethodAsync(UUID appId, String versionId, String modelId, ExamplesMethodOptionalParameter examplesMethodOptionalParameter) {
        return examplesMethodWithServiceResponseAsync(appId, versionId, modelId, examplesMethodOptionalParameter).map(new Func1<ServiceResponse<List<LabelTextObject>>, List<LabelTextObject>>() {
            @Override
            public List<LabelTextObject> call(ServiceResponse<List<LabelTextObject>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the example utterances for the given intent or entity model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param modelId The ID (GUID) of the model.
     * @param examplesMethodOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;LabelTextObject&gt; object
     */
    public Observable<ServiceResponse<List<LabelTextObject>>> examplesMethodWithServiceResponseAsync(UUID appId, String versionId, String modelId, ExamplesMethodOptionalParameter examplesMethodOptionalParameter) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (modelId == null) {
            throw new IllegalArgumentException("Parameter modelId is required and cannot be null.");
        }
        final Integer skip = examplesMethodOptionalParameter != null ? examplesMethodOptionalParameter.skip() : null;
        final Integer take = examplesMethodOptionalParameter != null ? examplesMethodOptionalParameter.take() : null;

        return examplesMethodWithServiceResponseAsync(appId, versionId, modelId, skip, take);
    }

    /**
     * Gets the example utterances for the given intent or entity model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param modelId The ID (GUID) of the model.
     * @param skip The number of entries to skip. Default value is 0.
     * @param take The number of entries to return. Maximum page size is 500. Default is 100.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;LabelTextObject&gt; object
     */
    public Observable<ServiceResponse<List<LabelTextObject>>> examplesMethodWithServiceResponseAsync(UUID appId, String versionId, String modelId, Integer skip, Integer take) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (modelId == null) {
            throw new IllegalArgumentException("Parameter modelId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.examplesMethod(appId, versionId, modelId, skip, take, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<LabelTextObject>>>>() {
                @Override
                public Observable<ServiceResponse<List<LabelTextObject>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<LabelTextObject>> clientResponse = examplesMethodDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<LabelTextObject>> examplesMethodDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<LabelTextObject>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<LabelTextObject>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    @Override
    public ModelsExamplesMethodParameters examplesMethod() {
        return new ModelsExamplesMethodParameters(this);
    }

    /**
     * Internal class implementing ModelsExamplesMethodDefinition.
     */
    class ModelsExamplesMethodParameters implements ModelsExamplesMethodDefinition {
        private ModelsImpl parent;
        private UUID appId;
        private String versionId;
        private String modelId;
        private Integer skip;
        private Integer take;

        /**
         * Constructor.
         * @param parent the parent object.
         */
        ModelsExamplesMethodParameters(ModelsImpl parent) {
            this.parent = parent;
        }

        @Override
        public ModelsExamplesMethodParameters withAppId(UUID appId) {
            this.appId = appId;
            return this;
        }

        @Override
        public ModelsExamplesMethodParameters withVersionId(String versionId) {
            this.versionId = versionId;
            return this;
        }

        @Override
        public ModelsExamplesMethodParameters withModelId(String modelId) {
            this.modelId = modelId;
            return this;
        }

        @Override
        public ModelsExamplesMethodParameters withSkip(Integer skip) {
            this.skip = skip;
            return this;
        }

        @Override
        public ModelsExamplesMethodParameters withTake(Integer take) {
            this.take = take;
            return this;
        }

        @Override
        public List<LabelTextObject> execute() {
        return examplesMethodWithServiceResponseAsync(appId, versionId, modelId, skip, take).toBlocking().single().body();
    }

        @Override
        public Observable<List<LabelTextObject>> executeAsync() {
            return examplesMethodWithServiceResponseAsync(appId, versionId, modelId, skip, take).map(new Func1<ServiceResponse<List<LabelTextObject>>, List<LabelTextObject>>() {
                @Override
                public List<LabelTextObject> call(ServiceResponse<List<LabelTextObject>> response) {
                    return response.body();
                }
            });
        }
    }

    /**
     * Gets information about the intent model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param intentId The intent classifier ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IntentClassifier object if successful.
     */
    public IntentClassifier getIntent(UUID appId, String versionId, UUID intentId) {
        return getIntentWithServiceResponseAsync(appId, versionId, intentId).toBlocking().single().body();
    }

    /**
     * Gets information about the intent model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param intentId The intent classifier ID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IntentClassifier> getIntentAsync(UUID appId, String versionId, UUID intentId, final ServiceCallback<IntentClassifier> serviceCallback) {
        return ServiceFuture.fromResponse(getIntentWithServiceResponseAsync(appId, versionId, intentId), serviceCallback);
    }

    /**
     * Gets information about the intent model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param intentId The intent classifier ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IntentClassifier object
     */
    public Observable<IntentClassifier> getIntentAsync(UUID appId, String versionId, UUID intentId) {
        return getIntentWithServiceResponseAsync(appId, versionId, intentId).map(new Func1<ServiceResponse<IntentClassifier>, IntentClassifier>() {
            @Override
            public IntentClassifier call(ServiceResponse<IntentClassifier> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets information about the intent model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param intentId The intent classifier ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IntentClassifier object
     */
    public Observable<ServiceResponse<IntentClassifier>> getIntentWithServiceResponseAsync(UUID appId, String versionId, UUID intentId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (intentId == null) {
            throw new IllegalArgumentException("Parameter intentId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.getIntent(appId, versionId, intentId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IntentClassifier>>>() {
                @Override
                public Observable<ServiceResponse<IntentClassifier>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IntentClassifier> clientResponse = getIntentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<IntentClassifier> getIntentDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<IntentClassifier, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<IntentClassifier>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }


    /**
     * Updates the name of an intent in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param intentId The intent classifier ID.
     * @param updateIntentOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatus object if successful.
     */
    public OperationStatus updateIntent(UUID appId, String versionId, UUID intentId, UpdateIntentOptionalParameter updateIntentOptionalParameter) {
        return updateIntentWithServiceResponseAsync(appId, versionId, intentId, updateIntentOptionalParameter).toBlocking().single().body();
    }

    /**
     * Updates the name of an intent in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param intentId The intent classifier ID.
     * @param updateIntentOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatus> updateIntentAsync(UUID appId, String versionId, UUID intentId, UpdateIntentOptionalParameter updateIntentOptionalParameter, final ServiceCallback<OperationStatus> serviceCallback) {
        return ServiceFuture.fromResponse(updateIntentWithServiceResponseAsync(appId, versionId, intentId, updateIntentOptionalParameter), serviceCallback);
    }

    /**
     * Updates the name of an intent in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param intentId The intent classifier ID.
     * @param updateIntentOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<OperationStatus> updateIntentAsync(UUID appId, String versionId, UUID intentId, UpdateIntentOptionalParameter updateIntentOptionalParameter) {
        return updateIntentWithServiceResponseAsync(appId, versionId, intentId, updateIntentOptionalParameter).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
            @Override
            public OperationStatus call(ServiceResponse<OperationStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the name of an intent in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param intentId The intent classifier ID.
     * @param updateIntentOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> updateIntentWithServiceResponseAsync(UUID appId, String versionId, UUID intentId, UpdateIntentOptionalParameter updateIntentOptionalParameter) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (intentId == null) {
            throw new IllegalArgumentException("Parameter intentId is required and cannot be null.");
        }
        final String name = updateIntentOptionalParameter != null ? updateIntentOptionalParameter.name() : null;

        return updateIntentWithServiceResponseAsync(appId, versionId, intentId, name);
    }

    /**
     * Updates the name of an intent in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param intentId The intent classifier ID.
     * @param name The entity's new name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> updateIntentWithServiceResponseAsync(UUID appId, String versionId, UUID intentId, String name) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (intentId == null) {
            throw new IllegalArgumentException("Parameter intentId is required and cannot be null.");
        }
        ModelUpdateObject modelUpdateObject = new ModelUpdateObject();
        modelUpdateObject.withName(name);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.updateIntent(appId, versionId, intentId, this.client.acceptLanguage(), modelUpdateObject, parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatus>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatus> clientResponse = updateIntentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatus> updateIntentDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatus, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatus>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    @Override
    public ModelsUpdateIntentParameters updateIntent() {
        return new ModelsUpdateIntentParameters(this);
    }

    /**
     * Internal class implementing ModelsUpdateIntentDefinition.
     */
    class ModelsUpdateIntentParameters implements ModelsUpdateIntentDefinition {
        private ModelsImpl parent;
        private UUID appId;
        private String versionId;
        private UUID intentId;
        private String name;

        /**
         * Constructor.
         * @param parent the parent object.
         */
        ModelsUpdateIntentParameters(ModelsImpl parent) {
            this.parent = parent;
        }

        @Override
        public ModelsUpdateIntentParameters withAppId(UUID appId) {
            this.appId = appId;
            return this;
        }

        @Override
        public ModelsUpdateIntentParameters withVersionId(String versionId) {
            this.versionId = versionId;
            return this;
        }

        @Override
        public ModelsUpdateIntentParameters withIntentId(UUID intentId) {
            this.intentId = intentId;
            return this;
        }

        @Override
        public ModelsUpdateIntentParameters withName(String name) {
            this.name = name;
            return this;
        }

        @Override
        public OperationStatus execute() {
        return updateIntentWithServiceResponseAsync(appId, versionId, intentId, name).toBlocking().single().body();
    }

        @Override
        public Observable<OperationStatus> executeAsync() {
            return updateIntentWithServiceResponseAsync(appId, versionId, intentId, name).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
                @Override
                public OperationStatus call(ServiceResponse<OperationStatus> response) {
                    return response.body();
                }
            });
        }
    }


    /**
     * Deletes an intent from a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param intentId The intent classifier ID.
     * @param deleteIntentOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatus object if successful.
     */
    public OperationStatus deleteIntent(UUID appId, String versionId, UUID intentId, DeleteIntentOptionalParameter deleteIntentOptionalParameter) {
        return deleteIntentWithServiceResponseAsync(appId, versionId, intentId, deleteIntentOptionalParameter).toBlocking().single().body();
    }

    /**
     * Deletes an intent from a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param intentId The intent classifier ID.
     * @param deleteIntentOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatus> deleteIntentAsync(UUID appId, String versionId, UUID intentId, DeleteIntentOptionalParameter deleteIntentOptionalParameter, final ServiceCallback<OperationStatus> serviceCallback) {
        return ServiceFuture.fromResponse(deleteIntentWithServiceResponseAsync(appId, versionId, intentId, deleteIntentOptionalParameter), serviceCallback);
    }

    /**
     * Deletes an intent from a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param intentId The intent classifier ID.
     * @param deleteIntentOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<OperationStatus> deleteIntentAsync(UUID appId, String versionId, UUID intentId, DeleteIntentOptionalParameter deleteIntentOptionalParameter) {
        return deleteIntentWithServiceResponseAsync(appId, versionId, intentId, deleteIntentOptionalParameter).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
            @Override
            public OperationStatus call(ServiceResponse<OperationStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes an intent from a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param intentId The intent classifier ID.
     * @param deleteIntentOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> deleteIntentWithServiceResponseAsync(UUID appId, String versionId, UUID intentId, DeleteIntentOptionalParameter deleteIntentOptionalParameter) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (intentId == null) {
            throw new IllegalArgumentException("Parameter intentId is required and cannot be null.");
        }
        final Boolean deleteUtterances = deleteIntentOptionalParameter != null ? deleteIntentOptionalParameter.deleteUtterances() : null;

        return deleteIntentWithServiceResponseAsync(appId, versionId, intentId, deleteUtterances);
    }

    /**
     * Deletes an intent from a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param intentId The intent classifier ID.
     * @param deleteUtterances If true, deletes the intent's example utterances. If false, moves the example utterances to the None intent. The default value is false.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> deleteIntentWithServiceResponseAsync(UUID appId, String versionId, UUID intentId, Boolean deleteUtterances) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (intentId == null) {
            throw new IllegalArgumentException("Parameter intentId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.deleteIntent(appId, versionId, intentId, deleteUtterances, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatus>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatus> clientResponse = deleteIntentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatus> deleteIntentDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatus, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatus>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    @Override
    public ModelsDeleteIntentParameters deleteIntent() {
        return new ModelsDeleteIntentParameters(this);
    }

    /**
     * Internal class implementing ModelsDeleteIntentDefinition.
     */
    class ModelsDeleteIntentParameters implements ModelsDeleteIntentDefinition {
        private ModelsImpl parent;
        private UUID appId;
        private String versionId;
        private UUID intentId;
        private Boolean deleteUtterances;

        /**
         * Constructor.
         * @param parent the parent object.
         */
        ModelsDeleteIntentParameters(ModelsImpl parent) {
            this.parent = parent;
        }

        @Override
        public ModelsDeleteIntentParameters withAppId(UUID appId) {
            this.appId = appId;
            return this;
        }

        @Override
        public ModelsDeleteIntentParameters withVersionId(String versionId) {
            this.versionId = versionId;
            return this;
        }

        @Override
        public ModelsDeleteIntentParameters withIntentId(UUID intentId) {
            this.intentId = intentId;
            return this;
        }

        @Override
        public ModelsDeleteIntentParameters withDeleteUtterances(Boolean deleteUtterances) {
            this.deleteUtterances = deleteUtterances;
            return this;
        }

        @Override
        public OperationStatus execute() {
        return deleteIntentWithServiceResponseAsync(appId, versionId, intentId, deleteUtterances).toBlocking().single().body();
    }

        @Override
        public Observable<OperationStatus> executeAsync() {
            return deleteIntentWithServiceResponseAsync(appId, versionId, intentId, deleteUtterances).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
                @Override
                public OperationStatus call(ServiceResponse<OperationStatus> response) {
                    return response.body();
                }
            });
        }
    }

    /**
     * Gets information about an entity model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity extractor ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the NDepthEntityExtractor object if successful.
     */
    public NDepthEntityExtractor getEntity(UUID appId, String versionId, UUID entityId) {
        return getEntityWithServiceResponseAsync(appId, versionId, entityId).toBlocking().single().body();
    }

    /**
     * Gets information about an entity model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity extractor ID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<NDepthEntityExtractor> getEntityAsync(UUID appId, String versionId, UUID entityId, final ServiceCallback<NDepthEntityExtractor> serviceCallback) {
        return ServiceFuture.fromResponse(getEntityWithServiceResponseAsync(appId, versionId, entityId), serviceCallback);
    }

    /**
     * Gets information about an entity model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity extractor ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the NDepthEntityExtractor object
     */
    public Observable<NDepthEntityExtractor> getEntityAsync(UUID appId, String versionId, UUID entityId) {
        return getEntityWithServiceResponseAsync(appId, versionId, entityId).map(new Func1<ServiceResponse<NDepthEntityExtractor>, NDepthEntityExtractor>() {
            @Override
            public NDepthEntityExtractor call(ServiceResponse<NDepthEntityExtractor> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets information about an entity model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity extractor ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the NDepthEntityExtractor object
     */
    public Observable<ServiceResponse<NDepthEntityExtractor>> getEntityWithServiceResponseAsync(UUID appId, String versionId, UUID entityId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.getEntity(appId, versionId, entityId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<NDepthEntityExtractor>>>() {
                @Override
                public Observable<ServiceResponse<NDepthEntityExtractor>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<NDepthEntityExtractor> clientResponse = getEntityDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<NDepthEntityExtractor> getEntityDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<NDepthEntityExtractor, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<NDepthEntityExtractor>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Deletes an entity or a child from a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity extractor or the child entity extractor ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatus object if successful.
     */
    public OperationStatus deleteEntity(UUID appId, String versionId, UUID entityId) {
        return deleteEntityWithServiceResponseAsync(appId, versionId, entityId).toBlocking().single().body();
    }

    /**
     * Deletes an entity or a child from a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity extractor or the child entity extractor ID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatus> deleteEntityAsync(UUID appId, String versionId, UUID entityId, final ServiceCallback<OperationStatus> serviceCallback) {
        return ServiceFuture.fromResponse(deleteEntityWithServiceResponseAsync(appId, versionId, entityId), serviceCallback);
    }

    /**
     * Deletes an entity or a child from a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity extractor or the child entity extractor ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<OperationStatus> deleteEntityAsync(UUID appId, String versionId, UUID entityId) {
        return deleteEntityWithServiceResponseAsync(appId, versionId, entityId).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
            @Override
            public OperationStatus call(ServiceResponse<OperationStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes an entity or a child from a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity extractor or the child entity extractor ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> deleteEntityWithServiceResponseAsync(UUID appId, String versionId, UUID entityId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.deleteEntity(appId, versionId, entityId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatus>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatus> clientResponse = deleteEntityDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatus> deleteEntityDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatus, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatus>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Updates the name of an entity extractor or the name and instanceOf model of a child entity extractor.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity extractor or the child entity extractor ID.
     * @param entityModelUpdateObject A model object containing the name new entity extractor or the name and instance of model of a child entity extractor
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatus object if successful.
     */
    public OperationStatus updateEntityChild(UUID appId, String versionId, UUID entityId, EntityModelUpdateObject entityModelUpdateObject) {
        return updateEntityChildWithServiceResponseAsync(appId, versionId, entityId, entityModelUpdateObject).toBlocking().single().body();
    }

    /**
     * Updates the name of an entity extractor or the name and instanceOf model of a child entity extractor.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity extractor or the child entity extractor ID.
     * @param entityModelUpdateObject A model object containing the name new entity extractor or the name and instance of model of a child entity extractor
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatus> updateEntityChildAsync(UUID appId, String versionId, UUID entityId, EntityModelUpdateObject entityModelUpdateObject, final ServiceCallback<OperationStatus> serviceCallback) {
        return ServiceFuture.fromResponse(updateEntityChildWithServiceResponseAsync(appId, versionId, entityId, entityModelUpdateObject), serviceCallback);
    }

    /**
     * Updates the name of an entity extractor or the name and instanceOf model of a child entity extractor.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity extractor or the child entity extractor ID.
     * @param entityModelUpdateObject A model object containing the name new entity extractor or the name and instance of model of a child entity extractor
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<OperationStatus> updateEntityChildAsync(UUID appId, String versionId, UUID entityId, EntityModelUpdateObject entityModelUpdateObject) {
        return updateEntityChildWithServiceResponseAsync(appId, versionId, entityId, entityModelUpdateObject).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
            @Override
            public OperationStatus call(ServiceResponse<OperationStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the name of an entity extractor or the name and instanceOf model of a child entity extractor.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity extractor or the child entity extractor ID.
     * @param entityModelUpdateObject A model object containing the name new entity extractor or the name and instance of model of a child entity extractor
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> updateEntityChildWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, EntityModelUpdateObject entityModelUpdateObject) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        if (entityModelUpdateObject == null) {
            throw new IllegalArgumentException("Parameter entityModelUpdateObject is required and cannot be null.");
        }
        Validator.validate(entityModelUpdateObject);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.updateEntityChild(appId, versionId, entityId, entityModelUpdateObject, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatus>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatus> clientResponse = updateEntityChildDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatus> updateEntityChildDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatus, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatus>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Gets the information of the features used by the intent in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param intentId The intent classifier ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ModelFeatureInformation&gt; object if successful.
     */
    public List<ModelFeatureInformation> getIntentFeatures(UUID appId, String versionId, UUID intentId) {
        return getIntentFeaturesWithServiceResponseAsync(appId, versionId, intentId).toBlocking().single().body();
    }

    /**
     * Gets the information of the features used by the intent in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param intentId The intent classifier ID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ModelFeatureInformation>> getIntentFeaturesAsync(UUID appId, String versionId, UUID intentId, final ServiceCallback<List<ModelFeatureInformation>> serviceCallback) {
        return ServiceFuture.fromResponse(getIntentFeaturesWithServiceResponseAsync(appId, versionId, intentId), serviceCallback);
    }

    /**
     * Gets the information of the features used by the intent in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param intentId The intent classifier ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ModelFeatureInformation&gt; object
     */
    public Observable<List<ModelFeatureInformation>> getIntentFeaturesAsync(UUID appId, String versionId, UUID intentId) {
        return getIntentFeaturesWithServiceResponseAsync(appId, versionId, intentId).map(new Func1<ServiceResponse<List<ModelFeatureInformation>>, List<ModelFeatureInformation>>() {
            @Override
            public List<ModelFeatureInformation> call(ServiceResponse<List<ModelFeatureInformation>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the information of the features used by the intent in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param intentId The intent classifier ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ModelFeatureInformation&gt; object
     */
    public Observable<ServiceResponse<List<ModelFeatureInformation>>> getIntentFeaturesWithServiceResponseAsync(UUID appId, String versionId, UUID intentId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (intentId == null) {
            throw new IllegalArgumentException("Parameter intentId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.getIntentFeatures(appId, versionId, intentId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ModelFeatureInformation>>>>() {
                @Override
                public Observable<ServiceResponse<List<ModelFeatureInformation>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<ModelFeatureInformation>> clientResponse = getIntentFeaturesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<ModelFeatureInformation>> getIntentFeaturesDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<ModelFeatureInformation>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<ModelFeatureInformation>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Updates the information of the features used by the intent in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param intentId The intent classifier ID.
     * @param featureRelationsUpdateObject A list of feature information objects containing the new feature relations.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatus object if successful.
     */
    public OperationStatus replaceIntentFeatures(UUID appId, String versionId, UUID intentId, List<ModelFeatureInformation> featureRelationsUpdateObject) {
        return replaceIntentFeaturesWithServiceResponseAsync(appId, versionId, intentId, featureRelationsUpdateObject).toBlocking().single().body();
    }

    /**
     * Updates the information of the features used by the intent in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param intentId The intent classifier ID.
     * @param featureRelationsUpdateObject A list of feature information objects containing the new feature relations.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatus> replaceIntentFeaturesAsync(UUID appId, String versionId, UUID intentId, List<ModelFeatureInformation> featureRelationsUpdateObject, final ServiceCallback<OperationStatus> serviceCallback) {
        return ServiceFuture.fromResponse(replaceIntentFeaturesWithServiceResponseAsync(appId, versionId, intentId, featureRelationsUpdateObject), serviceCallback);
    }

    /**
     * Updates the information of the features used by the intent in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param intentId The intent classifier ID.
     * @param featureRelationsUpdateObject A list of feature information objects containing the new feature relations.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<OperationStatus> replaceIntentFeaturesAsync(UUID appId, String versionId, UUID intentId, List<ModelFeatureInformation> featureRelationsUpdateObject) {
        return replaceIntentFeaturesWithServiceResponseAsync(appId, versionId, intentId, featureRelationsUpdateObject).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
            @Override
            public OperationStatus call(ServiceResponse<OperationStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the information of the features used by the intent in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param intentId The intent classifier ID.
     * @param featureRelationsUpdateObject A list of feature information objects containing the new feature relations.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> replaceIntentFeaturesWithServiceResponseAsync(UUID appId, String versionId, UUID intentId, List<ModelFeatureInformation> featureRelationsUpdateObject) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (intentId == null) {
            throw new IllegalArgumentException("Parameter intentId is required and cannot be null.");
        }
        if (featureRelationsUpdateObject == null) {
            throw new IllegalArgumentException("Parameter featureRelationsUpdateObject is required and cannot be null.");
        }
        Validator.validate(featureRelationsUpdateObject);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.replaceIntentFeatures(appId, versionId, intentId, featureRelationsUpdateObject, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatus>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatus> clientResponse = replaceIntentFeaturesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatus> replaceIntentFeaturesDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatus, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatus>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Deletes a relation from the feature relations used by the intent in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param intentId The intent classifier ID.
     * @param featureRelationDeleteObject A feature information object containing the feature relation to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatus object if successful.
     */
    public OperationStatus deleteIntentFeature(UUID appId, String versionId, UUID intentId, ModelFeatureInformation featureRelationDeleteObject) {
        return deleteIntentFeatureWithServiceResponseAsync(appId, versionId, intentId, featureRelationDeleteObject).toBlocking().single().body();
    }

    /**
     * Deletes a relation from the feature relations used by the intent in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param intentId The intent classifier ID.
     * @param featureRelationDeleteObject A feature information object containing the feature relation to delete.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatus> deleteIntentFeatureAsync(UUID appId, String versionId, UUID intentId, ModelFeatureInformation featureRelationDeleteObject, final ServiceCallback<OperationStatus> serviceCallback) {
        return ServiceFuture.fromResponse(deleteIntentFeatureWithServiceResponseAsync(appId, versionId, intentId, featureRelationDeleteObject), serviceCallback);
    }

    /**
     * Deletes a relation from the feature relations used by the intent in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param intentId The intent classifier ID.
     * @param featureRelationDeleteObject A feature information object containing the feature relation to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<OperationStatus> deleteIntentFeatureAsync(UUID appId, String versionId, UUID intentId, ModelFeatureInformation featureRelationDeleteObject) {
        return deleteIntentFeatureWithServiceResponseAsync(appId, versionId, intentId, featureRelationDeleteObject).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
            @Override
            public OperationStatus call(ServiceResponse<OperationStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a relation from the feature relations used by the intent in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param intentId The intent classifier ID.
     * @param featureRelationDeleteObject A feature information object containing the feature relation to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> deleteIntentFeatureWithServiceResponseAsync(UUID appId, String versionId, UUID intentId, ModelFeatureInformation featureRelationDeleteObject) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (intentId == null) {
            throw new IllegalArgumentException("Parameter intentId is required and cannot be null.");
        }
        if (featureRelationDeleteObject == null) {
            throw new IllegalArgumentException("Parameter featureRelationDeleteObject is required and cannot be null.");
        }
        Validator.validate(featureRelationDeleteObject);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.deleteIntentFeature(appId, versionId, intentId, featureRelationDeleteObject, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatus>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatus> clientResponse = deleteIntentFeatureDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatus> deleteIntentFeatureDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatus, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatus>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Gets the information of the features used by the entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity extractor ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ModelFeatureInformation&gt; object if successful.
     */
    public List<ModelFeatureInformation> getEntityFeatures(UUID appId, String versionId, UUID entityId) {
        return getEntityFeaturesWithServiceResponseAsync(appId, versionId, entityId).toBlocking().single().body();
    }

    /**
     * Gets the information of the features used by the entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity extractor ID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ModelFeatureInformation>> getEntityFeaturesAsync(UUID appId, String versionId, UUID entityId, final ServiceCallback<List<ModelFeatureInformation>> serviceCallback) {
        return ServiceFuture.fromResponse(getEntityFeaturesWithServiceResponseAsync(appId, versionId, entityId), serviceCallback);
    }

    /**
     * Gets the information of the features used by the entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity extractor ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ModelFeatureInformation&gt; object
     */
    public Observable<List<ModelFeatureInformation>> getEntityFeaturesAsync(UUID appId, String versionId, UUID entityId) {
        return getEntityFeaturesWithServiceResponseAsync(appId, versionId, entityId).map(new Func1<ServiceResponse<List<ModelFeatureInformation>>, List<ModelFeatureInformation>>() {
            @Override
            public List<ModelFeatureInformation> call(ServiceResponse<List<ModelFeatureInformation>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the information of the features used by the entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity extractor ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ModelFeatureInformation&gt; object
     */
    public Observable<ServiceResponse<List<ModelFeatureInformation>>> getEntityFeaturesWithServiceResponseAsync(UUID appId, String versionId, UUID entityId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.getEntityFeatures(appId, versionId, entityId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ModelFeatureInformation>>>>() {
                @Override
                public Observable<ServiceResponse<List<ModelFeatureInformation>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<ModelFeatureInformation>> clientResponse = getEntityFeaturesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<ModelFeatureInformation>> getEntityFeaturesDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<ModelFeatureInformation>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<ModelFeatureInformation>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Updates the information of the features used by the entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity extractor ID.
     * @param featureRelationsUpdateObject A list of feature information objects containing the new feature relations.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatus object if successful.
     */
    public OperationStatus replaceEntityFeatures(UUID appId, String versionId, UUID entityId, List<ModelFeatureInformation> featureRelationsUpdateObject) {
        return replaceEntityFeaturesWithServiceResponseAsync(appId, versionId, entityId, featureRelationsUpdateObject).toBlocking().single().body();
    }

    /**
     * Updates the information of the features used by the entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity extractor ID.
     * @param featureRelationsUpdateObject A list of feature information objects containing the new feature relations.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatus> replaceEntityFeaturesAsync(UUID appId, String versionId, UUID entityId, List<ModelFeatureInformation> featureRelationsUpdateObject, final ServiceCallback<OperationStatus> serviceCallback) {
        return ServiceFuture.fromResponse(replaceEntityFeaturesWithServiceResponseAsync(appId, versionId, entityId, featureRelationsUpdateObject), serviceCallback);
    }

    /**
     * Updates the information of the features used by the entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity extractor ID.
     * @param featureRelationsUpdateObject A list of feature information objects containing the new feature relations.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<OperationStatus> replaceEntityFeaturesAsync(UUID appId, String versionId, UUID entityId, List<ModelFeatureInformation> featureRelationsUpdateObject) {
        return replaceEntityFeaturesWithServiceResponseAsync(appId, versionId, entityId, featureRelationsUpdateObject).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
            @Override
            public OperationStatus call(ServiceResponse<OperationStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the information of the features used by the entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity extractor ID.
     * @param featureRelationsUpdateObject A list of feature information objects containing the new feature relations.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> replaceEntityFeaturesWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, List<ModelFeatureInformation> featureRelationsUpdateObject) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        if (featureRelationsUpdateObject == null) {
            throw new IllegalArgumentException("Parameter featureRelationsUpdateObject is required and cannot be null.");
        }
        Validator.validate(featureRelationsUpdateObject);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.replaceEntityFeatures(appId, versionId, entityId, featureRelationsUpdateObject, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatus>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatus> clientResponse = replaceEntityFeaturesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatus> replaceEntityFeaturesDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatus, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatus>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Deletes a relation from the feature relations used by the entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity extractor ID.
     * @param featureRelationDeleteObject A feature information object containing the feature relation to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatus object if successful.
     */
    public OperationStatus deleteEntityFeature(UUID appId, String versionId, UUID entityId, ModelFeatureInformation featureRelationDeleteObject) {
        return deleteEntityFeatureWithServiceResponseAsync(appId, versionId, entityId, featureRelationDeleteObject).toBlocking().single().body();
    }

    /**
     * Deletes a relation from the feature relations used by the entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity extractor ID.
     * @param featureRelationDeleteObject A feature information object containing the feature relation to delete.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatus> deleteEntityFeatureAsync(UUID appId, String versionId, UUID entityId, ModelFeatureInformation featureRelationDeleteObject, final ServiceCallback<OperationStatus> serviceCallback) {
        return ServiceFuture.fromResponse(deleteEntityFeatureWithServiceResponseAsync(appId, versionId, entityId, featureRelationDeleteObject), serviceCallback);
    }

    /**
     * Deletes a relation from the feature relations used by the entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity extractor ID.
     * @param featureRelationDeleteObject A feature information object containing the feature relation to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<OperationStatus> deleteEntityFeatureAsync(UUID appId, String versionId, UUID entityId, ModelFeatureInformation featureRelationDeleteObject) {
        return deleteEntityFeatureWithServiceResponseAsync(appId, versionId, entityId, featureRelationDeleteObject).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
            @Override
            public OperationStatus call(ServiceResponse<OperationStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a relation from the feature relations used by the entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity extractor ID.
     * @param featureRelationDeleteObject A feature information object containing the feature relation to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> deleteEntityFeatureWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, ModelFeatureInformation featureRelationDeleteObject) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        if (featureRelationDeleteObject == null) {
            throw new IllegalArgumentException("Parameter featureRelationDeleteObject is required and cannot be null.");
        }
        Validator.validate(featureRelationDeleteObject);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.deleteEntityFeature(appId, versionId, entityId, featureRelationDeleteObject, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatus>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatus> clientResponse = deleteEntityFeatureDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatus> deleteEntityFeatureDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatus, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatus>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Gets information about a hierarchical entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param hEntityId The hierarchical entity extractor ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HierarchicalEntityExtractor object if successful.
     */
    public HierarchicalEntityExtractor getHierarchicalEntity(UUID appId, String versionId, UUID hEntityId) {
        return getHierarchicalEntityWithServiceResponseAsync(appId, versionId, hEntityId).toBlocking().single().body();
    }

    /**
     * Gets information about a hierarchical entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param hEntityId The hierarchical entity extractor ID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HierarchicalEntityExtractor> getHierarchicalEntityAsync(UUID appId, String versionId, UUID hEntityId, final ServiceCallback<HierarchicalEntityExtractor> serviceCallback) {
        return ServiceFuture.fromResponse(getHierarchicalEntityWithServiceResponseAsync(appId, versionId, hEntityId), serviceCallback);
    }

    /**
     * Gets information about a hierarchical entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param hEntityId The hierarchical entity extractor ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HierarchicalEntityExtractor object
     */
    public Observable<HierarchicalEntityExtractor> getHierarchicalEntityAsync(UUID appId, String versionId, UUID hEntityId) {
        return getHierarchicalEntityWithServiceResponseAsync(appId, versionId, hEntityId).map(new Func1<ServiceResponse<HierarchicalEntityExtractor>, HierarchicalEntityExtractor>() {
            @Override
            public HierarchicalEntityExtractor call(ServiceResponse<HierarchicalEntityExtractor> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets information about a hierarchical entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param hEntityId The hierarchical entity extractor ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HierarchicalEntityExtractor object
     */
    public Observable<ServiceResponse<HierarchicalEntityExtractor>> getHierarchicalEntityWithServiceResponseAsync(UUID appId, String versionId, UUID hEntityId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (hEntityId == null) {
            throw new IllegalArgumentException("Parameter hEntityId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.getHierarchicalEntity(appId, versionId, hEntityId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HierarchicalEntityExtractor>>>() {
                @Override
                public Observable<ServiceResponse<HierarchicalEntityExtractor>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HierarchicalEntityExtractor> clientResponse = getHierarchicalEntityDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HierarchicalEntityExtractor> getHierarchicalEntityDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<HierarchicalEntityExtractor, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<HierarchicalEntityExtractor>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }


    /**
     * Updates the name of a hierarchical entity model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param hEntityId The hierarchical entity extractor ID.
     * @param updateHierarchicalEntityOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatus object if successful.
     */
    public OperationStatus updateHierarchicalEntity(UUID appId, String versionId, UUID hEntityId, UpdateHierarchicalEntityOptionalParameter updateHierarchicalEntityOptionalParameter) {
        return updateHierarchicalEntityWithServiceResponseAsync(appId, versionId, hEntityId, updateHierarchicalEntityOptionalParameter).toBlocking().single().body();
    }

    /**
     * Updates the name of a hierarchical entity model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param hEntityId The hierarchical entity extractor ID.
     * @param updateHierarchicalEntityOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatus> updateHierarchicalEntityAsync(UUID appId, String versionId, UUID hEntityId, UpdateHierarchicalEntityOptionalParameter updateHierarchicalEntityOptionalParameter, final ServiceCallback<OperationStatus> serviceCallback) {
        return ServiceFuture.fromResponse(updateHierarchicalEntityWithServiceResponseAsync(appId, versionId, hEntityId, updateHierarchicalEntityOptionalParameter), serviceCallback);
    }

    /**
     * Updates the name of a hierarchical entity model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param hEntityId The hierarchical entity extractor ID.
     * @param updateHierarchicalEntityOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<OperationStatus> updateHierarchicalEntityAsync(UUID appId, String versionId, UUID hEntityId, UpdateHierarchicalEntityOptionalParameter updateHierarchicalEntityOptionalParameter) {
        return updateHierarchicalEntityWithServiceResponseAsync(appId, versionId, hEntityId, updateHierarchicalEntityOptionalParameter).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
            @Override
            public OperationStatus call(ServiceResponse<OperationStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the name of a hierarchical entity model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param hEntityId The hierarchical entity extractor ID.
     * @param updateHierarchicalEntityOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> updateHierarchicalEntityWithServiceResponseAsync(UUID appId, String versionId, UUID hEntityId, UpdateHierarchicalEntityOptionalParameter updateHierarchicalEntityOptionalParameter) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (hEntityId == null) {
            throw new IllegalArgumentException("Parameter hEntityId is required and cannot be null.");
        }
        final String name = updateHierarchicalEntityOptionalParameter != null ? updateHierarchicalEntityOptionalParameter.name() : null;

        return updateHierarchicalEntityWithServiceResponseAsync(appId, versionId, hEntityId, name);
    }

    /**
     * Updates the name of a hierarchical entity model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param hEntityId The hierarchical entity extractor ID.
     * @param name The entity's new name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> updateHierarchicalEntityWithServiceResponseAsync(UUID appId, String versionId, UUID hEntityId, String name) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (hEntityId == null) {
            throw new IllegalArgumentException("Parameter hEntityId is required and cannot be null.");
        }
        ModelUpdateObject modelUpdateObject = new ModelUpdateObject();
        modelUpdateObject.withName(name);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.updateHierarchicalEntity(appId, versionId, hEntityId, this.client.acceptLanguage(), modelUpdateObject, parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatus>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatus> clientResponse = updateHierarchicalEntityDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatus> updateHierarchicalEntityDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatus, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatus>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    @Override
    public ModelsUpdateHierarchicalEntityParameters updateHierarchicalEntity() {
        return new ModelsUpdateHierarchicalEntityParameters(this);
    }

    /**
     * Internal class implementing ModelsUpdateHierarchicalEntityDefinition.
     */
    class ModelsUpdateHierarchicalEntityParameters implements ModelsUpdateHierarchicalEntityDefinition {
        private ModelsImpl parent;
        private UUID appId;
        private String versionId;
        private UUID hEntityId;
        private String name;

        /**
         * Constructor.
         * @param parent the parent object.
         */
        ModelsUpdateHierarchicalEntityParameters(ModelsImpl parent) {
            this.parent = parent;
        }

        @Override
        public ModelsUpdateHierarchicalEntityParameters withAppId(UUID appId) {
            this.appId = appId;
            return this;
        }

        @Override
        public ModelsUpdateHierarchicalEntityParameters withVersionId(String versionId) {
            this.versionId = versionId;
            return this;
        }

        @Override
        public ModelsUpdateHierarchicalEntityParameters withHEntityId(UUID hEntityId) {
            this.hEntityId = hEntityId;
            return this;
        }

        @Override
        public ModelsUpdateHierarchicalEntityParameters withName(String name) {
            this.name = name;
            return this;
        }

        @Override
        public OperationStatus execute() {
        return updateHierarchicalEntityWithServiceResponseAsync(appId, versionId, hEntityId, name).toBlocking().single().body();
    }

        @Override
        public Observable<OperationStatus> executeAsync() {
            return updateHierarchicalEntityWithServiceResponseAsync(appId, versionId, hEntityId, name).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
                @Override
                public OperationStatus call(ServiceResponse<OperationStatus> response) {
                    return response.body();
                }
            });
        }
    }

    /**
     * Deletes a hierarchical entity from a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param hEntityId The hierarchical entity extractor ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatus object if successful.
     */
    public OperationStatus deleteHierarchicalEntity(UUID appId, String versionId, UUID hEntityId) {
        return deleteHierarchicalEntityWithServiceResponseAsync(appId, versionId, hEntityId).toBlocking().single().body();
    }

    /**
     * Deletes a hierarchical entity from a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param hEntityId The hierarchical entity extractor ID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatus> deleteHierarchicalEntityAsync(UUID appId, String versionId, UUID hEntityId, final ServiceCallback<OperationStatus> serviceCallback) {
        return ServiceFuture.fromResponse(deleteHierarchicalEntityWithServiceResponseAsync(appId, versionId, hEntityId), serviceCallback);
    }

    /**
     * Deletes a hierarchical entity from a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param hEntityId The hierarchical entity extractor ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<OperationStatus> deleteHierarchicalEntityAsync(UUID appId, String versionId, UUID hEntityId) {
        return deleteHierarchicalEntityWithServiceResponseAsync(appId, versionId, hEntityId).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
            @Override
            public OperationStatus call(ServiceResponse<OperationStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a hierarchical entity from a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param hEntityId The hierarchical entity extractor ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> deleteHierarchicalEntityWithServiceResponseAsync(UUID appId, String versionId, UUID hEntityId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (hEntityId == null) {
            throw new IllegalArgumentException("Parameter hEntityId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.deleteHierarchicalEntity(appId, versionId, hEntityId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatus>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatus> clientResponse = deleteHierarchicalEntityDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatus> deleteHierarchicalEntityDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatus, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatus>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Gets information about a composite entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param cEntityId The composite entity extractor ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the CompositeEntityExtractor object if successful.
     */
    public CompositeEntityExtractor getCompositeEntity(UUID appId, String versionId, UUID cEntityId) {
        return getCompositeEntityWithServiceResponseAsync(appId, versionId, cEntityId).toBlocking().single().body();
    }

    /**
     * Gets information about a composite entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param cEntityId The composite entity extractor ID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<CompositeEntityExtractor> getCompositeEntityAsync(UUID appId, String versionId, UUID cEntityId, final ServiceCallback<CompositeEntityExtractor> serviceCallback) {
        return ServiceFuture.fromResponse(getCompositeEntityWithServiceResponseAsync(appId, versionId, cEntityId), serviceCallback);
    }

    /**
     * Gets information about a composite entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param cEntityId The composite entity extractor ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CompositeEntityExtractor object
     */
    public Observable<CompositeEntityExtractor> getCompositeEntityAsync(UUID appId, String versionId, UUID cEntityId) {
        return getCompositeEntityWithServiceResponseAsync(appId, versionId, cEntityId).map(new Func1<ServiceResponse<CompositeEntityExtractor>, CompositeEntityExtractor>() {
            @Override
            public CompositeEntityExtractor call(ServiceResponse<CompositeEntityExtractor> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets information about a composite entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param cEntityId The composite entity extractor ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CompositeEntityExtractor object
     */
    public Observable<ServiceResponse<CompositeEntityExtractor>> getCompositeEntityWithServiceResponseAsync(UUID appId, String versionId, UUID cEntityId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (cEntityId == null) {
            throw new IllegalArgumentException("Parameter cEntityId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.getCompositeEntity(appId, versionId, cEntityId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<CompositeEntityExtractor>>>() {
                @Override
                public Observable<ServiceResponse<CompositeEntityExtractor>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<CompositeEntityExtractor> clientResponse = getCompositeEntityDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<CompositeEntityExtractor> getCompositeEntityDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<CompositeEntityExtractor, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<CompositeEntityExtractor>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Updates a composite entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param cEntityId The composite entity extractor ID.
     * @param compositeModelUpdateObject A model object containing the new entity extractor name and children.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatus object if successful.
     */
    public OperationStatus updateCompositeEntity(UUID appId, String versionId, UUID cEntityId, CompositeEntityModel compositeModelUpdateObject) {
        return updateCompositeEntityWithServiceResponseAsync(appId, versionId, cEntityId, compositeModelUpdateObject).toBlocking().single().body();
    }

    /**
     * Updates a composite entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param cEntityId The composite entity extractor ID.
     * @param compositeModelUpdateObject A model object containing the new entity extractor name and children.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatus> updateCompositeEntityAsync(UUID appId, String versionId, UUID cEntityId, CompositeEntityModel compositeModelUpdateObject, final ServiceCallback<OperationStatus> serviceCallback) {
        return ServiceFuture.fromResponse(updateCompositeEntityWithServiceResponseAsync(appId, versionId, cEntityId, compositeModelUpdateObject), serviceCallback);
    }

    /**
     * Updates a composite entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param cEntityId The composite entity extractor ID.
     * @param compositeModelUpdateObject A model object containing the new entity extractor name and children.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<OperationStatus> updateCompositeEntityAsync(UUID appId, String versionId, UUID cEntityId, CompositeEntityModel compositeModelUpdateObject) {
        return updateCompositeEntityWithServiceResponseAsync(appId, versionId, cEntityId, compositeModelUpdateObject).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
            @Override
            public OperationStatus call(ServiceResponse<OperationStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates a composite entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param cEntityId The composite entity extractor ID.
     * @param compositeModelUpdateObject A model object containing the new entity extractor name and children.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> updateCompositeEntityWithServiceResponseAsync(UUID appId, String versionId, UUID cEntityId, CompositeEntityModel compositeModelUpdateObject) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (cEntityId == null) {
            throw new IllegalArgumentException("Parameter cEntityId is required and cannot be null.");
        }
        if (compositeModelUpdateObject == null) {
            throw new IllegalArgumentException("Parameter compositeModelUpdateObject is required and cannot be null.");
        }
        Validator.validate(compositeModelUpdateObject);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.updateCompositeEntity(appId, versionId, cEntityId, compositeModelUpdateObject, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatus>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatus> clientResponse = updateCompositeEntityDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatus> updateCompositeEntityDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatus, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatus>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Deletes a composite entity from a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param cEntityId The composite entity extractor ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatus object if successful.
     */
    public OperationStatus deleteCompositeEntity(UUID appId, String versionId, UUID cEntityId) {
        return deleteCompositeEntityWithServiceResponseAsync(appId, versionId, cEntityId).toBlocking().single().body();
    }

    /**
     * Deletes a composite entity from a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param cEntityId The composite entity extractor ID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatus> deleteCompositeEntityAsync(UUID appId, String versionId, UUID cEntityId, final ServiceCallback<OperationStatus> serviceCallback) {
        return ServiceFuture.fromResponse(deleteCompositeEntityWithServiceResponseAsync(appId, versionId, cEntityId), serviceCallback);
    }

    /**
     * Deletes a composite entity from a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param cEntityId The composite entity extractor ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<OperationStatus> deleteCompositeEntityAsync(UUID appId, String versionId, UUID cEntityId) {
        return deleteCompositeEntityWithServiceResponseAsync(appId, versionId, cEntityId).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
            @Override
            public OperationStatus call(ServiceResponse<OperationStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a composite entity from a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param cEntityId The composite entity extractor ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> deleteCompositeEntityWithServiceResponseAsync(UUID appId, String versionId, UUID cEntityId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (cEntityId == null) {
            throw new IllegalArgumentException("Parameter cEntityId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.deleteCompositeEntity(appId, versionId, cEntityId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatus>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatus> clientResponse = deleteCompositeEntityDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatus> deleteCompositeEntityDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatus, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatus>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Gets information about a list entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param clEntityId The list model ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ClosedListEntityExtractor object if successful.
     */
    public ClosedListEntityExtractor getClosedList(UUID appId, String versionId, UUID clEntityId) {
        return getClosedListWithServiceResponseAsync(appId, versionId, clEntityId).toBlocking().single().body();
    }

    /**
     * Gets information about a list entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param clEntityId The list model ID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ClosedListEntityExtractor> getClosedListAsync(UUID appId, String versionId, UUID clEntityId, final ServiceCallback<ClosedListEntityExtractor> serviceCallback) {
        return ServiceFuture.fromResponse(getClosedListWithServiceResponseAsync(appId, versionId, clEntityId), serviceCallback);
    }

    /**
     * Gets information about a list entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param clEntityId The list model ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ClosedListEntityExtractor object
     */
    public Observable<ClosedListEntityExtractor> getClosedListAsync(UUID appId, String versionId, UUID clEntityId) {
        return getClosedListWithServiceResponseAsync(appId, versionId, clEntityId).map(new Func1<ServiceResponse<ClosedListEntityExtractor>, ClosedListEntityExtractor>() {
            @Override
            public ClosedListEntityExtractor call(ServiceResponse<ClosedListEntityExtractor> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets information about a list entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param clEntityId The list model ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ClosedListEntityExtractor object
     */
    public Observable<ServiceResponse<ClosedListEntityExtractor>> getClosedListWithServiceResponseAsync(UUID appId, String versionId, UUID clEntityId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (clEntityId == null) {
            throw new IllegalArgumentException("Parameter clEntityId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.getClosedList(appId, versionId, clEntityId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ClosedListEntityExtractor>>>() {
                @Override
                public Observable<ServiceResponse<ClosedListEntityExtractor>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ClosedListEntityExtractor> clientResponse = getClosedListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ClosedListEntityExtractor> getClosedListDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ClosedListEntityExtractor, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ClosedListEntityExtractor>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Updates the list entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param clEntityId The list model ID.
     * @param closedListModelUpdateObject The new list entity name and words list.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatus object if successful.
     */
    public OperationStatus updateClosedList(UUID appId, String versionId, UUID clEntityId, ClosedListModelUpdateObject closedListModelUpdateObject) {
        return updateClosedListWithServiceResponseAsync(appId, versionId, clEntityId, closedListModelUpdateObject).toBlocking().single().body();
    }

    /**
     * Updates the list entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param clEntityId The list model ID.
     * @param closedListModelUpdateObject The new list entity name and words list.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatus> updateClosedListAsync(UUID appId, String versionId, UUID clEntityId, ClosedListModelUpdateObject closedListModelUpdateObject, final ServiceCallback<OperationStatus> serviceCallback) {
        return ServiceFuture.fromResponse(updateClosedListWithServiceResponseAsync(appId, versionId, clEntityId, closedListModelUpdateObject), serviceCallback);
    }

    /**
     * Updates the list entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param clEntityId The list model ID.
     * @param closedListModelUpdateObject The new list entity name and words list.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<OperationStatus> updateClosedListAsync(UUID appId, String versionId, UUID clEntityId, ClosedListModelUpdateObject closedListModelUpdateObject) {
        return updateClosedListWithServiceResponseAsync(appId, versionId, clEntityId, closedListModelUpdateObject).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
            @Override
            public OperationStatus call(ServiceResponse<OperationStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the list entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param clEntityId The list model ID.
     * @param closedListModelUpdateObject The new list entity name and words list.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> updateClosedListWithServiceResponseAsync(UUID appId, String versionId, UUID clEntityId, ClosedListModelUpdateObject closedListModelUpdateObject) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (clEntityId == null) {
            throw new IllegalArgumentException("Parameter clEntityId is required and cannot be null.");
        }
        if (closedListModelUpdateObject == null) {
            throw new IllegalArgumentException("Parameter closedListModelUpdateObject is required and cannot be null.");
        }
        Validator.validate(closedListModelUpdateObject);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.updateClosedList(appId, versionId, clEntityId, closedListModelUpdateObject, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatus>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatus> clientResponse = updateClosedListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatus> updateClosedListDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatus, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatus>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }


    /**
     * Adds a batch of sublists to an existing list entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param clEntityId The list entity model ID.
     * @param patchClosedListOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatus object if successful.
     */
    public OperationStatus patchClosedList(UUID appId, String versionId, UUID clEntityId, PatchClosedListOptionalParameter patchClosedListOptionalParameter) {
        return patchClosedListWithServiceResponseAsync(appId, versionId, clEntityId, patchClosedListOptionalParameter).toBlocking().single().body();
    }

    /**
     * Adds a batch of sublists to an existing list entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param clEntityId The list entity model ID.
     * @param patchClosedListOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatus> patchClosedListAsync(UUID appId, String versionId, UUID clEntityId, PatchClosedListOptionalParameter patchClosedListOptionalParameter, final ServiceCallback<OperationStatus> serviceCallback) {
        return ServiceFuture.fromResponse(patchClosedListWithServiceResponseAsync(appId, versionId, clEntityId, patchClosedListOptionalParameter), serviceCallback);
    }

    /**
     * Adds a batch of sublists to an existing list entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param clEntityId The list entity model ID.
     * @param patchClosedListOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<OperationStatus> patchClosedListAsync(UUID appId, String versionId, UUID clEntityId, PatchClosedListOptionalParameter patchClosedListOptionalParameter) {
        return patchClosedListWithServiceResponseAsync(appId, versionId, clEntityId, patchClosedListOptionalParameter).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
            @Override
            public OperationStatus call(ServiceResponse<OperationStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Adds a batch of sublists to an existing list entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param clEntityId The list entity model ID.
     * @param patchClosedListOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> patchClosedListWithServiceResponseAsync(UUID appId, String versionId, UUID clEntityId, PatchClosedListOptionalParameter patchClosedListOptionalParameter) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (clEntityId == null) {
            throw new IllegalArgumentException("Parameter clEntityId is required and cannot be null.");
        }
        final List<WordListObject> subLists = patchClosedListOptionalParameter != null ? patchClosedListOptionalParameter.subLists() : null;

        return patchClosedListWithServiceResponseAsync(appId, versionId, clEntityId, subLists);
    }

    /**
     * Adds a batch of sublists to an existing list entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param clEntityId The list entity model ID.
     * @param subLists Sublists to add.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> patchClosedListWithServiceResponseAsync(UUID appId, String versionId, UUID clEntityId, List<WordListObject> subLists) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (clEntityId == null) {
            throw new IllegalArgumentException("Parameter clEntityId is required and cannot be null.");
        }
        Validator.validate(subLists);
        ClosedListModelPatchObject closedListModelPatchObject = new ClosedListModelPatchObject();
        closedListModelPatchObject.withSubLists(subLists);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.patchClosedList(appId, versionId, clEntityId, this.client.acceptLanguage(), closedListModelPatchObject, parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatus>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatus> clientResponse = patchClosedListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatus> patchClosedListDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatus, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatus>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    @Override
    public ModelsPatchClosedListParameters patchClosedList() {
        return new ModelsPatchClosedListParameters(this);
    }

    /**
     * Internal class implementing ModelsPatchClosedListDefinition.
     */
    class ModelsPatchClosedListParameters implements ModelsPatchClosedListDefinition {
        private ModelsImpl parent;
        private UUID appId;
        private String versionId;
        private UUID clEntityId;
        private List<WordListObject> subLists;

        /**
         * Constructor.
         * @param parent the parent object.
         */
        ModelsPatchClosedListParameters(ModelsImpl parent) {
            this.parent = parent;
        }

        @Override
        public ModelsPatchClosedListParameters withAppId(UUID appId) {
            this.appId = appId;
            return this;
        }

        @Override
        public ModelsPatchClosedListParameters withVersionId(String versionId) {
            this.versionId = versionId;
            return this;
        }

        @Override
        public ModelsPatchClosedListParameters withClEntityId(UUID clEntityId) {
            this.clEntityId = clEntityId;
            return this;
        }

        @Override
        public ModelsPatchClosedListParameters withSubLists(List<WordListObject> subLists) {
            this.subLists = subLists;
            return this;
        }

        @Override
        public OperationStatus execute() {
        return patchClosedListWithServiceResponseAsync(appId, versionId, clEntityId, subLists).toBlocking().single().body();
    }

        @Override
        public Observable<OperationStatus> executeAsync() {
            return patchClosedListWithServiceResponseAsync(appId, versionId, clEntityId, subLists).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
                @Override
                public OperationStatus call(ServiceResponse<OperationStatus> response) {
                    return response.body();
                }
            });
        }
    }

    /**
     * Deletes a list entity model from a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param clEntityId The list entity model ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatus object if successful.
     */
    public OperationStatus deleteClosedList(UUID appId, String versionId, UUID clEntityId) {
        return deleteClosedListWithServiceResponseAsync(appId, versionId, clEntityId).toBlocking().single().body();
    }

    /**
     * Deletes a list entity model from a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param clEntityId The list entity model ID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatus> deleteClosedListAsync(UUID appId, String versionId, UUID clEntityId, final ServiceCallback<OperationStatus> serviceCallback) {
        return ServiceFuture.fromResponse(deleteClosedListWithServiceResponseAsync(appId, versionId, clEntityId), serviceCallback);
    }

    /**
     * Deletes a list entity model from a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param clEntityId The list entity model ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<OperationStatus> deleteClosedListAsync(UUID appId, String versionId, UUID clEntityId) {
        return deleteClosedListWithServiceResponseAsync(appId, versionId, clEntityId).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
            @Override
            public OperationStatus call(ServiceResponse<OperationStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a list entity model from a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param clEntityId The list entity model ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> deleteClosedListWithServiceResponseAsync(UUID appId, String versionId, UUID clEntityId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (clEntityId == null) {
            throw new IllegalArgumentException("Parameter clEntityId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.deleteClosedList(appId, versionId, clEntityId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatus>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatus> clientResponse = deleteClosedListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatus> deleteClosedListDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatus, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatus>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Gets information about a prebuilt entity model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param prebuiltId The prebuilt entity extractor ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PrebuiltEntityExtractor object if successful.
     */
    public PrebuiltEntityExtractor getPrebuilt(UUID appId, String versionId, UUID prebuiltId) {
        return getPrebuiltWithServiceResponseAsync(appId, versionId, prebuiltId).toBlocking().single().body();
    }

    /**
     * Gets information about a prebuilt entity model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param prebuiltId The prebuilt entity extractor ID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PrebuiltEntityExtractor> getPrebuiltAsync(UUID appId, String versionId, UUID prebuiltId, final ServiceCallback<PrebuiltEntityExtractor> serviceCallback) {
        return ServiceFuture.fromResponse(getPrebuiltWithServiceResponseAsync(appId, versionId, prebuiltId), serviceCallback);
    }

    /**
     * Gets information about a prebuilt entity model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param prebuiltId The prebuilt entity extractor ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PrebuiltEntityExtractor object
     */
    public Observable<PrebuiltEntityExtractor> getPrebuiltAsync(UUID appId, String versionId, UUID prebuiltId) {
        return getPrebuiltWithServiceResponseAsync(appId, versionId, prebuiltId).map(new Func1<ServiceResponse<PrebuiltEntityExtractor>, PrebuiltEntityExtractor>() {
            @Override
            public PrebuiltEntityExtractor call(ServiceResponse<PrebuiltEntityExtractor> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets information about a prebuilt entity model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param prebuiltId The prebuilt entity extractor ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PrebuiltEntityExtractor object
     */
    public Observable<ServiceResponse<PrebuiltEntityExtractor>> getPrebuiltWithServiceResponseAsync(UUID appId, String versionId, UUID prebuiltId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (prebuiltId == null) {
            throw new IllegalArgumentException("Parameter prebuiltId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.getPrebuilt(appId, versionId, prebuiltId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PrebuiltEntityExtractor>>>() {
                @Override
                public Observable<ServiceResponse<PrebuiltEntityExtractor>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PrebuiltEntityExtractor> clientResponse = getPrebuiltDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PrebuiltEntityExtractor> getPrebuiltDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PrebuiltEntityExtractor, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PrebuiltEntityExtractor>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Deletes a prebuilt entity extractor from a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param prebuiltId The prebuilt entity extractor ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatus object if successful.
     */
    public OperationStatus deletePrebuilt(UUID appId, String versionId, UUID prebuiltId) {
        return deletePrebuiltWithServiceResponseAsync(appId, versionId, prebuiltId).toBlocking().single().body();
    }

    /**
     * Deletes a prebuilt entity extractor from a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param prebuiltId The prebuilt entity extractor ID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatus> deletePrebuiltAsync(UUID appId, String versionId, UUID prebuiltId, final ServiceCallback<OperationStatus> serviceCallback) {
        return ServiceFuture.fromResponse(deletePrebuiltWithServiceResponseAsync(appId, versionId, prebuiltId), serviceCallback);
    }

    /**
     * Deletes a prebuilt entity extractor from a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param prebuiltId The prebuilt entity extractor ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<OperationStatus> deletePrebuiltAsync(UUID appId, String versionId, UUID prebuiltId) {
        return deletePrebuiltWithServiceResponseAsync(appId, versionId, prebuiltId).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
            @Override
            public OperationStatus call(ServiceResponse<OperationStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a prebuilt entity extractor from a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param prebuiltId The prebuilt entity extractor ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> deletePrebuiltWithServiceResponseAsync(UUID appId, String versionId, UUID prebuiltId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (prebuiltId == null) {
            throw new IllegalArgumentException("Parameter prebuiltId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.deletePrebuilt(appId, versionId, prebuiltId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatus>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatus> clientResponse = deletePrebuiltDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatus> deletePrebuiltDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatus, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatus>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Deletes a sublist of a specific list entity model from a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param clEntityId The list entity extractor ID.
     * @param subListId The sublist ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatus object if successful.
     */
    public OperationStatus deleteSubList(UUID appId, String versionId, UUID clEntityId, long subListId) {
        return deleteSubListWithServiceResponseAsync(appId, versionId, clEntityId, subListId).toBlocking().single().body();
    }

    /**
     * Deletes a sublist of a specific list entity model from a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param clEntityId The list entity extractor ID.
     * @param subListId The sublist ID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatus> deleteSubListAsync(UUID appId, String versionId, UUID clEntityId, long subListId, final ServiceCallback<OperationStatus> serviceCallback) {
        return ServiceFuture.fromResponse(deleteSubListWithServiceResponseAsync(appId, versionId, clEntityId, subListId), serviceCallback);
    }

    /**
     * Deletes a sublist of a specific list entity model from a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param clEntityId The list entity extractor ID.
     * @param subListId The sublist ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<OperationStatus> deleteSubListAsync(UUID appId, String versionId, UUID clEntityId, long subListId) {
        return deleteSubListWithServiceResponseAsync(appId, versionId, clEntityId, subListId).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
            @Override
            public OperationStatus call(ServiceResponse<OperationStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a sublist of a specific list entity model from a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param clEntityId The list entity extractor ID.
     * @param subListId The sublist ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> deleteSubListWithServiceResponseAsync(UUID appId, String versionId, UUID clEntityId, long subListId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (clEntityId == null) {
            throw new IllegalArgumentException("Parameter clEntityId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.deleteSubList(appId, versionId, clEntityId, subListId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatus>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatus> clientResponse = deleteSubListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatus> deleteSubListDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatus, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatus>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Updates one of the list entity's sublists in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param clEntityId The list entity extractor ID.
     * @param subListId The sublist ID.
     * @param wordListBaseUpdateObject A sublist update object containing the new canonical form and the list of words.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatus object if successful.
     */
    public OperationStatus updateSubList(UUID appId, String versionId, UUID clEntityId, long subListId, WordListBaseUpdateObject wordListBaseUpdateObject) {
        return updateSubListWithServiceResponseAsync(appId, versionId, clEntityId, subListId, wordListBaseUpdateObject).toBlocking().single().body();
    }

    /**
     * Updates one of the list entity's sublists in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param clEntityId The list entity extractor ID.
     * @param subListId The sublist ID.
     * @param wordListBaseUpdateObject A sublist update object containing the new canonical form and the list of words.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatus> updateSubListAsync(UUID appId, String versionId, UUID clEntityId, long subListId, WordListBaseUpdateObject wordListBaseUpdateObject, final ServiceCallback<OperationStatus> serviceCallback) {
        return ServiceFuture.fromResponse(updateSubListWithServiceResponseAsync(appId, versionId, clEntityId, subListId, wordListBaseUpdateObject), serviceCallback);
    }

    /**
     * Updates one of the list entity's sublists in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param clEntityId The list entity extractor ID.
     * @param subListId The sublist ID.
     * @param wordListBaseUpdateObject A sublist update object containing the new canonical form and the list of words.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<OperationStatus> updateSubListAsync(UUID appId, String versionId, UUID clEntityId, long subListId, WordListBaseUpdateObject wordListBaseUpdateObject) {
        return updateSubListWithServiceResponseAsync(appId, versionId, clEntityId, subListId, wordListBaseUpdateObject).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
            @Override
            public OperationStatus call(ServiceResponse<OperationStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates one of the list entity's sublists in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param clEntityId The list entity extractor ID.
     * @param subListId The sublist ID.
     * @param wordListBaseUpdateObject A sublist update object containing the new canonical form and the list of words.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> updateSubListWithServiceResponseAsync(UUID appId, String versionId, UUID clEntityId, long subListId, WordListBaseUpdateObject wordListBaseUpdateObject) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (clEntityId == null) {
            throw new IllegalArgumentException("Parameter clEntityId is required and cannot be null.");
        }
        if (wordListBaseUpdateObject == null) {
            throw new IllegalArgumentException("Parameter wordListBaseUpdateObject is required and cannot be null.");
        }
        Validator.validate(wordListBaseUpdateObject);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.updateSubList(appId, versionId, clEntityId, subListId, wordListBaseUpdateObject, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatus>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatus> clientResponse = updateSubListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatus> updateSubListDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatus, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatus>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }


    /**
     * Suggests example utterances that would improve the accuracy of the intent model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param intentId The intent classifier ID.
     * @param listIntentSuggestionsOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;IntentsSuggestionExample&gt; object if successful.
     */
    public List<IntentsSuggestionExample> listIntentSuggestions(UUID appId, String versionId, UUID intentId, ListIntentSuggestionsOptionalParameter listIntentSuggestionsOptionalParameter) {
        return listIntentSuggestionsWithServiceResponseAsync(appId, versionId, intentId, listIntentSuggestionsOptionalParameter).toBlocking().single().body();
    }

    /**
     * Suggests example utterances that would improve the accuracy of the intent model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param intentId The intent classifier ID.
     * @param listIntentSuggestionsOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<IntentsSuggestionExample>> listIntentSuggestionsAsync(UUID appId, String versionId, UUID intentId, ListIntentSuggestionsOptionalParameter listIntentSuggestionsOptionalParameter, final ServiceCallback<List<IntentsSuggestionExample>> serviceCallback) {
        return ServiceFuture.fromResponse(listIntentSuggestionsWithServiceResponseAsync(appId, versionId, intentId, listIntentSuggestionsOptionalParameter), serviceCallback);
    }

    /**
     * Suggests example utterances that would improve the accuracy of the intent model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param intentId The intent classifier ID.
     * @param listIntentSuggestionsOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;IntentsSuggestionExample&gt; object
     */
    public Observable<List<IntentsSuggestionExample>> listIntentSuggestionsAsync(UUID appId, String versionId, UUID intentId, ListIntentSuggestionsOptionalParameter listIntentSuggestionsOptionalParameter) {
        return listIntentSuggestionsWithServiceResponseAsync(appId, versionId, intentId, listIntentSuggestionsOptionalParameter).map(new Func1<ServiceResponse<List<IntentsSuggestionExample>>, List<IntentsSuggestionExample>>() {
            @Override
            public List<IntentsSuggestionExample> call(ServiceResponse<List<IntentsSuggestionExample>> response) {
                return response.body();
            }
        });
    }

    /**
     * Suggests example utterances that would improve the accuracy of the intent model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param intentId The intent classifier ID.
     * @param listIntentSuggestionsOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;IntentsSuggestionExample&gt; object
     */
    public Observable<ServiceResponse<List<IntentsSuggestionExample>>> listIntentSuggestionsWithServiceResponseAsync(UUID appId, String versionId, UUID intentId, ListIntentSuggestionsOptionalParameter listIntentSuggestionsOptionalParameter) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (intentId == null) {
            throw new IllegalArgumentException("Parameter intentId is required and cannot be null.");
        }
        final Integer take = listIntentSuggestionsOptionalParameter != null ? listIntentSuggestionsOptionalParameter.take() : null;
        final Boolean enableNestedChildren = listIntentSuggestionsOptionalParameter != null ? listIntentSuggestionsOptionalParameter.enableNestedChildren() : null;

        return listIntentSuggestionsWithServiceResponseAsync(appId, versionId, intentId, take, enableNestedChildren);
    }

    /**
     * Suggests example utterances that would improve the accuracy of the intent model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param intentId The intent classifier ID.
     * @param take The number of entries to return. Maximum page size is 500. Default is 100.
     * @param enableNestedChildren Toggles nested/flat format
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;IntentsSuggestionExample&gt; object
     */
    public Observable<ServiceResponse<List<IntentsSuggestionExample>>> listIntentSuggestionsWithServiceResponseAsync(UUID appId, String versionId, UUID intentId, Integer take, Boolean enableNestedChildren) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (intentId == null) {
            throw new IllegalArgumentException("Parameter intentId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.listIntentSuggestions(appId, versionId, intentId, take, enableNestedChildren, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<IntentsSuggestionExample>>>>() {
                @Override
                public Observable<ServiceResponse<List<IntentsSuggestionExample>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<IntentsSuggestionExample>> clientResponse = listIntentSuggestionsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<IntentsSuggestionExample>> listIntentSuggestionsDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<IntentsSuggestionExample>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<IntentsSuggestionExample>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    @Override
    public ModelsListIntentSuggestionsParameters listIntentSuggestions() {
        return new ModelsListIntentSuggestionsParameters(this);
    }

    /**
     * Internal class implementing ModelsListIntentSuggestionsDefinition.
     */
    class ModelsListIntentSuggestionsParameters implements ModelsListIntentSuggestionsDefinition {
        private ModelsImpl parent;
        private UUID appId;
        private String versionId;
        private UUID intentId;
        private Integer take;
        private Boolean enableNestedChildren;

        /**
         * Constructor.
         * @param parent the parent object.
         */
        ModelsListIntentSuggestionsParameters(ModelsImpl parent) {
            this.parent = parent;
        }

        @Override
        public ModelsListIntentSuggestionsParameters withAppId(UUID appId) {
            this.appId = appId;
            return this;
        }

        @Override
        public ModelsListIntentSuggestionsParameters withVersionId(String versionId) {
            this.versionId = versionId;
            return this;
        }

        @Override
        public ModelsListIntentSuggestionsParameters withIntentId(UUID intentId) {
            this.intentId = intentId;
            return this;
        }

        @Override
        public ModelsListIntentSuggestionsParameters withTake(Integer take) {
            this.take = take;
            return this;
        }

        @Override
        public ModelsListIntentSuggestionsParameters withEnableNestedChildren(Boolean enableNestedChildren) {
            this.enableNestedChildren = enableNestedChildren;
            return this;
        }

        @Override
        public List<IntentsSuggestionExample> execute() {
        return listIntentSuggestionsWithServiceResponseAsync(appId, versionId, intentId, take, enableNestedChildren).toBlocking().single().body();
    }

        @Override
        public Observable<List<IntentsSuggestionExample>> executeAsync() {
            return listIntentSuggestionsWithServiceResponseAsync(appId, versionId, intentId, take, enableNestedChildren).map(new Func1<ServiceResponse<List<IntentsSuggestionExample>>, List<IntentsSuggestionExample>>() {
                @Override
                public List<IntentsSuggestionExample> call(ServiceResponse<List<IntentsSuggestionExample>> response) {
                    return response.body();
                }
            });
        }
    }


    /**
     * Get suggested example utterances that would improve the accuracy of the entity model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The target entity extractor model to enhance.
     * @param listEntitySuggestionsOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;EntitiesSuggestionExample&gt; object if successful.
     */
    public List<EntitiesSuggestionExample> listEntitySuggestions(UUID appId, String versionId, UUID entityId, ListEntitySuggestionsOptionalParameter listEntitySuggestionsOptionalParameter) {
        return listEntitySuggestionsWithServiceResponseAsync(appId, versionId, entityId, listEntitySuggestionsOptionalParameter).toBlocking().single().body();
    }

    /**
     * Get suggested example utterances that would improve the accuracy of the entity model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The target entity extractor model to enhance.
     * @param listEntitySuggestionsOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<EntitiesSuggestionExample>> listEntitySuggestionsAsync(UUID appId, String versionId, UUID entityId, ListEntitySuggestionsOptionalParameter listEntitySuggestionsOptionalParameter, final ServiceCallback<List<EntitiesSuggestionExample>> serviceCallback) {
        return ServiceFuture.fromResponse(listEntitySuggestionsWithServiceResponseAsync(appId, versionId, entityId, listEntitySuggestionsOptionalParameter), serviceCallback);
    }

    /**
     * Get suggested example utterances that would improve the accuracy of the entity model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The target entity extractor model to enhance.
     * @param listEntitySuggestionsOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;EntitiesSuggestionExample&gt; object
     */
    public Observable<List<EntitiesSuggestionExample>> listEntitySuggestionsAsync(UUID appId, String versionId, UUID entityId, ListEntitySuggestionsOptionalParameter listEntitySuggestionsOptionalParameter) {
        return listEntitySuggestionsWithServiceResponseAsync(appId, versionId, entityId, listEntitySuggestionsOptionalParameter).map(new Func1<ServiceResponse<List<EntitiesSuggestionExample>>, List<EntitiesSuggestionExample>>() {
            @Override
            public List<EntitiesSuggestionExample> call(ServiceResponse<List<EntitiesSuggestionExample>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get suggested example utterances that would improve the accuracy of the entity model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The target entity extractor model to enhance.
     * @param listEntitySuggestionsOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;EntitiesSuggestionExample&gt; object
     */
    public Observable<ServiceResponse<List<EntitiesSuggestionExample>>> listEntitySuggestionsWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, ListEntitySuggestionsOptionalParameter listEntitySuggestionsOptionalParameter) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        final Integer take = listEntitySuggestionsOptionalParameter != null ? listEntitySuggestionsOptionalParameter.take() : null;
        final Boolean enableNestedChildren = listEntitySuggestionsOptionalParameter != null ? listEntitySuggestionsOptionalParameter.enableNestedChildren() : null;

        return listEntitySuggestionsWithServiceResponseAsync(appId, versionId, entityId, take, enableNestedChildren);
    }

    /**
     * Get suggested example utterances that would improve the accuracy of the entity model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The target entity extractor model to enhance.
     * @param take The number of entries to return. Maximum page size is 500. Default is 100.
     * @param enableNestedChildren Toggles nested/flat format
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;EntitiesSuggestionExample&gt; object
     */
    public Observable<ServiceResponse<List<EntitiesSuggestionExample>>> listEntitySuggestionsWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, Integer take, Boolean enableNestedChildren) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.listEntitySuggestions(appId, versionId, entityId, take, enableNestedChildren, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<EntitiesSuggestionExample>>>>() {
                @Override
                public Observable<ServiceResponse<List<EntitiesSuggestionExample>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<EntitiesSuggestionExample>> clientResponse = listEntitySuggestionsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<EntitiesSuggestionExample>> listEntitySuggestionsDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<EntitiesSuggestionExample>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<EntitiesSuggestionExample>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    @Override
    public ModelsListEntitySuggestionsParameters listEntitySuggestions() {
        return new ModelsListEntitySuggestionsParameters(this);
    }

    /**
     * Internal class implementing ModelsListEntitySuggestionsDefinition.
     */
    class ModelsListEntitySuggestionsParameters implements ModelsListEntitySuggestionsDefinition {
        private ModelsImpl parent;
        private UUID appId;
        private String versionId;
        private UUID entityId;
        private Integer take;
        private Boolean enableNestedChildren;

        /**
         * Constructor.
         * @param parent the parent object.
         */
        ModelsListEntitySuggestionsParameters(ModelsImpl parent) {
            this.parent = parent;
        }

        @Override
        public ModelsListEntitySuggestionsParameters withAppId(UUID appId) {
            this.appId = appId;
            return this;
        }

        @Override
        public ModelsListEntitySuggestionsParameters withVersionId(String versionId) {
            this.versionId = versionId;
            return this;
        }

        @Override
        public ModelsListEntitySuggestionsParameters withEntityId(UUID entityId) {
            this.entityId = entityId;
            return this;
        }

        @Override
        public ModelsListEntitySuggestionsParameters withTake(Integer take) {
            this.take = take;
            return this;
        }

        @Override
        public ModelsListEntitySuggestionsParameters withEnableNestedChildren(Boolean enableNestedChildren) {
            this.enableNestedChildren = enableNestedChildren;
            return this;
        }

        @Override
        public List<EntitiesSuggestionExample> execute() {
        return listEntitySuggestionsWithServiceResponseAsync(appId, versionId, entityId, take, enableNestedChildren).toBlocking().single().body();
    }

        @Override
        public Observable<List<EntitiesSuggestionExample>> executeAsync() {
            return listEntitySuggestionsWithServiceResponseAsync(appId, versionId, entityId, take, enableNestedChildren).map(new Func1<ServiceResponse<List<EntitiesSuggestionExample>>, List<EntitiesSuggestionExample>>() {
                @Override
                public List<EntitiesSuggestionExample> call(ServiceResponse<List<EntitiesSuggestionExample>> response) {
                    return response.body();
                }
            });
        }
    }

    /**
     * Adds a sublist to an existing list entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param clEntityId The list entity extractor ID.
     * @param wordListCreateObject Words list.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the long object if successful.
     */
    public long addSubList(UUID appId, String versionId, UUID clEntityId, WordListObject wordListCreateObject) {
        return addSubListWithServiceResponseAsync(appId, versionId, clEntityId, wordListCreateObject).toBlocking().single().body();
    }

    /**
     * Adds a sublist to an existing list entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param clEntityId The list entity extractor ID.
     * @param wordListCreateObject Words list.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Long> addSubListAsync(UUID appId, String versionId, UUID clEntityId, WordListObject wordListCreateObject, final ServiceCallback<Long> serviceCallback) {
        return ServiceFuture.fromResponse(addSubListWithServiceResponseAsync(appId, versionId, clEntityId, wordListCreateObject), serviceCallback);
    }

    /**
     * Adds a sublist to an existing list entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param clEntityId The list entity extractor ID.
     * @param wordListCreateObject Words list.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Long object
     */
    public Observable<Long> addSubListAsync(UUID appId, String versionId, UUID clEntityId, WordListObject wordListCreateObject) {
        return addSubListWithServiceResponseAsync(appId, versionId, clEntityId, wordListCreateObject).map(new Func1<ServiceResponse<Long>, Long>() {
            @Override
            public Long call(ServiceResponse<Long> response) {
                return response.body();
            }
        });
    }

    /**
     * Adds a sublist to an existing list entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param clEntityId The list entity extractor ID.
     * @param wordListCreateObject Words list.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Long object
     */
    public Observable<ServiceResponse<Long>> addSubListWithServiceResponseAsync(UUID appId, String versionId, UUID clEntityId, WordListObject wordListCreateObject) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (clEntityId == null) {
            throw new IllegalArgumentException("Parameter clEntityId is required and cannot be null.");
        }
        if (wordListCreateObject == null) {
            throw new IllegalArgumentException("Parameter wordListCreateObject is required and cannot be null.");
        }
        Validator.validate(wordListCreateObject);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.addSubList(appId, versionId, clEntityId, wordListCreateObject, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Long>>>() {
                @Override
                public Observable<ServiceResponse<Long>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Long> clientResponse = addSubListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Long> addSubListDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Long, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(201, new TypeToken<Long>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }


    /**
     * Adds a customizable prebuilt domain along with all of its intent and entity models in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param addCustomPrebuiltDomainOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;UUID&gt; object if successful.
     */
    public List<UUID> addCustomPrebuiltDomain(UUID appId, String versionId, AddCustomPrebuiltDomainModelsOptionalParameter addCustomPrebuiltDomainOptionalParameter) {
        return addCustomPrebuiltDomainWithServiceResponseAsync(appId, versionId, addCustomPrebuiltDomainOptionalParameter).toBlocking().single().body();
    }

    /**
     * Adds a customizable prebuilt domain along with all of its intent and entity models in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param addCustomPrebuiltDomainOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<UUID>> addCustomPrebuiltDomainAsync(UUID appId, String versionId, AddCustomPrebuiltDomainModelsOptionalParameter addCustomPrebuiltDomainOptionalParameter, final ServiceCallback<List<UUID>> serviceCallback) {
        return ServiceFuture.fromResponse(addCustomPrebuiltDomainWithServiceResponseAsync(appId, versionId, addCustomPrebuiltDomainOptionalParameter), serviceCallback);
    }

    /**
     * Adds a customizable prebuilt domain along with all of its intent and entity models in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param addCustomPrebuiltDomainOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;UUID&gt; object
     */
    public Observable<List<UUID>> addCustomPrebuiltDomainAsync(UUID appId, String versionId, AddCustomPrebuiltDomainModelsOptionalParameter addCustomPrebuiltDomainOptionalParameter) {
        return addCustomPrebuiltDomainWithServiceResponseAsync(appId, versionId, addCustomPrebuiltDomainOptionalParameter).map(new Func1<ServiceResponse<List<UUID>>, List<UUID>>() {
            @Override
            public List<UUID> call(ServiceResponse<List<UUID>> response) {
                return response.body();
            }
        });
    }

    /**
     * Adds a customizable prebuilt domain along with all of its intent and entity models in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param addCustomPrebuiltDomainOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;UUID&gt; object
     */
    public Observable<ServiceResponse<List<UUID>>> addCustomPrebuiltDomainWithServiceResponseAsync(UUID appId, String versionId, AddCustomPrebuiltDomainModelsOptionalParameter addCustomPrebuiltDomainOptionalParameter) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        final String domainName = addCustomPrebuiltDomainOptionalParameter != null ? addCustomPrebuiltDomainOptionalParameter.domainName() : null;

        return addCustomPrebuiltDomainWithServiceResponseAsync(appId, versionId, domainName);
    }

    /**
     * Adds a customizable prebuilt domain along with all of its intent and entity models in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param domainName The domain name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;UUID&gt; object
     */
    public Observable<ServiceResponse<List<UUID>>> addCustomPrebuiltDomainWithServiceResponseAsync(UUID appId, String versionId, String domainName) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        PrebuiltDomainCreateBaseObject prebuiltDomainObject = new PrebuiltDomainCreateBaseObject();
        prebuiltDomainObject.withDomainName(domainName);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.addCustomPrebuiltDomain(appId, versionId, this.client.acceptLanguage(), prebuiltDomainObject, parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<UUID>>>>() {
                @Override
                public Observable<ServiceResponse<List<UUID>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<UUID>> clientResponse = addCustomPrebuiltDomainDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<UUID>> addCustomPrebuiltDomainDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<UUID>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(201, new TypeToken<List<UUID>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    @Override
    public ModelsAddCustomPrebuiltDomainParameters addCustomPrebuiltDomain() {
        return new ModelsAddCustomPrebuiltDomainParameters(this);
    }

    /**
     * Internal class implementing ModelsAddCustomPrebuiltDomainDefinition.
     */
    class ModelsAddCustomPrebuiltDomainParameters implements ModelsAddCustomPrebuiltDomainDefinition {
        private ModelsImpl parent;
        private UUID appId;
        private String versionId;
        private String domainName;

        /**
         * Constructor.
         * @param parent the parent object.
         */
        ModelsAddCustomPrebuiltDomainParameters(ModelsImpl parent) {
            this.parent = parent;
        }

        @Override
        public ModelsAddCustomPrebuiltDomainParameters withAppId(UUID appId) {
            this.appId = appId;
            return this;
        }

        @Override
        public ModelsAddCustomPrebuiltDomainParameters withVersionId(String versionId) {
            this.versionId = versionId;
            return this;
        }

        @Override
        public ModelsAddCustomPrebuiltDomainParameters withDomainName(String domainName) {
            this.domainName = domainName;
            return this;
        }

        @Override
        public List<UUID> execute() {
        return addCustomPrebuiltDomainWithServiceResponseAsync(appId, versionId, domainName).toBlocking().single().body();
    }

        @Override
        public Observable<List<UUID>> executeAsync() {
            return addCustomPrebuiltDomainWithServiceResponseAsync(appId, versionId, domainName).map(new Func1<ServiceResponse<List<UUID>>, List<UUID>>() {
                @Override
                public List<UUID> call(ServiceResponse<List<UUID>> response) {
                    return response.body();
                }
            });
        }
    }

    /**
     * Adds a customizable prebuilt intent model to a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param prebuiltDomainModelCreateObject A model object containing the name of the customizable prebuilt intent and the name of the domain to which this model belongs.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UUID object if successful.
     */
    public UUID addCustomPrebuiltIntent(UUID appId, String versionId, PrebuiltDomainModelCreateObject prebuiltDomainModelCreateObject) {
        return addCustomPrebuiltIntentWithServiceResponseAsync(appId, versionId, prebuiltDomainModelCreateObject).toBlocking().single().body();
    }

    /**
     * Adds a customizable prebuilt intent model to a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param prebuiltDomainModelCreateObject A model object containing the name of the customizable prebuilt intent and the name of the domain to which this model belongs.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UUID> addCustomPrebuiltIntentAsync(UUID appId, String versionId, PrebuiltDomainModelCreateObject prebuiltDomainModelCreateObject, final ServiceCallback<UUID> serviceCallback) {
        return ServiceFuture.fromResponse(addCustomPrebuiltIntentWithServiceResponseAsync(appId, versionId, prebuiltDomainModelCreateObject), serviceCallback);
    }

    /**
     * Adds a customizable prebuilt intent model to a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param prebuiltDomainModelCreateObject A model object containing the name of the customizable prebuilt intent and the name of the domain to which this model belongs.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UUID object
     */
    public Observable<UUID> addCustomPrebuiltIntentAsync(UUID appId, String versionId, PrebuiltDomainModelCreateObject prebuiltDomainModelCreateObject) {
        return addCustomPrebuiltIntentWithServiceResponseAsync(appId, versionId, prebuiltDomainModelCreateObject).map(new Func1<ServiceResponse<UUID>, UUID>() {
            @Override
            public UUID call(ServiceResponse<UUID> response) {
                return response.body();
            }
        });
    }

    /**
     * Adds a customizable prebuilt intent model to a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param prebuiltDomainModelCreateObject A model object containing the name of the customizable prebuilt intent and the name of the domain to which this model belongs.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UUID object
     */
    public Observable<ServiceResponse<UUID>> addCustomPrebuiltIntentWithServiceResponseAsync(UUID appId, String versionId, PrebuiltDomainModelCreateObject prebuiltDomainModelCreateObject) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (prebuiltDomainModelCreateObject == null) {
            throw new IllegalArgumentException("Parameter prebuiltDomainModelCreateObject is required and cannot be null.");
        }
        Validator.validate(prebuiltDomainModelCreateObject);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.addCustomPrebuiltIntent(appId, versionId, prebuiltDomainModelCreateObject, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UUID>>>() {
                @Override
                public Observable<ServiceResponse<UUID>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UUID> clientResponse = addCustomPrebuiltIntentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<UUID> addCustomPrebuiltIntentDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<UUID, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(201, new TypeToken<UUID>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Gets information about customizable prebuilt intents added to a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;IntentClassifier&gt; object if successful.
     */
    public List<IntentClassifier> listCustomPrebuiltIntents(UUID appId, String versionId) {
        return listCustomPrebuiltIntentsWithServiceResponseAsync(appId, versionId).toBlocking().single().body();
    }

    /**
     * Gets information about customizable prebuilt intents added to a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<IntentClassifier>> listCustomPrebuiltIntentsAsync(UUID appId, String versionId, final ServiceCallback<List<IntentClassifier>> serviceCallback) {
        return ServiceFuture.fromResponse(listCustomPrebuiltIntentsWithServiceResponseAsync(appId, versionId), serviceCallback);
    }

    /**
     * Gets information about customizable prebuilt intents added to a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;IntentClassifier&gt; object
     */
    public Observable<List<IntentClassifier>> listCustomPrebuiltIntentsAsync(UUID appId, String versionId) {
        return listCustomPrebuiltIntentsWithServiceResponseAsync(appId, versionId).map(new Func1<ServiceResponse<List<IntentClassifier>>, List<IntentClassifier>>() {
            @Override
            public List<IntentClassifier> call(ServiceResponse<List<IntentClassifier>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets information about customizable prebuilt intents added to a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;IntentClassifier&gt; object
     */
    public Observable<ServiceResponse<List<IntentClassifier>>> listCustomPrebuiltIntentsWithServiceResponseAsync(UUID appId, String versionId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.listCustomPrebuiltIntents(appId, versionId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<IntentClassifier>>>>() {
                @Override
                public Observable<ServiceResponse<List<IntentClassifier>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<IntentClassifier>> clientResponse = listCustomPrebuiltIntentsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<IntentClassifier>> listCustomPrebuiltIntentsDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<IntentClassifier>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<IntentClassifier>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Adds a prebuilt entity model to a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param prebuiltDomainModelCreateObject A model object containing the name of the prebuilt entity and the name of the domain to which this model belongs.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UUID object if successful.
     */
    public UUID addCustomPrebuiltEntity(UUID appId, String versionId, PrebuiltDomainModelCreateObject prebuiltDomainModelCreateObject) {
        return addCustomPrebuiltEntityWithServiceResponseAsync(appId, versionId, prebuiltDomainModelCreateObject).toBlocking().single().body();
    }

    /**
     * Adds a prebuilt entity model to a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param prebuiltDomainModelCreateObject A model object containing the name of the prebuilt entity and the name of the domain to which this model belongs.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UUID> addCustomPrebuiltEntityAsync(UUID appId, String versionId, PrebuiltDomainModelCreateObject prebuiltDomainModelCreateObject, final ServiceCallback<UUID> serviceCallback) {
        return ServiceFuture.fromResponse(addCustomPrebuiltEntityWithServiceResponseAsync(appId, versionId, prebuiltDomainModelCreateObject), serviceCallback);
    }

    /**
     * Adds a prebuilt entity model to a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param prebuiltDomainModelCreateObject A model object containing the name of the prebuilt entity and the name of the domain to which this model belongs.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UUID object
     */
    public Observable<UUID> addCustomPrebuiltEntityAsync(UUID appId, String versionId, PrebuiltDomainModelCreateObject prebuiltDomainModelCreateObject) {
        return addCustomPrebuiltEntityWithServiceResponseAsync(appId, versionId, prebuiltDomainModelCreateObject).map(new Func1<ServiceResponse<UUID>, UUID>() {
            @Override
            public UUID call(ServiceResponse<UUID> response) {
                return response.body();
            }
        });
    }

    /**
     * Adds a prebuilt entity model to a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param prebuiltDomainModelCreateObject A model object containing the name of the prebuilt entity and the name of the domain to which this model belongs.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UUID object
     */
    public Observable<ServiceResponse<UUID>> addCustomPrebuiltEntityWithServiceResponseAsync(UUID appId, String versionId, PrebuiltDomainModelCreateObject prebuiltDomainModelCreateObject) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (prebuiltDomainModelCreateObject == null) {
            throw new IllegalArgumentException("Parameter prebuiltDomainModelCreateObject is required and cannot be null.");
        }
        Validator.validate(prebuiltDomainModelCreateObject);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.addCustomPrebuiltEntity(appId, versionId, prebuiltDomainModelCreateObject, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UUID>>>() {
                @Override
                public Observable<ServiceResponse<UUID>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UUID> clientResponse = addCustomPrebuiltEntityDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<UUID> addCustomPrebuiltEntityDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<UUID, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(201, new TypeToken<UUID>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Gets all prebuilt entities used in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;EntityExtractor&gt; object if successful.
     */
    public List<EntityExtractor> listCustomPrebuiltEntities(UUID appId, String versionId) {
        return listCustomPrebuiltEntitiesWithServiceResponseAsync(appId, versionId).toBlocking().single().body();
    }

    /**
     * Gets all prebuilt entities used in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<EntityExtractor>> listCustomPrebuiltEntitiesAsync(UUID appId, String versionId, final ServiceCallback<List<EntityExtractor>> serviceCallback) {
        return ServiceFuture.fromResponse(listCustomPrebuiltEntitiesWithServiceResponseAsync(appId, versionId), serviceCallback);
    }

    /**
     * Gets all prebuilt entities used in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;EntityExtractor&gt; object
     */
    public Observable<List<EntityExtractor>> listCustomPrebuiltEntitiesAsync(UUID appId, String versionId) {
        return listCustomPrebuiltEntitiesWithServiceResponseAsync(appId, versionId).map(new Func1<ServiceResponse<List<EntityExtractor>>, List<EntityExtractor>>() {
            @Override
            public List<EntityExtractor> call(ServiceResponse<List<EntityExtractor>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets all prebuilt entities used in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;EntityExtractor&gt; object
     */
    public Observable<ServiceResponse<List<EntityExtractor>>> listCustomPrebuiltEntitiesWithServiceResponseAsync(UUID appId, String versionId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.listCustomPrebuiltEntities(appId, versionId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<EntityExtractor>>>>() {
                @Override
                public Observable<ServiceResponse<List<EntityExtractor>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<EntityExtractor>> clientResponse = listCustomPrebuiltEntitiesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<EntityExtractor>> listCustomPrebuiltEntitiesDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<EntityExtractor>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<EntityExtractor>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Gets all prebuilt intent and entity model information used in a version of this application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;CustomPrebuiltModel&gt; object if successful.
     */
    public List<CustomPrebuiltModel> listCustomPrebuiltModels(UUID appId, String versionId) {
        return listCustomPrebuiltModelsWithServiceResponseAsync(appId, versionId).toBlocking().single().body();
    }

    /**
     * Gets all prebuilt intent and entity model information used in a version of this application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<CustomPrebuiltModel>> listCustomPrebuiltModelsAsync(UUID appId, String versionId, final ServiceCallback<List<CustomPrebuiltModel>> serviceCallback) {
        return ServiceFuture.fromResponse(listCustomPrebuiltModelsWithServiceResponseAsync(appId, versionId), serviceCallback);
    }

    /**
     * Gets all prebuilt intent and entity model information used in a version of this application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;CustomPrebuiltModel&gt; object
     */
    public Observable<List<CustomPrebuiltModel>> listCustomPrebuiltModelsAsync(UUID appId, String versionId) {
        return listCustomPrebuiltModelsWithServiceResponseAsync(appId, versionId).map(new Func1<ServiceResponse<List<CustomPrebuiltModel>>, List<CustomPrebuiltModel>>() {
            @Override
            public List<CustomPrebuiltModel> call(ServiceResponse<List<CustomPrebuiltModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets all prebuilt intent and entity model information used in a version of this application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;CustomPrebuiltModel&gt; object
     */
    public Observable<ServiceResponse<List<CustomPrebuiltModel>>> listCustomPrebuiltModelsWithServiceResponseAsync(UUID appId, String versionId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.listCustomPrebuiltModels(appId, versionId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<CustomPrebuiltModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<CustomPrebuiltModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<CustomPrebuiltModel>> clientResponse = listCustomPrebuiltModelsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<CustomPrebuiltModel>> listCustomPrebuiltModelsDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<CustomPrebuiltModel>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<CustomPrebuiltModel>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Deletes a prebuilt domain's models in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param domainName Domain name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatus object if successful.
     */
    public OperationStatus deleteCustomPrebuiltDomain(UUID appId, String versionId, String domainName) {
        return deleteCustomPrebuiltDomainWithServiceResponseAsync(appId, versionId, domainName).toBlocking().single().body();
    }

    /**
     * Deletes a prebuilt domain's models in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param domainName Domain name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatus> deleteCustomPrebuiltDomainAsync(UUID appId, String versionId, String domainName, final ServiceCallback<OperationStatus> serviceCallback) {
        return ServiceFuture.fromResponse(deleteCustomPrebuiltDomainWithServiceResponseAsync(appId, versionId, domainName), serviceCallback);
    }

    /**
     * Deletes a prebuilt domain's models in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param domainName Domain name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<OperationStatus> deleteCustomPrebuiltDomainAsync(UUID appId, String versionId, String domainName) {
        return deleteCustomPrebuiltDomainWithServiceResponseAsync(appId, versionId, domainName).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
            @Override
            public OperationStatus call(ServiceResponse<OperationStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a prebuilt domain's models in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param domainName Domain name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> deleteCustomPrebuiltDomainWithServiceResponseAsync(UUID appId, String versionId, String domainName) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (domainName == null) {
            throw new IllegalArgumentException("Parameter domainName is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.deleteCustomPrebuiltDomain(appId, versionId, domainName, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatus>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatus> clientResponse = deleteCustomPrebuiltDomainDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatus> deleteCustomPrebuiltDomainDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatus, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatus>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Creates a single child in an existing entity model hierarchy in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity extractor ID.
     * @param childEntityModelCreateObject A model object containing the name of the new child model and its children.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UUID object if successful.
     */
    public UUID addEntityChild(UUID appId, String versionId, UUID entityId, ChildEntityModelCreateObject childEntityModelCreateObject) {
        return addEntityChildWithServiceResponseAsync(appId, versionId, entityId, childEntityModelCreateObject).toBlocking().single().body();
    }

    /**
     * Creates a single child in an existing entity model hierarchy in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity extractor ID.
     * @param childEntityModelCreateObject A model object containing the name of the new child model and its children.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UUID> addEntityChildAsync(UUID appId, String versionId, UUID entityId, ChildEntityModelCreateObject childEntityModelCreateObject, final ServiceCallback<UUID> serviceCallback) {
        return ServiceFuture.fromResponse(addEntityChildWithServiceResponseAsync(appId, versionId, entityId, childEntityModelCreateObject), serviceCallback);
    }

    /**
     * Creates a single child in an existing entity model hierarchy in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity extractor ID.
     * @param childEntityModelCreateObject A model object containing the name of the new child model and its children.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UUID object
     */
    public Observable<UUID> addEntityChildAsync(UUID appId, String versionId, UUID entityId, ChildEntityModelCreateObject childEntityModelCreateObject) {
        return addEntityChildWithServiceResponseAsync(appId, versionId, entityId, childEntityModelCreateObject).map(new Func1<ServiceResponse<UUID>, UUID>() {
            @Override
            public UUID call(ServiceResponse<UUID> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a single child in an existing entity model hierarchy in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity extractor ID.
     * @param childEntityModelCreateObject A model object containing the name of the new child model and its children.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UUID object
     */
    public Observable<ServiceResponse<UUID>> addEntityChildWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, ChildEntityModelCreateObject childEntityModelCreateObject) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        if (childEntityModelCreateObject == null) {
            throw new IllegalArgumentException("Parameter childEntityModelCreateObject is required and cannot be null.");
        }
        Validator.validate(childEntityModelCreateObject);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.addEntityChild(appId, versionId, entityId, childEntityModelCreateObject, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UUID>>>() {
                @Override
                public Observable<ServiceResponse<UUID>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UUID> clientResponse = addEntityChildDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<UUID> addEntityChildDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<UUID, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(201, new TypeToken<UUID>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Gets information about the child's model contained in an hierarchical entity child model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param hEntityId The hierarchical entity extractor ID.
     * @param hChildId The hierarchical entity extractor child ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HierarchicalChildEntity object if successful.
     */
    public HierarchicalChildEntity getHierarchicalEntityChild(UUID appId, String versionId, UUID hEntityId, UUID hChildId) {
        return getHierarchicalEntityChildWithServiceResponseAsync(appId, versionId, hEntityId, hChildId).toBlocking().single().body();
    }

    /**
     * Gets information about the child's model contained in an hierarchical entity child model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param hEntityId The hierarchical entity extractor ID.
     * @param hChildId The hierarchical entity extractor child ID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HierarchicalChildEntity> getHierarchicalEntityChildAsync(UUID appId, String versionId, UUID hEntityId, UUID hChildId, final ServiceCallback<HierarchicalChildEntity> serviceCallback) {
        return ServiceFuture.fromResponse(getHierarchicalEntityChildWithServiceResponseAsync(appId, versionId, hEntityId, hChildId), serviceCallback);
    }

    /**
     * Gets information about the child's model contained in an hierarchical entity child model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param hEntityId The hierarchical entity extractor ID.
     * @param hChildId The hierarchical entity extractor child ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HierarchicalChildEntity object
     */
    public Observable<HierarchicalChildEntity> getHierarchicalEntityChildAsync(UUID appId, String versionId, UUID hEntityId, UUID hChildId) {
        return getHierarchicalEntityChildWithServiceResponseAsync(appId, versionId, hEntityId, hChildId).map(new Func1<ServiceResponse<HierarchicalChildEntity>, HierarchicalChildEntity>() {
            @Override
            public HierarchicalChildEntity call(ServiceResponse<HierarchicalChildEntity> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets information about the child's model contained in an hierarchical entity child model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param hEntityId The hierarchical entity extractor ID.
     * @param hChildId The hierarchical entity extractor child ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HierarchicalChildEntity object
     */
    public Observable<ServiceResponse<HierarchicalChildEntity>> getHierarchicalEntityChildWithServiceResponseAsync(UUID appId, String versionId, UUID hEntityId, UUID hChildId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (hEntityId == null) {
            throw new IllegalArgumentException("Parameter hEntityId is required and cannot be null.");
        }
        if (hChildId == null) {
            throw new IllegalArgumentException("Parameter hChildId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.getHierarchicalEntityChild(appId, versionId, hEntityId, hChildId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HierarchicalChildEntity>>>() {
                @Override
                public Observable<ServiceResponse<HierarchicalChildEntity>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HierarchicalChildEntity> clientResponse = getHierarchicalEntityChildDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HierarchicalChildEntity> getHierarchicalEntityChildDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<HierarchicalChildEntity, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<HierarchicalChildEntity>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }


    /**
     * Renames a single child in an existing hierarchical entity model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param hEntityId The hierarchical entity extractor ID.
     * @param hChildId The hierarchical entity extractor child ID.
     * @param updateHierarchicalEntityChildOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatus object if successful.
     */
    public OperationStatus updateHierarchicalEntityChild(UUID appId, String versionId, UUID hEntityId, UUID hChildId, UpdateHierarchicalEntityChildOptionalParameter updateHierarchicalEntityChildOptionalParameter) {
        return updateHierarchicalEntityChildWithServiceResponseAsync(appId, versionId, hEntityId, hChildId, updateHierarchicalEntityChildOptionalParameter).toBlocking().single().body();
    }

    /**
     * Renames a single child in an existing hierarchical entity model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param hEntityId The hierarchical entity extractor ID.
     * @param hChildId The hierarchical entity extractor child ID.
     * @param updateHierarchicalEntityChildOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatus> updateHierarchicalEntityChildAsync(UUID appId, String versionId, UUID hEntityId, UUID hChildId, UpdateHierarchicalEntityChildOptionalParameter updateHierarchicalEntityChildOptionalParameter, final ServiceCallback<OperationStatus> serviceCallback) {
        return ServiceFuture.fromResponse(updateHierarchicalEntityChildWithServiceResponseAsync(appId, versionId, hEntityId, hChildId, updateHierarchicalEntityChildOptionalParameter), serviceCallback);
    }

    /**
     * Renames a single child in an existing hierarchical entity model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param hEntityId The hierarchical entity extractor ID.
     * @param hChildId The hierarchical entity extractor child ID.
     * @param updateHierarchicalEntityChildOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<OperationStatus> updateHierarchicalEntityChildAsync(UUID appId, String versionId, UUID hEntityId, UUID hChildId, UpdateHierarchicalEntityChildOptionalParameter updateHierarchicalEntityChildOptionalParameter) {
        return updateHierarchicalEntityChildWithServiceResponseAsync(appId, versionId, hEntityId, hChildId, updateHierarchicalEntityChildOptionalParameter).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
            @Override
            public OperationStatus call(ServiceResponse<OperationStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Renames a single child in an existing hierarchical entity model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param hEntityId The hierarchical entity extractor ID.
     * @param hChildId The hierarchical entity extractor child ID.
     * @param updateHierarchicalEntityChildOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> updateHierarchicalEntityChildWithServiceResponseAsync(UUID appId, String versionId, UUID hEntityId, UUID hChildId, UpdateHierarchicalEntityChildOptionalParameter updateHierarchicalEntityChildOptionalParameter) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (hEntityId == null) {
            throw new IllegalArgumentException("Parameter hEntityId is required and cannot be null.");
        }
        if (hChildId == null) {
            throw new IllegalArgumentException("Parameter hChildId is required and cannot be null.");
        }
        final String name = updateHierarchicalEntityChildOptionalParameter != null ? updateHierarchicalEntityChildOptionalParameter.name() : null;

        return updateHierarchicalEntityChildWithServiceResponseAsync(appId, versionId, hEntityId, hChildId, name);
    }

    /**
     * Renames a single child in an existing hierarchical entity model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param hEntityId The hierarchical entity extractor ID.
     * @param hChildId The hierarchical entity extractor child ID.
     * @param name the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> updateHierarchicalEntityChildWithServiceResponseAsync(UUID appId, String versionId, UUID hEntityId, UUID hChildId, String name) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (hEntityId == null) {
            throw new IllegalArgumentException("Parameter hEntityId is required and cannot be null.");
        }
        if (hChildId == null) {
            throw new IllegalArgumentException("Parameter hChildId is required and cannot be null.");
        }
        HierarchicalChildModelUpdateObject hierarchicalChildModelUpdateObject = new HierarchicalChildModelUpdateObject();
        hierarchicalChildModelUpdateObject.withName(name);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.updateHierarchicalEntityChild(appId, versionId, hEntityId, hChildId, this.client.acceptLanguage(), hierarchicalChildModelUpdateObject, parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatus>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatus> clientResponse = updateHierarchicalEntityChildDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatus> updateHierarchicalEntityChildDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatus, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatus>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    @Override
    public ModelsUpdateHierarchicalEntityChildParameters updateHierarchicalEntityChild() {
        return new ModelsUpdateHierarchicalEntityChildParameters(this);
    }

    /**
     * Internal class implementing ModelsUpdateHierarchicalEntityChildDefinition.
     */
    class ModelsUpdateHierarchicalEntityChildParameters implements ModelsUpdateHierarchicalEntityChildDefinition {
        private ModelsImpl parent;
        private UUID appId;
        private String versionId;
        private UUID hEntityId;
        private UUID hChildId;
        private String name;

        /**
         * Constructor.
         * @param parent the parent object.
         */
        ModelsUpdateHierarchicalEntityChildParameters(ModelsImpl parent) {
            this.parent = parent;
        }

        @Override
        public ModelsUpdateHierarchicalEntityChildParameters withAppId(UUID appId) {
            this.appId = appId;
            return this;
        }

        @Override
        public ModelsUpdateHierarchicalEntityChildParameters withVersionId(String versionId) {
            this.versionId = versionId;
            return this;
        }

        @Override
        public ModelsUpdateHierarchicalEntityChildParameters withHEntityId(UUID hEntityId) {
            this.hEntityId = hEntityId;
            return this;
        }

        @Override
        public ModelsUpdateHierarchicalEntityChildParameters withHChildId(UUID hChildId) {
            this.hChildId = hChildId;
            return this;
        }

        @Override
        public ModelsUpdateHierarchicalEntityChildParameters withName(String name) {
            this.name = name;
            return this;
        }

        @Override
        public OperationStatus execute() {
        return updateHierarchicalEntityChildWithServiceResponseAsync(appId, versionId, hEntityId, hChildId, name).toBlocking().single().body();
    }

        @Override
        public Observable<OperationStatus> executeAsync() {
            return updateHierarchicalEntityChildWithServiceResponseAsync(appId, versionId, hEntityId, hChildId, name).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
                @Override
                public OperationStatus call(ServiceResponse<OperationStatus> response) {
                    return response.body();
                }
            });
        }
    }

    /**
     * Deletes a hierarchical entity extractor child in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param hEntityId The hierarchical entity extractor ID.
     * @param hChildId The hierarchical entity extractor child ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatus object if successful.
     */
    public OperationStatus deleteHierarchicalEntityChild(UUID appId, String versionId, UUID hEntityId, UUID hChildId) {
        return deleteHierarchicalEntityChildWithServiceResponseAsync(appId, versionId, hEntityId, hChildId).toBlocking().single().body();
    }

    /**
     * Deletes a hierarchical entity extractor child in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param hEntityId The hierarchical entity extractor ID.
     * @param hChildId The hierarchical entity extractor child ID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatus> deleteHierarchicalEntityChildAsync(UUID appId, String versionId, UUID hEntityId, UUID hChildId, final ServiceCallback<OperationStatus> serviceCallback) {
        return ServiceFuture.fromResponse(deleteHierarchicalEntityChildWithServiceResponseAsync(appId, versionId, hEntityId, hChildId), serviceCallback);
    }

    /**
     * Deletes a hierarchical entity extractor child in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param hEntityId The hierarchical entity extractor ID.
     * @param hChildId The hierarchical entity extractor child ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<OperationStatus> deleteHierarchicalEntityChildAsync(UUID appId, String versionId, UUID hEntityId, UUID hChildId) {
        return deleteHierarchicalEntityChildWithServiceResponseAsync(appId, versionId, hEntityId, hChildId).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
            @Override
            public OperationStatus call(ServiceResponse<OperationStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a hierarchical entity extractor child in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param hEntityId The hierarchical entity extractor ID.
     * @param hChildId The hierarchical entity extractor child ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> deleteHierarchicalEntityChildWithServiceResponseAsync(UUID appId, String versionId, UUID hEntityId, UUID hChildId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (hEntityId == null) {
            throw new IllegalArgumentException("Parameter hEntityId is required and cannot be null.");
        }
        if (hChildId == null) {
            throw new IllegalArgumentException("Parameter hChildId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.deleteHierarchicalEntityChild(appId, versionId, hEntityId, hChildId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatus>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatus> clientResponse = deleteHierarchicalEntityChildDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatus> deleteHierarchicalEntityChildDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatus, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatus>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }


    /**
     * Creates a single child in an existing composite entity model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param cEntityId The composite entity extractor ID.
     * @param addCompositeEntityChildOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UUID object if successful.
     */
    public UUID addCompositeEntityChild(UUID appId, String versionId, UUID cEntityId, AddCompositeEntityChildOptionalParameter addCompositeEntityChildOptionalParameter) {
        return addCompositeEntityChildWithServiceResponseAsync(appId, versionId, cEntityId, addCompositeEntityChildOptionalParameter).toBlocking().single().body();
    }

    /**
     * Creates a single child in an existing composite entity model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param cEntityId The composite entity extractor ID.
     * @param addCompositeEntityChildOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UUID> addCompositeEntityChildAsync(UUID appId, String versionId, UUID cEntityId, AddCompositeEntityChildOptionalParameter addCompositeEntityChildOptionalParameter, final ServiceCallback<UUID> serviceCallback) {
        return ServiceFuture.fromResponse(addCompositeEntityChildWithServiceResponseAsync(appId, versionId, cEntityId, addCompositeEntityChildOptionalParameter), serviceCallback);
    }

    /**
     * Creates a single child in an existing composite entity model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param cEntityId The composite entity extractor ID.
     * @param addCompositeEntityChildOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UUID object
     */
    public Observable<UUID> addCompositeEntityChildAsync(UUID appId, String versionId, UUID cEntityId, AddCompositeEntityChildOptionalParameter addCompositeEntityChildOptionalParameter) {
        return addCompositeEntityChildWithServiceResponseAsync(appId, versionId, cEntityId, addCompositeEntityChildOptionalParameter).map(new Func1<ServiceResponse<UUID>, UUID>() {
            @Override
            public UUID call(ServiceResponse<UUID> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a single child in an existing composite entity model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param cEntityId The composite entity extractor ID.
     * @param addCompositeEntityChildOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UUID object
     */
    public Observable<ServiceResponse<UUID>> addCompositeEntityChildWithServiceResponseAsync(UUID appId, String versionId, UUID cEntityId, AddCompositeEntityChildOptionalParameter addCompositeEntityChildOptionalParameter) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (cEntityId == null) {
            throw new IllegalArgumentException("Parameter cEntityId is required and cannot be null.");
        }
        final String name = addCompositeEntityChildOptionalParameter != null ? addCompositeEntityChildOptionalParameter.name() : null;

        return addCompositeEntityChildWithServiceResponseAsync(appId, versionId, cEntityId, name);
    }

    /**
     * Creates a single child in an existing composite entity model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param cEntityId The composite entity extractor ID.
     * @param name the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UUID object
     */
    public Observable<ServiceResponse<UUID>> addCompositeEntityChildWithServiceResponseAsync(UUID appId, String versionId, UUID cEntityId, String name) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (cEntityId == null) {
            throw new IllegalArgumentException("Parameter cEntityId is required and cannot be null.");
        }
        CompositeChildModelCreateObject compositeChildModelCreateObject = new CompositeChildModelCreateObject();
        compositeChildModelCreateObject.withName(name);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.addCompositeEntityChild(appId, versionId, cEntityId, this.client.acceptLanguage(), compositeChildModelCreateObject, parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UUID>>>() {
                @Override
                public Observable<ServiceResponse<UUID>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UUID> clientResponse = addCompositeEntityChildDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<UUID> addCompositeEntityChildDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<UUID, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(201, new TypeToken<UUID>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    @Override
    public ModelsAddCompositeEntityChildParameters addCompositeEntityChild() {
        return new ModelsAddCompositeEntityChildParameters(this);
    }

    /**
     * Internal class implementing ModelsAddCompositeEntityChildDefinition.
     */
    class ModelsAddCompositeEntityChildParameters implements ModelsAddCompositeEntityChildDefinition {
        private ModelsImpl parent;
        private UUID appId;
        private String versionId;
        private UUID cEntityId;
        private String name;

        /**
         * Constructor.
         * @param parent the parent object.
         */
        ModelsAddCompositeEntityChildParameters(ModelsImpl parent) {
            this.parent = parent;
        }

        @Override
        public ModelsAddCompositeEntityChildParameters withAppId(UUID appId) {
            this.appId = appId;
            return this;
        }

        @Override
        public ModelsAddCompositeEntityChildParameters withVersionId(String versionId) {
            this.versionId = versionId;
            return this;
        }

        @Override
        public ModelsAddCompositeEntityChildParameters withCEntityId(UUID cEntityId) {
            this.cEntityId = cEntityId;
            return this;
        }

        @Override
        public ModelsAddCompositeEntityChildParameters withName(String name) {
            this.name = name;
            return this;
        }

        @Override
        public UUID execute() {
        return addCompositeEntityChildWithServiceResponseAsync(appId, versionId, cEntityId, name).toBlocking().single().body();
    }

        @Override
        public Observable<UUID> executeAsync() {
            return addCompositeEntityChildWithServiceResponseAsync(appId, versionId, cEntityId, name).map(new Func1<ServiceResponse<UUID>, UUID>() {
                @Override
                public UUID call(ServiceResponse<UUID> response) {
                    return response.body();
                }
            });
        }
    }

    /**
     * Deletes a composite entity extractor child from a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param cEntityId The composite entity extractor ID.
     * @param cChildId The hierarchical entity extractor child ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatus object if successful.
     */
    public OperationStatus deleteCompositeEntityChild(UUID appId, String versionId, UUID cEntityId, UUID cChildId) {
        return deleteCompositeEntityChildWithServiceResponseAsync(appId, versionId, cEntityId, cChildId).toBlocking().single().body();
    }

    /**
     * Deletes a composite entity extractor child from a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param cEntityId The composite entity extractor ID.
     * @param cChildId The hierarchical entity extractor child ID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatus> deleteCompositeEntityChildAsync(UUID appId, String versionId, UUID cEntityId, UUID cChildId, final ServiceCallback<OperationStatus> serviceCallback) {
        return ServiceFuture.fromResponse(deleteCompositeEntityChildWithServiceResponseAsync(appId, versionId, cEntityId, cChildId), serviceCallback);
    }

    /**
     * Deletes a composite entity extractor child from a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param cEntityId The composite entity extractor ID.
     * @param cChildId The hierarchical entity extractor child ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<OperationStatus> deleteCompositeEntityChildAsync(UUID appId, String versionId, UUID cEntityId, UUID cChildId) {
        return deleteCompositeEntityChildWithServiceResponseAsync(appId, versionId, cEntityId, cChildId).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
            @Override
            public OperationStatus call(ServiceResponse<OperationStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a composite entity extractor child from a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param cEntityId The composite entity extractor ID.
     * @param cChildId The hierarchical entity extractor child ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> deleteCompositeEntityChildWithServiceResponseAsync(UUID appId, String versionId, UUID cEntityId, UUID cChildId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (cEntityId == null) {
            throw new IllegalArgumentException("Parameter cEntityId is required and cannot be null.");
        }
        if (cChildId == null) {
            throw new IllegalArgumentException("Parameter cChildId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.deleteCompositeEntityChild(appId, versionId, cEntityId, cChildId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatus>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatus> clientResponse = deleteCompositeEntityChildDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatus> deleteCompositeEntityChildDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatus, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatus>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }


    /**
     * Gets information about the regular expression entity models in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param listRegexEntityInfosOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;RegexEntityExtractor&gt; object if successful.
     */
    public List<RegexEntityExtractor> listRegexEntityInfos(UUID appId, String versionId, ListRegexEntityInfosOptionalParameter listRegexEntityInfosOptionalParameter) {
        return listRegexEntityInfosWithServiceResponseAsync(appId, versionId, listRegexEntityInfosOptionalParameter).toBlocking().single().body();
    }

    /**
     * Gets information about the regular expression entity models in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param listRegexEntityInfosOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<RegexEntityExtractor>> listRegexEntityInfosAsync(UUID appId, String versionId, ListRegexEntityInfosOptionalParameter listRegexEntityInfosOptionalParameter, final ServiceCallback<List<RegexEntityExtractor>> serviceCallback) {
        return ServiceFuture.fromResponse(listRegexEntityInfosWithServiceResponseAsync(appId, versionId, listRegexEntityInfosOptionalParameter), serviceCallback);
    }

    /**
     * Gets information about the regular expression entity models in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param listRegexEntityInfosOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RegexEntityExtractor&gt; object
     */
    public Observable<List<RegexEntityExtractor>> listRegexEntityInfosAsync(UUID appId, String versionId, ListRegexEntityInfosOptionalParameter listRegexEntityInfosOptionalParameter) {
        return listRegexEntityInfosWithServiceResponseAsync(appId, versionId, listRegexEntityInfosOptionalParameter).map(new Func1<ServiceResponse<List<RegexEntityExtractor>>, List<RegexEntityExtractor>>() {
            @Override
            public List<RegexEntityExtractor> call(ServiceResponse<List<RegexEntityExtractor>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets information about the regular expression entity models in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param listRegexEntityInfosOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RegexEntityExtractor&gt; object
     */
    public Observable<ServiceResponse<List<RegexEntityExtractor>>> listRegexEntityInfosWithServiceResponseAsync(UUID appId, String versionId, ListRegexEntityInfosOptionalParameter listRegexEntityInfosOptionalParameter) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        final Integer skip = listRegexEntityInfosOptionalParameter != null ? listRegexEntityInfosOptionalParameter.skip() : null;
        final Integer take = listRegexEntityInfosOptionalParameter != null ? listRegexEntityInfosOptionalParameter.take() : null;

        return listRegexEntityInfosWithServiceResponseAsync(appId, versionId, skip, take);
    }

    /**
     * Gets information about the regular expression entity models in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param skip The number of entries to skip. Default value is 0.
     * @param take The number of entries to return. Maximum page size is 500. Default is 100.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RegexEntityExtractor&gt; object
     */
    public Observable<ServiceResponse<List<RegexEntityExtractor>>> listRegexEntityInfosWithServiceResponseAsync(UUID appId, String versionId, Integer skip, Integer take) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.listRegexEntityInfos(appId, versionId, skip, take, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<RegexEntityExtractor>>>>() {
                @Override
                public Observable<ServiceResponse<List<RegexEntityExtractor>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<RegexEntityExtractor>> clientResponse = listRegexEntityInfosDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<RegexEntityExtractor>> listRegexEntityInfosDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<RegexEntityExtractor>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<RegexEntityExtractor>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    @Override
    public ModelsListRegexEntityInfosParameters listRegexEntityInfos() {
        return new ModelsListRegexEntityInfosParameters(this);
    }

    /**
     * Internal class implementing ModelsListRegexEntityInfosDefinition.
     */
    class ModelsListRegexEntityInfosParameters implements ModelsListRegexEntityInfosDefinition {
        private ModelsImpl parent;
        private UUID appId;
        private String versionId;
        private Integer skip;
        private Integer take;

        /**
         * Constructor.
         * @param parent the parent object.
         */
        ModelsListRegexEntityInfosParameters(ModelsImpl parent) {
            this.parent = parent;
        }

        @Override
        public ModelsListRegexEntityInfosParameters withAppId(UUID appId) {
            this.appId = appId;
            return this;
        }

        @Override
        public ModelsListRegexEntityInfosParameters withVersionId(String versionId) {
            this.versionId = versionId;
            return this;
        }

        @Override
        public ModelsListRegexEntityInfosParameters withSkip(Integer skip) {
            this.skip = skip;
            return this;
        }

        @Override
        public ModelsListRegexEntityInfosParameters withTake(Integer take) {
            this.take = take;
            return this;
        }

        @Override
        public List<RegexEntityExtractor> execute() {
        return listRegexEntityInfosWithServiceResponseAsync(appId, versionId, skip, take).toBlocking().single().body();
    }

        @Override
        public Observable<List<RegexEntityExtractor>> executeAsync() {
            return listRegexEntityInfosWithServiceResponseAsync(appId, versionId, skip, take).map(new Func1<ServiceResponse<List<RegexEntityExtractor>>, List<RegexEntityExtractor>>() {
                @Override
                public List<RegexEntityExtractor> call(ServiceResponse<List<RegexEntityExtractor>> response) {
                    return response.body();
                }
            });
        }
    }

    /**
     * Adds a regular expression entity model to a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param regexEntityExtractorCreateObj A model object containing the name and regex pattern for the new regular expression entity extractor.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UUID object if successful.
     */
    public UUID createRegexEntityModel(UUID appId, String versionId, RegexModelCreateObject regexEntityExtractorCreateObj) {
        return createRegexEntityModelWithServiceResponseAsync(appId, versionId, regexEntityExtractorCreateObj).toBlocking().single().body();
    }

    /**
     * Adds a regular expression entity model to a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param regexEntityExtractorCreateObj A model object containing the name and regex pattern for the new regular expression entity extractor.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UUID> createRegexEntityModelAsync(UUID appId, String versionId, RegexModelCreateObject regexEntityExtractorCreateObj, final ServiceCallback<UUID> serviceCallback) {
        return ServiceFuture.fromResponse(createRegexEntityModelWithServiceResponseAsync(appId, versionId, regexEntityExtractorCreateObj), serviceCallback);
    }

    /**
     * Adds a regular expression entity model to a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param regexEntityExtractorCreateObj A model object containing the name and regex pattern for the new regular expression entity extractor.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UUID object
     */
    public Observable<UUID> createRegexEntityModelAsync(UUID appId, String versionId, RegexModelCreateObject regexEntityExtractorCreateObj) {
        return createRegexEntityModelWithServiceResponseAsync(appId, versionId, regexEntityExtractorCreateObj).map(new Func1<ServiceResponse<UUID>, UUID>() {
            @Override
            public UUID call(ServiceResponse<UUID> response) {
                return response.body();
            }
        });
    }

    /**
     * Adds a regular expression entity model to a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param regexEntityExtractorCreateObj A model object containing the name and regex pattern for the new regular expression entity extractor.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UUID object
     */
    public Observable<ServiceResponse<UUID>> createRegexEntityModelWithServiceResponseAsync(UUID appId, String versionId, RegexModelCreateObject regexEntityExtractorCreateObj) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (regexEntityExtractorCreateObj == null) {
            throw new IllegalArgumentException("Parameter regexEntityExtractorCreateObj is required and cannot be null.");
        }
        Validator.validate(regexEntityExtractorCreateObj);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.createRegexEntityModel(appId, versionId, regexEntityExtractorCreateObj, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UUID>>>() {
                @Override
                public Observable<ServiceResponse<UUID>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UUID> clientResponse = createRegexEntityModelDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<UUID> createRegexEntityModelDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<UUID, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(201, new TypeToken<UUID>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }


    /**
     * Get information about the Pattern.Any entity models in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param listPatternAnyEntityInfosOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;PatternAnyEntityExtractor&gt; object if successful.
     */
    public List<PatternAnyEntityExtractor> listPatternAnyEntityInfos(UUID appId, String versionId, ListPatternAnyEntityInfosOptionalParameter listPatternAnyEntityInfosOptionalParameter) {
        return listPatternAnyEntityInfosWithServiceResponseAsync(appId, versionId, listPatternAnyEntityInfosOptionalParameter).toBlocking().single().body();
    }

    /**
     * Get information about the Pattern.Any entity models in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param listPatternAnyEntityInfosOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<PatternAnyEntityExtractor>> listPatternAnyEntityInfosAsync(UUID appId, String versionId, ListPatternAnyEntityInfosOptionalParameter listPatternAnyEntityInfosOptionalParameter, final ServiceCallback<List<PatternAnyEntityExtractor>> serviceCallback) {
        return ServiceFuture.fromResponse(listPatternAnyEntityInfosWithServiceResponseAsync(appId, versionId, listPatternAnyEntityInfosOptionalParameter), serviceCallback);
    }

    /**
     * Get information about the Pattern.Any entity models in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param listPatternAnyEntityInfosOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PatternAnyEntityExtractor&gt; object
     */
    public Observable<List<PatternAnyEntityExtractor>> listPatternAnyEntityInfosAsync(UUID appId, String versionId, ListPatternAnyEntityInfosOptionalParameter listPatternAnyEntityInfosOptionalParameter) {
        return listPatternAnyEntityInfosWithServiceResponseAsync(appId, versionId, listPatternAnyEntityInfosOptionalParameter).map(new Func1<ServiceResponse<List<PatternAnyEntityExtractor>>, List<PatternAnyEntityExtractor>>() {
            @Override
            public List<PatternAnyEntityExtractor> call(ServiceResponse<List<PatternAnyEntityExtractor>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get information about the Pattern.Any entity models in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param listPatternAnyEntityInfosOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PatternAnyEntityExtractor&gt; object
     */
    public Observable<ServiceResponse<List<PatternAnyEntityExtractor>>> listPatternAnyEntityInfosWithServiceResponseAsync(UUID appId, String versionId, ListPatternAnyEntityInfosOptionalParameter listPatternAnyEntityInfosOptionalParameter) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        final Integer skip = listPatternAnyEntityInfosOptionalParameter != null ? listPatternAnyEntityInfosOptionalParameter.skip() : null;
        final Integer take = listPatternAnyEntityInfosOptionalParameter != null ? listPatternAnyEntityInfosOptionalParameter.take() : null;

        return listPatternAnyEntityInfosWithServiceResponseAsync(appId, versionId, skip, take);
    }

    /**
     * Get information about the Pattern.Any entity models in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param skip The number of entries to skip. Default value is 0.
     * @param take The number of entries to return. Maximum page size is 500. Default is 100.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PatternAnyEntityExtractor&gt; object
     */
    public Observable<ServiceResponse<List<PatternAnyEntityExtractor>>> listPatternAnyEntityInfosWithServiceResponseAsync(UUID appId, String versionId, Integer skip, Integer take) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.listPatternAnyEntityInfos(appId, versionId, skip, take, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<PatternAnyEntityExtractor>>>>() {
                @Override
                public Observable<ServiceResponse<List<PatternAnyEntityExtractor>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<PatternAnyEntityExtractor>> clientResponse = listPatternAnyEntityInfosDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<PatternAnyEntityExtractor>> listPatternAnyEntityInfosDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<PatternAnyEntityExtractor>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<PatternAnyEntityExtractor>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    @Override
    public ModelsListPatternAnyEntityInfosParameters listPatternAnyEntityInfos() {
        return new ModelsListPatternAnyEntityInfosParameters(this);
    }

    /**
     * Internal class implementing ModelsListPatternAnyEntityInfosDefinition.
     */
    class ModelsListPatternAnyEntityInfosParameters implements ModelsListPatternAnyEntityInfosDefinition {
        private ModelsImpl parent;
        private UUID appId;
        private String versionId;
        private Integer skip;
        private Integer take;

        /**
         * Constructor.
         * @param parent the parent object.
         */
        ModelsListPatternAnyEntityInfosParameters(ModelsImpl parent) {
            this.parent = parent;
        }

        @Override
        public ModelsListPatternAnyEntityInfosParameters withAppId(UUID appId) {
            this.appId = appId;
            return this;
        }

        @Override
        public ModelsListPatternAnyEntityInfosParameters withVersionId(String versionId) {
            this.versionId = versionId;
            return this;
        }

        @Override
        public ModelsListPatternAnyEntityInfosParameters withSkip(Integer skip) {
            this.skip = skip;
            return this;
        }

        @Override
        public ModelsListPatternAnyEntityInfosParameters withTake(Integer take) {
            this.take = take;
            return this;
        }

        @Override
        public List<PatternAnyEntityExtractor> execute() {
        return listPatternAnyEntityInfosWithServiceResponseAsync(appId, versionId, skip, take).toBlocking().single().body();
    }

        @Override
        public Observable<List<PatternAnyEntityExtractor>> executeAsync() {
            return listPatternAnyEntityInfosWithServiceResponseAsync(appId, versionId, skip, take).map(new Func1<ServiceResponse<List<PatternAnyEntityExtractor>>, List<PatternAnyEntityExtractor>>() {
                @Override
                public List<PatternAnyEntityExtractor> call(ServiceResponse<List<PatternAnyEntityExtractor>> response) {
                    return response.body();
                }
            });
        }
    }

    /**
     * Adds a pattern.any entity extractor to a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param extractorCreateObject A model object containing the name and explicit list for the new Pattern.Any entity extractor.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UUID object if successful.
     */
    public UUID createPatternAnyEntityModel(UUID appId, String versionId, PatternAnyModelCreateObject extractorCreateObject) {
        return createPatternAnyEntityModelWithServiceResponseAsync(appId, versionId, extractorCreateObject).toBlocking().single().body();
    }

    /**
     * Adds a pattern.any entity extractor to a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param extractorCreateObject A model object containing the name and explicit list for the new Pattern.Any entity extractor.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UUID> createPatternAnyEntityModelAsync(UUID appId, String versionId, PatternAnyModelCreateObject extractorCreateObject, final ServiceCallback<UUID> serviceCallback) {
        return ServiceFuture.fromResponse(createPatternAnyEntityModelWithServiceResponseAsync(appId, versionId, extractorCreateObject), serviceCallback);
    }

    /**
     * Adds a pattern.any entity extractor to a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param extractorCreateObject A model object containing the name and explicit list for the new Pattern.Any entity extractor.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UUID object
     */
    public Observable<UUID> createPatternAnyEntityModelAsync(UUID appId, String versionId, PatternAnyModelCreateObject extractorCreateObject) {
        return createPatternAnyEntityModelWithServiceResponseAsync(appId, versionId, extractorCreateObject).map(new Func1<ServiceResponse<UUID>, UUID>() {
            @Override
            public UUID call(ServiceResponse<UUID> response) {
                return response.body();
            }
        });
    }

    /**
     * Adds a pattern.any entity extractor to a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param extractorCreateObject A model object containing the name and explicit list for the new Pattern.Any entity extractor.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UUID object
     */
    public Observable<ServiceResponse<UUID>> createPatternAnyEntityModelWithServiceResponseAsync(UUID appId, String versionId, PatternAnyModelCreateObject extractorCreateObject) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (extractorCreateObject == null) {
            throw new IllegalArgumentException("Parameter extractorCreateObject is required and cannot be null.");
        }
        Validator.validate(extractorCreateObject);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.createPatternAnyEntityModel(appId, versionId, extractorCreateObject, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UUID>>>() {
                @Override
                public Observable<ServiceResponse<UUID>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UUID> clientResponse = createPatternAnyEntityModelDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<UUID> createPatternAnyEntityModelDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<UUID, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(201, new TypeToken<UUID>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Get all roles for an entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId entity Id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;EntityRole&gt; object if successful.
     */
    public List<EntityRole> listEntityRoles(UUID appId, String versionId, UUID entityId) {
        return listEntityRolesWithServiceResponseAsync(appId, versionId, entityId).toBlocking().single().body();
    }

    /**
     * Get all roles for an entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId entity Id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<EntityRole>> listEntityRolesAsync(UUID appId, String versionId, UUID entityId, final ServiceCallback<List<EntityRole>> serviceCallback) {
        return ServiceFuture.fromResponse(listEntityRolesWithServiceResponseAsync(appId, versionId, entityId), serviceCallback);
    }

    /**
     * Get all roles for an entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId entity Id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;EntityRole&gt; object
     */
    public Observable<List<EntityRole>> listEntityRolesAsync(UUID appId, String versionId, UUID entityId) {
        return listEntityRolesWithServiceResponseAsync(appId, versionId, entityId).map(new Func1<ServiceResponse<List<EntityRole>>, List<EntityRole>>() {
            @Override
            public List<EntityRole> call(ServiceResponse<List<EntityRole>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get all roles for an entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId entity Id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;EntityRole&gt; object
     */
    public Observable<ServiceResponse<List<EntityRole>>> listEntityRolesWithServiceResponseAsync(UUID appId, String versionId, UUID entityId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.listEntityRoles(appId, versionId, entityId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<EntityRole>>>>() {
                @Override
                public Observable<ServiceResponse<List<EntityRole>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<EntityRole>> clientResponse = listEntityRolesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<EntityRole>> listEntityRolesDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<EntityRole>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<EntityRole>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }


    /**
     * Create an entity role in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity model ID.
     * @param createEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UUID object if successful.
     */
    public UUID createEntityRole(UUID appId, String versionId, UUID entityId, CreateEntityRoleOptionalParameter createEntityRoleOptionalParameter) {
        return createEntityRoleWithServiceResponseAsync(appId, versionId, entityId, createEntityRoleOptionalParameter).toBlocking().single().body();
    }

    /**
     * Create an entity role in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity model ID.
     * @param createEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UUID> createEntityRoleAsync(UUID appId, String versionId, UUID entityId, CreateEntityRoleOptionalParameter createEntityRoleOptionalParameter, final ServiceCallback<UUID> serviceCallback) {
        return ServiceFuture.fromResponse(createEntityRoleWithServiceResponseAsync(appId, versionId, entityId, createEntityRoleOptionalParameter), serviceCallback);
    }

    /**
     * Create an entity role in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity model ID.
     * @param createEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UUID object
     */
    public Observable<UUID> createEntityRoleAsync(UUID appId, String versionId, UUID entityId, CreateEntityRoleOptionalParameter createEntityRoleOptionalParameter) {
        return createEntityRoleWithServiceResponseAsync(appId, versionId, entityId, createEntityRoleOptionalParameter).map(new Func1<ServiceResponse<UUID>, UUID>() {
            @Override
            public UUID call(ServiceResponse<UUID> response) {
                return response.body();
            }
        });
    }

    /**
     * Create an entity role in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity model ID.
     * @param createEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UUID object
     */
    public Observable<ServiceResponse<UUID>> createEntityRoleWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, CreateEntityRoleOptionalParameter createEntityRoleOptionalParameter) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        final String name = createEntityRoleOptionalParameter != null ? createEntityRoleOptionalParameter.name() : null;

        return createEntityRoleWithServiceResponseAsync(appId, versionId, entityId, name);
    }

    /**
     * Create an entity role in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity model ID.
     * @param name The entity role name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UUID object
     */
    public Observable<ServiceResponse<UUID>> createEntityRoleWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, String name) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        EntityRoleCreateObject entityRoleCreateObject = new EntityRoleCreateObject();
        entityRoleCreateObject.withName(name);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.createEntityRole(appId, versionId, entityId, this.client.acceptLanguage(), entityRoleCreateObject, parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UUID>>>() {
                @Override
                public Observable<ServiceResponse<UUID>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UUID> clientResponse = createEntityRoleDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<UUID> createEntityRoleDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<UUID, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(201, new TypeToken<UUID>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    @Override
    public ModelsCreateEntityRoleParameters createEntityRole() {
        return new ModelsCreateEntityRoleParameters(this);
    }

    /**
     * Internal class implementing ModelsCreateEntityRoleDefinition.
     */
    class ModelsCreateEntityRoleParameters implements ModelsCreateEntityRoleDefinition {
        private ModelsImpl parent;
        private UUID appId;
        private String versionId;
        private UUID entityId;
        private String name;

        /**
         * Constructor.
         * @param parent the parent object.
         */
        ModelsCreateEntityRoleParameters(ModelsImpl parent) {
            this.parent = parent;
        }

        @Override
        public ModelsCreateEntityRoleParameters withAppId(UUID appId) {
            this.appId = appId;
            return this;
        }

        @Override
        public ModelsCreateEntityRoleParameters withVersionId(String versionId) {
            this.versionId = versionId;
            return this;
        }

        @Override
        public ModelsCreateEntityRoleParameters withEntityId(UUID entityId) {
            this.entityId = entityId;
            return this;
        }

        @Override
        public ModelsCreateEntityRoleParameters withName(String name) {
            this.name = name;
            return this;
        }

        @Override
        public UUID execute() {
        return createEntityRoleWithServiceResponseAsync(appId, versionId, entityId, name).toBlocking().single().body();
    }

        @Override
        public Observable<UUID> executeAsync() {
            return createEntityRoleWithServiceResponseAsync(appId, versionId, entityId, name).map(new Func1<ServiceResponse<UUID>, UUID>() {
                @Override
                public UUID call(ServiceResponse<UUID> response) {
                    return response.body();
                }
            });
        }
    }

    /**
     * Get a prebuilt entity's roles in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId entity Id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;EntityRole&gt; object if successful.
     */
    public List<EntityRole> listPrebuiltEntityRoles(UUID appId, String versionId, UUID entityId) {
        return listPrebuiltEntityRolesWithServiceResponseAsync(appId, versionId, entityId).toBlocking().single().body();
    }

    /**
     * Get a prebuilt entity's roles in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId entity Id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<EntityRole>> listPrebuiltEntityRolesAsync(UUID appId, String versionId, UUID entityId, final ServiceCallback<List<EntityRole>> serviceCallback) {
        return ServiceFuture.fromResponse(listPrebuiltEntityRolesWithServiceResponseAsync(appId, versionId, entityId), serviceCallback);
    }

    /**
     * Get a prebuilt entity's roles in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId entity Id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;EntityRole&gt; object
     */
    public Observable<List<EntityRole>> listPrebuiltEntityRolesAsync(UUID appId, String versionId, UUID entityId) {
        return listPrebuiltEntityRolesWithServiceResponseAsync(appId, versionId, entityId).map(new Func1<ServiceResponse<List<EntityRole>>, List<EntityRole>>() {
            @Override
            public List<EntityRole> call(ServiceResponse<List<EntityRole>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get a prebuilt entity's roles in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId entity Id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;EntityRole&gt; object
     */
    public Observable<ServiceResponse<List<EntityRole>>> listPrebuiltEntityRolesWithServiceResponseAsync(UUID appId, String versionId, UUID entityId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.listPrebuiltEntityRoles(appId, versionId, entityId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<EntityRole>>>>() {
                @Override
                public Observable<ServiceResponse<List<EntityRole>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<EntityRole>> clientResponse = listPrebuiltEntityRolesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<EntityRole>> listPrebuiltEntityRolesDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<EntityRole>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<EntityRole>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }


    /**
     * Create a role for a prebuilt entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity model ID.
     * @param createPrebuiltEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UUID object if successful.
     */
    public UUID createPrebuiltEntityRole(UUID appId, String versionId, UUID entityId, CreatePrebuiltEntityRoleOptionalParameter createPrebuiltEntityRoleOptionalParameter) {
        return createPrebuiltEntityRoleWithServiceResponseAsync(appId, versionId, entityId, createPrebuiltEntityRoleOptionalParameter).toBlocking().single().body();
    }

    /**
     * Create a role for a prebuilt entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity model ID.
     * @param createPrebuiltEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UUID> createPrebuiltEntityRoleAsync(UUID appId, String versionId, UUID entityId, CreatePrebuiltEntityRoleOptionalParameter createPrebuiltEntityRoleOptionalParameter, final ServiceCallback<UUID> serviceCallback) {
        return ServiceFuture.fromResponse(createPrebuiltEntityRoleWithServiceResponseAsync(appId, versionId, entityId, createPrebuiltEntityRoleOptionalParameter), serviceCallback);
    }

    /**
     * Create a role for a prebuilt entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity model ID.
     * @param createPrebuiltEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UUID object
     */
    public Observable<UUID> createPrebuiltEntityRoleAsync(UUID appId, String versionId, UUID entityId, CreatePrebuiltEntityRoleOptionalParameter createPrebuiltEntityRoleOptionalParameter) {
        return createPrebuiltEntityRoleWithServiceResponseAsync(appId, versionId, entityId, createPrebuiltEntityRoleOptionalParameter).map(new Func1<ServiceResponse<UUID>, UUID>() {
            @Override
            public UUID call(ServiceResponse<UUID> response) {
                return response.body();
            }
        });
    }

    /**
     * Create a role for a prebuilt entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity model ID.
     * @param createPrebuiltEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UUID object
     */
    public Observable<ServiceResponse<UUID>> createPrebuiltEntityRoleWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, CreatePrebuiltEntityRoleOptionalParameter createPrebuiltEntityRoleOptionalParameter) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        final String name = createPrebuiltEntityRoleOptionalParameter != null ? createPrebuiltEntityRoleOptionalParameter.name() : null;

        return createPrebuiltEntityRoleWithServiceResponseAsync(appId, versionId, entityId, name);
    }

    /**
     * Create a role for a prebuilt entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity model ID.
     * @param name The entity role name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UUID object
     */
    public Observable<ServiceResponse<UUID>> createPrebuiltEntityRoleWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, String name) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        EntityRoleCreateObject entityRoleCreateObject = new EntityRoleCreateObject();
        entityRoleCreateObject.withName(name);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.createPrebuiltEntityRole(appId, versionId, entityId, this.client.acceptLanguage(), entityRoleCreateObject, parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UUID>>>() {
                @Override
                public Observable<ServiceResponse<UUID>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UUID> clientResponse = createPrebuiltEntityRoleDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<UUID> createPrebuiltEntityRoleDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<UUID, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(201, new TypeToken<UUID>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    @Override
    public ModelsCreatePrebuiltEntityRoleParameters createPrebuiltEntityRole() {
        return new ModelsCreatePrebuiltEntityRoleParameters(this);
    }

    /**
     * Internal class implementing ModelsCreatePrebuiltEntityRoleDefinition.
     */
    class ModelsCreatePrebuiltEntityRoleParameters implements ModelsCreatePrebuiltEntityRoleDefinition {
        private ModelsImpl parent;
        private UUID appId;
        private String versionId;
        private UUID entityId;
        private String name;

        /**
         * Constructor.
         * @param parent the parent object.
         */
        ModelsCreatePrebuiltEntityRoleParameters(ModelsImpl parent) {
            this.parent = parent;
        }

        @Override
        public ModelsCreatePrebuiltEntityRoleParameters withAppId(UUID appId) {
            this.appId = appId;
            return this;
        }

        @Override
        public ModelsCreatePrebuiltEntityRoleParameters withVersionId(String versionId) {
            this.versionId = versionId;
            return this;
        }

        @Override
        public ModelsCreatePrebuiltEntityRoleParameters withEntityId(UUID entityId) {
            this.entityId = entityId;
            return this;
        }

        @Override
        public ModelsCreatePrebuiltEntityRoleParameters withName(String name) {
            this.name = name;
            return this;
        }

        @Override
        public UUID execute() {
        return createPrebuiltEntityRoleWithServiceResponseAsync(appId, versionId, entityId, name).toBlocking().single().body();
    }

        @Override
        public Observable<UUID> executeAsync() {
            return createPrebuiltEntityRoleWithServiceResponseAsync(appId, versionId, entityId, name).map(new Func1<ServiceResponse<UUID>, UUID>() {
                @Override
                public UUID call(ServiceResponse<UUID> response) {
                    return response.body();
                }
            });
        }
    }

    /**
     * Get all roles for a list entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId entity Id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;EntityRole&gt; object if successful.
     */
    public List<EntityRole> listClosedListEntityRoles(UUID appId, String versionId, UUID entityId) {
        return listClosedListEntityRolesWithServiceResponseAsync(appId, versionId, entityId).toBlocking().single().body();
    }

    /**
     * Get all roles for a list entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId entity Id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<EntityRole>> listClosedListEntityRolesAsync(UUID appId, String versionId, UUID entityId, final ServiceCallback<List<EntityRole>> serviceCallback) {
        return ServiceFuture.fromResponse(listClosedListEntityRolesWithServiceResponseAsync(appId, versionId, entityId), serviceCallback);
    }

    /**
     * Get all roles for a list entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId entity Id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;EntityRole&gt; object
     */
    public Observable<List<EntityRole>> listClosedListEntityRolesAsync(UUID appId, String versionId, UUID entityId) {
        return listClosedListEntityRolesWithServiceResponseAsync(appId, versionId, entityId).map(new Func1<ServiceResponse<List<EntityRole>>, List<EntityRole>>() {
            @Override
            public List<EntityRole> call(ServiceResponse<List<EntityRole>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get all roles for a list entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId entity Id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;EntityRole&gt; object
     */
    public Observable<ServiceResponse<List<EntityRole>>> listClosedListEntityRolesWithServiceResponseAsync(UUID appId, String versionId, UUID entityId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.listClosedListEntityRoles(appId, versionId, entityId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<EntityRole>>>>() {
                @Override
                public Observable<ServiceResponse<List<EntityRole>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<EntityRole>> clientResponse = listClosedListEntityRolesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<EntityRole>> listClosedListEntityRolesDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<EntityRole>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<EntityRole>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }


    /**
     * Create a role for a list entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity model ID.
     * @param createClosedListEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UUID object if successful.
     */
    public UUID createClosedListEntityRole(UUID appId, String versionId, UUID entityId, CreateClosedListEntityRoleOptionalParameter createClosedListEntityRoleOptionalParameter) {
        return createClosedListEntityRoleWithServiceResponseAsync(appId, versionId, entityId, createClosedListEntityRoleOptionalParameter).toBlocking().single().body();
    }

    /**
     * Create a role for a list entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity model ID.
     * @param createClosedListEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UUID> createClosedListEntityRoleAsync(UUID appId, String versionId, UUID entityId, CreateClosedListEntityRoleOptionalParameter createClosedListEntityRoleOptionalParameter, final ServiceCallback<UUID> serviceCallback) {
        return ServiceFuture.fromResponse(createClosedListEntityRoleWithServiceResponseAsync(appId, versionId, entityId, createClosedListEntityRoleOptionalParameter), serviceCallback);
    }

    /**
     * Create a role for a list entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity model ID.
     * @param createClosedListEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UUID object
     */
    public Observable<UUID> createClosedListEntityRoleAsync(UUID appId, String versionId, UUID entityId, CreateClosedListEntityRoleOptionalParameter createClosedListEntityRoleOptionalParameter) {
        return createClosedListEntityRoleWithServiceResponseAsync(appId, versionId, entityId, createClosedListEntityRoleOptionalParameter).map(new Func1<ServiceResponse<UUID>, UUID>() {
            @Override
            public UUID call(ServiceResponse<UUID> response) {
                return response.body();
            }
        });
    }

    /**
     * Create a role for a list entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity model ID.
     * @param createClosedListEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UUID object
     */
    public Observable<ServiceResponse<UUID>> createClosedListEntityRoleWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, CreateClosedListEntityRoleOptionalParameter createClosedListEntityRoleOptionalParameter) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        final String name = createClosedListEntityRoleOptionalParameter != null ? createClosedListEntityRoleOptionalParameter.name() : null;

        return createClosedListEntityRoleWithServiceResponseAsync(appId, versionId, entityId, name);
    }

    /**
     * Create a role for a list entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity model ID.
     * @param name The entity role name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UUID object
     */
    public Observable<ServiceResponse<UUID>> createClosedListEntityRoleWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, String name) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        EntityRoleCreateObject entityRoleCreateObject = new EntityRoleCreateObject();
        entityRoleCreateObject.withName(name);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.createClosedListEntityRole(appId, versionId, entityId, this.client.acceptLanguage(), entityRoleCreateObject, parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UUID>>>() {
                @Override
                public Observable<ServiceResponse<UUID>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UUID> clientResponse = createClosedListEntityRoleDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<UUID> createClosedListEntityRoleDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<UUID, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(201, new TypeToken<UUID>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    @Override
    public ModelsCreateClosedListEntityRoleParameters createClosedListEntityRole() {
        return new ModelsCreateClosedListEntityRoleParameters(this);
    }

    /**
     * Internal class implementing ModelsCreateClosedListEntityRoleDefinition.
     */
    class ModelsCreateClosedListEntityRoleParameters implements ModelsCreateClosedListEntityRoleDefinition {
        private ModelsImpl parent;
        private UUID appId;
        private String versionId;
        private UUID entityId;
        private String name;

        /**
         * Constructor.
         * @param parent the parent object.
         */
        ModelsCreateClosedListEntityRoleParameters(ModelsImpl parent) {
            this.parent = parent;
        }

        @Override
        public ModelsCreateClosedListEntityRoleParameters withAppId(UUID appId) {
            this.appId = appId;
            return this;
        }

        @Override
        public ModelsCreateClosedListEntityRoleParameters withVersionId(String versionId) {
            this.versionId = versionId;
            return this;
        }

        @Override
        public ModelsCreateClosedListEntityRoleParameters withEntityId(UUID entityId) {
            this.entityId = entityId;
            return this;
        }

        @Override
        public ModelsCreateClosedListEntityRoleParameters withName(String name) {
            this.name = name;
            return this;
        }

        @Override
        public UUID execute() {
        return createClosedListEntityRoleWithServiceResponseAsync(appId, versionId, entityId, name).toBlocking().single().body();
    }

        @Override
        public Observable<UUID> executeAsync() {
            return createClosedListEntityRoleWithServiceResponseAsync(appId, versionId, entityId, name).map(new Func1<ServiceResponse<UUID>, UUID>() {
                @Override
                public UUID call(ServiceResponse<UUID> response) {
                    return response.body();
                }
            });
        }
    }

    /**
     * Get all roles for a regular expression entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId entity Id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;EntityRole&gt; object if successful.
     */
    public List<EntityRole> listRegexEntityRoles(UUID appId, String versionId, UUID entityId) {
        return listRegexEntityRolesWithServiceResponseAsync(appId, versionId, entityId).toBlocking().single().body();
    }

    /**
     * Get all roles for a regular expression entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId entity Id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<EntityRole>> listRegexEntityRolesAsync(UUID appId, String versionId, UUID entityId, final ServiceCallback<List<EntityRole>> serviceCallback) {
        return ServiceFuture.fromResponse(listRegexEntityRolesWithServiceResponseAsync(appId, versionId, entityId), serviceCallback);
    }

    /**
     * Get all roles for a regular expression entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId entity Id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;EntityRole&gt; object
     */
    public Observable<List<EntityRole>> listRegexEntityRolesAsync(UUID appId, String versionId, UUID entityId) {
        return listRegexEntityRolesWithServiceResponseAsync(appId, versionId, entityId).map(new Func1<ServiceResponse<List<EntityRole>>, List<EntityRole>>() {
            @Override
            public List<EntityRole> call(ServiceResponse<List<EntityRole>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get all roles for a regular expression entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId entity Id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;EntityRole&gt; object
     */
    public Observable<ServiceResponse<List<EntityRole>>> listRegexEntityRolesWithServiceResponseAsync(UUID appId, String versionId, UUID entityId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.listRegexEntityRoles(appId, versionId, entityId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<EntityRole>>>>() {
                @Override
                public Observable<ServiceResponse<List<EntityRole>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<EntityRole>> clientResponse = listRegexEntityRolesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<EntityRole>> listRegexEntityRolesDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<EntityRole>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<EntityRole>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }


    /**
     * Create a role for an regular expression entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity model ID.
     * @param createRegexEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UUID object if successful.
     */
    public UUID createRegexEntityRole(UUID appId, String versionId, UUID entityId, CreateRegexEntityRoleOptionalParameter createRegexEntityRoleOptionalParameter) {
        return createRegexEntityRoleWithServiceResponseAsync(appId, versionId, entityId, createRegexEntityRoleOptionalParameter).toBlocking().single().body();
    }

    /**
     * Create a role for an regular expression entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity model ID.
     * @param createRegexEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UUID> createRegexEntityRoleAsync(UUID appId, String versionId, UUID entityId, CreateRegexEntityRoleOptionalParameter createRegexEntityRoleOptionalParameter, final ServiceCallback<UUID> serviceCallback) {
        return ServiceFuture.fromResponse(createRegexEntityRoleWithServiceResponseAsync(appId, versionId, entityId, createRegexEntityRoleOptionalParameter), serviceCallback);
    }

    /**
     * Create a role for an regular expression entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity model ID.
     * @param createRegexEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UUID object
     */
    public Observable<UUID> createRegexEntityRoleAsync(UUID appId, String versionId, UUID entityId, CreateRegexEntityRoleOptionalParameter createRegexEntityRoleOptionalParameter) {
        return createRegexEntityRoleWithServiceResponseAsync(appId, versionId, entityId, createRegexEntityRoleOptionalParameter).map(new Func1<ServiceResponse<UUID>, UUID>() {
            @Override
            public UUID call(ServiceResponse<UUID> response) {
                return response.body();
            }
        });
    }

    /**
     * Create a role for an regular expression entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity model ID.
     * @param createRegexEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UUID object
     */
    public Observable<ServiceResponse<UUID>> createRegexEntityRoleWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, CreateRegexEntityRoleOptionalParameter createRegexEntityRoleOptionalParameter) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        final String name = createRegexEntityRoleOptionalParameter != null ? createRegexEntityRoleOptionalParameter.name() : null;

        return createRegexEntityRoleWithServiceResponseAsync(appId, versionId, entityId, name);
    }

    /**
     * Create a role for an regular expression entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity model ID.
     * @param name The entity role name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UUID object
     */
    public Observable<ServiceResponse<UUID>> createRegexEntityRoleWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, String name) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        EntityRoleCreateObject entityRoleCreateObject = new EntityRoleCreateObject();
        entityRoleCreateObject.withName(name);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.createRegexEntityRole(appId, versionId, entityId, this.client.acceptLanguage(), entityRoleCreateObject, parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UUID>>>() {
                @Override
                public Observable<ServiceResponse<UUID>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UUID> clientResponse = createRegexEntityRoleDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<UUID> createRegexEntityRoleDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<UUID, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(201, new TypeToken<UUID>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    @Override
    public ModelsCreateRegexEntityRoleParameters createRegexEntityRole() {
        return new ModelsCreateRegexEntityRoleParameters(this);
    }

    /**
     * Internal class implementing ModelsCreateRegexEntityRoleDefinition.
     */
    class ModelsCreateRegexEntityRoleParameters implements ModelsCreateRegexEntityRoleDefinition {
        private ModelsImpl parent;
        private UUID appId;
        private String versionId;
        private UUID entityId;
        private String name;

        /**
         * Constructor.
         * @param parent the parent object.
         */
        ModelsCreateRegexEntityRoleParameters(ModelsImpl parent) {
            this.parent = parent;
        }

        @Override
        public ModelsCreateRegexEntityRoleParameters withAppId(UUID appId) {
            this.appId = appId;
            return this;
        }

        @Override
        public ModelsCreateRegexEntityRoleParameters withVersionId(String versionId) {
            this.versionId = versionId;
            return this;
        }

        @Override
        public ModelsCreateRegexEntityRoleParameters withEntityId(UUID entityId) {
            this.entityId = entityId;
            return this;
        }

        @Override
        public ModelsCreateRegexEntityRoleParameters withName(String name) {
            this.name = name;
            return this;
        }

        @Override
        public UUID execute() {
        return createRegexEntityRoleWithServiceResponseAsync(appId, versionId, entityId, name).toBlocking().single().body();
    }

        @Override
        public Observable<UUID> executeAsync() {
            return createRegexEntityRoleWithServiceResponseAsync(appId, versionId, entityId, name).map(new Func1<ServiceResponse<UUID>, UUID>() {
                @Override
                public UUID call(ServiceResponse<UUID> response) {
                    return response.body();
                }
            });
        }
    }

    /**
     * Get all roles for a composite entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param cEntityId The composite entity extractor ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;EntityRole&gt; object if successful.
     */
    public List<EntityRole> listCompositeEntityRoles(UUID appId, String versionId, UUID cEntityId) {
        return listCompositeEntityRolesWithServiceResponseAsync(appId, versionId, cEntityId).toBlocking().single().body();
    }

    /**
     * Get all roles for a composite entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param cEntityId The composite entity extractor ID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<EntityRole>> listCompositeEntityRolesAsync(UUID appId, String versionId, UUID cEntityId, final ServiceCallback<List<EntityRole>> serviceCallback) {
        return ServiceFuture.fromResponse(listCompositeEntityRolesWithServiceResponseAsync(appId, versionId, cEntityId), serviceCallback);
    }

    /**
     * Get all roles for a composite entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param cEntityId The composite entity extractor ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;EntityRole&gt; object
     */
    public Observable<List<EntityRole>> listCompositeEntityRolesAsync(UUID appId, String versionId, UUID cEntityId) {
        return listCompositeEntityRolesWithServiceResponseAsync(appId, versionId, cEntityId).map(new Func1<ServiceResponse<List<EntityRole>>, List<EntityRole>>() {
            @Override
            public List<EntityRole> call(ServiceResponse<List<EntityRole>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get all roles for a composite entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param cEntityId The composite entity extractor ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;EntityRole&gt; object
     */
    public Observable<ServiceResponse<List<EntityRole>>> listCompositeEntityRolesWithServiceResponseAsync(UUID appId, String versionId, UUID cEntityId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (cEntityId == null) {
            throw new IllegalArgumentException("Parameter cEntityId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.listCompositeEntityRoles(appId, versionId, cEntityId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<EntityRole>>>>() {
                @Override
                public Observable<ServiceResponse<List<EntityRole>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<EntityRole>> clientResponse = listCompositeEntityRolesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<EntityRole>> listCompositeEntityRolesDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<EntityRole>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<EntityRole>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }


    /**
     * Create a role for a composite entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param cEntityId The composite entity extractor ID.
     * @param createCompositeEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UUID object if successful.
     */
    public UUID createCompositeEntityRole(UUID appId, String versionId, UUID cEntityId, CreateCompositeEntityRoleOptionalParameter createCompositeEntityRoleOptionalParameter) {
        return createCompositeEntityRoleWithServiceResponseAsync(appId, versionId, cEntityId, createCompositeEntityRoleOptionalParameter).toBlocking().single().body();
    }

    /**
     * Create a role for a composite entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param cEntityId The composite entity extractor ID.
     * @param createCompositeEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UUID> createCompositeEntityRoleAsync(UUID appId, String versionId, UUID cEntityId, CreateCompositeEntityRoleOptionalParameter createCompositeEntityRoleOptionalParameter, final ServiceCallback<UUID> serviceCallback) {
        return ServiceFuture.fromResponse(createCompositeEntityRoleWithServiceResponseAsync(appId, versionId, cEntityId, createCompositeEntityRoleOptionalParameter), serviceCallback);
    }

    /**
     * Create a role for a composite entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param cEntityId The composite entity extractor ID.
     * @param createCompositeEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UUID object
     */
    public Observable<UUID> createCompositeEntityRoleAsync(UUID appId, String versionId, UUID cEntityId, CreateCompositeEntityRoleOptionalParameter createCompositeEntityRoleOptionalParameter) {
        return createCompositeEntityRoleWithServiceResponseAsync(appId, versionId, cEntityId, createCompositeEntityRoleOptionalParameter).map(new Func1<ServiceResponse<UUID>, UUID>() {
            @Override
            public UUID call(ServiceResponse<UUID> response) {
                return response.body();
            }
        });
    }

    /**
     * Create a role for a composite entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param cEntityId The composite entity extractor ID.
     * @param createCompositeEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UUID object
     */
    public Observable<ServiceResponse<UUID>> createCompositeEntityRoleWithServiceResponseAsync(UUID appId, String versionId, UUID cEntityId, CreateCompositeEntityRoleOptionalParameter createCompositeEntityRoleOptionalParameter) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (cEntityId == null) {
            throw new IllegalArgumentException("Parameter cEntityId is required and cannot be null.");
        }
        final String name = createCompositeEntityRoleOptionalParameter != null ? createCompositeEntityRoleOptionalParameter.name() : null;

        return createCompositeEntityRoleWithServiceResponseAsync(appId, versionId, cEntityId, name);
    }

    /**
     * Create a role for a composite entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param cEntityId The composite entity extractor ID.
     * @param name The entity role name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UUID object
     */
    public Observable<ServiceResponse<UUID>> createCompositeEntityRoleWithServiceResponseAsync(UUID appId, String versionId, UUID cEntityId, String name) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (cEntityId == null) {
            throw new IllegalArgumentException("Parameter cEntityId is required and cannot be null.");
        }
        EntityRoleCreateObject entityRoleCreateObject = new EntityRoleCreateObject();
        entityRoleCreateObject.withName(name);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.createCompositeEntityRole(appId, versionId, cEntityId, this.client.acceptLanguage(), entityRoleCreateObject, parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UUID>>>() {
                @Override
                public Observable<ServiceResponse<UUID>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UUID> clientResponse = createCompositeEntityRoleDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<UUID> createCompositeEntityRoleDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<UUID, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(201, new TypeToken<UUID>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    @Override
    public ModelsCreateCompositeEntityRoleParameters createCompositeEntityRole() {
        return new ModelsCreateCompositeEntityRoleParameters(this);
    }

    /**
     * Internal class implementing ModelsCreateCompositeEntityRoleDefinition.
     */
    class ModelsCreateCompositeEntityRoleParameters implements ModelsCreateCompositeEntityRoleDefinition {
        private ModelsImpl parent;
        private UUID appId;
        private String versionId;
        private UUID cEntityId;
        private String name;

        /**
         * Constructor.
         * @param parent the parent object.
         */
        ModelsCreateCompositeEntityRoleParameters(ModelsImpl parent) {
            this.parent = parent;
        }

        @Override
        public ModelsCreateCompositeEntityRoleParameters withAppId(UUID appId) {
            this.appId = appId;
            return this;
        }

        @Override
        public ModelsCreateCompositeEntityRoleParameters withVersionId(String versionId) {
            this.versionId = versionId;
            return this;
        }

        @Override
        public ModelsCreateCompositeEntityRoleParameters withCEntityId(UUID cEntityId) {
            this.cEntityId = cEntityId;
            return this;
        }

        @Override
        public ModelsCreateCompositeEntityRoleParameters withName(String name) {
            this.name = name;
            return this;
        }

        @Override
        public UUID execute() {
        return createCompositeEntityRoleWithServiceResponseAsync(appId, versionId, cEntityId, name).toBlocking().single().body();
    }

        @Override
        public Observable<UUID> executeAsync() {
            return createCompositeEntityRoleWithServiceResponseAsync(appId, versionId, cEntityId, name).map(new Func1<ServiceResponse<UUID>, UUID>() {
                @Override
                public UUID call(ServiceResponse<UUID> response) {
                    return response.body();
                }
            });
        }
    }

    /**
     * Get all roles for a Pattern.any entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId entity Id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;EntityRole&gt; object if successful.
     */
    public List<EntityRole> listPatternAnyEntityRoles(UUID appId, String versionId, UUID entityId) {
        return listPatternAnyEntityRolesWithServiceResponseAsync(appId, versionId, entityId).toBlocking().single().body();
    }

    /**
     * Get all roles for a Pattern.any entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId entity Id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<EntityRole>> listPatternAnyEntityRolesAsync(UUID appId, String versionId, UUID entityId, final ServiceCallback<List<EntityRole>> serviceCallback) {
        return ServiceFuture.fromResponse(listPatternAnyEntityRolesWithServiceResponseAsync(appId, versionId, entityId), serviceCallback);
    }

    /**
     * Get all roles for a Pattern.any entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId entity Id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;EntityRole&gt; object
     */
    public Observable<List<EntityRole>> listPatternAnyEntityRolesAsync(UUID appId, String versionId, UUID entityId) {
        return listPatternAnyEntityRolesWithServiceResponseAsync(appId, versionId, entityId).map(new Func1<ServiceResponse<List<EntityRole>>, List<EntityRole>>() {
            @Override
            public List<EntityRole> call(ServiceResponse<List<EntityRole>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get all roles for a Pattern.any entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId entity Id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;EntityRole&gt; object
     */
    public Observable<ServiceResponse<List<EntityRole>>> listPatternAnyEntityRolesWithServiceResponseAsync(UUID appId, String versionId, UUID entityId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.listPatternAnyEntityRoles(appId, versionId, entityId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<EntityRole>>>>() {
                @Override
                public Observable<ServiceResponse<List<EntityRole>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<EntityRole>> clientResponse = listPatternAnyEntityRolesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<EntityRole>> listPatternAnyEntityRolesDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<EntityRole>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<EntityRole>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }


    /**
     * Create a role for an Pattern.any entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity model ID.
     * @param createPatternAnyEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UUID object if successful.
     */
    public UUID createPatternAnyEntityRole(UUID appId, String versionId, UUID entityId, CreatePatternAnyEntityRoleOptionalParameter createPatternAnyEntityRoleOptionalParameter) {
        return createPatternAnyEntityRoleWithServiceResponseAsync(appId, versionId, entityId, createPatternAnyEntityRoleOptionalParameter).toBlocking().single().body();
    }

    /**
     * Create a role for an Pattern.any entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity model ID.
     * @param createPatternAnyEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UUID> createPatternAnyEntityRoleAsync(UUID appId, String versionId, UUID entityId, CreatePatternAnyEntityRoleOptionalParameter createPatternAnyEntityRoleOptionalParameter, final ServiceCallback<UUID> serviceCallback) {
        return ServiceFuture.fromResponse(createPatternAnyEntityRoleWithServiceResponseAsync(appId, versionId, entityId, createPatternAnyEntityRoleOptionalParameter), serviceCallback);
    }

    /**
     * Create a role for an Pattern.any entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity model ID.
     * @param createPatternAnyEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UUID object
     */
    public Observable<UUID> createPatternAnyEntityRoleAsync(UUID appId, String versionId, UUID entityId, CreatePatternAnyEntityRoleOptionalParameter createPatternAnyEntityRoleOptionalParameter) {
        return createPatternAnyEntityRoleWithServiceResponseAsync(appId, versionId, entityId, createPatternAnyEntityRoleOptionalParameter).map(new Func1<ServiceResponse<UUID>, UUID>() {
            @Override
            public UUID call(ServiceResponse<UUID> response) {
                return response.body();
            }
        });
    }

    /**
     * Create a role for an Pattern.any entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity model ID.
     * @param createPatternAnyEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UUID object
     */
    public Observable<ServiceResponse<UUID>> createPatternAnyEntityRoleWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, CreatePatternAnyEntityRoleOptionalParameter createPatternAnyEntityRoleOptionalParameter) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        final String name = createPatternAnyEntityRoleOptionalParameter != null ? createPatternAnyEntityRoleOptionalParameter.name() : null;

        return createPatternAnyEntityRoleWithServiceResponseAsync(appId, versionId, entityId, name);
    }

    /**
     * Create a role for an Pattern.any entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity model ID.
     * @param name The entity role name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UUID object
     */
    public Observable<ServiceResponse<UUID>> createPatternAnyEntityRoleWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, String name) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        EntityRoleCreateObject entityRoleCreateObject = new EntityRoleCreateObject();
        entityRoleCreateObject.withName(name);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.createPatternAnyEntityRole(appId, versionId, entityId, this.client.acceptLanguage(), entityRoleCreateObject, parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UUID>>>() {
                @Override
                public Observable<ServiceResponse<UUID>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UUID> clientResponse = createPatternAnyEntityRoleDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<UUID> createPatternAnyEntityRoleDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<UUID, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(201, new TypeToken<UUID>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    @Override
    public ModelsCreatePatternAnyEntityRoleParameters createPatternAnyEntityRole() {
        return new ModelsCreatePatternAnyEntityRoleParameters(this);
    }

    /**
     * Internal class implementing ModelsCreatePatternAnyEntityRoleDefinition.
     */
    class ModelsCreatePatternAnyEntityRoleParameters implements ModelsCreatePatternAnyEntityRoleDefinition {
        private ModelsImpl parent;
        private UUID appId;
        private String versionId;
        private UUID entityId;
        private String name;

        /**
         * Constructor.
         * @param parent the parent object.
         */
        ModelsCreatePatternAnyEntityRoleParameters(ModelsImpl parent) {
            this.parent = parent;
        }

        @Override
        public ModelsCreatePatternAnyEntityRoleParameters withAppId(UUID appId) {
            this.appId = appId;
            return this;
        }

        @Override
        public ModelsCreatePatternAnyEntityRoleParameters withVersionId(String versionId) {
            this.versionId = versionId;
            return this;
        }

        @Override
        public ModelsCreatePatternAnyEntityRoleParameters withEntityId(UUID entityId) {
            this.entityId = entityId;
            return this;
        }

        @Override
        public ModelsCreatePatternAnyEntityRoleParameters withName(String name) {
            this.name = name;
            return this;
        }

        @Override
        public UUID execute() {
        return createPatternAnyEntityRoleWithServiceResponseAsync(appId, versionId, entityId, name).toBlocking().single().body();
    }

        @Override
        public Observable<UUID> executeAsync() {
            return createPatternAnyEntityRoleWithServiceResponseAsync(appId, versionId, entityId, name).map(new Func1<ServiceResponse<UUID>, UUID>() {
                @Override
                public UUID call(ServiceResponse<UUID> response) {
                    return response.body();
                }
            });
        }
    }

    /**
     * Get all roles for a hierarchical entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param hEntityId The hierarchical entity extractor ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;EntityRole&gt; object if successful.
     */
    public List<EntityRole> listHierarchicalEntityRoles(UUID appId, String versionId, UUID hEntityId) {
        return listHierarchicalEntityRolesWithServiceResponseAsync(appId, versionId, hEntityId).toBlocking().single().body();
    }

    /**
     * Get all roles for a hierarchical entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param hEntityId The hierarchical entity extractor ID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<EntityRole>> listHierarchicalEntityRolesAsync(UUID appId, String versionId, UUID hEntityId, final ServiceCallback<List<EntityRole>> serviceCallback) {
        return ServiceFuture.fromResponse(listHierarchicalEntityRolesWithServiceResponseAsync(appId, versionId, hEntityId), serviceCallback);
    }

    /**
     * Get all roles for a hierarchical entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param hEntityId The hierarchical entity extractor ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;EntityRole&gt; object
     */
    public Observable<List<EntityRole>> listHierarchicalEntityRolesAsync(UUID appId, String versionId, UUID hEntityId) {
        return listHierarchicalEntityRolesWithServiceResponseAsync(appId, versionId, hEntityId).map(new Func1<ServiceResponse<List<EntityRole>>, List<EntityRole>>() {
            @Override
            public List<EntityRole> call(ServiceResponse<List<EntityRole>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get all roles for a hierarchical entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param hEntityId The hierarchical entity extractor ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;EntityRole&gt; object
     */
    public Observable<ServiceResponse<List<EntityRole>>> listHierarchicalEntityRolesWithServiceResponseAsync(UUID appId, String versionId, UUID hEntityId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (hEntityId == null) {
            throw new IllegalArgumentException("Parameter hEntityId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.listHierarchicalEntityRoles(appId, versionId, hEntityId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<EntityRole>>>>() {
                @Override
                public Observable<ServiceResponse<List<EntityRole>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<EntityRole>> clientResponse = listHierarchicalEntityRolesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<EntityRole>> listHierarchicalEntityRolesDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<EntityRole>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<EntityRole>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }


    /**
     * Create a role for an hierarchical entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param hEntityId The hierarchical entity extractor ID.
     * @param createHierarchicalEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UUID object if successful.
     */
    public UUID createHierarchicalEntityRole(UUID appId, String versionId, UUID hEntityId, CreateHierarchicalEntityRoleOptionalParameter createHierarchicalEntityRoleOptionalParameter) {
        return createHierarchicalEntityRoleWithServiceResponseAsync(appId, versionId, hEntityId, createHierarchicalEntityRoleOptionalParameter).toBlocking().single().body();
    }

    /**
     * Create a role for an hierarchical entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param hEntityId The hierarchical entity extractor ID.
     * @param createHierarchicalEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UUID> createHierarchicalEntityRoleAsync(UUID appId, String versionId, UUID hEntityId, CreateHierarchicalEntityRoleOptionalParameter createHierarchicalEntityRoleOptionalParameter, final ServiceCallback<UUID> serviceCallback) {
        return ServiceFuture.fromResponse(createHierarchicalEntityRoleWithServiceResponseAsync(appId, versionId, hEntityId, createHierarchicalEntityRoleOptionalParameter), serviceCallback);
    }

    /**
     * Create a role for an hierarchical entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param hEntityId The hierarchical entity extractor ID.
     * @param createHierarchicalEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UUID object
     */
    public Observable<UUID> createHierarchicalEntityRoleAsync(UUID appId, String versionId, UUID hEntityId, CreateHierarchicalEntityRoleOptionalParameter createHierarchicalEntityRoleOptionalParameter) {
        return createHierarchicalEntityRoleWithServiceResponseAsync(appId, versionId, hEntityId, createHierarchicalEntityRoleOptionalParameter).map(new Func1<ServiceResponse<UUID>, UUID>() {
            @Override
            public UUID call(ServiceResponse<UUID> response) {
                return response.body();
            }
        });
    }

    /**
     * Create a role for an hierarchical entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param hEntityId The hierarchical entity extractor ID.
     * @param createHierarchicalEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UUID object
     */
    public Observable<ServiceResponse<UUID>> createHierarchicalEntityRoleWithServiceResponseAsync(UUID appId, String versionId, UUID hEntityId, CreateHierarchicalEntityRoleOptionalParameter createHierarchicalEntityRoleOptionalParameter) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (hEntityId == null) {
            throw new IllegalArgumentException("Parameter hEntityId is required and cannot be null.");
        }
        final String name = createHierarchicalEntityRoleOptionalParameter != null ? createHierarchicalEntityRoleOptionalParameter.name() : null;

        return createHierarchicalEntityRoleWithServiceResponseAsync(appId, versionId, hEntityId, name);
    }

    /**
     * Create a role for an hierarchical entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param hEntityId The hierarchical entity extractor ID.
     * @param name The entity role name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UUID object
     */
    public Observable<ServiceResponse<UUID>> createHierarchicalEntityRoleWithServiceResponseAsync(UUID appId, String versionId, UUID hEntityId, String name) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (hEntityId == null) {
            throw new IllegalArgumentException("Parameter hEntityId is required and cannot be null.");
        }
        EntityRoleCreateObject entityRoleCreateObject = new EntityRoleCreateObject();
        entityRoleCreateObject.withName(name);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.createHierarchicalEntityRole(appId, versionId, hEntityId, this.client.acceptLanguage(), entityRoleCreateObject, parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UUID>>>() {
                @Override
                public Observable<ServiceResponse<UUID>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UUID> clientResponse = createHierarchicalEntityRoleDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<UUID> createHierarchicalEntityRoleDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<UUID, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(201, new TypeToken<UUID>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    @Override
    public ModelsCreateHierarchicalEntityRoleParameters createHierarchicalEntityRole() {
        return new ModelsCreateHierarchicalEntityRoleParameters(this);
    }

    /**
     * Internal class implementing ModelsCreateHierarchicalEntityRoleDefinition.
     */
    class ModelsCreateHierarchicalEntityRoleParameters implements ModelsCreateHierarchicalEntityRoleDefinition {
        private ModelsImpl parent;
        private UUID appId;
        private String versionId;
        private UUID hEntityId;
        private String name;

        /**
         * Constructor.
         * @param parent the parent object.
         */
        ModelsCreateHierarchicalEntityRoleParameters(ModelsImpl parent) {
            this.parent = parent;
        }

        @Override
        public ModelsCreateHierarchicalEntityRoleParameters withAppId(UUID appId) {
            this.appId = appId;
            return this;
        }

        @Override
        public ModelsCreateHierarchicalEntityRoleParameters withVersionId(String versionId) {
            this.versionId = versionId;
            return this;
        }

        @Override
        public ModelsCreateHierarchicalEntityRoleParameters withHEntityId(UUID hEntityId) {
            this.hEntityId = hEntityId;
            return this;
        }

        @Override
        public ModelsCreateHierarchicalEntityRoleParameters withName(String name) {
            this.name = name;
            return this;
        }

        @Override
        public UUID execute() {
        return createHierarchicalEntityRoleWithServiceResponseAsync(appId, versionId, hEntityId, name).toBlocking().single().body();
    }

        @Override
        public Observable<UUID> executeAsync() {
            return createHierarchicalEntityRoleWithServiceResponseAsync(appId, versionId, hEntityId, name).map(new Func1<ServiceResponse<UUID>, UUID>() {
                @Override
                public UUID call(ServiceResponse<UUID> response) {
                    return response.body();
                }
            });
        }
    }

    /**
     * Get all roles for a prebuilt entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId entity Id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;EntityRole&gt; object if successful.
     */
    public List<EntityRole> listCustomPrebuiltEntityRoles(UUID appId, String versionId, UUID entityId) {
        return listCustomPrebuiltEntityRolesWithServiceResponseAsync(appId, versionId, entityId).toBlocking().single().body();
    }

    /**
     * Get all roles for a prebuilt entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId entity Id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<EntityRole>> listCustomPrebuiltEntityRolesAsync(UUID appId, String versionId, UUID entityId, final ServiceCallback<List<EntityRole>> serviceCallback) {
        return ServiceFuture.fromResponse(listCustomPrebuiltEntityRolesWithServiceResponseAsync(appId, versionId, entityId), serviceCallback);
    }

    /**
     * Get all roles for a prebuilt entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId entity Id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;EntityRole&gt; object
     */
    public Observable<List<EntityRole>> listCustomPrebuiltEntityRolesAsync(UUID appId, String versionId, UUID entityId) {
        return listCustomPrebuiltEntityRolesWithServiceResponseAsync(appId, versionId, entityId).map(new Func1<ServiceResponse<List<EntityRole>>, List<EntityRole>>() {
            @Override
            public List<EntityRole> call(ServiceResponse<List<EntityRole>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get all roles for a prebuilt entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId entity Id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;EntityRole&gt; object
     */
    public Observable<ServiceResponse<List<EntityRole>>> listCustomPrebuiltEntityRolesWithServiceResponseAsync(UUID appId, String versionId, UUID entityId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.listCustomPrebuiltEntityRoles(appId, versionId, entityId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<EntityRole>>>>() {
                @Override
                public Observable<ServiceResponse<List<EntityRole>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<EntityRole>> clientResponse = listCustomPrebuiltEntityRolesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<EntityRole>> listCustomPrebuiltEntityRolesDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<EntityRole>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<EntityRole>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }


    /**
     * Create a role for a prebuilt entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity model ID.
     * @param createCustomPrebuiltEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UUID object if successful.
     */
    public UUID createCustomPrebuiltEntityRole(UUID appId, String versionId, UUID entityId, CreateCustomPrebuiltEntityRoleOptionalParameter createCustomPrebuiltEntityRoleOptionalParameter) {
        return createCustomPrebuiltEntityRoleWithServiceResponseAsync(appId, versionId, entityId, createCustomPrebuiltEntityRoleOptionalParameter).toBlocking().single().body();
    }

    /**
     * Create a role for a prebuilt entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity model ID.
     * @param createCustomPrebuiltEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UUID> createCustomPrebuiltEntityRoleAsync(UUID appId, String versionId, UUID entityId, CreateCustomPrebuiltEntityRoleOptionalParameter createCustomPrebuiltEntityRoleOptionalParameter, final ServiceCallback<UUID> serviceCallback) {
        return ServiceFuture.fromResponse(createCustomPrebuiltEntityRoleWithServiceResponseAsync(appId, versionId, entityId, createCustomPrebuiltEntityRoleOptionalParameter), serviceCallback);
    }

    /**
     * Create a role for a prebuilt entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity model ID.
     * @param createCustomPrebuiltEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UUID object
     */
    public Observable<UUID> createCustomPrebuiltEntityRoleAsync(UUID appId, String versionId, UUID entityId, CreateCustomPrebuiltEntityRoleOptionalParameter createCustomPrebuiltEntityRoleOptionalParameter) {
        return createCustomPrebuiltEntityRoleWithServiceResponseAsync(appId, versionId, entityId, createCustomPrebuiltEntityRoleOptionalParameter).map(new Func1<ServiceResponse<UUID>, UUID>() {
            @Override
            public UUID call(ServiceResponse<UUID> response) {
                return response.body();
            }
        });
    }

    /**
     * Create a role for a prebuilt entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity model ID.
     * @param createCustomPrebuiltEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UUID object
     */
    public Observable<ServiceResponse<UUID>> createCustomPrebuiltEntityRoleWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, CreateCustomPrebuiltEntityRoleOptionalParameter createCustomPrebuiltEntityRoleOptionalParameter) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        final String name = createCustomPrebuiltEntityRoleOptionalParameter != null ? createCustomPrebuiltEntityRoleOptionalParameter.name() : null;

        return createCustomPrebuiltEntityRoleWithServiceResponseAsync(appId, versionId, entityId, name);
    }

    /**
     * Create a role for a prebuilt entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity model ID.
     * @param name The entity role name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UUID object
     */
    public Observable<ServiceResponse<UUID>> createCustomPrebuiltEntityRoleWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, String name) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        EntityRoleCreateObject entityRoleCreateObject = new EntityRoleCreateObject();
        entityRoleCreateObject.withName(name);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.createCustomPrebuiltEntityRole(appId, versionId, entityId, this.client.acceptLanguage(), entityRoleCreateObject, parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UUID>>>() {
                @Override
                public Observable<ServiceResponse<UUID>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UUID> clientResponse = createCustomPrebuiltEntityRoleDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<UUID> createCustomPrebuiltEntityRoleDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<UUID, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(201, new TypeToken<UUID>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    @Override
    public ModelsCreateCustomPrebuiltEntityRoleParameters createCustomPrebuiltEntityRole() {
        return new ModelsCreateCustomPrebuiltEntityRoleParameters(this);
    }

    /**
     * Internal class implementing ModelsCreateCustomPrebuiltEntityRoleDefinition.
     */
    class ModelsCreateCustomPrebuiltEntityRoleParameters implements ModelsCreateCustomPrebuiltEntityRoleDefinition {
        private ModelsImpl parent;
        private UUID appId;
        private String versionId;
        private UUID entityId;
        private String name;

        /**
         * Constructor.
         * @param parent the parent object.
         */
        ModelsCreateCustomPrebuiltEntityRoleParameters(ModelsImpl parent) {
            this.parent = parent;
        }

        @Override
        public ModelsCreateCustomPrebuiltEntityRoleParameters withAppId(UUID appId) {
            this.appId = appId;
            return this;
        }

        @Override
        public ModelsCreateCustomPrebuiltEntityRoleParameters withVersionId(String versionId) {
            this.versionId = versionId;
            return this;
        }

        @Override
        public ModelsCreateCustomPrebuiltEntityRoleParameters withEntityId(UUID entityId) {
            this.entityId = entityId;
            return this;
        }

        @Override
        public ModelsCreateCustomPrebuiltEntityRoleParameters withName(String name) {
            this.name = name;
            return this;
        }

        @Override
        public UUID execute() {
        return createCustomPrebuiltEntityRoleWithServiceResponseAsync(appId, versionId, entityId, name).toBlocking().single().body();
    }

        @Override
        public Observable<UUID> executeAsync() {
            return createCustomPrebuiltEntityRoleWithServiceResponseAsync(appId, versionId, entityId, name).map(new Func1<ServiceResponse<UUID>, UUID>() {
                @Override
                public UUID call(ServiceResponse<UUID> response) {
                    return response.body();
                }
            });
        }
    }

    /**
     * Get the explicit (exception) list of the pattern.any entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The Pattern.Any entity id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ExplicitListItem&gt; object if successful.
     */
    public List<ExplicitListItem> getExplicitList(UUID appId, String versionId, UUID entityId) {
        return getExplicitListWithServiceResponseAsync(appId, versionId, entityId).toBlocking().single().body();
    }

    /**
     * Get the explicit (exception) list of the pattern.any entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The Pattern.Any entity id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ExplicitListItem>> getExplicitListAsync(UUID appId, String versionId, UUID entityId, final ServiceCallback<List<ExplicitListItem>> serviceCallback) {
        return ServiceFuture.fromResponse(getExplicitListWithServiceResponseAsync(appId, versionId, entityId), serviceCallback);
    }

    /**
     * Get the explicit (exception) list of the pattern.any entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The Pattern.Any entity id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ExplicitListItem&gt; object
     */
    public Observable<List<ExplicitListItem>> getExplicitListAsync(UUID appId, String versionId, UUID entityId) {
        return getExplicitListWithServiceResponseAsync(appId, versionId, entityId).map(new Func1<ServiceResponse<List<ExplicitListItem>>, List<ExplicitListItem>>() {
            @Override
            public List<ExplicitListItem> call(ServiceResponse<List<ExplicitListItem>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get the explicit (exception) list of the pattern.any entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The Pattern.Any entity id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ExplicitListItem&gt; object
     */
    public Observable<ServiceResponse<List<ExplicitListItem>>> getExplicitListWithServiceResponseAsync(UUID appId, String versionId, UUID entityId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.getExplicitList(appId, versionId, entityId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ExplicitListItem>>>>() {
                @Override
                public Observable<ServiceResponse<List<ExplicitListItem>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<ExplicitListItem>> clientResponse = getExplicitListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<ExplicitListItem>> getExplicitListDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<ExplicitListItem>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<ExplicitListItem>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }


    /**
     * Add a new exception to the explicit list for the Pattern.Any entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The Pattern.Any entity extractor ID.
     * @param addExplicitListItemOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the int object if successful.
     */
    public int addExplicitListItem(UUID appId, String versionId, UUID entityId, AddExplicitListItemOptionalParameter addExplicitListItemOptionalParameter) {
        return addExplicitListItemWithServiceResponseAsync(appId, versionId, entityId, addExplicitListItemOptionalParameter).toBlocking().single().body();
    }

    /**
     * Add a new exception to the explicit list for the Pattern.Any entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The Pattern.Any entity extractor ID.
     * @param addExplicitListItemOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Integer> addExplicitListItemAsync(UUID appId, String versionId, UUID entityId, AddExplicitListItemOptionalParameter addExplicitListItemOptionalParameter, final ServiceCallback<Integer> serviceCallback) {
        return ServiceFuture.fromResponse(addExplicitListItemWithServiceResponseAsync(appId, versionId, entityId, addExplicitListItemOptionalParameter), serviceCallback);
    }

    /**
     * Add a new exception to the explicit list for the Pattern.Any entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The Pattern.Any entity extractor ID.
     * @param addExplicitListItemOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Integer object
     */
    public Observable<Integer> addExplicitListItemAsync(UUID appId, String versionId, UUID entityId, AddExplicitListItemOptionalParameter addExplicitListItemOptionalParameter) {
        return addExplicitListItemWithServiceResponseAsync(appId, versionId, entityId, addExplicitListItemOptionalParameter).map(new Func1<ServiceResponse<Integer>, Integer>() {
            @Override
            public Integer call(ServiceResponse<Integer> response) {
                return response.body();
            }
        });
    }

    /**
     * Add a new exception to the explicit list for the Pattern.Any entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The Pattern.Any entity extractor ID.
     * @param addExplicitListItemOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Integer object
     */
    public Observable<ServiceResponse<Integer>> addExplicitListItemWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, AddExplicitListItemOptionalParameter addExplicitListItemOptionalParameter) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        final String explicitListItem = addExplicitListItemOptionalParameter != null ? addExplicitListItemOptionalParameter.explicitListItem() : null;

        return addExplicitListItemWithServiceResponseAsync(appId, versionId, entityId, explicitListItem);
    }

    /**
     * Add a new exception to the explicit list for the Pattern.Any entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The Pattern.Any entity extractor ID.
     * @param explicitListItem The explicit list item.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Integer object
     */
    public Observable<ServiceResponse<Integer>> addExplicitListItemWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, String explicitListItem) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        ExplicitListItemCreateObject item = new ExplicitListItemCreateObject();
        item.withExplicitListItem(explicitListItem);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.addExplicitListItem(appId, versionId, entityId, this.client.acceptLanguage(), item, parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Integer>>>() {
                @Override
                public Observable<ServiceResponse<Integer>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Integer> clientResponse = addExplicitListItemDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Integer> addExplicitListItemDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Integer, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(201, new TypeToken<Integer>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    @Override
    public ModelsAddExplicitListItemParameters addExplicitListItem() {
        return new ModelsAddExplicitListItemParameters(this);
    }

    /**
     * Internal class implementing ModelsAddExplicitListItemDefinition.
     */
    class ModelsAddExplicitListItemParameters implements ModelsAddExplicitListItemDefinition {
        private ModelsImpl parent;
        private UUID appId;
        private String versionId;
        private UUID entityId;
        private String explicitListItem;

        /**
         * Constructor.
         * @param parent the parent object.
         */
        ModelsAddExplicitListItemParameters(ModelsImpl parent) {
            this.parent = parent;
        }

        @Override
        public ModelsAddExplicitListItemParameters withAppId(UUID appId) {
            this.appId = appId;
            return this;
        }

        @Override
        public ModelsAddExplicitListItemParameters withVersionId(String versionId) {
            this.versionId = versionId;
            return this;
        }

        @Override
        public ModelsAddExplicitListItemParameters withEntityId(UUID entityId) {
            this.entityId = entityId;
            return this;
        }

        @Override
        public ModelsAddExplicitListItemParameters withExplicitListItem(String explicitListItem) {
            this.explicitListItem = explicitListItem;
            return this;
        }

        @Override
        public int execute() {
        return addExplicitListItemWithServiceResponseAsync(appId, versionId, entityId, explicitListItem).toBlocking().single().body();
    }

        @Override
        public Observable<Integer> executeAsync() {
            return addExplicitListItemWithServiceResponseAsync(appId, versionId, entityId, explicitListItem).map(new Func1<ServiceResponse<Integer>, Integer>() {
                @Override
                public Integer call(ServiceResponse<Integer> response) {
                    return response.body();
                }
            });
        }
    }

    /**
     * Gets information about a regular expression entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param regexEntityId The regular expression entity model ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RegexEntityExtractor object if successful.
     */
    public RegexEntityExtractor getRegexEntityEntityInfo(UUID appId, String versionId, UUID regexEntityId) {
        return getRegexEntityEntityInfoWithServiceResponseAsync(appId, versionId, regexEntityId).toBlocking().single().body();
    }

    /**
     * Gets information about a regular expression entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param regexEntityId The regular expression entity model ID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RegexEntityExtractor> getRegexEntityEntityInfoAsync(UUID appId, String versionId, UUID regexEntityId, final ServiceCallback<RegexEntityExtractor> serviceCallback) {
        return ServiceFuture.fromResponse(getRegexEntityEntityInfoWithServiceResponseAsync(appId, versionId, regexEntityId), serviceCallback);
    }

    /**
     * Gets information about a regular expression entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param regexEntityId The regular expression entity model ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RegexEntityExtractor object
     */
    public Observable<RegexEntityExtractor> getRegexEntityEntityInfoAsync(UUID appId, String versionId, UUID regexEntityId) {
        return getRegexEntityEntityInfoWithServiceResponseAsync(appId, versionId, regexEntityId).map(new Func1<ServiceResponse<RegexEntityExtractor>, RegexEntityExtractor>() {
            @Override
            public RegexEntityExtractor call(ServiceResponse<RegexEntityExtractor> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets information about a regular expression entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param regexEntityId The regular expression entity model ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RegexEntityExtractor object
     */
    public Observable<ServiceResponse<RegexEntityExtractor>> getRegexEntityEntityInfoWithServiceResponseAsync(UUID appId, String versionId, UUID regexEntityId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (regexEntityId == null) {
            throw new IllegalArgumentException("Parameter regexEntityId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.getRegexEntityEntityInfo(appId, versionId, regexEntityId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RegexEntityExtractor>>>() {
                @Override
                public Observable<ServiceResponse<RegexEntityExtractor>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RegexEntityExtractor> clientResponse = getRegexEntityEntityInfoDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RegexEntityExtractor> getRegexEntityEntityInfoDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<RegexEntityExtractor, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<RegexEntityExtractor>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Updates the regular expression entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param regexEntityId The regular expression entity extractor ID.
     * @param regexEntityUpdateObject An object containing the new entity name and regex pattern.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatus object if successful.
     */
    public OperationStatus updateRegexEntityModel(UUID appId, String versionId, UUID regexEntityId, RegexModelUpdateObject regexEntityUpdateObject) {
        return updateRegexEntityModelWithServiceResponseAsync(appId, versionId, regexEntityId, regexEntityUpdateObject).toBlocking().single().body();
    }

    /**
     * Updates the regular expression entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param regexEntityId The regular expression entity extractor ID.
     * @param regexEntityUpdateObject An object containing the new entity name and regex pattern.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatus> updateRegexEntityModelAsync(UUID appId, String versionId, UUID regexEntityId, RegexModelUpdateObject regexEntityUpdateObject, final ServiceCallback<OperationStatus> serviceCallback) {
        return ServiceFuture.fromResponse(updateRegexEntityModelWithServiceResponseAsync(appId, versionId, regexEntityId, regexEntityUpdateObject), serviceCallback);
    }

    /**
     * Updates the regular expression entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param regexEntityId The regular expression entity extractor ID.
     * @param regexEntityUpdateObject An object containing the new entity name and regex pattern.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<OperationStatus> updateRegexEntityModelAsync(UUID appId, String versionId, UUID regexEntityId, RegexModelUpdateObject regexEntityUpdateObject) {
        return updateRegexEntityModelWithServiceResponseAsync(appId, versionId, regexEntityId, regexEntityUpdateObject).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
            @Override
            public OperationStatus call(ServiceResponse<OperationStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the regular expression entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param regexEntityId The regular expression entity extractor ID.
     * @param regexEntityUpdateObject An object containing the new entity name and regex pattern.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> updateRegexEntityModelWithServiceResponseAsync(UUID appId, String versionId, UUID regexEntityId, RegexModelUpdateObject regexEntityUpdateObject) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (regexEntityId == null) {
            throw new IllegalArgumentException("Parameter regexEntityId is required and cannot be null.");
        }
        if (regexEntityUpdateObject == null) {
            throw new IllegalArgumentException("Parameter regexEntityUpdateObject is required and cannot be null.");
        }
        Validator.validate(regexEntityUpdateObject);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.updateRegexEntityModel(appId, versionId, regexEntityId, regexEntityUpdateObject, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatus>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatus> clientResponse = updateRegexEntityModelDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatus> updateRegexEntityModelDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatus, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatus>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Deletes a regular expression entity from a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param regexEntityId The regular expression entity extractor ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatus object if successful.
     */
    public OperationStatus deleteRegexEntityModel(UUID appId, String versionId, UUID regexEntityId) {
        return deleteRegexEntityModelWithServiceResponseAsync(appId, versionId, regexEntityId).toBlocking().single().body();
    }

    /**
     * Deletes a regular expression entity from a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param regexEntityId The regular expression entity extractor ID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatus> deleteRegexEntityModelAsync(UUID appId, String versionId, UUID regexEntityId, final ServiceCallback<OperationStatus> serviceCallback) {
        return ServiceFuture.fromResponse(deleteRegexEntityModelWithServiceResponseAsync(appId, versionId, regexEntityId), serviceCallback);
    }

    /**
     * Deletes a regular expression entity from a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param regexEntityId The regular expression entity extractor ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<OperationStatus> deleteRegexEntityModelAsync(UUID appId, String versionId, UUID regexEntityId) {
        return deleteRegexEntityModelWithServiceResponseAsync(appId, versionId, regexEntityId).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
            @Override
            public OperationStatus call(ServiceResponse<OperationStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a regular expression entity from a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param regexEntityId The regular expression entity extractor ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> deleteRegexEntityModelWithServiceResponseAsync(UUID appId, String versionId, UUID regexEntityId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (regexEntityId == null) {
            throw new IllegalArgumentException("Parameter regexEntityId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.deleteRegexEntityModel(appId, versionId, regexEntityId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatus>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatus> clientResponse = deleteRegexEntityModelDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatus> deleteRegexEntityModelDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatus, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatus>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Gets information about the Pattern.Any model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity extractor ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PatternAnyEntityExtractor object if successful.
     */
    public PatternAnyEntityExtractor getPatternAnyEntityInfo(UUID appId, String versionId, UUID entityId) {
        return getPatternAnyEntityInfoWithServiceResponseAsync(appId, versionId, entityId).toBlocking().single().body();
    }

    /**
     * Gets information about the Pattern.Any model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity extractor ID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PatternAnyEntityExtractor> getPatternAnyEntityInfoAsync(UUID appId, String versionId, UUID entityId, final ServiceCallback<PatternAnyEntityExtractor> serviceCallback) {
        return ServiceFuture.fromResponse(getPatternAnyEntityInfoWithServiceResponseAsync(appId, versionId, entityId), serviceCallback);
    }

    /**
     * Gets information about the Pattern.Any model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity extractor ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PatternAnyEntityExtractor object
     */
    public Observable<PatternAnyEntityExtractor> getPatternAnyEntityInfoAsync(UUID appId, String versionId, UUID entityId) {
        return getPatternAnyEntityInfoWithServiceResponseAsync(appId, versionId, entityId).map(new Func1<ServiceResponse<PatternAnyEntityExtractor>, PatternAnyEntityExtractor>() {
            @Override
            public PatternAnyEntityExtractor call(ServiceResponse<PatternAnyEntityExtractor> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets information about the Pattern.Any model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity extractor ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PatternAnyEntityExtractor object
     */
    public Observable<ServiceResponse<PatternAnyEntityExtractor>> getPatternAnyEntityInfoWithServiceResponseAsync(UUID appId, String versionId, UUID entityId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.getPatternAnyEntityInfo(appId, versionId, entityId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PatternAnyEntityExtractor>>>() {
                @Override
                public Observable<ServiceResponse<PatternAnyEntityExtractor>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PatternAnyEntityExtractor> clientResponse = getPatternAnyEntityInfoDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PatternAnyEntityExtractor> getPatternAnyEntityInfoDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PatternAnyEntityExtractor, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PatternAnyEntityExtractor>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Updates the name and explicit (exception) list of a Pattern.Any entity model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The Pattern.Any entity extractor ID.
     * @param patternAnyUpdateObject An object containing the explicit list of the Pattern.Any entity.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatus object if successful.
     */
    public OperationStatus updatePatternAnyEntityModel(UUID appId, String versionId, UUID entityId, PatternAnyModelUpdateObject patternAnyUpdateObject) {
        return updatePatternAnyEntityModelWithServiceResponseAsync(appId, versionId, entityId, patternAnyUpdateObject).toBlocking().single().body();
    }

    /**
     * Updates the name and explicit (exception) list of a Pattern.Any entity model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The Pattern.Any entity extractor ID.
     * @param patternAnyUpdateObject An object containing the explicit list of the Pattern.Any entity.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatus> updatePatternAnyEntityModelAsync(UUID appId, String versionId, UUID entityId, PatternAnyModelUpdateObject patternAnyUpdateObject, final ServiceCallback<OperationStatus> serviceCallback) {
        return ServiceFuture.fromResponse(updatePatternAnyEntityModelWithServiceResponseAsync(appId, versionId, entityId, patternAnyUpdateObject), serviceCallback);
    }

    /**
     * Updates the name and explicit (exception) list of a Pattern.Any entity model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The Pattern.Any entity extractor ID.
     * @param patternAnyUpdateObject An object containing the explicit list of the Pattern.Any entity.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<OperationStatus> updatePatternAnyEntityModelAsync(UUID appId, String versionId, UUID entityId, PatternAnyModelUpdateObject patternAnyUpdateObject) {
        return updatePatternAnyEntityModelWithServiceResponseAsync(appId, versionId, entityId, patternAnyUpdateObject).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
            @Override
            public OperationStatus call(ServiceResponse<OperationStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the name and explicit (exception) list of a Pattern.Any entity model in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The Pattern.Any entity extractor ID.
     * @param patternAnyUpdateObject An object containing the explicit list of the Pattern.Any entity.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> updatePatternAnyEntityModelWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, PatternAnyModelUpdateObject patternAnyUpdateObject) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        if (patternAnyUpdateObject == null) {
            throw new IllegalArgumentException("Parameter patternAnyUpdateObject is required and cannot be null.");
        }
        Validator.validate(patternAnyUpdateObject);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.updatePatternAnyEntityModel(appId, versionId, entityId, patternAnyUpdateObject, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatus>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatus> clientResponse = updatePatternAnyEntityModelDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatus> updatePatternAnyEntityModelDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatus, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatus>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Deletes a Pattern.Any entity extractor from a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The Pattern.Any entity extractor ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatus object if successful.
     */
    public OperationStatus deletePatternAnyEntityModel(UUID appId, String versionId, UUID entityId) {
        return deletePatternAnyEntityModelWithServiceResponseAsync(appId, versionId, entityId).toBlocking().single().body();
    }

    /**
     * Deletes a Pattern.Any entity extractor from a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The Pattern.Any entity extractor ID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatus> deletePatternAnyEntityModelAsync(UUID appId, String versionId, UUID entityId, final ServiceCallback<OperationStatus> serviceCallback) {
        return ServiceFuture.fromResponse(deletePatternAnyEntityModelWithServiceResponseAsync(appId, versionId, entityId), serviceCallback);
    }

    /**
     * Deletes a Pattern.Any entity extractor from a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The Pattern.Any entity extractor ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<OperationStatus> deletePatternAnyEntityModelAsync(UUID appId, String versionId, UUID entityId) {
        return deletePatternAnyEntityModelWithServiceResponseAsync(appId, versionId, entityId).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
            @Override
            public OperationStatus call(ServiceResponse<OperationStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a Pattern.Any entity extractor from a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The Pattern.Any entity extractor ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> deletePatternAnyEntityModelWithServiceResponseAsync(UUID appId, String versionId, UUID entityId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.deletePatternAnyEntityModel(appId, versionId, entityId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatus>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatus> clientResponse = deletePatternAnyEntityModelDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatus> deletePatternAnyEntityModelDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatus, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatus>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Get one role for a given entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId entity ID.
     * @param roleId entity role ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the EntityRole object if successful.
     */
    public EntityRole getEntityRole(UUID appId, String versionId, UUID entityId, UUID roleId) {
        return getEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId).toBlocking().single().body();
    }

    /**
     * Get one role for a given entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId entity ID.
     * @param roleId entity role ID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<EntityRole> getEntityRoleAsync(UUID appId, String versionId, UUID entityId, UUID roleId, final ServiceCallback<EntityRole> serviceCallback) {
        return ServiceFuture.fromResponse(getEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId), serviceCallback);
    }

    /**
     * Get one role for a given entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId entity ID.
     * @param roleId entity role ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EntityRole object
     */
    public Observable<EntityRole> getEntityRoleAsync(UUID appId, String versionId, UUID entityId, UUID roleId) {
        return getEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId).map(new Func1<ServiceResponse<EntityRole>, EntityRole>() {
            @Override
            public EntityRole call(ServiceResponse<EntityRole> response) {
                return response.body();
            }
        });
    }

    /**
     * Get one role for a given entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId entity ID.
     * @param roleId entity role ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EntityRole object
     */
    public Observable<ServiceResponse<EntityRole>> getEntityRoleWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, UUID roleId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        if (roleId == null) {
            throw new IllegalArgumentException("Parameter roleId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.getEntityRole(appId, versionId, entityId, roleId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<EntityRole>>>() {
                @Override
                public Observable<ServiceResponse<EntityRole>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<EntityRole> clientResponse = getEntityRoleDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<EntityRole> getEntityRoleDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<EntityRole, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<EntityRole>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }


    /**
     * Update a role for a given entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role ID.
     * @param updateEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatus object if successful.
     */
    public OperationStatus updateEntityRole(UUID appId, String versionId, UUID entityId, UUID roleId, UpdateEntityRoleOptionalParameter updateEntityRoleOptionalParameter) {
        return updateEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId, updateEntityRoleOptionalParameter).toBlocking().single().body();
    }

    /**
     * Update a role for a given entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role ID.
     * @param updateEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatus> updateEntityRoleAsync(UUID appId, String versionId, UUID entityId, UUID roleId, UpdateEntityRoleOptionalParameter updateEntityRoleOptionalParameter, final ServiceCallback<OperationStatus> serviceCallback) {
        return ServiceFuture.fromResponse(updateEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId, updateEntityRoleOptionalParameter), serviceCallback);
    }

    /**
     * Update a role for a given entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role ID.
     * @param updateEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<OperationStatus> updateEntityRoleAsync(UUID appId, String versionId, UUID entityId, UUID roleId, UpdateEntityRoleOptionalParameter updateEntityRoleOptionalParameter) {
        return updateEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId, updateEntityRoleOptionalParameter).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
            @Override
            public OperationStatus call(ServiceResponse<OperationStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Update a role for a given entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role ID.
     * @param updateEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> updateEntityRoleWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, UUID roleId, UpdateEntityRoleOptionalParameter updateEntityRoleOptionalParameter) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        if (roleId == null) {
            throw new IllegalArgumentException("Parameter roleId is required and cannot be null.");
        }
        final String name = updateEntityRoleOptionalParameter != null ? updateEntityRoleOptionalParameter.name() : null;

        return updateEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId, name);
    }

    /**
     * Update a role for a given entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role ID.
     * @param name The entity role name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> updateEntityRoleWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, UUID roleId, String name) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        if (roleId == null) {
            throw new IllegalArgumentException("Parameter roleId is required and cannot be null.");
        }
        EntityRoleUpdateObject entityRoleUpdateObject = new EntityRoleUpdateObject();
        entityRoleUpdateObject.withName(name);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.updateEntityRole(appId, versionId, entityId, roleId, this.client.acceptLanguage(), entityRoleUpdateObject, parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatus>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatus> clientResponse = updateEntityRoleDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatus> updateEntityRoleDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatus, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatus>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    @Override
    public ModelsUpdateEntityRoleParameters updateEntityRole() {
        return new ModelsUpdateEntityRoleParameters(this);
    }

    /**
     * Internal class implementing ModelsUpdateEntityRoleDefinition.
     */
    class ModelsUpdateEntityRoleParameters implements ModelsUpdateEntityRoleDefinition {
        private ModelsImpl parent;
        private UUID appId;
        private String versionId;
        private UUID entityId;
        private UUID roleId;
        private String name;

        /**
         * Constructor.
         * @param parent the parent object.
         */
        ModelsUpdateEntityRoleParameters(ModelsImpl parent) {
            this.parent = parent;
        }

        @Override
        public ModelsUpdateEntityRoleParameters withAppId(UUID appId) {
            this.appId = appId;
            return this;
        }

        @Override
        public ModelsUpdateEntityRoleParameters withVersionId(String versionId) {
            this.versionId = versionId;
            return this;
        }

        @Override
        public ModelsUpdateEntityRoleParameters withEntityId(UUID entityId) {
            this.entityId = entityId;
            return this;
        }

        @Override
        public ModelsUpdateEntityRoleParameters withRoleId(UUID roleId) {
            this.roleId = roleId;
            return this;
        }

        @Override
        public ModelsUpdateEntityRoleParameters withName(String name) {
            this.name = name;
            return this;
        }

        @Override
        public OperationStatus execute() {
        return updateEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId, name).toBlocking().single().body();
    }

        @Override
        public Observable<OperationStatus> executeAsync() {
            return updateEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId, name).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
                @Override
                public OperationStatus call(ServiceResponse<OperationStatus> response) {
                    return response.body();
                }
            });
        }
    }

    /**
     * Delete an entity role in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatus object if successful.
     */
    public OperationStatus deleteEntityRole(UUID appId, String versionId, UUID entityId, UUID roleId) {
        return deleteEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId).toBlocking().single().body();
    }

    /**
     * Delete an entity role in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role Id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatus> deleteEntityRoleAsync(UUID appId, String versionId, UUID entityId, UUID roleId, final ServiceCallback<OperationStatus> serviceCallback) {
        return ServiceFuture.fromResponse(deleteEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId), serviceCallback);
    }

    /**
     * Delete an entity role in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<OperationStatus> deleteEntityRoleAsync(UUID appId, String versionId, UUID entityId, UUID roleId) {
        return deleteEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
            @Override
            public OperationStatus call(ServiceResponse<OperationStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete an entity role in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> deleteEntityRoleWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, UUID roleId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        if (roleId == null) {
            throw new IllegalArgumentException("Parameter roleId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.deleteEntityRole(appId, versionId, entityId, roleId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatus>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatus> clientResponse = deleteEntityRoleDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatus> deleteEntityRoleDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatus, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatus>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Get one role for a given prebuilt entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId entity ID.
     * @param roleId entity role ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the EntityRole object if successful.
     */
    public EntityRole getPrebuiltEntityRole(UUID appId, String versionId, UUID entityId, UUID roleId) {
        return getPrebuiltEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId).toBlocking().single().body();
    }

    /**
     * Get one role for a given prebuilt entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId entity ID.
     * @param roleId entity role ID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<EntityRole> getPrebuiltEntityRoleAsync(UUID appId, String versionId, UUID entityId, UUID roleId, final ServiceCallback<EntityRole> serviceCallback) {
        return ServiceFuture.fromResponse(getPrebuiltEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId), serviceCallback);
    }

    /**
     * Get one role for a given prebuilt entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId entity ID.
     * @param roleId entity role ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EntityRole object
     */
    public Observable<EntityRole> getPrebuiltEntityRoleAsync(UUID appId, String versionId, UUID entityId, UUID roleId) {
        return getPrebuiltEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId).map(new Func1<ServiceResponse<EntityRole>, EntityRole>() {
            @Override
            public EntityRole call(ServiceResponse<EntityRole> response) {
                return response.body();
            }
        });
    }

    /**
     * Get one role for a given prebuilt entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId entity ID.
     * @param roleId entity role ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EntityRole object
     */
    public Observable<ServiceResponse<EntityRole>> getPrebuiltEntityRoleWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, UUID roleId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        if (roleId == null) {
            throw new IllegalArgumentException("Parameter roleId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.getPrebuiltEntityRole(appId, versionId, entityId, roleId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<EntityRole>>>() {
                @Override
                public Observable<ServiceResponse<EntityRole>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<EntityRole> clientResponse = getPrebuiltEntityRoleDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<EntityRole> getPrebuiltEntityRoleDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<EntityRole, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<EntityRole>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }


    /**
     * Update a role for a given prebuilt entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role ID.
     * @param updatePrebuiltEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatus object if successful.
     */
    public OperationStatus updatePrebuiltEntityRole(UUID appId, String versionId, UUID entityId, UUID roleId, UpdatePrebuiltEntityRoleOptionalParameter updatePrebuiltEntityRoleOptionalParameter) {
        return updatePrebuiltEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId, updatePrebuiltEntityRoleOptionalParameter).toBlocking().single().body();
    }

    /**
     * Update a role for a given prebuilt entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role ID.
     * @param updatePrebuiltEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatus> updatePrebuiltEntityRoleAsync(UUID appId, String versionId, UUID entityId, UUID roleId, UpdatePrebuiltEntityRoleOptionalParameter updatePrebuiltEntityRoleOptionalParameter, final ServiceCallback<OperationStatus> serviceCallback) {
        return ServiceFuture.fromResponse(updatePrebuiltEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId, updatePrebuiltEntityRoleOptionalParameter), serviceCallback);
    }

    /**
     * Update a role for a given prebuilt entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role ID.
     * @param updatePrebuiltEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<OperationStatus> updatePrebuiltEntityRoleAsync(UUID appId, String versionId, UUID entityId, UUID roleId, UpdatePrebuiltEntityRoleOptionalParameter updatePrebuiltEntityRoleOptionalParameter) {
        return updatePrebuiltEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId, updatePrebuiltEntityRoleOptionalParameter).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
            @Override
            public OperationStatus call(ServiceResponse<OperationStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Update a role for a given prebuilt entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role ID.
     * @param updatePrebuiltEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> updatePrebuiltEntityRoleWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, UUID roleId, UpdatePrebuiltEntityRoleOptionalParameter updatePrebuiltEntityRoleOptionalParameter) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        if (roleId == null) {
            throw new IllegalArgumentException("Parameter roleId is required and cannot be null.");
        }
        final String name = updatePrebuiltEntityRoleOptionalParameter != null ? updatePrebuiltEntityRoleOptionalParameter.name() : null;

        return updatePrebuiltEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId, name);
    }

    /**
     * Update a role for a given prebuilt entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role ID.
     * @param name The entity role name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> updatePrebuiltEntityRoleWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, UUID roleId, String name) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        if (roleId == null) {
            throw new IllegalArgumentException("Parameter roleId is required and cannot be null.");
        }
        EntityRoleUpdateObject entityRoleUpdateObject = new EntityRoleUpdateObject();
        entityRoleUpdateObject.withName(name);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.updatePrebuiltEntityRole(appId, versionId, entityId, roleId, this.client.acceptLanguage(), entityRoleUpdateObject, parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatus>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatus> clientResponse = updatePrebuiltEntityRoleDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatus> updatePrebuiltEntityRoleDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatus, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatus>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    @Override
    public ModelsUpdatePrebuiltEntityRoleParameters updatePrebuiltEntityRole() {
        return new ModelsUpdatePrebuiltEntityRoleParameters(this);
    }

    /**
     * Internal class implementing ModelsUpdatePrebuiltEntityRoleDefinition.
     */
    class ModelsUpdatePrebuiltEntityRoleParameters implements ModelsUpdatePrebuiltEntityRoleDefinition {
        private ModelsImpl parent;
        private UUID appId;
        private String versionId;
        private UUID entityId;
        private UUID roleId;
        private String name;

        /**
         * Constructor.
         * @param parent the parent object.
         */
        ModelsUpdatePrebuiltEntityRoleParameters(ModelsImpl parent) {
            this.parent = parent;
        }

        @Override
        public ModelsUpdatePrebuiltEntityRoleParameters withAppId(UUID appId) {
            this.appId = appId;
            return this;
        }

        @Override
        public ModelsUpdatePrebuiltEntityRoleParameters withVersionId(String versionId) {
            this.versionId = versionId;
            return this;
        }

        @Override
        public ModelsUpdatePrebuiltEntityRoleParameters withEntityId(UUID entityId) {
            this.entityId = entityId;
            return this;
        }

        @Override
        public ModelsUpdatePrebuiltEntityRoleParameters withRoleId(UUID roleId) {
            this.roleId = roleId;
            return this;
        }

        @Override
        public ModelsUpdatePrebuiltEntityRoleParameters withName(String name) {
            this.name = name;
            return this;
        }

        @Override
        public OperationStatus execute() {
        return updatePrebuiltEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId, name).toBlocking().single().body();
    }

        @Override
        public Observable<OperationStatus> executeAsync() {
            return updatePrebuiltEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId, name).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
                @Override
                public OperationStatus call(ServiceResponse<OperationStatus> response) {
                    return response.body();
                }
            });
        }
    }

    /**
     * Delete a role in a prebuilt entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatus object if successful.
     */
    public OperationStatus deletePrebuiltEntityRole(UUID appId, String versionId, UUID entityId, UUID roleId) {
        return deletePrebuiltEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId).toBlocking().single().body();
    }

    /**
     * Delete a role in a prebuilt entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role Id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatus> deletePrebuiltEntityRoleAsync(UUID appId, String versionId, UUID entityId, UUID roleId, final ServiceCallback<OperationStatus> serviceCallback) {
        return ServiceFuture.fromResponse(deletePrebuiltEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId), serviceCallback);
    }

    /**
     * Delete a role in a prebuilt entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<OperationStatus> deletePrebuiltEntityRoleAsync(UUID appId, String versionId, UUID entityId, UUID roleId) {
        return deletePrebuiltEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
            @Override
            public OperationStatus call(ServiceResponse<OperationStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete a role in a prebuilt entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> deletePrebuiltEntityRoleWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, UUID roleId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        if (roleId == null) {
            throw new IllegalArgumentException("Parameter roleId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.deletePrebuiltEntityRole(appId, versionId, entityId, roleId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatus>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatus> clientResponse = deletePrebuiltEntityRoleDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatus> deletePrebuiltEntityRoleDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatus, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatus>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Get one role for a given list entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId entity ID.
     * @param roleId entity role ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the EntityRole object if successful.
     */
    public EntityRole getClosedListEntityRole(UUID appId, String versionId, UUID entityId, UUID roleId) {
        return getClosedListEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId).toBlocking().single().body();
    }

    /**
     * Get one role for a given list entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId entity ID.
     * @param roleId entity role ID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<EntityRole> getClosedListEntityRoleAsync(UUID appId, String versionId, UUID entityId, UUID roleId, final ServiceCallback<EntityRole> serviceCallback) {
        return ServiceFuture.fromResponse(getClosedListEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId), serviceCallback);
    }

    /**
     * Get one role for a given list entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId entity ID.
     * @param roleId entity role ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EntityRole object
     */
    public Observable<EntityRole> getClosedListEntityRoleAsync(UUID appId, String versionId, UUID entityId, UUID roleId) {
        return getClosedListEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId).map(new Func1<ServiceResponse<EntityRole>, EntityRole>() {
            @Override
            public EntityRole call(ServiceResponse<EntityRole> response) {
                return response.body();
            }
        });
    }

    /**
     * Get one role for a given list entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId entity ID.
     * @param roleId entity role ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EntityRole object
     */
    public Observable<ServiceResponse<EntityRole>> getClosedListEntityRoleWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, UUID roleId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        if (roleId == null) {
            throw new IllegalArgumentException("Parameter roleId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.getClosedListEntityRole(appId, versionId, entityId, roleId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<EntityRole>>>() {
                @Override
                public Observable<ServiceResponse<EntityRole>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<EntityRole> clientResponse = getClosedListEntityRoleDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<EntityRole> getClosedListEntityRoleDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<EntityRole, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<EntityRole>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }


    /**
     * Update a role for a given list entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role ID.
     * @param updateClosedListEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatus object if successful.
     */
    public OperationStatus updateClosedListEntityRole(UUID appId, String versionId, UUID entityId, UUID roleId, UpdateClosedListEntityRoleOptionalParameter updateClosedListEntityRoleOptionalParameter) {
        return updateClosedListEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId, updateClosedListEntityRoleOptionalParameter).toBlocking().single().body();
    }

    /**
     * Update a role for a given list entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role ID.
     * @param updateClosedListEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatus> updateClosedListEntityRoleAsync(UUID appId, String versionId, UUID entityId, UUID roleId, UpdateClosedListEntityRoleOptionalParameter updateClosedListEntityRoleOptionalParameter, final ServiceCallback<OperationStatus> serviceCallback) {
        return ServiceFuture.fromResponse(updateClosedListEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId, updateClosedListEntityRoleOptionalParameter), serviceCallback);
    }

    /**
     * Update a role for a given list entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role ID.
     * @param updateClosedListEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<OperationStatus> updateClosedListEntityRoleAsync(UUID appId, String versionId, UUID entityId, UUID roleId, UpdateClosedListEntityRoleOptionalParameter updateClosedListEntityRoleOptionalParameter) {
        return updateClosedListEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId, updateClosedListEntityRoleOptionalParameter).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
            @Override
            public OperationStatus call(ServiceResponse<OperationStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Update a role for a given list entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role ID.
     * @param updateClosedListEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> updateClosedListEntityRoleWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, UUID roleId, UpdateClosedListEntityRoleOptionalParameter updateClosedListEntityRoleOptionalParameter) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        if (roleId == null) {
            throw new IllegalArgumentException("Parameter roleId is required and cannot be null.");
        }
        final String name = updateClosedListEntityRoleOptionalParameter != null ? updateClosedListEntityRoleOptionalParameter.name() : null;

        return updateClosedListEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId, name);
    }

    /**
     * Update a role for a given list entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role ID.
     * @param name The entity role name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> updateClosedListEntityRoleWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, UUID roleId, String name) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        if (roleId == null) {
            throw new IllegalArgumentException("Parameter roleId is required and cannot be null.");
        }
        EntityRoleUpdateObject entityRoleUpdateObject = new EntityRoleUpdateObject();
        entityRoleUpdateObject.withName(name);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.updateClosedListEntityRole(appId, versionId, entityId, roleId, this.client.acceptLanguage(), entityRoleUpdateObject, parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatus>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatus> clientResponse = updateClosedListEntityRoleDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatus> updateClosedListEntityRoleDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatus, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatus>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    @Override
    public ModelsUpdateClosedListEntityRoleParameters updateClosedListEntityRole() {
        return new ModelsUpdateClosedListEntityRoleParameters(this);
    }

    /**
     * Internal class implementing ModelsUpdateClosedListEntityRoleDefinition.
     */
    class ModelsUpdateClosedListEntityRoleParameters implements ModelsUpdateClosedListEntityRoleDefinition {
        private ModelsImpl parent;
        private UUID appId;
        private String versionId;
        private UUID entityId;
        private UUID roleId;
        private String name;

        /**
         * Constructor.
         * @param parent the parent object.
         */
        ModelsUpdateClosedListEntityRoleParameters(ModelsImpl parent) {
            this.parent = parent;
        }

        @Override
        public ModelsUpdateClosedListEntityRoleParameters withAppId(UUID appId) {
            this.appId = appId;
            return this;
        }

        @Override
        public ModelsUpdateClosedListEntityRoleParameters withVersionId(String versionId) {
            this.versionId = versionId;
            return this;
        }

        @Override
        public ModelsUpdateClosedListEntityRoleParameters withEntityId(UUID entityId) {
            this.entityId = entityId;
            return this;
        }

        @Override
        public ModelsUpdateClosedListEntityRoleParameters withRoleId(UUID roleId) {
            this.roleId = roleId;
            return this;
        }

        @Override
        public ModelsUpdateClosedListEntityRoleParameters withName(String name) {
            this.name = name;
            return this;
        }

        @Override
        public OperationStatus execute() {
        return updateClosedListEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId, name).toBlocking().single().body();
    }

        @Override
        public Observable<OperationStatus> executeAsync() {
            return updateClosedListEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId, name).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
                @Override
                public OperationStatus call(ServiceResponse<OperationStatus> response) {
                    return response.body();
                }
            });
        }
    }

    /**
     * Delete a role for a given list entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatus object if successful.
     */
    public OperationStatus deleteClosedListEntityRole(UUID appId, String versionId, UUID entityId, UUID roleId) {
        return deleteClosedListEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId).toBlocking().single().body();
    }

    /**
     * Delete a role for a given list entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role Id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatus> deleteClosedListEntityRoleAsync(UUID appId, String versionId, UUID entityId, UUID roleId, final ServiceCallback<OperationStatus> serviceCallback) {
        return ServiceFuture.fromResponse(deleteClosedListEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId), serviceCallback);
    }

    /**
     * Delete a role for a given list entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<OperationStatus> deleteClosedListEntityRoleAsync(UUID appId, String versionId, UUID entityId, UUID roleId) {
        return deleteClosedListEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
            @Override
            public OperationStatus call(ServiceResponse<OperationStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete a role for a given list entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> deleteClosedListEntityRoleWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, UUID roleId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        if (roleId == null) {
            throw new IllegalArgumentException("Parameter roleId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.deleteClosedListEntityRole(appId, versionId, entityId, roleId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatus>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatus> clientResponse = deleteClosedListEntityRoleDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatus> deleteClosedListEntityRoleDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatus, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatus>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Get one role for a given regular expression entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId entity ID.
     * @param roleId entity role ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the EntityRole object if successful.
     */
    public EntityRole getRegexEntityRole(UUID appId, String versionId, UUID entityId, UUID roleId) {
        return getRegexEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId).toBlocking().single().body();
    }

    /**
     * Get one role for a given regular expression entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId entity ID.
     * @param roleId entity role ID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<EntityRole> getRegexEntityRoleAsync(UUID appId, String versionId, UUID entityId, UUID roleId, final ServiceCallback<EntityRole> serviceCallback) {
        return ServiceFuture.fromResponse(getRegexEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId), serviceCallback);
    }

    /**
     * Get one role for a given regular expression entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId entity ID.
     * @param roleId entity role ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EntityRole object
     */
    public Observable<EntityRole> getRegexEntityRoleAsync(UUID appId, String versionId, UUID entityId, UUID roleId) {
        return getRegexEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId).map(new Func1<ServiceResponse<EntityRole>, EntityRole>() {
            @Override
            public EntityRole call(ServiceResponse<EntityRole> response) {
                return response.body();
            }
        });
    }

    /**
     * Get one role for a given regular expression entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId entity ID.
     * @param roleId entity role ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EntityRole object
     */
    public Observable<ServiceResponse<EntityRole>> getRegexEntityRoleWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, UUID roleId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        if (roleId == null) {
            throw new IllegalArgumentException("Parameter roleId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.getRegexEntityRole(appId, versionId, entityId, roleId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<EntityRole>>>() {
                @Override
                public Observable<ServiceResponse<EntityRole>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<EntityRole> clientResponse = getRegexEntityRoleDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<EntityRole> getRegexEntityRoleDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<EntityRole, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<EntityRole>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }


    /**
     * Update a role for a given regular expression entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role ID.
     * @param updateRegexEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatus object if successful.
     */
    public OperationStatus updateRegexEntityRole(UUID appId, String versionId, UUID entityId, UUID roleId, UpdateRegexEntityRoleOptionalParameter updateRegexEntityRoleOptionalParameter) {
        return updateRegexEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId, updateRegexEntityRoleOptionalParameter).toBlocking().single().body();
    }

    /**
     * Update a role for a given regular expression entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role ID.
     * @param updateRegexEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatus> updateRegexEntityRoleAsync(UUID appId, String versionId, UUID entityId, UUID roleId, UpdateRegexEntityRoleOptionalParameter updateRegexEntityRoleOptionalParameter, final ServiceCallback<OperationStatus> serviceCallback) {
        return ServiceFuture.fromResponse(updateRegexEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId, updateRegexEntityRoleOptionalParameter), serviceCallback);
    }

    /**
     * Update a role for a given regular expression entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role ID.
     * @param updateRegexEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<OperationStatus> updateRegexEntityRoleAsync(UUID appId, String versionId, UUID entityId, UUID roleId, UpdateRegexEntityRoleOptionalParameter updateRegexEntityRoleOptionalParameter) {
        return updateRegexEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId, updateRegexEntityRoleOptionalParameter).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
            @Override
            public OperationStatus call(ServiceResponse<OperationStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Update a role for a given regular expression entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role ID.
     * @param updateRegexEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> updateRegexEntityRoleWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, UUID roleId, UpdateRegexEntityRoleOptionalParameter updateRegexEntityRoleOptionalParameter) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        if (roleId == null) {
            throw new IllegalArgumentException("Parameter roleId is required and cannot be null.");
        }
        final String name = updateRegexEntityRoleOptionalParameter != null ? updateRegexEntityRoleOptionalParameter.name() : null;

        return updateRegexEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId, name);
    }

    /**
     * Update a role for a given regular expression entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role ID.
     * @param name The entity role name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> updateRegexEntityRoleWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, UUID roleId, String name) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        if (roleId == null) {
            throw new IllegalArgumentException("Parameter roleId is required and cannot be null.");
        }
        EntityRoleUpdateObject entityRoleUpdateObject = new EntityRoleUpdateObject();
        entityRoleUpdateObject.withName(name);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.updateRegexEntityRole(appId, versionId, entityId, roleId, this.client.acceptLanguage(), entityRoleUpdateObject, parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatus>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatus> clientResponse = updateRegexEntityRoleDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatus> updateRegexEntityRoleDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatus, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatus>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    @Override
    public ModelsUpdateRegexEntityRoleParameters updateRegexEntityRole() {
        return new ModelsUpdateRegexEntityRoleParameters(this);
    }

    /**
     * Internal class implementing ModelsUpdateRegexEntityRoleDefinition.
     */
    class ModelsUpdateRegexEntityRoleParameters implements ModelsUpdateRegexEntityRoleDefinition {
        private ModelsImpl parent;
        private UUID appId;
        private String versionId;
        private UUID entityId;
        private UUID roleId;
        private String name;

        /**
         * Constructor.
         * @param parent the parent object.
         */
        ModelsUpdateRegexEntityRoleParameters(ModelsImpl parent) {
            this.parent = parent;
        }

        @Override
        public ModelsUpdateRegexEntityRoleParameters withAppId(UUID appId) {
            this.appId = appId;
            return this;
        }

        @Override
        public ModelsUpdateRegexEntityRoleParameters withVersionId(String versionId) {
            this.versionId = versionId;
            return this;
        }

        @Override
        public ModelsUpdateRegexEntityRoleParameters withEntityId(UUID entityId) {
            this.entityId = entityId;
            return this;
        }

        @Override
        public ModelsUpdateRegexEntityRoleParameters withRoleId(UUID roleId) {
            this.roleId = roleId;
            return this;
        }

        @Override
        public ModelsUpdateRegexEntityRoleParameters withName(String name) {
            this.name = name;
            return this;
        }

        @Override
        public OperationStatus execute() {
        return updateRegexEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId, name).toBlocking().single().body();
    }

        @Override
        public Observable<OperationStatus> executeAsync() {
            return updateRegexEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId, name).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
                @Override
                public OperationStatus call(ServiceResponse<OperationStatus> response) {
                    return response.body();
                }
            });
        }
    }

    /**
     * Delete a role for a given regular expression in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatus object if successful.
     */
    public OperationStatus deleteRegexEntityRole(UUID appId, String versionId, UUID entityId, UUID roleId) {
        return deleteRegexEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId).toBlocking().single().body();
    }

    /**
     * Delete a role for a given regular expression in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role Id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatus> deleteRegexEntityRoleAsync(UUID appId, String versionId, UUID entityId, UUID roleId, final ServiceCallback<OperationStatus> serviceCallback) {
        return ServiceFuture.fromResponse(deleteRegexEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId), serviceCallback);
    }

    /**
     * Delete a role for a given regular expression in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<OperationStatus> deleteRegexEntityRoleAsync(UUID appId, String versionId, UUID entityId, UUID roleId) {
        return deleteRegexEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
            @Override
            public OperationStatus call(ServiceResponse<OperationStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete a role for a given regular expression in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> deleteRegexEntityRoleWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, UUID roleId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        if (roleId == null) {
            throw new IllegalArgumentException("Parameter roleId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.deleteRegexEntityRole(appId, versionId, entityId, roleId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatus>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatus> clientResponse = deleteRegexEntityRoleDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatus> deleteRegexEntityRoleDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatus, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatus>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Get one role for a given composite entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param cEntityId The composite entity extractor ID.
     * @param roleId entity role ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the EntityRole object if successful.
     */
    public EntityRole getCompositeEntityRole(UUID appId, String versionId, UUID cEntityId, UUID roleId) {
        return getCompositeEntityRoleWithServiceResponseAsync(appId, versionId, cEntityId, roleId).toBlocking().single().body();
    }

    /**
     * Get one role for a given composite entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param cEntityId The composite entity extractor ID.
     * @param roleId entity role ID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<EntityRole> getCompositeEntityRoleAsync(UUID appId, String versionId, UUID cEntityId, UUID roleId, final ServiceCallback<EntityRole> serviceCallback) {
        return ServiceFuture.fromResponse(getCompositeEntityRoleWithServiceResponseAsync(appId, versionId, cEntityId, roleId), serviceCallback);
    }

    /**
     * Get one role for a given composite entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param cEntityId The composite entity extractor ID.
     * @param roleId entity role ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EntityRole object
     */
    public Observable<EntityRole> getCompositeEntityRoleAsync(UUID appId, String versionId, UUID cEntityId, UUID roleId) {
        return getCompositeEntityRoleWithServiceResponseAsync(appId, versionId, cEntityId, roleId).map(new Func1<ServiceResponse<EntityRole>, EntityRole>() {
            @Override
            public EntityRole call(ServiceResponse<EntityRole> response) {
                return response.body();
            }
        });
    }

    /**
     * Get one role for a given composite entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param cEntityId The composite entity extractor ID.
     * @param roleId entity role ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EntityRole object
     */
    public Observable<ServiceResponse<EntityRole>> getCompositeEntityRoleWithServiceResponseAsync(UUID appId, String versionId, UUID cEntityId, UUID roleId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (cEntityId == null) {
            throw new IllegalArgumentException("Parameter cEntityId is required and cannot be null.");
        }
        if (roleId == null) {
            throw new IllegalArgumentException("Parameter roleId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.getCompositeEntityRole(appId, versionId, cEntityId, roleId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<EntityRole>>>() {
                @Override
                public Observable<ServiceResponse<EntityRole>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<EntityRole> clientResponse = getCompositeEntityRoleDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<EntityRole> getCompositeEntityRoleDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<EntityRole, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<EntityRole>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }


    /**
     * Update a role for a given composite entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param cEntityId The composite entity extractor ID.
     * @param roleId The entity role ID.
     * @param updateCompositeEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatus object if successful.
     */
    public OperationStatus updateCompositeEntityRole(UUID appId, String versionId, UUID cEntityId, UUID roleId, UpdateCompositeEntityRoleOptionalParameter updateCompositeEntityRoleOptionalParameter) {
        return updateCompositeEntityRoleWithServiceResponseAsync(appId, versionId, cEntityId, roleId, updateCompositeEntityRoleOptionalParameter).toBlocking().single().body();
    }

    /**
     * Update a role for a given composite entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param cEntityId The composite entity extractor ID.
     * @param roleId The entity role ID.
     * @param updateCompositeEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatus> updateCompositeEntityRoleAsync(UUID appId, String versionId, UUID cEntityId, UUID roleId, UpdateCompositeEntityRoleOptionalParameter updateCompositeEntityRoleOptionalParameter, final ServiceCallback<OperationStatus> serviceCallback) {
        return ServiceFuture.fromResponse(updateCompositeEntityRoleWithServiceResponseAsync(appId, versionId, cEntityId, roleId, updateCompositeEntityRoleOptionalParameter), serviceCallback);
    }

    /**
     * Update a role for a given composite entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param cEntityId The composite entity extractor ID.
     * @param roleId The entity role ID.
     * @param updateCompositeEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<OperationStatus> updateCompositeEntityRoleAsync(UUID appId, String versionId, UUID cEntityId, UUID roleId, UpdateCompositeEntityRoleOptionalParameter updateCompositeEntityRoleOptionalParameter) {
        return updateCompositeEntityRoleWithServiceResponseAsync(appId, versionId, cEntityId, roleId, updateCompositeEntityRoleOptionalParameter).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
            @Override
            public OperationStatus call(ServiceResponse<OperationStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Update a role for a given composite entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param cEntityId The composite entity extractor ID.
     * @param roleId The entity role ID.
     * @param updateCompositeEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> updateCompositeEntityRoleWithServiceResponseAsync(UUID appId, String versionId, UUID cEntityId, UUID roleId, UpdateCompositeEntityRoleOptionalParameter updateCompositeEntityRoleOptionalParameter) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (cEntityId == null) {
            throw new IllegalArgumentException("Parameter cEntityId is required and cannot be null.");
        }
        if (roleId == null) {
            throw new IllegalArgumentException("Parameter roleId is required and cannot be null.");
        }
        final String name = updateCompositeEntityRoleOptionalParameter != null ? updateCompositeEntityRoleOptionalParameter.name() : null;

        return updateCompositeEntityRoleWithServiceResponseAsync(appId, versionId, cEntityId, roleId, name);
    }

    /**
     * Update a role for a given composite entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param cEntityId The composite entity extractor ID.
     * @param roleId The entity role ID.
     * @param name The entity role name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> updateCompositeEntityRoleWithServiceResponseAsync(UUID appId, String versionId, UUID cEntityId, UUID roleId, String name) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (cEntityId == null) {
            throw new IllegalArgumentException("Parameter cEntityId is required and cannot be null.");
        }
        if (roleId == null) {
            throw new IllegalArgumentException("Parameter roleId is required and cannot be null.");
        }
        EntityRoleUpdateObject entityRoleUpdateObject = new EntityRoleUpdateObject();
        entityRoleUpdateObject.withName(name);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.updateCompositeEntityRole(appId, versionId, cEntityId, roleId, this.client.acceptLanguage(), entityRoleUpdateObject, parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatus>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatus> clientResponse = updateCompositeEntityRoleDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatus> updateCompositeEntityRoleDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatus, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatus>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    @Override
    public ModelsUpdateCompositeEntityRoleParameters updateCompositeEntityRole() {
        return new ModelsUpdateCompositeEntityRoleParameters(this);
    }

    /**
     * Internal class implementing ModelsUpdateCompositeEntityRoleDefinition.
     */
    class ModelsUpdateCompositeEntityRoleParameters implements ModelsUpdateCompositeEntityRoleDefinition {
        private ModelsImpl parent;
        private UUID appId;
        private String versionId;
        private UUID cEntityId;
        private UUID roleId;
        private String name;

        /**
         * Constructor.
         * @param parent the parent object.
         */
        ModelsUpdateCompositeEntityRoleParameters(ModelsImpl parent) {
            this.parent = parent;
        }

        @Override
        public ModelsUpdateCompositeEntityRoleParameters withAppId(UUID appId) {
            this.appId = appId;
            return this;
        }

        @Override
        public ModelsUpdateCompositeEntityRoleParameters withVersionId(String versionId) {
            this.versionId = versionId;
            return this;
        }

        @Override
        public ModelsUpdateCompositeEntityRoleParameters withCEntityId(UUID cEntityId) {
            this.cEntityId = cEntityId;
            return this;
        }

        @Override
        public ModelsUpdateCompositeEntityRoleParameters withRoleId(UUID roleId) {
            this.roleId = roleId;
            return this;
        }

        @Override
        public ModelsUpdateCompositeEntityRoleParameters withName(String name) {
            this.name = name;
            return this;
        }

        @Override
        public OperationStatus execute() {
        return updateCompositeEntityRoleWithServiceResponseAsync(appId, versionId, cEntityId, roleId, name).toBlocking().single().body();
    }

        @Override
        public Observable<OperationStatus> executeAsync() {
            return updateCompositeEntityRoleWithServiceResponseAsync(appId, versionId, cEntityId, roleId, name).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
                @Override
                public OperationStatus call(ServiceResponse<OperationStatus> response) {
                    return response.body();
                }
            });
        }
    }

    /**
     * Delete a role for a given composite entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param cEntityId The composite entity extractor ID.
     * @param roleId The entity role Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatus object if successful.
     */
    public OperationStatus deleteCompositeEntityRole(UUID appId, String versionId, UUID cEntityId, UUID roleId) {
        return deleteCompositeEntityRoleWithServiceResponseAsync(appId, versionId, cEntityId, roleId).toBlocking().single().body();
    }

    /**
     * Delete a role for a given composite entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param cEntityId The composite entity extractor ID.
     * @param roleId The entity role Id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatus> deleteCompositeEntityRoleAsync(UUID appId, String versionId, UUID cEntityId, UUID roleId, final ServiceCallback<OperationStatus> serviceCallback) {
        return ServiceFuture.fromResponse(deleteCompositeEntityRoleWithServiceResponseAsync(appId, versionId, cEntityId, roleId), serviceCallback);
    }

    /**
     * Delete a role for a given composite entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param cEntityId The composite entity extractor ID.
     * @param roleId The entity role Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<OperationStatus> deleteCompositeEntityRoleAsync(UUID appId, String versionId, UUID cEntityId, UUID roleId) {
        return deleteCompositeEntityRoleWithServiceResponseAsync(appId, versionId, cEntityId, roleId).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
            @Override
            public OperationStatus call(ServiceResponse<OperationStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete a role for a given composite entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param cEntityId The composite entity extractor ID.
     * @param roleId The entity role Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> deleteCompositeEntityRoleWithServiceResponseAsync(UUID appId, String versionId, UUID cEntityId, UUID roleId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (cEntityId == null) {
            throw new IllegalArgumentException("Parameter cEntityId is required and cannot be null.");
        }
        if (roleId == null) {
            throw new IllegalArgumentException("Parameter roleId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.deleteCompositeEntityRole(appId, versionId, cEntityId, roleId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatus>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatus> clientResponse = deleteCompositeEntityRoleDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatus> deleteCompositeEntityRoleDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatus, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatus>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Get one role for a given Pattern.any entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId entity ID.
     * @param roleId entity role ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the EntityRole object if successful.
     */
    public EntityRole getPatternAnyEntityRole(UUID appId, String versionId, UUID entityId, UUID roleId) {
        return getPatternAnyEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId).toBlocking().single().body();
    }

    /**
     * Get one role for a given Pattern.any entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId entity ID.
     * @param roleId entity role ID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<EntityRole> getPatternAnyEntityRoleAsync(UUID appId, String versionId, UUID entityId, UUID roleId, final ServiceCallback<EntityRole> serviceCallback) {
        return ServiceFuture.fromResponse(getPatternAnyEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId), serviceCallback);
    }

    /**
     * Get one role for a given Pattern.any entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId entity ID.
     * @param roleId entity role ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EntityRole object
     */
    public Observable<EntityRole> getPatternAnyEntityRoleAsync(UUID appId, String versionId, UUID entityId, UUID roleId) {
        return getPatternAnyEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId).map(new Func1<ServiceResponse<EntityRole>, EntityRole>() {
            @Override
            public EntityRole call(ServiceResponse<EntityRole> response) {
                return response.body();
            }
        });
    }

    /**
     * Get one role for a given Pattern.any entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId entity ID.
     * @param roleId entity role ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EntityRole object
     */
    public Observable<ServiceResponse<EntityRole>> getPatternAnyEntityRoleWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, UUID roleId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        if (roleId == null) {
            throw new IllegalArgumentException("Parameter roleId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.getPatternAnyEntityRole(appId, versionId, entityId, roleId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<EntityRole>>>() {
                @Override
                public Observable<ServiceResponse<EntityRole>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<EntityRole> clientResponse = getPatternAnyEntityRoleDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<EntityRole> getPatternAnyEntityRoleDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<EntityRole, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<EntityRole>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }


    /**
     * Update a role for a given Pattern.any entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role ID.
     * @param updatePatternAnyEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatus object if successful.
     */
    public OperationStatus updatePatternAnyEntityRole(UUID appId, String versionId, UUID entityId, UUID roleId, UpdatePatternAnyEntityRoleOptionalParameter updatePatternAnyEntityRoleOptionalParameter) {
        return updatePatternAnyEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId, updatePatternAnyEntityRoleOptionalParameter).toBlocking().single().body();
    }

    /**
     * Update a role for a given Pattern.any entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role ID.
     * @param updatePatternAnyEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatus> updatePatternAnyEntityRoleAsync(UUID appId, String versionId, UUID entityId, UUID roleId, UpdatePatternAnyEntityRoleOptionalParameter updatePatternAnyEntityRoleOptionalParameter, final ServiceCallback<OperationStatus> serviceCallback) {
        return ServiceFuture.fromResponse(updatePatternAnyEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId, updatePatternAnyEntityRoleOptionalParameter), serviceCallback);
    }

    /**
     * Update a role for a given Pattern.any entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role ID.
     * @param updatePatternAnyEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<OperationStatus> updatePatternAnyEntityRoleAsync(UUID appId, String versionId, UUID entityId, UUID roleId, UpdatePatternAnyEntityRoleOptionalParameter updatePatternAnyEntityRoleOptionalParameter) {
        return updatePatternAnyEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId, updatePatternAnyEntityRoleOptionalParameter).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
            @Override
            public OperationStatus call(ServiceResponse<OperationStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Update a role for a given Pattern.any entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role ID.
     * @param updatePatternAnyEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> updatePatternAnyEntityRoleWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, UUID roleId, UpdatePatternAnyEntityRoleOptionalParameter updatePatternAnyEntityRoleOptionalParameter) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        if (roleId == null) {
            throw new IllegalArgumentException("Parameter roleId is required and cannot be null.");
        }
        final String name = updatePatternAnyEntityRoleOptionalParameter != null ? updatePatternAnyEntityRoleOptionalParameter.name() : null;

        return updatePatternAnyEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId, name);
    }

    /**
     * Update a role for a given Pattern.any entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role ID.
     * @param name The entity role name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> updatePatternAnyEntityRoleWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, UUID roleId, String name) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        if (roleId == null) {
            throw new IllegalArgumentException("Parameter roleId is required and cannot be null.");
        }
        EntityRoleUpdateObject entityRoleUpdateObject = new EntityRoleUpdateObject();
        entityRoleUpdateObject.withName(name);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.updatePatternAnyEntityRole(appId, versionId, entityId, roleId, this.client.acceptLanguage(), entityRoleUpdateObject, parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatus>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatus> clientResponse = updatePatternAnyEntityRoleDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatus> updatePatternAnyEntityRoleDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatus, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatus>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    @Override
    public ModelsUpdatePatternAnyEntityRoleParameters updatePatternAnyEntityRole() {
        return new ModelsUpdatePatternAnyEntityRoleParameters(this);
    }

    /**
     * Internal class implementing ModelsUpdatePatternAnyEntityRoleDefinition.
     */
    class ModelsUpdatePatternAnyEntityRoleParameters implements ModelsUpdatePatternAnyEntityRoleDefinition {
        private ModelsImpl parent;
        private UUID appId;
        private String versionId;
        private UUID entityId;
        private UUID roleId;
        private String name;

        /**
         * Constructor.
         * @param parent the parent object.
         */
        ModelsUpdatePatternAnyEntityRoleParameters(ModelsImpl parent) {
            this.parent = parent;
        }

        @Override
        public ModelsUpdatePatternAnyEntityRoleParameters withAppId(UUID appId) {
            this.appId = appId;
            return this;
        }

        @Override
        public ModelsUpdatePatternAnyEntityRoleParameters withVersionId(String versionId) {
            this.versionId = versionId;
            return this;
        }

        @Override
        public ModelsUpdatePatternAnyEntityRoleParameters withEntityId(UUID entityId) {
            this.entityId = entityId;
            return this;
        }

        @Override
        public ModelsUpdatePatternAnyEntityRoleParameters withRoleId(UUID roleId) {
            this.roleId = roleId;
            return this;
        }

        @Override
        public ModelsUpdatePatternAnyEntityRoleParameters withName(String name) {
            this.name = name;
            return this;
        }

        @Override
        public OperationStatus execute() {
        return updatePatternAnyEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId, name).toBlocking().single().body();
    }

        @Override
        public Observable<OperationStatus> executeAsync() {
            return updatePatternAnyEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId, name).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
                @Override
                public OperationStatus call(ServiceResponse<OperationStatus> response) {
                    return response.body();
                }
            });
        }
    }

    /**
     * Delete a role for a given Pattern.any entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatus object if successful.
     */
    public OperationStatus deletePatternAnyEntityRole(UUID appId, String versionId, UUID entityId, UUID roleId) {
        return deletePatternAnyEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId).toBlocking().single().body();
    }

    /**
     * Delete a role for a given Pattern.any entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role Id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatus> deletePatternAnyEntityRoleAsync(UUID appId, String versionId, UUID entityId, UUID roleId, final ServiceCallback<OperationStatus> serviceCallback) {
        return ServiceFuture.fromResponse(deletePatternAnyEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId), serviceCallback);
    }

    /**
     * Delete a role for a given Pattern.any entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<OperationStatus> deletePatternAnyEntityRoleAsync(UUID appId, String versionId, UUID entityId, UUID roleId) {
        return deletePatternAnyEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
            @Override
            public OperationStatus call(ServiceResponse<OperationStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete a role for a given Pattern.any entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> deletePatternAnyEntityRoleWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, UUID roleId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        if (roleId == null) {
            throw new IllegalArgumentException("Parameter roleId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.deletePatternAnyEntityRole(appId, versionId, entityId, roleId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatus>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatus> clientResponse = deletePatternAnyEntityRoleDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatus> deletePatternAnyEntityRoleDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatus, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatus>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Get one role for a given hierarchical entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param hEntityId The hierarchical entity extractor ID.
     * @param roleId entity role ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the EntityRole object if successful.
     */
    public EntityRole getHierarchicalEntityRole(UUID appId, String versionId, UUID hEntityId, UUID roleId) {
        return getHierarchicalEntityRoleWithServiceResponseAsync(appId, versionId, hEntityId, roleId).toBlocking().single().body();
    }

    /**
     * Get one role for a given hierarchical entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param hEntityId The hierarchical entity extractor ID.
     * @param roleId entity role ID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<EntityRole> getHierarchicalEntityRoleAsync(UUID appId, String versionId, UUID hEntityId, UUID roleId, final ServiceCallback<EntityRole> serviceCallback) {
        return ServiceFuture.fromResponse(getHierarchicalEntityRoleWithServiceResponseAsync(appId, versionId, hEntityId, roleId), serviceCallback);
    }

    /**
     * Get one role for a given hierarchical entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param hEntityId The hierarchical entity extractor ID.
     * @param roleId entity role ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EntityRole object
     */
    public Observable<EntityRole> getHierarchicalEntityRoleAsync(UUID appId, String versionId, UUID hEntityId, UUID roleId) {
        return getHierarchicalEntityRoleWithServiceResponseAsync(appId, versionId, hEntityId, roleId).map(new Func1<ServiceResponse<EntityRole>, EntityRole>() {
            @Override
            public EntityRole call(ServiceResponse<EntityRole> response) {
                return response.body();
            }
        });
    }

    /**
     * Get one role for a given hierarchical entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param hEntityId The hierarchical entity extractor ID.
     * @param roleId entity role ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EntityRole object
     */
    public Observable<ServiceResponse<EntityRole>> getHierarchicalEntityRoleWithServiceResponseAsync(UUID appId, String versionId, UUID hEntityId, UUID roleId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (hEntityId == null) {
            throw new IllegalArgumentException("Parameter hEntityId is required and cannot be null.");
        }
        if (roleId == null) {
            throw new IllegalArgumentException("Parameter roleId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.getHierarchicalEntityRole(appId, versionId, hEntityId, roleId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<EntityRole>>>() {
                @Override
                public Observable<ServiceResponse<EntityRole>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<EntityRole> clientResponse = getHierarchicalEntityRoleDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<EntityRole> getHierarchicalEntityRoleDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<EntityRole, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<EntityRole>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }


    /**
     * Update a role for a given hierarchical entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param hEntityId The hierarchical entity extractor ID.
     * @param roleId The entity role ID.
     * @param updateHierarchicalEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatus object if successful.
     */
    public OperationStatus updateHierarchicalEntityRole(UUID appId, String versionId, UUID hEntityId, UUID roleId, UpdateHierarchicalEntityRoleOptionalParameter updateHierarchicalEntityRoleOptionalParameter) {
        return updateHierarchicalEntityRoleWithServiceResponseAsync(appId, versionId, hEntityId, roleId, updateHierarchicalEntityRoleOptionalParameter).toBlocking().single().body();
    }

    /**
     * Update a role for a given hierarchical entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param hEntityId The hierarchical entity extractor ID.
     * @param roleId The entity role ID.
     * @param updateHierarchicalEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatus> updateHierarchicalEntityRoleAsync(UUID appId, String versionId, UUID hEntityId, UUID roleId, UpdateHierarchicalEntityRoleOptionalParameter updateHierarchicalEntityRoleOptionalParameter, final ServiceCallback<OperationStatus> serviceCallback) {
        return ServiceFuture.fromResponse(updateHierarchicalEntityRoleWithServiceResponseAsync(appId, versionId, hEntityId, roleId, updateHierarchicalEntityRoleOptionalParameter), serviceCallback);
    }

    /**
     * Update a role for a given hierarchical entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param hEntityId The hierarchical entity extractor ID.
     * @param roleId The entity role ID.
     * @param updateHierarchicalEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<OperationStatus> updateHierarchicalEntityRoleAsync(UUID appId, String versionId, UUID hEntityId, UUID roleId, UpdateHierarchicalEntityRoleOptionalParameter updateHierarchicalEntityRoleOptionalParameter) {
        return updateHierarchicalEntityRoleWithServiceResponseAsync(appId, versionId, hEntityId, roleId, updateHierarchicalEntityRoleOptionalParameter).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
            @Override
            public OperationStatus call(ServiceResponse<OperationStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Update a role for a given hierarchical entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param hEntityId The hierarchical entity extractor ID.
     * @param roleId The entity role ID.
     * @param updateHierarchicalEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> updateHierarchicalEntityRoleWithServiceResponseAsync(UUID appId, String versionId, UUID hEntityId, UUID roleId, UpdateHierarchicalEntityRoleOptionalParameter updateHierarchicalEntityRoleOptionalParameter) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (hEntityId == null) {
            throw new IllegalArgumentException("Parameter hEntityId is required and cannot be null.");
        }
        if (roleId == null) {
            throw new IllegalArgumentException("Parameter roleId is required and cannot be null.");
        }
        final String name = updateHierarchicalEntityRoleOptionalParameter != null ? updateHierarchicalEntityRoleOptionalParameter.name() : null;

        return updateHierarchicalEntityRoleWithServiceResponseAsync(appId, versionId, hEntityId, roleId, name);
    }

    /**
     * Update a role for a given hierarchical entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param hEntityId The hierarchical entity extractor ID.
     * @param roleId The entity role ID.
     * @param name The entity role name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> updateHierarchicalEntityRoleWithServiceResponseAsync(UUID appId, String versionId, UUID hEntityId, UUID roleId, String name) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (hEntityId == null) {
            throw new IllegalArgumentException("Parameter hEntityId is required and cannot be null.");
        }
        if (roleId == null) {
            throw new IllegalArgumentException("Parameter roleId is required and cannot be null.");
        }
        EntityRoleUpdateObject entityRoleUpdateObject = new EntityRoleUpdateObject();
        entityRoleUpdateObject.withName(name);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.updateHierarchicalEntityRole(appId, versionId, hEntityId, roleId, this.client.acceptLanguage(), entityRoleUpdateObject, parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatus>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatus> clientResponse = updateHierarchicalEntityRoleDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatus> updateHierarchicalEntityRoleDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatus, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatus>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    @Override
    public ModelsUpdateHierarchicalEntityRoleParameters updateHierarchicalEntityRole() {
        return new ModelsUpdateHierarchicalEntityRoleParameters(this);
    }

    /**
     * Internal class implementing ModelsUpdateHierarchicalEntityRoleDefinition.
     */
    class ModelsUpdateHierarchicalEntityRoleParameters implements ModelsUpdateHierarchicalEntityRoleDefinition {
        private ModelsImpl parent;
        private UUID appId;
        private String versionId;
        private UUID hEntityId;
        private UUID roleId;
        private String name;

        /**
         * Constructor.
         * @param parent the parent object.
         */
        ModelsUpdateHierarchicalEntityRoleParameters(ModelsImpl parent) {
            this.parent = parent;
        }

        @Override
        public ModelsUpdateHierarchicalEntityRoleParameters withAppId(UUID appId) {
            this.appId = appId;
            return this;
        }

        @Override
        public ModelsUpdateHierarchicalEntityRoleParameters withVersionId(String versionId) {
            this.versionId = versionId;
            return this;
        }

        @Override
        public ModelsUpdateHierarchicalEntityRoleParameters withHEntityId(UUID hEntityId) {
            this.hEntityId = hEntityId;
            return this;
        }

        @Override
        public ModelsUpdateHierarchicalEntityRoleParameters withRoleId(UUID roleId) {
            this.roleId = roleId;
            return this;
        }

        @Override
        public ModelsUpdateHierarchicalEntityRoleParameters withName(String name) {
            this.name = name;
            return this;
        }

        @Override
        public OperationStatus execute() {
        return updateHierarchicalEntityRoleWithServiceResponseAsync(appId, versionId, hEntityId, roleId, name).toBlocking().single().body();
    }

        @Override
        public Observable<OperationStatus> executeAsync() {
            return updateHierarchicalEntityRoleWithServiceResponseAsync(appId, versionId, hEntityId, roleId, name).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
                @Override
                public OperationStatus call(ServiceResponse<OperationStatus> response) {
                    return response.body();
                }
            });
        }
    }

    /**
     * Delete a role for a given hierarchical role in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param hEntityId The hierarchical entity extractor ID.
     * @param roleId The entity role Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatus object if successful.
     */
    public OperationStatus deleteHierarchicalEntityRole(UUID appId, String versionId, UUID hEntityId, UUID roleId) {
        return deleteHierarchicalEntityRoleWithServiceResponseAsync(appId, versionId, hEntityId, roleId).toBlocking().single().body();
    }

    /**
     * Delete a role for a given hierarchical role in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param hEntityId The hierarchical entity extractor ID.
     * @param roleId The entity role Id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatus> deleteHierarchicalEntityRoleAsync(UUID appId, String versionId, UUID hEntityId, UUID roleId, final ServiceCallback<OperationStatus> serviceCallback) {
        return ServiceFuture.fromResponse(deleteHierarchicalEntityRoleWithServiceResponseAsync(appId, versionId, hEntityId, roleId), serviceCallback);
    }

    /**
     * Delete a role for a given hierarchical role in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param hEntityId The hierarchical entity extractor ID.
     * @param roleId The entity role Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<OperationStatus> deleteHierarchicalEntityRoleAsync(UUID appId, String versionId, UUID hEntityId, UUID roleId) {
        return deleteHierarchicalEntityRoleWithServiceResponseAsync(appId, versionId, hEntityId, roleId).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
            @Override
            public OperationStatus call(ServiceResponse<OperationStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete a role for a given hierarchical role in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param hEntityId The hierarchical entity extractor ID.
     * @param roleId The entity role Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> deleteHierarchicalEntityRoleWithServiceResponseAsync(UUID appId, String versionId, UUID hEntityId, UUID roleId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (hEntityId == null) {
            throw new IllegalArgumentException("Parameter hEntityId is required and cannot be null.");
        }
        if (roleId == null) {
            throw new IllegalArgumentException("Parameter roleId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.deleteHierarchicalEntityRole(appId, versionId, hEntityId, roleId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatus>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatus> clientResponse = deleteHierarchicalEntityRoleDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatus> deleteHierarchicalEntityRoleDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatus, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatus>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Get one role for a given prebuilt entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId entity ID.
     * @param roleId entity role ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the EntityRole object if successful.
     */
    public EntityRole getCustomEntityRole(UUID appId, String versionId, UUID entityId, UUID roleId) {
        return getCustomEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId).toBlocking().single().body();
    }

    /**
     * Get one role for a given prebuilt entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId entity ID.
     * @param roleId entity role ID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<EntityRole> getCustomEntityRoleAsync(UUID appId, String versionId, UUID entityId, UUID roleId, final ServiceCallback<EntityRole> serviceCallback) {
        return ServiceFuture.fromResponse(getCustomEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId), serviceCallback);
    }

    /**
     * Get one role for a given prebuilt entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId entity ID.
     * @param roleId entity role ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EntityRole object
     */
    public Observable<EntityRole> getCustomEntityRoleAsync(UUID appId, String versionId, UUID entityId, UUID roleId) {
        return getCustomEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId).map(new Func1<ServiceResponse<EntityRole>, EntityRole>() {
            @Override
            public EntityRole call(ServiceResponse<EntityRole> response) {
                return response.body();
            }
        });
    }

    /**
     * Get one role for a given prebuilt entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId entity ID.
     * @param roleId entity role ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EntityRole object
     */
    public Observable<ServiceResponse<EntityRole>> getCustomEntityRoleWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, UUID roleId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        if (roleId == null) {
            throw new IllegalArgumentException("Parameter roleId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.getCustomEntityRole(appId, versionId, entityId, roleId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<EntityRole>>>() {
                @Override
                public Observable<ServiceResponse<EntityRole>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<EntityRole> clientResponse = getCustomEntityRoleDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<EntityRole> getCustomEntityRoleDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<EntityRole, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<EntityRole>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }


    /**
     * Update a role for a given prebuilt entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role ID.
     * @param updateCustomPrebuiltEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatus object if successful.
     */
    public OperationStatus updateCustomPrebuiltEntityRole(UUID appId, String versionId, UUID entityId, UUID roleId, UpdateCustomPrebuiltEntityRoleOptionalParameter updateCustomPrebuiltEntityRoleOptionalParameter) {
        return updateCustomPrebuiltEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId, updateCustomPrebuiltEntityRoleOptionalParameter).toBlocking().single().body();
    }

    /**
     * Update a role for a given prebuilt entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role ID.
     * @param updateCustomPrebuiltEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatus> updateCustomPrebuiltEntityRoleAsync(UUID appId, String versionId, UUID entityId, UUID roleId, UpdateCustomPrebuiltEntityRoleOptionalParameter updateCustomPrebuiltEntityRoleOptionalParameter, final ServiceCallback<OperationStatus> serviceCallback) {
        return ServiceFuture.fromResponse(updateCustomPrebuiltEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId, updateCustomPrebuiltEntityRoleOptionalParameter), serviceCallback);
    }

    /**
     * Update a role for a given prebuilt entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role ID.
     * @param updateCustomPrebuiltEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<OperationStatus> updateCustomPrebuiltEntityRoleAsync(UUID appId, String versionId, UUID entityId, UUID roleId, UpdateCustomPrebuiltEntityRoleOptionalParameter updateCustomPrebuiltEntityRoleOptionalParameter) {
        return updateCustomPrebuiltEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId, updateCustomPrebuiltEntityRoleOptionalParameter).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
            @Override
            public OperationStatus call(ServiceResponse<OperationStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Update a role for a given prebuilt entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role ID.
     * @param updateCustomPrebuiltEntityRoleOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> updateCustomPrebuiltEntityRoleWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, UUID roleId, UpdateCustomPrebuiltEntityRoleOptionalParameter updateCustomPrebuiltEntityRoleOptionalParameter) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        if (roleId == null) {
            throw new IllegalArgumentException("Parameter roleId is required and cannot be null.");
        }
        final String name = updateCustomPrebuiltEntityRoleOptionalParameter != null ? updateCustomPrebuiltEntityRoleOptionalParameter.name() : null;

        return updateCustomPrebuiltEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId, name);
    }

    /**
     * Update a role for a given prebuilt entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role ID.
     * @param name The entity role name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> updateCustomPrebuiltEntityRoleWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, UUID roleId, String name) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        if (roleId == null) {
            throw new IllegalArgumentException("Parameter roleId is required and cannot be null.");
        }
        EntityRoleUpdateObject entityRoleUpdateObject = new EntityRoleUpdateObject();
        entityRoleUpdateObject.withName(name);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.updateCustomPrebuiltEntityRole(appId, versionId, entityId, roleId, this.client.acceptLanguage(), entityRoleUpdateObject, parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatus>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatus> clientResponse = updateCustomPrebuiltEntityRoleDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatus> updateCustomPrebuiltEntityRoleDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatus, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatus>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    @Override
    public ModelsUpdateCustomPrebuiltEntityRoleParameters updateCustomPrebuiltEntityRole() {
        return new ModelsUpdateCustomPrebuiltEntityRoleParameters(this);
    }

    /**
     * Internal class implementing ModelsUpdateCustomPrebuiltEntityRoleDefinition.
     */
    class ModelsUpdateCustomPrebuiltEntityRoleParameters implements ModelsUpdateCustomPrebuiltEntityRoleDefinition {
        private ModelsImpl parent;
        private UUID appId;
        private String versionId;
        private UUID entityId;
        private UUID roleId;
        private String name;

        /**
         * Constructor.
         * @param parent the parent object.
         */
        ModelsUpdateCustomPrebuiltEntityRoleParameters(ModelsImpl parent) {
            this.parent = parent;
        }

        @Override
        public ModelsUpdateCustomPrebuiltEntityRoleParameters withAppId(UUID appId) {
            this.appId = appId;
            return this;
        }

        @Override
        public ModelsUpdateCustomPrebuiltEntityRoleParameters withVersionId(String versionId) {
            this.versionId = versionId;
            return this;
        }

        @Override
        public ModelsUpdateCustomPrebuiltEntityRoleParameters withEntityId(UUID entityId) {
            this.entityId = entityId;
            return this;
        }

        @Override
        public ModelsUpdateCustomPrebuiltEntityRoleParameters withRoleId(UUID roleId) {
            this.roleId = roleId;
            return this;
        }

        @Override
        public ModelsUpdateCustomPrebuiltEntityRoleParameters withName(String name) {
            this.name = name;
            return this;
        }

        @Override
        public OperationStatus execute() {
        return updateCustomPrebuiltEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId, name).toBlocking().single().body();
    }

        @Override
        public Observable<OperationStatus> executeAsync() {
            return updateCustomPrebuiltEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId, name).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
                @Override
                public OperationStatus call(ServiceResponse<OperationStatus> response) {
                    return response.body();
                }
            });
        }
    }

    /**
     * Delete a role for a given prebuilt entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatus object if successful.
     */
    public OperationStatus deleteCustomEntityRole(UUID appId, String versionId, UUID entityId, UUID roleId) {
        return deleteCustomEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId).toBlocking().single().body();
    }

    /**
     * Delete a role for a given prebuilt entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role Id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatus> deleteCustomEntityRoleAsync(UUID appId, String versionId, UUID entityId, UUID roleId, final ServiceCallback<OperationStatus> serviceCallback) {
        return ServiceFuture.fromResponse(deleteCustomEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId), serviceCallback);
    }

    /**
     * Delete a role for a given prebuilt entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<OperationStatus> deleteCustomEntityRoleAsync(UUID appId, String versionId, UUID entityId, UUID roleId) {
        return deleteCustomEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
            @Override
            public OperationStatus call(ServiceResponse<OperationStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete a role for a given prebuilt entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The entity ID.
     * @param roleId The entity role Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> deleteCustomEntityRoleWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, UUID roleId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        if (roleId == null) {
            throw new IllegalArgumentException("Parameter roleId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.deleteCustomEntityRole(appId, versionId, entityId, roleId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatus>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatus> clientResponse = deleteCustomEntityRoleDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatus> deleteCustomEntityRoleDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatus, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatus>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Get the explicit (exception) list of the pattern.any entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The Pattern.Any entity Id.
     * @param itemId The explicit list item Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ExplicitListItem object if successful.
     */
    public ExplicitListItem getExplicitListItem(UUID appId, String versionId, UUID entityId, long itemId) {
        return getExplicitListItemWithServiceResponseAsync(appId, versionId, entityId, itemId).toBlocking().single().body();
    }

    /**
     * Get the explicit (exception) list of the pattern.any entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The Pattern.Any entity Id.
     * @param itemId The explicit list item Id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ExplicitListItem> getExplicitListItemAsync(UUID appId, String versionId, UUID entityId, long itemId, final ServiceCallback<ExplicitListItem> serviceCallback) {
        return ServiceFuture.fromResponse(getExplicitListItemWithServiceResponseAsync(appId, versionId, entityId, itemId), serviceCallback);
    }

    /**
     * Get the explicit (exception) list of the pattern.any entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The Pattern.Any entity Id.
     * @param itemId The explicit list item Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ExplicitListItem object
     */
    public Observable<ExplicitListItem> getExplicitListItemAsync(UUID appId, String versionId, UUID entityId, long itemId) {
        return getExplicitListItemWithServiceResponseAsync(appId, versionId, entityId, itemId).map(new Func1<ServiceResponse<ExplicitListItem>, ExplicitListItem>() {
            @Override
            public ExplicitListItem call(ServiceResponse<ExplicitListItem> response) {
                return response.body();
            }
        });
    }

    /**
     * Get the explicit (exception) list of the pattern.any entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The Pattern.Any entity Id.
     * @param itemId The explicit list item Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ExplicitListItem object
     */
    public Observable<ServiceResponse<ExplicitListItem>> getExplicitListItemWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, long itemId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.getExplicitListItem(appId, versionId, entityId, itemId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ExplicitListItem>>>() {
                @Override
                public Observable<ServiceResponse<ExplicitListItem>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ExplicitListItem> clientResponse = getExplicitListItemDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ExplicitListItem> getExplicitListItemDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ExplicitListItem, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ExplicitListItem>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }


    /**
     * Updates an explicit (exception) list item for a Pattern.Any entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The Pattern.Any entity extractor ID.
     * @param itemId The explicit list item ID.
     * @param updateExplicitListItemOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatus object if successful.
     */
    public OperationStatus updateExplicitListItem(UUID appId, String versionId, UUID entityId, long itemId, UpdateExplicitListItemOptionalParameter updateExplicitListItemOptionalParameter) {
        return updateExplicitListItemWithServiceResponseAsync(appId, versionId, entityId, itemId, updateExplicitListItemOptionalParameter).toBlocking().single().body();
    }

    /**
     * Updates an explicit (exception) list item for a Pattern.Any entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The Pattern.Any entity extractor ID.
     * @param itemId The explicit list item ID.
     * @param updateExplicitListItemOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatus> updateExplicitListItemAsync(UUID appId, String versionId, UUID entityId, long itemId, UpdateExplicitListItemOptionalParameter updateExplicitListItemOptionalParameter, final ServiceCallback<OperationStatus> serviceCallback) {
        return ServiceFuture.fromResponse(updateExplicitListItemWithServiceResponseAsync(appId, versionId, entityId, itemId, updateExplicitListItemOptionalParameter), serviceCallback);
    }

    /**
     * Updates an explicit (exception) list item for a Pattern.Any entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The Pattern.Any entity extractor ID.
     * @param itemId The explicit list item ID.
     * @param updateExplicitListItemOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<OperationStatus> updateExplicitListItemAsync(UUID appId, String versionId, UUID entityId, long itemId, UpdateExplicitListItemOptionalParameter updateExplicitListItemOptionalParameter) {
        return updateExplicitListItemWithServiceResponseAsync(appId, versionId, entityId, itemId, updateExplicitListItemOptionalParameter).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
            @Override
            public OperationStatus call(ServiceResponse<OperationStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates an explicit (exception) list item for a Pattern.Any entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The Pattern.Any entity extractor ID.
     * @param itemId The explicit list item ID.
     * @param updateExplicitListItemOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> updateExplicitListItemWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, long itemId, UpdateExplicitListItemOptionalParameter updateExplicitListItemOptionalParameter) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        final String explicitListItem = updateExplicitListItemOptionalParameter != null ? updateExplicitListItemOptionalParameter.explicitListItem() : null;

        return updateExplicitListItemWithServiceResponseAsync(appId, versionId, entityId, itemId, explicitListItem);
    }

    /**
     * Updates an explicit (exception) list item for a Pattern.Any entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The Pattern.Any entity extractor ID.
     * @param itemId The explicit list item ID.
     * @param explicitListItem The explicit list item.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> updateExplicitListItemWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, long itemId, String explicitListItem) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        ExplicitListItemUpdateObject item = new ExplicitListItemUpdateObject();
        item.withExplicitListItem(explicitListItem);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.updateExplicitListItem(appId, versionId, entityId, itemId, this.client.acceptLanguage(), item, parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatus>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatus> clientResponse = updateExplicitListItemDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatus> updateExplicitListItemDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatus, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatus>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    @Override
    public ModelsUpdateExplicitListItemParameters updateExplicitListItem() {
        return new ModelsUpdateExplicitListItemParameters(this);
    }

    /**
     * Internal class implementing ModelsUpdateExplicitListItemDefinition.
     */
    class ModelsUpdateExplicitListItemParameters implements ModelsUpdateExplicitListItemDefinition {
        private ModelsImpl parent;
        private UUID appId;
        private String versionId;
        private UUID entityId;
        private long itemId;
        private String explicitListItem;

        /**
         * Constructor.
         * @param parent the parent object.
         */
        ModelsUpdateExplicitListItemParameters(ModelsImpl parent) {
            this.parent = parent;
        }

        @Override
        public ModelsUpdateExplicitListItemParameters withAppId(UUID appId) {
            this.appId = appId;
            return this;
        }

        @Override
        public ModelsUpdateExplicitListItemParameters withVersionId(String versionId) {
            this.versionId = versionId;
            return this;
        }

        @Override
        public ModelsUpdateExplicitListItemParameters withEntityId(UUID entityId) {
            this.entityId = entityId;
            return this;
        }

        @Override
        public ModelsUpdateExplicitListItemParameters withItemId(long itemId) {
            this.itemId = itemId;
            return this;
        }

        @Override
        public ModelsUpdateExplicitListItemParameters withExplicitListItem(String explicitListItem) {
            this.explicitListItem = explicitListItem;
            return this;
        }

        @Override
        public OperationStatus execute() {
        return updateExplicitListItemWithServiceResponseAsync(appId, versionId, entityId, itemId, explicitListItem).toBlocking().single().body();
    }

        @Override
        public Observable<OperationStatus> executeAsync() {
            return updateExplicitListItemWithServiceResponseAsync(appId, versionId, entityId, itemId, explicitListItem).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
                @Override
                public OperationStatus call(ServiceResponse<OperationStatus> response) {
                    return response.body();
                }
            });
        }
    }

    /**
     * Delete an item from the explicit (exception) list for a Pattern.any entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The pattern.any entity id.
     * @param itemId The explicit list item which will be deleted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatus object if successful.
     */
    public OperationStatus deleteExplicitListItem(UUID appId, String versionId, UUID entityId, long itemId) {
        return deleteExplicitListItemWithServiceResponseAsync(appId, versionId, entityId, itemId).toBlocking().single().body();
    }

    /**
     * Delete an item from the explicit (exception) list for a Pattern.any entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The pattern.any entity id.
     * @param itemId The explicit list item which will be deleted.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatus> deleteExplicitListItemAsync(UUID appId, String versionId, UUID entityId, long itemId, final ServiceCallback<OperationStatus> serviceCallback) {
        return ServiceFuture.fromResponse(deleteExplicitListItemWithServiceResponseAsync(appId, versionId, entityId, itemId), serviceCallback);
    }

    /**
     * Delete an item from the explicit (exception) list for a Pattern.any entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The pattern.any entity id.
     * @param itemId The explicit list item which will be deleted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<OperationStatus> deleteExplicitListItemAsync(UUID appId, String versionId, UUID entityId, long itemId) {
        return deleteExplicitListItemWithServiceResponseAsync(appId, versionId, entityId, itemId).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
            @Override
            public OperationStatus call(ServiceResponse<OperationStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete an item from the explicit (exception) list for a Pattern.any entity in a version of the application.
     *
     * @param appId The application ID.
     * @param versionId The version ID.
     * @param entityId The pattern.any entity id.
     * @param itemId The explicit list item which will be deleted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> deleteExplicitListItemWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, long itemId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (versionId == null) {
            throw new IllegalArgumentException("Parameter versionId is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.deleteExplicitListItem(appId, versionId, entityId, itemId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatus>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatus> clientResponse = deleteExplicitListItemDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatus> deleteExplicitListItemDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatus, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatus>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

}
