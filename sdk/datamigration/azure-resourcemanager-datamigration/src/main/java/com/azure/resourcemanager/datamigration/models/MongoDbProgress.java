// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.datamigration.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.CoreUtils;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Map;

/**
 * Base class for MongoDB migration outputs.
 */
@Fluent
public class MongoDbProgress implements JsonSerializable<MongoDbProgress> {
    /*
     * The type of progress object
     */
    private MongoDbProgressResultType resultType = MongoDbProgressResultType.fromString("MongoDbProgress");

    /*
     * The number of document bytes copied during the Copying stage
     */
    private long bytesCopied;

    /*
     * The number of documents copied during the Copying stage
     */
    private long documentsCopied;

    /*
     * The elapsed time in the format [ddd.]hh:mm:ss[.fffffff] (i.e. TimeSpan format)
     */
    private String elapsedTime;

    /*
     * The errors and warnings that have occurred for the current object. The keys are the error codes.
     */
    private Map<String, MongoDbError> errors;

    /*
     * The number of oplog events awaiting replay
     */
    private long eventsPending;

    /*
     * The number of oplog events replayed so far
     */
    private long eventsReplayed;

    /*
     * The timestamp of the last oplog event received, or null if no oplog event has been received yet
     */
    private OffsetDateTime lastEventTime;

    /*
     * The timestamp of the last oplog event replayed, or null if no oplog event has been replayed yet
     */
    private OffsetDateTime lastReplayTime;

    /*
     * The name of the progress object. For a collection, this is the unqualified collection name. For a database, this
     * is the database name. For the overall migration, this is null.
     */
    private String name;

    /*
     * The qualified name of the progress object. For a collection, this is the database-qualified name. For a database,
     * this is the database name. For the overall migration, this is null.
     */
    private String qualifiedName;

    /*
     * The state property.
     */
    private MongoDbMigrationState state;

    /*
     * The total number of document bytes on the source at the beginning of the Copying stage, or -1 if the total size
     * was unknown
     */
    private long totalBytes;

    /*
     * The total number of documents on the source at the beginning of the Copying stage, or -1 if the total count was
     * unknown
     */
    private long totalDocuments;

    /**
     * Creates an instance of MongoDbProgress class.
     */
    public MongoDbProgress() {
    }

    /**
     * Get the resultType property: The type of progress object.
     * 
     * @return the resultType value.
     */
    public MongoDbProgressResultType resultType() {
        return this.resultType;
    }

    /**
     * Get the bytesCopied property: The number of document bytes copied during the Copying stage.
     * 
     * @return the bytesCopied value.
     */
    public long bytesCopied() {
        return this.bytesCopied;
    }

    /**
     * Set the bytesCopied property: The number of document bytes copied during the Copying stage.
     * 
     * @param bytesCopied the bytesCopied value to set.
     * @return the MongoDbProgress object itself.
     */
    public MongoDbProgress withBytesCopied(long bytesCopied) {
        this.bytesCopied = bytesCopied;
        return this;
    }

    /**
     * Get the documentsCopied property: The number of documents copied during the Copying stage.
     * 
     * @return the documentsCopied value.
     */
    public long documentsCopied() {
        return this.documentsCopied;
    }

    /**
     * Set the documentsCopied property: The number of documents copied during the Copying stage.
     * 
     * @param documentsCopied the documentsCopied value to set.
     * @return the MongoDbProgress object itself.
     */
    public MongoDbProgress withDocumentsCopied(long documentsCopied) {
        this.documentsCopied = documentsCopied;
        return this;
    }

    /**
     * Get the elapsedTime property: The elapsed time in the format [ddd.]hh:mm:ss[.fffffff] (i.e. TimeSpan format).
     * 
     * @return the elapsedTime value.
     */
    public String elapsedTime() {
        return this.elapsedTime;
    }

    /**
     * Set the elapsedTime property: The elapsed time in the format [ddd.]hh:mm:ss[.fffffff] (i.e. TimeSpan format).
     * 
     * @param elapsedTime the elapsedTime value to set.
     * @return the MongoDbProgress object itself.
     */
    public MongoDbProgress withElapsedTime(String elapsedTime) {
        this.elapsedTime = elapsedTime;
        return this;
    }

    /**
     * Get the errors property: The errors and warnings that have occurred for the current object. The keys are the
     * error codes.
     * 
     * @return the errors value.
     */
    public Map<String, MongoDbError> errors() {
        return this.errors;
    }

    /**
     * Set the errors property: The errors and warnings that have occurred for the current object. The keys are the
     * error codes.
     * 
     * @param errors the errors value to set.
     * @return the MongoDbProgress object itself.
     */
    public MongoDbProgress withErrors(Map<String, MongoDbError> errors) {
        this.errors = errors;
        return this;
    }

    /**
     * Get the eventsPending property: The number of oplog events awaiting replay.
     * 
     * @return the eventsPending value.
     */
    public long eventsPending() {
        return this.eventsPending;
    }

    /**
     * Set the eventsPending property: The number of oplog events awaiting replay.
     * 
     * @param eventsPending the eventsPending value to set.
     * @return the MongoDbProgress object itself.
     */
    public MongoDbProgress withEventsPending(long eventsPending) {
        this.eventsPending = eventsPending;
        return this;
    }

    /**
     * Get the eventsReplayed property: The number of oplog events replayed so far.
     * 
     * @return the eventsReplayed value.
     */
    public long eventsReplayed() {
        return this.eventsReplayed;
    }

    /**
     * Set the eventsReplayed property: The number of oplog events replayed so far.
     * 
     * @param eventsReplayed the eventsReplayed value to set.
     * @return the MongoDbProgress object itself.
     */
    public MongoDbProgress withEventsReplayed(long eventsReplayed) {
        this.eventsReplayed = eventsReplayed;
        return this;
    }

    /**
     * Get the lastEventTime property: The timestamp of the last oplog event received, or null if no oplog event has
     * been received yet.
     * 
     * @return the lastEventTime value.
     */
    public OffsetDateTime lastEventTime() {
        return this.lastEventTime;
    }

    /**
     * Set the lastEventTime property: The timestamp of the last oplog event received, or null if no oplog event has
     * been received yet.
     * 
     * @param lastEventTime the lastEventTime value to set.
     * @return the MongoDbProgress object itself.
     */
    public MongoDbProgress withLastEventTime(OffsetDateTime lastEventTime) {
        this.lastEventTime = lastEventTime;
        return this;
    }

    /**
     * Get the lastReplayTime property: The timestamp of the last oplog event replayed, or null if no oplog event has
     * been replayed yet.
     * 
     * @return the lastReplayTime value.
     */
    public OffsetDateTime lastReplayTime() {
        return this.lastReplayTime;
    }

    /**
     * Set the lastReplayTime property: The timestamp of the last oplog event replayed, or null if no oplog event has
     * been replayed yet.
     * 
     * @param lastReplayTime the lastReplayTime value to set.
     * @return the MongoDbProgress object itself.
     */
    public MongoDbProgress withLastReplayTime(OffsetDateTime lastReplayTime) {
        this.lastReplayTime = lastReplayTime;
        return this;
    }

    /**
     * Get the name property: The name of the progress object. For a collection, this is the unqualified collection
     * name. For a database, this is the database name. For the overall migration, this is null.
     * 
     * @return the name value.
     */
    public String name() {
        return this.name;
    }

    /**
     * Set the name property: The name of the progress object. For a collection, this is the unqualified collection
     * name. For a database, this is the database name. For the overall migration, this is null.
     * 
     * @param name the name value to set.
     * @return the MongoDbProgress object itself.
     */
    public MongoDbProgress withName(String name) {
        this.name = name;
        return this;
    }

    /**
     * Get the qualifiedName property: The qualified name of the progress object. For a collection, this is the
     * database-qualified name. For a database, this is the database name. For the overall migration, this is null.
     * 
     * @return the qualifiedName value.
     */
    public String qualifiedName() {
        return this.qualifiedName;
    }

    /**
     * Set the qualifiedName property: The qualified name of the progress object. For a collection, this is the
     * database-qualified name. For a database, this is the database name. For the overall migration, this is null.
     * 
     * @param qualifiedName the qualifiedName value to set.
     * @return the MongoDbProgress object itself.
     */
    public MongoDbProgress withQualifiedName(String qualifiedName) {
        this.qualifiedName = qualifiedName;
        return this;
    }

    /**
     * Get the state property: The state property.
     * 
     * @return the state value.
     */
    public MongoDbMigrationState state() {
        return this.state;
    }

    /**
     * Set the state property: The state property.
     * 
     * @param state the state value to set.
     * @return the MongoDbProgress object itself.
     */
    public MongoDbProgress withState(MongoDbMigrationState state) {
        this.state = state;
        return this;
    }

    /**
     * Get the totalBytes property: The total number of document bytes on the source at the beginning of the Copying
     * stage, or -1 if the total size was unknown.
     * 
     * @return the totalBytes value.
     */
    public long totalBytes() {
        return this.totalBytes;
    }

    /**
     * Set the totalBytes property: The total number of document bytes on the source at the beginning of the Copying
     * stage, or -1 if the total size was unknown.
     * 
     * @param totalBytes the totalBytes value to set.
     * @return the MongoDbProgress object itself.
     */
    public MongoDbProgress withTotalBytes(long totalBytes) {
        this.totalBytes = totalBytes;
        return this;
    }

    /**
     * Get the totalDocuments property: The total number of documents on the source at the beginning of the Copying
     * stage, or -1 if the total count was unknown.
     * 
     * @return the totalDocuments value.
     */
    public long totalDocuments() {
        return this.totalDocuments;
    }

    /**
     * Set the totalDocuments property: The total number of documents on the source at the beginning of the Copying
     * stage, or -1 if the total count was unknown.
     * 
     * @param totalDocuments the totalDocuments value to set.
     * @return the MongoDbProgress object itself.
     */
    public MongoDbProgress withTotalDocuments(long totalDocuments) {
        this.totalDocuments = totalDocuments;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (elapsedTime() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property elapsedTime in model MongoDbProgress"));
        }
        if (errors() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property errors in model MongoDbProgress"));
        } else {
            errors().values().forEach(e -> {
                if (e != null) {
                    e.validate();
                }
            });
        }
        if (state() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property state in model MongoDbProgress"));
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(MongoDbProgress.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeLongField("bytesCopied", this.bytesCopied);
        jsonWriter.writeLongField("documentsCopied", this.documentsCopied);
        jsonWriter.writeStringField("elapsedTime", this.elapsedTime);
        jsonWriter.writeMapField("errors", this.errors, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeLongField("eventsPending", this.eventsPending);
        jsonWriter.writeLongField("eventsReplayed", this.eventsReplayed);
        jsonWriter.writeStringField("state", this.state == null ? null : this.state.toString());
        jsonWriter.writeLongField("totalBytes", this.totalBytes);
        jsonWriter.writeLongField("totalDocuments", this.totalDocuments);
        jsonWriter.writeStringField("resultType", this.resultType == null ? null : this.resultType.toString());
        jsonWriter.writeStringField("lastEventTime",
            this.lastEventTime == null ? null : DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(this.lastEventTime));
        jsonWriter.writeStringField("lastReplayTime",
            this.lastReplayTime == null ? null : DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(this.lastReplayTime));
        jsonWriter.writeStringField("name", this.name);
        jsonWriter.writeStringField("qualifiedName", this.qualifiedName);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of MongoDbProgress from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of MongoDbProgress if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the MongoDbProgress.
     */
    public static MongoDbProgress fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            String discriminatorValue = null;
            try (JsonReader readerToUse = reader.bufferObject()) {
                readerToUse.nextToken(); // Prepare for reading
                while (readerToUse.nextToken() != JsonToken.END_OBJECT) {
                    String fieldName = readerToUse.getFieldName();
                    readerToUse.nextToken();
                    if ("resultType".equals(fieldName)) {
                        discriminatorValue = readerToUse.getString();
                        break;
                    } else {
                        readerToUse.skipChildren();
                    }
                }
                // Use the discriminator value to determine which subtype should be deserialized.
                if ("Collection".equals(discriminatorValue)) {
                    return MongoDbCollectionProgress.fromJson(readerToUse.reset());
                } else if ("Database".equals(discriminatorValue)) {
                    return MongoDbDatabaseProgress.fromJson(readerToUse.reset());
                } else if ("Migration".equals(discriminatorValue)) {
                    return MongoDbMigrationProgress.fromJson(readerToUse.reset());
                } else {
                    return fromJsonKnownDiscriminator(readerToUse.reset());
                }
            }
        });
    }

    static MongoDbProgress fromJsonKnownDiscriminator(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            MongoDbProgress deserializedMongoDbProgress = new MongoDbProgress();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("bytesCopied".equals(fieldName)) {
                    deserializedMongoDbProgress.bytesCopied = reader.getLong();
                } else if ("documentsCopied".equals(fieldName)) {
                    deserializedMongoDbProgress.documentsCopied = reader.getLong();
                } else if ("elapsedTime".equals(fieldName)) {
                    deserializedMongoDbProgress.elapsedTime = reader.getString();
                } else if ("errors".equals(fieldName)) {
                    Map<String, MongoDbError> errors = reader.readMap(reader1 -> MongoDbError.fromJson(reader1));
                    deserializedMongoDbProgress.errors = errors;
                } else if ("eventsPending".equals(fieldName)) {
                    deserializedMongoDbProgress.eventsPending = reader.getLong();
                } else if ("eventsReplayed".equals(fieldName)) {
                    deserializedMongoDbProgress.eventsReplayed = reader.getLong();
                } else if ("state".equals(fieldName)) {
                    deserializedMongoDbProgress.state = MongoDbMigrationState.fromString(reader.getString());
                } else if ("totalBytes".equals(fieldName)) {
                    deserializedMongoDbProgress.totalBytes = reader.getLong();
                } else if ("totalDocuments".equals(fieldName)) {
                    deserializedMongoDbProgress.totalDocuments = reader.getLong();
                } else if ("resultType".equals(fieldName)) {
                    deserializedMongoDbProgress.resultType = MongoDbProgressResultType.fromString(reader.getString());
                } else if ("lastEventTime".equals(fieldName)) {
                    deserializedMongoDbProgress.lastEventTime = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("lastReplayTime".equals(fieldName)) {
                    deserializedMongoDbProgress.lastReplayTime = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("name".equals(fieldName)) {
                    deserializedMongoDbProgress.name = reader.getString();
                } else if ("qualifiedName".equals(fieldName)) {
                    deserializedMongoDbProgress.qualifiedName = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedMongoDbProgress;
        });
    }
}
