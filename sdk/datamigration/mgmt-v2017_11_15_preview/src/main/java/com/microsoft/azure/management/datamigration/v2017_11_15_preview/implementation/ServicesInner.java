/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.management.datamigration.v2017_11_15_preview.implementation;

import com.microsoft.azure.arm.collection.InnerSupportsGet;
import com.microsoft.azure.arm.collection.InnerSupportsDelete;
import com.microsoft.azure.arm.collection.InnerSupportsListing;
import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.AzureServiceFuture;
import com.microsoft.azure.ListOperationCallback;
import com.microsoft.azure.management.datamigration.v2017_11_15_preview.ApiErrorException;
import com.microsoft.azure.management.datamigration.v2017_11_15_preview.NameAvailabilityRequest;
import com.microsoft.azure.Page;
import com.microsoft.azure.PagedList;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.List;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.PATCH;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.http.Url;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in Services.
 */
public class ServicesInner implements InnerSupportsGet<DataMigrationServiceInner>, InnerSupportsDelete<Void>, InnerSupportsListing<DataMigrationServiceInner> {
    /** The Retrofit service to perform REST calls. */
    private ServicesService service;
    /** The service client containing this operation class. */
    private DataMigrationServiceClientImpl client;

    /**
     * Initializes an instance of ServicesInner.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public ServicesInner(Retrofit retrofit, DataMigrationServiceClientImpl client) {
        this.service = retrofit.create(ServicesService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for Services to be
     * used by Retrofit to perform actually REST calls.
     */
    interface ServicesService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.datamigration.v2017_11_15_preview.Services createOrUpdate" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.DataMigration/services/{serviceName}")
        Observable<Response<ResponseBody>> createOrUpdate(@Path("subscriptionId") String subscriptionId, @Path("groupName") String groupName, @Path("serviceName") String serviceName, @Body DataMigrationServiceInner parameters, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.datamigration.v2017_11_15_preview.Services beginCreateOrUpdate" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.DataMigration/services/{serviceName}")
        Observable<Response<ResponseBody>> beginCreateOrUpdate(@Path("subscriptionId") String subscriptionId, @Path("groupName") String groupName, @Path("serviceName") String serviceName, @Body DataMigrationServiceInner parameters, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.datamigration.v2017_11_15_preview.Services getByResourceGroup" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.DataMigration/services/{serviceName}")
        Observable<Response<ResponseBody>> getByResourceGroup(@Path("subscriptionId") String subscriptionId, @Path("groupName") String groupName, @Path("serviceName") String serviceName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.datamigration.v2017_11_15_preview.Services delete" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.DataMigration/services/{serviceName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> delete(@Path("subscriptionId") String subscriptionId, @Path("groupName") String groupName, @Path("serviceName") String serviceName, @Query("deleteRunningTasks") Boolean deleteRunningTasks, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.datamigration.v2017_11_15_preview.Services beginDelete" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.DataMigration/services/{serviceName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> beginDelete(@Path("subscriptionId") String subscriptionId, @Path("groupName") String groupName, @Path("serviceName") String serviceName, @Query("deleteRunningTasks") Boolean deleteRunningTasks, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.datamigration.v2017_11_15_preview.Services update" })
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.DataMigration/services/{serviceName}")
        Observable<Response<ResponseBody>> update(@Path("subscriptionId") String subscriptionId, @Path("groupName") String groupName, @Path("serviceName") String serviceName, @Body DataMigrationServiceInner parameters, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.datamigration.v2017_11_15_preview.Services beginUpdate" })
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.DataMigration/services/{serviceName}")
        Observable<Response<ResponseBody>> beginUpdate(@Path("subscriptionId") String subscriptionId, @Path("groupName") String groupName, @Path("serviceName") String serviceName, @Body DataMigrationServiceInner parameters, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.datamigration.v2017_11_15_preview.Services checkStatus" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.DataMigration/services/{serviceName}/checkStatus")
        Observable<Response<ResponseBody>> checkStatus(@Path("subscriptionId") String subscriptionId, @Path("groupName") String groupName, @Path("serviceName") String serviceName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.datamigration.v2017_11_15_preview.Services start" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.DataMigration/services/{serviceName}/start")
        Observable<Response<ResponseBody>> start(@Path("subscriptionId") String subscriptionId, @Path("groupName") String groupName, @Path("serviceName") String serviceName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.datamigration.v2017_11_15_preview.Services beginStart" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.DataMigration/services/{serviceName}/start")
        Observable<Response<ResponseBody>> beginStart(@Path("subscriptionId") String subscriptionId, @Path("groupName") String groupName, @Path("serviceName") String serviceName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.datamigration.v2017_11_15_preview.Services stop" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.DataMigration/services/{serviceName}/stop")
        Observable<Response<ResponseBody>> stop(@Path("subscriptionId") String subscriptionId, @Path("groupName") String groupName, @Path("serviceName") String serviceName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.datamigration.v2017_11_15_preview.Services beginStop" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.DataMigration/services/{serviceName}/stop")
        Observable<Response<ResponseBody>> beginStop(@Path("subscriptionId") String subscriptionId, @Path("groupName") String groupName, @Path("serviceName") String serviceName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.datamigration.v2017_11_15_preview.Services listSkus" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.DataMigration/services/{serviceName}/skus")
        Observable<Response<ResponseBody>> listSkus(@Path("subscriptionId") String subscriptionId, @Path("groupName") String groupName, @Path("serviceName") String serviceName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.datamigration.v2017_11_15_preview.Services checkChildrenNameAvailability" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.DataMigration/services/{serviceName}/checkNameAvailability")
        Observable<Response<ResponseBody>> checkChildrenNameAvailability(@Path("subscriptionId") String subscriptionId, @Path("groupName") String groupName, @Path("serviceName") String serviceName, @Query("api-version") String apiVersion, @Body NameAvailabilityRequest parameters, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.datamigration.v2017_11_15_preview.Services listByResourceGroup" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.DataMigration/services")
        Observable<Response<ResponseBody>> listByResourceGroup(@Path("subscriptionId") String subscriptionId, @Path("groupName") String groupName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.datamigration.v2017_11_15_preview.Services list" })
        @GET("subscriptions/{subscriptionId}/providers/Microsoft.DataMigration/services")
        Observable<Response<ResponseBody>> list(@Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.datamigration.v2017_11_15_preview.Services checkNameAvailability" })
        @POST("subscriptions/{subscriptionId}/providers/Microsoft.DataMigration/locations/{location}/checkNameAvailability")
        Observable<Response<ResponseBody>> checkNameAvailability(@Path("subscriptionId") String subscriptionId, @Path("location") String location, @Query("api-version") String apiVersion, @Body NameAvailabilityRequest parameters, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.datamigration.v2017_11_15_preview.Services listSkusNext" })
        @GET
        Observable<Response<ResponseBody>> listSkusNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.datamigration.v2017_11_15_preview.Services listByResourceGroupNext" })
        @GET
        Observable<Response<ResponseBody>> listByResourceGroupNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.datamigration.v2017_11_15_preview.Services listNext" })
        @GET
        Observable<Response<ResponseBody>> listNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

    }

    /**
     * Create or update DMS Instance.
     * The services resource is the top-level resource that represents the Data Migration Service. The PUT method creates a new service or updates an existing one. When a service is updated, existing child resources (i.e. tasks) are unaffected. Services currently support a single kind, "vm", which refers to a VM-based service, although other kinds may be added in the future. This method can change the kind, SKU, and network of the service, but if tasks are currently running (i.e. the service is busy), this will fail with 400 Bad Request ("ServiceIsBusy"). The provider will reply when successful with 200 OK or 201 Created. Long-running operations use the provisioningState property.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @param parameters Information about the service
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ApiErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the DataMigrationServiceInner object if successful.
     */
    public DataMigrationServiceInner createOrUpdate(String groupName, String serviceName, DataMigrationServiceInner parameters) {
        return createOrUpdateWithServiceResponseAsync(groupName, serviceName, parameters).toBlocking().last().body();
    }

    /**
     * Create or update DMS Instance.
     * The services resource is the top-level resource that represents the Data Migration Service. The PUT method creates a new service or updates an existing one. When a service is updated, existing child resources (i.e. tasks) are unaffected. Services currently support a single kind, "vm", which refers to a VM-based service, although other kinds may be added in the future. This method can change the kind, SKU, and network of the service, but if tasks are currently running (i.e. the service is busy), this will fail with 400 Bad Request ("ServiceIsBusy"). The provider will reply when successful with 200 OK or 201 Created. Long-running operations use the provisioningState property.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @param parameters Information about the service
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<DataMigrationServiceInner> createOrUpdateAsync(String groupName, String serviceName, DataMigrationServiceInner parameters, final ServiceCallback<DataMigrationServiceInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateWithServiceResponseAsync(groupName, serviceName, parameters), serviceCallback);
    }

    /**
     * Create or update DMS Instance.
     * The services resource is the top-level resource that represents the Data Migration Service. The PUT method creates a new service or updates an existing one. When a service is updated, existing child resources (i.e. tasks) are unaffected. Services currently support a single kind, "vm", which refers to a VM-based service, although other kinds may be added in the future. This method can change the kind, SKU, and network of the service, but if tasks are currently running (i.e. the service is busy), this will fail with 400 Bad Request ("ServiceIsBusy"). The provider will reply when successful with 200 OK or 201 Created. Long-running operations use the provisioningState property.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @param parameters Information about the service
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<DataMigrationServiceInner> createOrUpdateAsync(String groupName, String serviceName, DataMigrationServiceInner parameters) {
        return createOrUpdateWithServiceResponseAsync(groupName, serviceName, parameters).map(new Func1<ServiceResponse<DataMigrationServiceInner>, DataMigrationServiceInner>() {
            @Override
            public DataMigrationServiceInner call(ServiceResponse<DataMigrationServiceInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Create or update DMS Instance.
     * The services resource is the top-level resource that represents the Data Migration Service. The PUT method creates a new service or updates an existing one. When a service is updated, existing child resources (i.e. tasks) are unaffected. Services currently support a single kind, "vm", which refers to a VM-based service, although other kinds may be added in the future. This method can change the kind, SKU, and network of the service, but if tasks are currently running (i.e. the service is busy), this will fail with 400 Bad Request ("ServiceIsBusy"). The provider will reply when successful with 200 OK or 201 Created. Long-running operations use the provisioningState property.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @param parameters Information about the service
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<DataMigrationServiceInner>> createOrUpdateWithServiceResponseAsync(String groupName, String serviceName, DataMigrationServiceInner parameters) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (groupName == null) {
            throw new IllegalArgumentException("Parameter groupName is required and cannot be null.");
        }
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (parameters == null) {
            throw new IllegalArgumentException("Parameter parameters is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(parameters);
        Observable<Response<ResponseBody>> observable = service.createOrUpdate(this.client.subscriptionId(), groupName, serviceName, parameters, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultAsync(observable, new TypeToken<DataMigrationServiceInner>() { }.getType());
    }

    /**
     * Create or update DMS Instance.
     * The services resource is the top-level resource that represents the Data Migration Service. The PUT method creates a new service or updates an existing one. When a service is updated, existing child resources (i.e. tasks) are unaffected. Services currently support a single kind, "vm", which refers to a VM-based service, although other kinds may be added in the future. This method can change the kind, SKU, and network of the service, but if tasks are currently running (i.e. the service is busy), this will fail with 400 Bad Request ("ServiceIsBusy"). The provider will reply when successful with 200 OK or 201 Created. Long-running operations use the provisioningState property.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @param parameters Information about the service
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ApiErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the DataMigrationServiceInner object if successful.
     */
    public DataMigrationServiceInner beginCreateOrUpdate(String groupName, String serviceName, DataMigrationServiceInner parameters) {
        return beginCreateOrUpdateWithServiceResponseAsync(groupName, serviceName, parameters).toBlocking().single().body();
    }

    /**
     * Create or update DMS Instance.
     * The services resource is the top-level resource that represents the Data Migration Service. The PUT method creates a new service or updates an existing one. When a service is updated, existing child resources (i.e. tasks) are unaffected. Services currently support a single kind, "vm", which refers to a VM-based service, although other kinds may be added in the future. This method can change the kind, SKU, and network of the service, but if tasks are currently running (i.e. the service is busy), this will fail with 400 Bad Request ("ServiceIsBusy"). The provider will reply when successful with 200 OK or 201 Created. Long-running operations use the provisioningState property.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @param parameters Information about the service
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<DataMigrationServiceInner> beginCreateOrUpdateAsync(String groupName, String serviceName, DataMigrationServiceInner parameters, final ServiceCallback<DataMigrationServiceInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginCreateOrUpdateWithServiceResponseAsync(groupName, serviceName, parameters), serviceCallback);
    }

    /**
     * Create or update DMS Instance.
     * The services resource is the top-level resource that represents the Data Migration Service. The PUT method creates a new service or updates an existing one. When a service is updated, existing child resources (i.e. tasks) are unaffected. Services currently support a single kind, "vm", which refers to a VM-based service, although other kinds may be added in the future. This method can change the kind, SKU, and network of the service, but if tasks are currently running (i.e. the service is busy), this will fail with 400 Bad Request ("ServiceIsBusy"). The provider will reply when successful with 200 OK or 201 Created. Long-running operations use the provisioningState property.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @param parameters Information about the service
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DataMigrationServiceInner object
     */
    public Observable<DataMigrationServiceInner> beginCreateOrUpdateAsync(String groupName, String serviceName, DataMigrationServiceInner parameters) {
        return beginCreateOrUpdateWithServiceResponseAsync(groupName, serviceName, parameters).map(new Func1<ServiceResponse<DataMigrationServiceInner>, DataMigrationServiceInner>() {
            @Override
            public DataMigrationServiceInner call(ServiceResponse<DataMigrationServiceInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Create or update DMS Instance.
     * The services resource is the top-level resource that represents the Data Migration Service. The PUT method creates a new service or updates an existing one. When a service is updated, existing child resources (i.e. tasks) are unaffected. Services currently support a single kind, "vm", which refers to a VM-based service, although other kinds may be added in the future. This method can change the kind, SKU, and network of the service, but if tasks are currently running (i.e. the service is busy), this will fail with 400 Bad Request ("ServiceIsBusy"). The provider will reply when successful with 200 OK or 201 Created. Long-running operations use the provisioningState property.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @param parameters Information about the service
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DataMigrationServiceInner object
     */
    public Observable<ServiceResponse<DataMigrationServiceInner>> beginCreateOrUpdateWithServiceResponseAsync(String groupName, String serviceName, DataMigrationServiceInner parameters) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (groupName == null) {
            throw new IllegalArgumentException("Parameter groupName is required and cannot be null.");
        }
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (parameters == null) {
            throw new IllegalArgumentException("Parameter parameters is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(parameters);
        return service.beginCreateOrUpdate(this.client.subscriptionId(), groupName, serviceName, parameters, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DataMigrationServiceInner>>>() {
                @Override
                public Observable<ServiceResponse<DataMigrationServiceInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DataMigrationServiceInner> clientResponse = beginCreateOrUpdateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DataMigrationServiceInner> beginCreateOrUpdateDelegate(Response<ResponseBody> response) throws ApiErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<DataMigrationServiceInner, ApiErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<DataMigrationServiceInner>() { }.getType())
                .register(201, new TypeToken<DataMigrationServiceInner>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(ApiErrorException.class)
                .build(response);
    }

    /**
     * Get DMS Service Instance.
     * The services resource is the top-level resource that represents the Data Migration Service. The GET method retrieves information about a service instance.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ApiErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the DataMigrationServiceInner object if successful.
     */
    public DataMigrationServiceInner getByResourceGroup(String groupName, String serviceName) {
        return getByResourceGroupWithServiceResponseAsync(groupName, serviceName).toBlocking().single().body();
    }

    /**
     * Get DMS Service Instance.
     * The services resource is the top-level resource that represents the Data Migration Service. The GET method retrieves information about a service instance.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<DataMigrationServiceInner> getByResourceGroupAsync(String groupName, String serviceName, final ServiceCallback<DataMigrationServiceInner> serviceCallback) {
        return ServiceFuture.fromResponse(getByResourceGroupWithServiceResponseAsync(groupName, serviceName), serviceCallback);
    }

    /**
     * Get DMS Service Instance.
     * The services resource is the top-level resource that represents the Data Migration Service. The GET method retrieves information about a service instance.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DataMigrationServiceInner object
     */
    public Observable<DataMigrationServiceInner> getByResourceGroupAsync(String groupName, String serviceName) {
        return getByResourceGroupWithServiceResponseAsync(groupName, serviceName).map(new Func1<ServiceResponse<DataMigrationServiceInner>, DataMigrationServiceInner>() {
            @Override
            public DataMigrationServiceInner call(ServiceResponse<DataMigrationServiceInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get DMS Service Instance.
     * The services resource is the top-level resource that represents the Data Migration Service. The GET method retrieves information about a service instance.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DataMigrationServiceInner object
     */
    public Observable<ServiceResponse<DataMigrationServiceInner>> getByResourceGroupWithServiceResponseAsync(String groupName, String serviceName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (groupName == null) {
            throw new IllegalArgumentException("Parameter groupName is required and cannot be null.");
        }
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getByResourceGroup(this.client.subscriptionId(), groupName, serviceName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DataMigrationServiceInner>>>() {
                @Override
                public Observable<ServiceResponse<DataMigrationServiceInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DataMigrationServiceInner> clientResponse = getByResourceGroupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DataMigrationServiceInner> getByResourceGroupDelegate(Response<ResponseBody> response) throws ApiErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<DataMigrationServiceInner, ApiErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<DataMigrationServiceInner>() { }.getType())
                .registerError(ApiErrorException.class)
                .build(response);
    }

    /**
     * Delete DMS Service Instance.
     * The services resource is the top-level resource that represents the Data Migration Service. The DELETE method deletes a service. Any running tasks will be canceled.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ApiErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void delete(String groupName, String serviceName) {
        deleteWithServiceResponseAsync(groupName, serviceName).toBlocking().last().body();
    }

    /**
     * Delete DMS Service Instance.
     * The services resource is the top-level resource that represents the Data Migration Service. The DELETE method deletes a service. Any running tasks will be canceled.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteAsync(String groupName, String serviceName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteWithServiceResponseAsync(groupName, serviceName), serviceCallback);
    }

    /**
     * Delete DMS Service Instance.
     * The services resource is the top-level resource that represents the Data Migration Service. The DELETE method deletes a service. Any running tasks will be canceled.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<Void> deleteAsync(String groupName, String serviceName) {
        return deleteWithServiceResponseAsync(groupName, serviceName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete DMS Service Instance.
     * The services resource is the top-level resource that represents the Data Migration Service. The DELETE method deletes a service. Any running tasks will be canceled.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<Void>> deleteWithServiceResponseAsync(String groupName, String serviceName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (groupName == null) {
            throw new IllegalArgumentException("Parameter groupName is required and cannot be null.");
        }
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final Boolean deleteRunningTasks = null;
        Observable<Response<ResponseBody>> observable = service.delete(this.client.subscriptionId(), groupName, serviceName, deleteRunningTasks, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<Void>() { }.getType());
    }
    /**
     * Delete DMS Service Instance.
     * The services resource is the top-level resource that represents the Data Migration Service. The DELETE method deletes a service. Any running tasks will be canceled.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @param deleteRunningTasks Delete the resource even if it contains running tasks
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ApiErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void delete(String groupName, String serviceName, Boolean deleteRunningTasks) {
        deleteWithServiceResponseAsync(groupName, serviceName, deleteRunningTasks).toBlocking().last().body();
    }

    /**
     * Delete DMS Service Instance.
     * The services resource is the top-level resource that represents the Data Migration Service. The DELETE method deletes a service. Any running tasks will be canceled.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @param deleteRunningTasks Delete the resource even if it contains running tasks
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteAsync(String groupName, String serviceName, Boolean deleteRunningTasks, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteWithServiceResponseAsync(groupName, serviceName, deleteRunningTasks), serviceCallback);
    }

    /**
     * Delete DMS Service Instance.
     * The services resource is the top-level resource that represents the Data Migration Service. The DELETE method deletes a service. Any running tasks will be canceled.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @param deleteRunningTasks Delete the resource even if it contains running tasks
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<Void> deleteAsync(String groupName, String serviceName, Boolean deleteRunningTasks) {
        return deleteWithServiceResponseAsync(groupName, serviceName, deleteRunningTasks).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete DMS Service Instance.
     * The services resource is the top-level resource that represents the Data Migration Service. The DELETE method deletes a service. Any running tasks will be canceled.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @param deleteRunningTasks Delete the resource even if it contains running tasks
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<Void>> deleteWithServiceResponseAsync(String groupName, String serviceName, Boolean deleteRunningTasks) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (groupName == null) {
            throw new IllegalArgumentException("Parameter groupName is required and cannot be null.");
        }
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Observable<Response<ResponseBody>> observable = service.delete(this.client.subscriptionId(), groupName, serviceName, deleteRunningTasks, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<Void>() { }.getType());
    }

    /**
     * Delete DMS Service Instance.
     * The services resource is the top-level resource that represents the Data Migration Service. The DELETE method deletes a service. Any running tasks will be canceled.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ApiErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void beginDelete(String groupName, String serviceName) {
        beginDeleteWithServiceResponseAsync(groupName, serviceName).toBlocking().single().body();
    }

    /**
     * Delete DMS Service Instance.
     * The services resource is the top-level resource that represents the Data Migration Service. The DELETE method deletes a service. Any running tasks will be canceled.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> beginDeleteAsync(String groupName, String serviceName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(beginDeleteWithServiceResponseAsync(groupName, serviceName), serviceCallback);
    }

    /**
     * Delete DMS Service Instance.
     * The services resource is the top-level resource that represents the Data Migration Service. The DELETE method deletes a service. Any running tasks will be canceled.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> beginDeleteAsync(String groupName, String serviceName) {
        return beginDeleteWithServiceResponseAsync(groupName, serviceName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete DMS Service Instance.
     * The services resource is the top-level resource that represents the Data Migration Service. The DELETE method deletes a service. Any running tasks will be canceled.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> beginDeleteWithServiceResponseAsync(String groupName, String serviceName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (groupName == null) {
            throw new IllegalArgumentException("Parameter groupName is required and cannot be null.");
        }
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final Boolean deleteRunningTasks = null;
        return service.beginDelete(this.client.subscriptionId(), groupName, serviceName, deleteRunningTasks, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = beginDeleteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Delete DMS Service Instance.
     * The services resource is the top-level resource that represents the Data Migration Service. The DELETE method deletes a service. Any running tasks will be canceled.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @param deleteRunningTasks Delete the resource even if it contains running tasks
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ApiErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void beginDelete(String groupName, String serviceName, Boolean deleteRunningTasks) {
        beginDeleteWithServiceResponseAsync(groupName, serviceName, deleteRunningTasks).toBlocking().single().body();
    }

    /**
     * Delete DMS Service Instance.
     * The services resource is the top-level resource that represents the Data Migration Service. The DELETE method deletes a service. Any running tasks will be canceled.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @param deleteRunningTasks Delete the resource even if it contains running tasks
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> beginDeleteAsync(String groupName, String serviceName, Boolean deleteRunningTasks, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(beginDeleteWithServiceResponseAsync(groupName, serviceName, deleteRunningTasks), serviceCallback);
    }

    /**
     * Delete DMS Service Instance.
     * The services resource is the top-level resource that represents the Data Migration Service. The DELETE method deletes a service. Any running tasks will be canceled.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @param deleteRunningTasks Delete the resource even if it contains running tasks
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> beginDeleteAsync(String groupName, String serviceName, Boolean deleteRunningTasks) {
        return beginDeleteWithServiceResponseAsync(groupName, serviceName, deleteRunningTasks).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete DMS Service Instance.
     * The services resource is the top-level resource that represents the Data Migration Service. The DELETE method deletes a service. Any running tasks will be canceled.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @param deleteRunningTasks Delete the resource even if it contains running tasks
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> beginDeleteWithServiceResponseAsync(String groupName, String serviceName, Boolean deleteRunningTasks) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (groupName == null) {
            throw new IllegalArgumentException("Parameter groupName is required and cannot be null.");
        }
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.beginDelete(this.client.subscriptionId(), groupName, serviceName, deleteRunningTasks, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = beginDeleteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> beginDeleteDelegate(Response<ResponseBody> response) throws ApiErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, ApiErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(ApiErrorException.class)
                .build(response);
    }

    /**
     * Create or update DMS Service Instance.
     * The services resource is the top-level resource that represents the Data Migration Service. The PATCH method updates an existing service. This method can change the kind, SKU, and network of the service, but if tasks are currently running (i.e. the service is busy), this will fail with 400 Bad Request ("ServiceIsBusy").
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @param parameters Information about the service
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ApiErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the DataMigrationServiceInner object if successful.
     */
    public DataMigrationServiceInner update(String groupName, String serviceName, DataMigrationServiceInner parameters) {
        return updateWithServiceResponseAsync(groupName, serviceName, parameters).toBlocking().last().body();
    }

    /**
     * Create or update DMS Service Instance.
     * The services resource is the top-level resource that represents the Data Migration Service. The PATCH method updates an existing service. This method can change the kind, SKU, and network of the service, but if tasks are currently running (i.e. the service is busy), this will fail with 400 Bad Request ("ServiceIsBusy").
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @param parameters Information about the service
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<DataMigrationServiceInner> updateAsync(String groupName, String serviceName, DataMigrationServiceInner parameters, final ServiceCallback<DataMigrationServiceInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateWithServiceResponseAsync(groupName, serviceName, parameters), serviceCallback);
    }

    /**
     * Create or update DMS Service Instance.
     * The services resource is the top-level resource that represents the Data Migration Service. The PATCH method updates an existing service. This method can change the kind, SKU, and network of the service, but if tasks are currently running (i.e. the service is busy), this will fail with 400 Bad Request ("ServiceIsBusy").
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @param parameters Information about the service
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<DataMigrationServiceInner> updateAsync(String groupName, String serviceName, DataMigrationServiceInner parameters) {
        return updateWithServiceResponseAsync(groupName, serviceName, parameters).map(new Func1<ServiceResponse<DataMigrationServiceInner>, DataMigrationServiceInner>() {
            @Override
            public DataMigrationServiceInner call(ServiceResponse<DataMigrationServiceInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Create or update DMS Service Instance.
     * The services resource is the top-level resource that represents the Data Migration Service. The PATCH method updates an existing service. This method can change the kind, SKU, and network of the service, but if tasks are currently running (i.e. the service is busy), this will fail with 400 Bad Request ("ServiceIsBusy").
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @param parameters Information about the service
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<DataMigrationServiceInner>> updateWithServiceResponseAsync(String groupName, String serviceName, DataMigrationServiceInner parameters) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (groupName == null) {
            throw new IllegalArgumentException("Parameter groupName is required and cannot be null.");
        }
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (parameters == null) {
            throw new IllegalArgumentException("Parameter parameters is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(parameters);
        Observable<Response<ResponseBody>> observable = service.update(this.client.subscriptionId(), groupName, serviceName, parameters, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultAsync(observable, new TypeToken<DataMigrationServiceInner>() { }.getType());
    }

    /**
     * Create or update DMS Service Instance.
     * The services resource is the top-level resource that represents the Data Migration Service. The PATCH method updates an existing service. This method can change the kind, SKU, and network of the service, but if tasks are currently running (i.e. the service is busy), this will fail with 400 Bad Request ("ServiceIsBusy").
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @param parameters Information about the service
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ApiErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the DataMigrationServiceInner object if successful.
     */
    public DataMigrationServiceInner beginUpdate(String groupName, String serviceName, DataMigrationServiceInner parameters) {
        return beginUpdateWithServiceResponseAsync(groupName, serviceName, parameters).toBlocking().single().body();
    }

    /**
     * Create or update DMS Service Instance.
     * The services resource is the top-level resource that represents the Data Migration Service. The PATCH method updates an existing service. This method can change the kind, SKU, and network of the service, but if tasks are currently running (i.e. the service is busy), this will fail with 400 Bad Request ("ServiceIsBusy").
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @param parameters Information about the service
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<DataMigrationServiceInner> beginUpdateAsync(String groupName, String serviceName, DataMigrationServiceInner parameters, final ServiceCallback<DataMigrationServiceInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginUpdateWithServiceResponseAsync(groupName, serviceName, parameters), serviceCallback);
    }

    /**
     * Create or update DMS Service Instance.
     * The services resource is the top-level resource that represents the Data Migration Service. The PATCH method updates an existing service. This method can change the kind, SKU, and network of the service, but if tasks are currently running (i.e. the service is busy), this will fail with 400 Bad Request ("ServiceIsBusy").
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @param parameters Information about the service
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DataMigrationServiceInner object
     */
    public Observable<DataMigrationServiceInner> beginUpdateAsync(String groupName, String serviceName, DataMigrationServiceInner parameters) {
        return beginUpdateWithServiceResponseAsync(groupName, serviceName, parameters).map(new Func1<ServiceResponse<DataMigrationServiceInner>, DataMigrationServiceInner>() {
            @Override
            public DataMigrationServiceInner call(ServiceResponse<DataMigrationServiceInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Create or update DMS Service Instance.
     * The services resource is the top-level resource that represents the Data Migration Service. The PATCH method updates an existing service. This method can change the kind, SKU, and network of the service, but if tasks are currently running (i.e. the service is busy), this will fail with 400 Bad Request ("ServiceIsBusy").
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @param parameters Information about the service
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DataMigrationServiceInner object
     */
    public Observable<ServiceResponse<DataMigrationServiceInner>> beginUpdateWithServiceResponseAsync(String groupName, String serviceName, DataMigrationServiceInner parameters) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (groupName == null) {
            throw new IllegalArgumentException("Parameter groupName is required and cannot be null.");
        }
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (parameters == null) {
            throw new IllegalArgumentException("Parameter parameters is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(parameters);
        return service.beginUpdate(this.client.subscriptionId(), groupName, serviceName, parameters, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DataMigrationServiceInner>>>() {
                @Override
                public Observable<ServiceResponse<DataMigrationServiceInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DataMigrationServiceInner> clientResponse = beginUpdateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DataMigrationServiceInner> beginUpdateDelegate(Response<ResponseBody> response) throws ApiErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<DataMigrationServiceInner, ApiErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<DataMigrationServiceInner>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(ApiErrorException.class)
                .build(response);
    }

    /**
     * Check service health status.
     * The services resource is the top-level resource that represents the Data Migration Service. This action performs a health check and returns the status of the service and virtual machine size.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ApiErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the DataMigrationServiceStatusResponseInner object if successful.
     */
    public DataMigrationServiceStatusResponseInner checkStatus(String groupName, String serviceName) {
        return checkStatusWithServiceResponseAsync(groupName, serviceName).toBlocking().single().body();
    }

    /**
     * Check service health status.
     * The services resource is the top-level resource that represents the Data Migration Service. This action performs a health check and returns the status of the service and virtual machine size.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<DataMigrationServiceStatusResponseInner> checkStatusAsync(String groupName, String serviceName, final ServiceCallback<DataMigrationServiceStatusResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(checkStatusWithServiceResponseAsync(groupName, serviceName), serviceCallback);
    }

    /**
     * Check service health status.
     * The services resource is the top-level resource that represents the Data Migration Service. This action performs a health check and returns the status of the service and virtual machine size.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DataMigrationServiceStatusResponseInner object
     */
    public Observable<DataMigrationServiceStatusResponseInner> checkStatusAsync(String groupName, String serviceName) {
        return checkStatusWithServiceResponseAsync(groupName, serviceName).map(new Func1<ServiceResponse<DataMigrationServiceStatusResponseInner>, DataMigrationServiceStatusResponseInner>() {
            @Override
            public DataMigrationServiceStatusResponseInner call(ServiceResponse<DataMigrationServiceStatusResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Check service health status.
     * The services resource is the top-level resource that represents the Data Migration Service. This action performs a health check and returns the status of the service and virtual machine size.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DataMigrationServiceStatusResponseInner object
     */
    public Observable<ServiceResponse<DataMigrationServiceStatusResponseInner>> checkStatusWithServiceResponseAsync(String groupName, String serviceName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (groupName == null) {
            throw new IllegalArgumentException("Parameter groupName is required and cannot be null.");
        }
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.checkStatus(this.client.subscriptionId(), groupName, serviceName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DataMigrationServiceStatusResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<DataMigrationServiceStatusResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DataMigrationServiceStatusResponseInner> clientResponse = checkStatusDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DataMigrationServiceStatusResponseInner> checkStatusDelegate(Response<ResponseBody> response) throws ApiErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<DataMigrationServiceStatusResponseInner, ApiErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<DataMigrationServiceStatusResponseInner>() { }.getType())
                .registerError(ApiErrorException.class)
                .build(response);
    }

    /**
     * Start service.
     * The services resource is the top-level resource that represents the Data Migration Service. This action starts the service and the service can be used for data migration.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ApiErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void start(String groupName, String serviceName) {
        startWithServiceResponseAsync(groupName, serviceName).toBlocking().last().body();
    }

    /**
     * Start service.
     * The services resource is the top-level resource that represents the Data Migration Service. This action starts the service and the service can be used for data migration.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> startAsync(String groupName, String serviceName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(startWithServiceResponseAsync(groupName, serviceName), serviceCallback);
    }

    /**
     * Start service.
     * The services resource is the top-level resource that represents the Data Migration Service. This action starts the service and the service can be used for data migration.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<Void> startAsync(String groupName, String serviceName) {
        return startWithServiceResponseAsync(groupName, serviceName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Start service.
     * The services resource is the top-level resource that represents the Data Migration Service. This action starts the service and the service can be used for data migration.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<Void>> startWithServiceResponseAsync(String groupName, String serviceName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (groupName == null) {
            throw new IllegalArgumentException("Parameter groupName is required and cannot be null.");
        }
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Observable<Response<ResponseBody>> observable = service.start(this.client.subscriptionId(), groupName, serviceName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<Void>() { }.getType());
    }

    /**
     * Start service.
     * The services resource is the top-level resource that represents the Data Migration Service. This action starts the service and the service can be used for data migration.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ApiErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void beginStart(String groupName, String serviceName) {
        beginStartWithServiceResponseAsync(groupName, serviceName).toBlocking().single().body();
    }

    /**
     * Start service.
     * The services resource is the top-level resource that represents the Data Migration Service. This action starts the service and the service can be used for data migration.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> beginStartAsync(String groupName, String serviceName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(beginStartWithServiceResponseAsync(groupName, serviceName), serviceCallback);
    }

    /**
     * Start service.
     * The services resource is the top-level resource that represents the Data Migration Service. This action starts the service and the service can be used for data migration.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> beginStartAsync(String groupName, String serviceName) {
        return beginStartWithServiceResponseAsync(groupName, serviceName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Start service.
     * The services resource is the top-level resource that represents the Data Migration Service. This action starts the service and the service can be used for data migration.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> beginStartWithServiceResponseAsync(String groupName, String serviceName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (groupName == null) {
            throw new IllegalArgumentException("Parameter groupName is required and cannot be null.");
        }
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.beginStart(this.client.subscriptionId(), groupName, serviceName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = beginStartDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> beginStartDelegate(Response<ResponseBody> response) throws ApiErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, ApiErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(ApiErrorException.class)
                .build(response);
    }

    /**
     * Stop service.
     * The services resource is the top-level resource that represents the Data Migration Service. This action stops the service and the service cannot be used for data migration. The service owner won't be billed when the service is stopped.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ApiErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void stop(String groupName, String serviceName) {
        stopWithServiceResponseAsync(groupName, serviceName).toBlocking().last().body();
    }

    /**
     * Stop service.
     * The services resource is the top-level resource that represents the Data Migration Service. This action stops the service and the service cannot be used for data migration. The service owner won't be billed when the service is stopped.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> stopAsync(String groupName, String serviceName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(stopWithServiceResponseAsync(groupName, serviceName), serviceCallback);
    }

    /**
     * Stop service.
     * The services resource is the top-level resource that represents the Data Migration Service. This action stops the service and the service cannot be used for data migration. The service owner won't be billed when the service is stopped.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<Void> stopAsync(String groupName, String serviceName) {
        return stopWithServiceResponseAsync(groupName, serviceName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Stop service.
     * The services resource is the top-level resource that represents the Data Migration Service. This action stops the service and the service cannot be used for data migration. The service owner won't be billed when the service is stopped.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<Void>> stopWithServiceResponseAsync(String groupName, String serviceName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (groupName == null) {
            throw new IllegalArgumentException("Parameter groupName is required and cannot be null.");
        }
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Observable<Response<ResponseBody>> observable = service.stop(this.client.subscriptionId(), groupName, serviceName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<Void>() { }.getType());
    }

    /**
     * Stop service.
     * The services resource is the top-level resource that represents the Data Migration Service. This action stops the service and the service cannot be used for data migration. The service owner won't be billed when the service is stopped.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ApiErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void beginStop(String groupName, String serviceName) {
        beginStopWithServiceResponseAsync(groupName, serviceName).toBlocking().single().body();
    }

    /**
     * Stop service.
     * The services resource is the top-level resource that represents the Data Migration Service. This action stops the service and the service cannot be used for data migration. The service owner won't be billed when the service is stopped.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> beginStopAsync(String groupName, String serviceName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(beginStopWithServiceResponseAsync(groupName, serviceName), serviceCallback);
    }

    /**
     * Stop service.
     * The services resource is the top-level resource that represents the Data Migration Service. This action stops the service and the service cannot be used for data migration. The service owner won't be billed when the service is stopped.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> beginStopAsync(String groupName, String serviceName) {
        return beginStopWithServiceResponseAsync(groupName, serviceName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Stop service.
     * The services resource is the top-level resource that represents the Data Migration Service. This action stops the service and the service cannot be used for data migration. The service owner won't be billed when the service is stopped.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> beginStopWithServiceResponseAsync(String groupName, String serviceName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (groupName == null) {
            throw new IllegalArgumentException("Parameter groupName is required and cannot be null.");
        }
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.beginStop(this.client.subscriptionId(), groupName, serviceName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = beginStopDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> beginStopDelegate(Response<ResponseBody> response) throws ApiErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, ApiErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(ApiErrorException.class)
                .build(response);
    }

    /**
     * Get compatible SKUs.
     * The services resource is the top-level resource that represents the Data Migration Service. The skus action returns the list of SKUs that a service resource can be updated to.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ApiErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;AvailableServiceSkuInner&gt; object if successful.
     */
    public PagedList<AvailableServiceSkuInner> listSkus(final String groupName, final String serviceName) {
        ServiceResponse<Page<AvailableServiceSkuInner>> response = listSkusSinglePageAsync(groupName, serviceName).toBlocking().single();
        return new PagedList<AvailableServiceSkuInner>(response.body()) {
            @Override
            public Page<AvailableServiceSkuInner> nextPage(String nextPageLink) {
                return listSkusNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get compatible SKUs.
     * The services resource is the top-level resource that represents the Data Migration Service. The skus action returns the list of SKUs that a service resource can be updated to.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<AvailableServiceSkuInner>> listSkusAsync(final String groupName, final String serviceName, final ListOperationCallback<AvailableServiceSkuInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listSkusSinglePageAsync(groupName, serviceName),
            new Func1<String, Observable<ServiceResponse<Page<AvailableServiceSkuInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<AvailableServiceSkuInner>>> call(String nextPageLink) {
                    return listSkusNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get compatible SKUs.
     * The services resource is the top-level resource that represents the Data Migration Service. The skus action returns the list of SKUs that a service resource can be updated to.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;AvailableServiceSkuInner&gt; object
     */
    public Observable<Page<AvailableServiceSkuInner>> listSkusAsync(final String groupName, final String serviceName) {
        return listSkusWithServiceResponseAsync(groupName, serviceName)
            .map(new Func1<ServiceResponse<Page<AvailableServiceSkuInner>>, Page<AvailableServiceSkuInner>>() {
                @Override
                public Page<AvailableServiceSkuInner> call(ServiceResponse<Page<AvailableServiceSkuInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get compatible SKUs.
     * The services resource is the top-level resource that represents the Data Migration Service. The skus action returns the list of SKUs that a service resource can be updated to.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;AvailableServiceSkuInner&gt; object
     */
    public Observable<ServiceResponse<Page<AvailableServiceSkuInner>>> listSkusWithServiceResponseAsync(final String groupName, final String serviceName) {
        return listSkusSinglePageAsync(groupName, serviceName)
            .concatMap(new Func1<ServiceResponse<Page<AvailableServiceSkuInner>>, Observable<ServiceResponse<Page<AvailableServiceSkuInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<AvailableServiceSkuInner>>> call(ServiceResponse<Page<AvailableServiceSkuInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listSkusNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get compatible SKUs.
     * The services resource is the top-level resource that represents the Data Migration Service. The skus action returns the list of SKUs that a service resource can be updated to.
     *
    ServiceResponse<PageImpl<AvailableServiceSkuInner>> * @param groupName Name of the resource group
    ServiceResponse<PageImpl<AvailableServiceSkuInner>> * @param serviceName Name of the service
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;AvailableServiceSkuInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<AvailableServiceSkuInner>>> listSkusSinglePageAsync(final String groupName, final String serviceName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (groupName == null) {
            throw new IllegalArgumentException("Parameter groupName is required and cannot be null.");
        }
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listSkus(this.client.subscriptionId(), groupName, serviceName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<AvailableServiceSkuInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<AvailableServiceSkuInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<AvailableServiceSkuInner>> result = listSkusDelegate(response);
                        return Observable.just(new ServiceResponse<Page<AvailableServiceSkuInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<AvailableServiceSkuInner>> listSkusDelegate(Response<ResponseBody> response) throws ApiErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<AvailableServiceSkuInner>, ApiErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<AvailableServiceSkuInner>>() { }.getType())
                .registerError(ApiErrorException.class)
                .build(response);
    }

    /**
     * Check nested resource name validity and availability.
     * This method checks whether a proposed nested resource name is valid and available.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @param parameters Requested name to validate
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ApiErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the NameAvailabilityResponseInner object if successful.
     */
    public NameAvailabilityResponseInner checkChildrenNameAvailability(String groupName, String serviceName, NameAvailabilityRequest parameters) {
        return checkChildrenNameAvailabilityWithServiceResponseAsync(groupName, serviceName, parameters).toBlocking().single().body();
    }

    /**
     * Check nested resource name validity and availability.
     * This method checks whether a proposed nested resource name is valid and available.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @param parameters Requested name to validate
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<NameAvailabilityResponseInner> checkChildrenNameAvailabilityAsync(String groupName, String serviceName, NameAvailabilityRequest parameters, final ServiceCallback<NameAvailabilityResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(checkChildrenNameAvailabilityWithServiceResponseAsync(groupName, serviceName, parameters), serviceCallback);
    }

    /**
     * Check nested resource name validity and availability.
     * This method checks whether a proposed nested resource name is valid and available.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @param parameters Requested name to validate
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the NameAvailabilityResponseInner object
     */
    public Observable<NameAvailabilityResponseInner> checkChildrenNameAvailabilityAsync(String groupName, String serviceName, NameAvailabilityRequest parameters) {
        return checkChildrenNameAvailabilityWithServiceResponseAsync(groupName, serviceName, parameters).map(new Func1<ServiceResponse<NameAvailabilityResponseInner>, NameAvailabilityResponseInner>() {
            @Override
            public NameAvailabilityResponseInner call(ServiceResponse<NameAvailabilityResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Check nested resource name validity and availability.
     * This method checks whether a proposed nested resource name is valid and available.
     *
     * @param groupName Name of the resource group
     * @param serviceName Name of the service
     * @param parameters Requested name to validate
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the NameAvailabilityResponseInner object
     */
    public Observable<ServiceResponse<NameAvailabilityResponseInner>> checkChildrenNameAvailabilityWithServiceResponseAsync(String groupName, String serviceName, NameAvailabilityRequest parameters) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (groupName == null) {
            throw new IllegalArgumentException("Parameter groupName is required and cannot be null.");
        }
        if (serviceName == null) {
            throw new IllegalArgumentException("Parameter serviceName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        if (parameters == null) {
            throw new IllegalArgumentException("Parameter parameters is required and cannot be null.");
        }
        Validator.validate(parameters);
        return service.checkChildrenNameAvailability(this.client.subscriptionId(), groupName, serviceName, this.client.apiVersion(), parameters, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<NameAvailabilityResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<NameAvailabilityResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<NameAvailabilityResponseInner> clientResponse = checkChildrenNameAvailabilityDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<NameAvailabilityResponseInner> checkChildrenNameAvailabilityDelegate(Response<ResponseBody> response) throws ApiErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<NameAvailabilityResponseInner, ApiErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<NameAvailabilityResponseInner>() { }.getType())
                .registerError(ApiErrorException.class)
                .build(response);
    }

    /**
     * Get services in resource group.
     * The Services resource is the top-level resource that represents the Data Migration Service. This method returns a list of service resources in a resource group.
     *
     * @param groupName Name of the resource group
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ApiErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;DataMigrationServiceInner&gt; object if successful.
     */
    public PagedList<DataMigrationServiceInner> listByResourceGroup(final String groupName) {
        ServiceResponse<Page<DataMigrationServiceInner>> response = listByResourceGroupSinglePageAsync(groupName).toBlocking().single();
        return new PagedList<DataMigrationServiceInner>(response.body()) {
            @Override
            public Page<DataMigrationServiceInner> nextPage(String nextPageLink) {
                return listByResourceGroupNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get services in resource group.
     * The Services resource is the top-level resource that represents the Data Migration Service. This method returns a list of service resources in a resource group.
     *
     * @param groupName Name of the resource group
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<DataMigrationServiceInner>> listByResourceGroupAsync(final String groupName, final ListOperationCallback<DataMigrationServiceInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByResourceGroupSinglePageAsync(groupName),
            new Func1<String, Observable<ServiceResponse<Page<DataMigrationServiceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DataMigrationServiceInner>>> call(String nextPageLink) {
                    return listByResourceGroupNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get services in resource group.
     * The Services resource is the top-level resource that represents the Data Migration Service. This method returns a list of service resources in a resource group.
     *
     * @param groupName Name of the resource group
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;DataMigrationServiceInner&gt; object
     */
    public Observable<Page<DataMigrationServiceInner>> listByResourceGroupAsync(final String groupName) {
        return listByResourceGroupWithServiceResponseAsync(groupName)
            .map(new Func1<ServiceResponse<Page<DataMigrationServiceInner>>, Page<DataMigrationServiceInner>>() {
                @Override
                public Page<DataMigrationServiceInner> call(ServiceResponse<Page<DataMigrationServiceInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get services in resource group.
     * The Services resource is the top-level resource that represents the Data Migration Service. This method returns a list of service resources in a resource group.
     *
     * @param groupName Name of the resource group
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;DataMigrationServiceInner&gt; object
     */
    public Observable<ServiceResponse<Page<DataMigrationServiceInner>>> listByResourceGroupWithServiceResponseAsync(final String groupName) {
        return listByResourceGroupSinglePageAsync(groupName)
            .concatMap(new Func1<ServiceResponse<Page<DataMigrationServiceInner>>, Observable<ServiceResponse<Page<DataMigrationServiceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DataMigrationServiceInner>>> call(ServiceResponse<Page<DataMigrationServiceInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByResourceGroupNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get services in resource group.
     * The Services resource is the top-level resource that represents the Data Migration Service. This method returns a list of service resources in a resource group.
     *
    ServiceResponse<PageImpl<DataMigrationServiceInner>> * @param groupName Name of the resource group
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;DataMigrationServiceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<DataMigrationServiceInner>>> listByResourceGroupSinglePageAsync(final String groupName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (groupName == null) {
            throw new IllegalArgumentException("Parameter groupName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listByResourceGroup(this.client.subscriptionId(), groupName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<DataMigrationServiceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DataMigrationServiceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<DataMigrationServiceInner>> result = listByResourceGroupDelegate(response);
                        return Observable.just(new ServiceResponse<Page<DataMigrationServiceInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<DataMigrationServiceInner>> listByResourceGroupDelegate(Response<ResponseBody> response) throws ApiErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<DataMigrationServiceInner>, ApiErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<DataMigrationServiceInner>>() { }.getType())
                .registerError(ApiErrorException.class)
                .build(response);
    }

    /**
     * Get services in subscription.
     * The services resource is the top-level resource that represents the Data Migration Service. This method returns a list of service resources in a subscription.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ApiErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;DataMigrationServiceInner&gt; object if successful.
     */
    public PagedList<DataMigrationServiceInner> list() {
        ServiceResponse<Page<DataMigrationServiceInner>> response = listSinglePageAsync().toBlocking().single();
        return new PagedList<DataMigrationServiceInner>(response.body()) {
            @Override
            public Page<DataMigrationServiceInner> nextPage(String nextPageLink) {
                return listNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get services in subscription.
     * The services resource is the top-level resource that represents the Data Migration Service. This method returns a list of service resources in a subscription.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<DataMigrationServiceInner>> listAsync(final ListOperationCallback<DataMigrationServiceInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listSinglePageAsync(),
            new Func1<String, Observable<ServiceResponse<Page<DataMigrationServiceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DataMigrationServiceInner>>> call(String nextPageLink) {
                    return listNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get services in subscription.
     * The services resource is the top-level resource that represents the Data Migration Service. This method returns a list of service resources in a subscription.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;DataMigrationServiceInner&gt; object
     */
    public Observable<Page<DataMigrationServiceInner>> listAsync() {
        return listWithServiceResponseAsync()
            .map(new Func1<ServiceResponse<Page<DataMigrationServiceInner>>, Page<DataMigrationServiceInner>>() {
                @Override
                public Page<DataMigrationServiceInner> call(ServiceResponse<Page<DataMigrationServiceInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get services in subscription.
     * The services resource is the top-level resource that represents the Data Migration Service. This method returns a list of service resources in a subscription.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;DataMigrationServiceInner&gt; object
     */
    public Observable<ServiceResponse<Page<DataMigrationServiceInner>>> listWithServiceResponseAsync() {
        return listSinglePageAsync()
            .concatMap(new Func1<ServiceResponse<Page<DataMigrationServiceInner>>, Observable<ServiceResponse<Page<DataMigrationServiceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DataMigrationServiceInner>>> call(ServiceResponse<Page<DataMigrationServiceInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get services in subscription.
     * The services resource is the top-level resource that represents the Data Migration Service. This method returns a list of service resources in a subscription.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;DataMigrationServiceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<DataMigrationServiceInner>>> listSinglePageAsync() {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.list(this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<DataMigrationServiceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DataMigrationServiceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<DataMigrationServiceInner>> result = listDelegate(response);
                        return Observable.just(new ServiceResponse<Page<DataMigrationServiceInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<DataMigrationServiceInner>> listDelegate(Response<ResponseBody> response) throws ApiErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<DataMigrationServiceInner>, ApiErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<DataMigrationServiceInner>>() { }.getType())
                .registerError(ApiErrorException.class)
                .build(response);
    }

    /**
     * Check name validity and availability.
     * This method checks whether a proposed top-level resource name is valid and available.
     *
     * @param location The Azure region of the operation
     * @param parameters Requested name to validate
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ApiErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the NameAvailabilityResponseInner object if successful.
     */
    public NameAvailabilityResponseInner checkNameAvailability(String location, NameAvailabilityRequest parameters) {
        return checkNameAvailabilityWithServiceResponseAsync(location, parameters).toBlocking().single().body();
    }

    /**
     * Check name validity and availability.
     * This method checks whether a proposed top-level resource name is valid and available.
     *
     * @param location The Azure region of the operation
     * @param parameters Requested name to validate
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<NameAvailabilityResponseInner> checkNameAvailabilityAsync(String location, NameAvailabilityRequest parameters, final ServiceCallback<NameAvailabilityResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(checkNameAvailabilityWithServiceResponseAsync(location, parameters), serviceCallback);
    }

    /**
     * Check name validity and availability.
     * This method checks whether a proposed top-level resource name is valid and available.
     *
     * @param location The Azure region of the operation
     * @param parameters Requested name to validate
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the NameAvailabilityResponseInner object
     */
    public Observable<NameAvailabilityResponseInner> checkNameAvailabilityAsync(String location, NameAvailabilityRequest parameters) {
        return checkNameAvailabilityWithServiceResponseAsync(location, parameters).map(new Func1<ServiceResponse<NameAvailabilityResponseInner>, NameAvailabilityResponseInner>() {
            @Override
            public NameAvailabilityResponseInner call(ServiceResponse<NameAvailabilityResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Check name validity and availability.
     * This method checks whether a proposed top-level resource name is valid and available.
     *
     * @param location The Azure region of the operation
     * @param parameters Requested name to validate
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the NameAvailabilityResponseInner object
     */
    public Observable<ServiceResponse<NameAvailabilityResponseInner>> checkNameAvailabilityWithServiceResponseAsync(String location, NameAvailabilityRequest parameters) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (location == null) {
            throw new IllegalArgumentException("Parameter location is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        if (parameters == null) {
            throw new IllegalArgumentException("Parameter parameters is required and cannot be null.");
        }
        Validator.validate(parameters);
        return service.checkNameAvailability(this.client.subscriptionId(), location, this.client.apiVersion(), parameters, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<NameAvailabilityResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<NameAvailabilityResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<NameAvailabilityResponseInner> clientResponse = checkNameAvailabilityDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<NameAvailabilityResponseInner> checkNameAvailabilityDelegate(Response<ResponseBody> response) throws ApiErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<NameAvailabilityResponseInner, ApiErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<NameAvailabilityResponseInner>() { }.getType())
                .registerError(ApiErrorException.class)
                .build(response);
    }

    /**
     * Get compatible SKUs.
     * The services resource is the top-level resource that represents the Data Migration Service. The skus action returns the list of SKUs that a service resource can be updated to.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ApiErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;AvailableServiceSkuInner&gt; object if successful.
     */
    public PagedList<AvailableServiceSkuInner> listSkusNext(final String nextPageLink) {
        ServiceResponse<Page<AvailableServiceSkuInner>> response = listSkusNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<AvailableServiceSkuInner>(response.body()) {
            @Override
            public Page<AvailableServiceSkuInner> nextPage(String nextPageLink) {
                return listSkusNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get compatible SKUs.
     * The services resource is the top-level resource that represents the Data Migration Service. The skus action returns the list of SKUs that a service resource can be updated to.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<AvailableServiceSkuInner>> listSkusNextAsync(final String nextPageLink, final ServiceFuture<List<AvailableServiceSkuInner>> serviceFuture, final ListOperationCallback<AvailableServiceSkuInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listSkusNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<AvailableServiceSkuInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<AvailableServiceSkuInner>>> call(String nextPageLink) {
                    return listSkusNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get compatible SKUs.
     * The services resource is the top-level resource that represents the Data Migration Service. The skus action returns the list of SKUs that a service resource can be updated to.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;AvailableServiceSkuInner&gt; object
     */
    public Observable<Page<AvailableServiceSkuInner>> listSkusNextAsync(final String nextPageLink) {
        return listSkusNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<AvailableServiceSkuInner>>, Page<AvailableServiceSkuInner>>() {
                @Override
                public Page<AvailableServiceSkuInner> call(ServiceResponse<Page<AvailableServiceSkuInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get compatible SKUs.
     * The services resource is the top-level resource that represents the Data Migration Service. The skus action returns the list of SKUs that a service resource can be updated to.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;AvailableServiceSkuInner&gt; object
     */
    public Observable<ServiceResponse<Page<AvailableServiceSkuInner>>> listSkusNextWithServiceResponseAsync(final String nextPageLink) {
        return listSkusNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<AvailableServiceSkuInner>>, Observable<ServiceResponse<Page<AvailableServiceSkuInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<AvailableServiceSkuInner>>> call(ServiceResponse<Page<AvailableServiceSkuInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listSkusNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get compatible SKUs.
     * The services resource is the top-level resource that represents the Data Migration Service. The skus action returns the list of SKUs that a service resource can be updated to.
     *
    ServiceResponse<PageImpl<AvailableServiceSkuInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;AvailableServiceSkuInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<AvailableServiceSkuInner>>> listSkusNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listSkusNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<AvailableServiceSkuInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<AvailableServiceSkuInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<AvailableServiceSkuInner>> result = listSkusNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<AvailableServiceSkuInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<AvailableServiceSkuInner>> listSkusNextDelegate(Response<ResponseBody> response) throws ApiErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<AvailableServiceSkuInner>, ApiErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<AvailableServiceSkuInner>>() { }.getType())
                .registerError(ApiErrorException.class)
                .build(response);
    }

    /**
     * Get services in resource group.
     * The Services resource is the top-level resource that represents the Data Migration Service. This method returns a list of service resources in a resource group.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ApiErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;DataMigrationServiceInner&gt; object if successful.
     */
    public PagedList<DataMigrationServiceInner> listByResourceGroupNext(final String nextPageLink) {
        ServiceResponse<Page<DataMigrationServiceInner>> response = listByResourceGroupNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<DataMigrationServiceInner>(response.body()) {
            @Override
            public Page<DataMigrationServiceInner> nextPage(String nextPageLink) {
                return listByResourceGroupNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get services in resource group.
     * The Services resource is the top-level resource that represents the Data Migration Service. This method returns a list of service resources in a resource group.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<DataMigrationServiceInner>> listByResourceGroupNextAsync(final String nextPageLink, final ServiceFuture<List<DataMigrationServiceInner>> serviceFuture, final ListOperationCallback<DataMigrationServiceInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByResourceGroupNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<DataMigrationServiceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DataMigrationServiceInner>>> call(String nextPageLink) {
                    return listByResourceGroupNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get services in resource group.
     * The Services resource is the top-level resource that represents the Data Migration Service. This method returns a list of service resources in a resource group.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;DataMigrationServiceInner&gt; object
     */
    public Observable<Page<DataMigrationServiceInner>> listByResourceGroupNextAsync(final String nextPageLink) {
        return listByResourceGroupNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<DataMigrationServiceInner>>, Page<DataMigrationServiceInner>>() {
                @Override
                public Page<DataMigrationServiceInner> call(ServiceResponse<Page<DataMigrationServiceInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get services in resource group.
     * The Services resource is the top-level resource that represents the Data Migration Service. This method returns a list of service resources in a resource group.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;DataMigrationServiceInner&gt; object
     */
    public Observable<ServiceResponse<Page<DataMigrationServiceInner>>> listByResourceGroupNextWithServiceResponseAsync(final String nextPageLink) {
        return listByResourceGroupNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<DataMigrationServiceInner>>, Observable<ServiceResponse<Page<DataMigrationServiceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DataMigrationServiceInner>>> call(ServiceResponse<Page<DataMigrationServiceInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByResourceGroupNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get services in resource group.
     * The Services resource is the top-level resource that represents the Data Migration Service. This method returns a list of service resources in a resource group.
     *
    ServiceResponse<PageImpl<DataMigrationServiceInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;DataMigrationServiceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<DataMigrationServiceInner>>> listByResourceGroupNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listByResourceGroupNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<DataMigrationServiceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DataMigrationServiceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<DataMigrationServiceInner>> result = listByResourceGroupNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<DataMigrationServiceInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<DataMigrationServiceInner>> listByResourceGroupNextDelegate(Response<ResponseBody> response) throws ApiErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<DataMigrationServiceInner>, ApiErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<DataMigrationServiceInner>>() { }.getType())
                .registerError(ApiErrorException.class)
                .build(response);
    }

    /**
     * Get services in subscription.
     * The services resource is the top-level resource that represents the Data Migration Service. This method returns a list of service resources in a subscription.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ApiErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;DataMigrationServiceInner&gt; object if successful.
     */
    public PagedList<DataMigrationServiceInner> listNext(final String nextPageLink) {
        ServiceResponse<Page<DataMigrationServiceInner>> response = listNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<DataMigrationServiceInner>(response.body()) {
            @Override
            public Page<DataMigrationServiceInner> nextPage(String nextPageLink) {
                return listNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get services in subscription.
     * The services resource is the top-level resource that represents the Data Migration Service. This method returns a list of service resources in a subscription.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<DataMigrationServiceInner>> listNextAsync(final String nextPageLink, final ServiceFuture<List<DataMigrationServiceInner>> serviceFuture, final ListOperationCallback<DataMigrationServiceInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<DataMigrationServiceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DataMigrationServiceInner>>> call(String nextPageLink) {
                    return listNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get services in subscription.
     * The services resource is the top-level resource that represents the Data Migration Service. This method returns a list of service resources in a subscription.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;DataMigrationServiceInner&gt; object
     */
    public Observable<Page<DataMigrationServiceInner>> listNextAsync(final String nextPageLink) {
        return listNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<DataMigrationServiceInner>>, Page<DataMigrationServiceInner>>() {
                @Override
                public Page<DataMigrationServiceInner> call(ServiceResponse<Page<DataMigrationServiceInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get services in subscription.
     * The services resource is the top-level resource that represents the Data Migration Service. This method returns a list of service resources in a subscription.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;DataMigrationServiceInner&gt; object
     */
    public Observable<ServiceResponse<Page<DataMigrationServiceInner>>> listNextWithServiceResponseAsync(final String nextPageLink) {
        return listNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<DataMigrationServiceInner>>, Observable<ServiceResponse<Page<DataMigrationServiceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DataMigrationServiceInner>>> call(ServiceResponse<Page<DataMigrationServiceInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get services in subscription.
     * The services resource is the top-level resource that represents the Data Migration Service. This method returns a list of service resources in a subscription.
     *
    ServiceResponse<PageImpl<DataMigrationServiceInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;DataMigrationServiceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<DataMigrationServiceInner>>> listNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<DataMigrationServiceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DataMigrationServiceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<DataMigrationServiceInner>> result = listNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<DataMigrationServiceInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<DataMigrationServiceInner>> listNextDelegate(Response<ResponseBody> response) throws ApiErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<DataMigrationServiceInner>, ApiErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<DataMigrationServiceInner>>() { }.getType())
                .registerError(ApiErrorException.class)
                .build(response);
    }

}
