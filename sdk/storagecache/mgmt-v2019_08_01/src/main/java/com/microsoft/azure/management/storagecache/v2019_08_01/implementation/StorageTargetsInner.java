/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.management.storagecache.v2019_08_01.implementation;

import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.AzureServiceFuture;
import com.microsoft.azure.CloudException;
import com.microsoft.azure.ListOperationCallback;
import com.microsoft.azure.Page;
import com.microsoft.azure.PagedList;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.List;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.PATCH;
import retrofit2.http.Path;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.http.Url;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in StorageTargets.
 */
public class StorageTargetsInner {
    /** The Retrofit service to perform REST calls. */
    private StorageTargetsService service;
    /** The service client containing this operation class. */
    private StorageCacheManagementClientImpl client;

    /**
     * Initializes an instance of StorageTargetsInner.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public StorageTargetsInner(Retrofit retrofit, StorageCacheManagementClientImpl client) {
        this.service = retrofit.create(StorageTargetsService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for StorageTargets to be
     * used by Retrofit to perform actually REST calls.
     */
    interface StorageTargetsService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.storagecache.v2019_08_01.StorageTargets listByCache" })
        @GET("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StorageCache/caches/{cacheName}/storageTargets")
        Observable<Response<ResponseBody>> listByCache(@Path("resourceGroupName") String resourceGroupName, @Path("subscriptionId") String subscriptionId, @Path("cacheName") String cacheName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.storagecache.v2019_08_01.StorageTargets delete" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StorageCache/caches/{cacheName}/storageTargets/{storageTargetName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> delete(@Path("resourceGroupName") String resourceGroupName, @Path("subscriptionId") String subscriptionId, @Path("cacheName") String cacheName, @Path("storageTargetName") String storageTargetName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.storagecache.v2019_08_01.StorageTargets beginDelete" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StorageCache/caches/{cacheName}/storageTargets/{storageTargetName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> beginDelete(@Path("resourceGroupName") String resourceGroupName, @Path("subscriptionId") String subscriptionId, @Path("cacheName") String cacheName, @Path("storageTargetName") String storageTargetName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.storagecache.v2019_08_01.StorageTargets get" })
        @GET("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StorageCache/caches/{cacheName}/storageTargets/{storageTargetName}")
        Observable<Response<ResponseBody>> get(@Path("resourceGroupName") String resourceGroupName, @Path("subscriptionId") String subscriptionId, @Path("cacheName") String cacheName, @Path("storageTargetName") String storageTargetName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.storagecache.v2019_08_01.StorageTargets create" })
        @PUT("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StorageCache/caches/{cacheName}/storageTargets/{storageTargetName}")
        Observable<Response<ResponseBody>> create(@Path("resourceGroupName") String resourceGroupName, @Path("subscriptionId") String subscriptionId, @Path("cacheName") String cacheName, @Path("storageTargetName") String storageTargetName, @Query("api-version") String apiVersion, @Body StorageTargetInner storagetarget, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.storagecache.v2019_08_01.StorageTargets beginCreate" })
        @PUT("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StorageCache/caches/{cacheName}/storageTargets/{storageTargetName}")
        Observable<Response<ResponseBody>> beginCreate(@Path("resourceGroupName") String resourceGroupName, @Path("subscriptionId") String subscriptionId, @Path("cacheName") String cacheName, @Path("storageTargetName") String storageTargetName, @Query("api-version") String apiVersion, @Body StorageTargetInner storagetarget, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.storagecache.v2019_08_01.StorageTargets update" })
        @PATCH("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StorageCache/caches/{cacheName}/storageTargets/{storageTargetName}")
        Observable<Response<ResponseBody>> update(@Path("resourceGroupName") String resourceGroupName, @Path("subscriptionId") String subscriptionId, @Path("cacheName") String cacheName, @Path("storageTargetName") String storageTargetName, @Query("api-version") String apiVersion, @Body StorageTargetInner storagetarget, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.storagecache.v2019_08_01.StorageTargets listByCacheNext" })
        @GET
        Observable<Response<ResponseBody>> listByCacheNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

    }

    /**
     * Returns the StorageTargets for this cache in the subscription and resource group.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of cache.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;StorageTargetInner&gt; object if successful.
     */
    public PagedList<StorageTargetInner> listByCache(final String resourceGroupName, final String cacheName) {
        ServiceResponse<Page<StorageTargetInner>> response = listByCacheSinglePageAsync(resourceGroupName, cacheName).toBlocking().single();
        return new PagedList<StorageTargetInner>(response.body()) {
            @Override
            public Page<StorageTargetInner> nextPage(String nextPageLink) {
                return listByCacheNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Returns the StorageTargets for this cache in the subscription and resource group.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of cache.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<StorageTargetInner>> listByCacheAsync(final String resourceGroupName, final String cacheName, final ListOperationCallback<StorageTargetInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByCacheSinglePageAsync(resourceGroupName, cacheName),
            new Func1<String, Observable<ServiceResponse<Page<StorageTargetInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<StorageTargetInner>>> call(String nextPageLink) {
                    return listByCacheNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Returns the StorageTargets for this cache in the subscription and resource group.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of cache.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;StorageTargetInner&gt; object
     */
    public Observable<Page<StorageTargetInner>> listByCacheAsync(final String resourceGroupName, final String cacheName) {
        return listByCacheWithServiceResponseAsync(resourceGroupName, cacheName)
            .map(new Func1<ServiceResponse<Page<StorageTargetInner>>, Page<StorageTargetInner>>() {
                @Override
                public Page<StorageTargetInner> call(ServiceResponse<Page<StorageTargetInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Returns the StorageTargets for this cache in the subscription and resource group.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of cache.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;StorageTargetInner&gt; object
     */
    public Observable<ServiceResponse<Page<StorageTargetInner>>> listByCacheWithServiceResponseAsync(final String resourceGroupName, final String cacheName) {
        return listByCacheSinglePageAsync(resourceGroupName, cacheName)
            .concatMap(new Func1<ServiceResponse<Page<StorageTargetInner>>, Observable<ServiceResponse<Page<StorageTargetInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<StorageTargetInner>>> call(ServiceResponse<Page<StorageTargetInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByCacheNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Returns the StorageTargets for this cache in the subscription and resource group.
     *
    ServiceResponse<PageImpl<StorageTargetInner>> * @param resourceGroupName Target resource group.
    ServiceResponse<PageImpl<StorageTargetInner>> * @param cacheName Name of cache.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;StorageTargetInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<StorageTargetInner>>> listByCacheSinglePageAsync(final String resourceGroupName, final String cacheName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (cacheName == null) {
            throw new IllegalArgumentException("Parameter cacheName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listByCache(resourceGroupName, this.client.subscriptionId(), cacheName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<StorageTargetInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<StorageTargetInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<StorageTargetInner>> result = listByCacheDelegate(response);
                        return Observable.just(new ServiceResponse<Page<StorageTargetInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<StorageTargetInner>> listByCacheDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<StorageTargetInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<StorageTargetInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Removes a storage target from a cache.  This operation is allowed at any time, but if the cache is down or unhealthy, the actual removal of the storage target may be delayed until the cache is healthy again.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of cache.
     * @param storageTargetName Name of storage target.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object delete(String resourceGroupName, String cacheName, String storageTargetName) {
        return deleteWithServiceResponseAsync(resourceGroupName, cacheName, storageTargetName).toBlocking().last().body();
    }

    /**
     * Removes a storage target from a cache.  This operation is allowed at any time, but if the cache is down or unhealthy, the actual removal of the storage target may be delayed until the cache is healthy again.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of cache.
     * @param storageTargetName Name of storage target.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> deleteAsync(String resourceGroupName, String cacheName, String storageTargetName, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(deleteWithServiceResponseAsync(resourceGroupName, cacheName, storageTargetName), serviceCallback);
    }

    /**
     * Removes a storage target from a cache.  This operation is allowed at any time, but if the cache is down or unhealthy, the actual removal of the storage target may be delayed until the cache is healthy again.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of cache.
     * @param storageTargetName Name of storage target.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<Object> deleteAsync(String resourceGroupName, String cacheName, String storageTargetName) {
        return deleteWithServiceResponseAsync(resourceGroupName, cacheName, storageTargetName).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Removes a storage target from a cache.  This operation is allowed at any time, but if the cache is down or unhealthy, the actual removal of the storage target may be delayed until the cache is healthy again.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of cache.
     * @param storageTargetName Name of storage target.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<Object>> deleteWithServiceResponseAsync(String resourceGroupName, String cacheName, String storageTargetName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (cacheName == null) {
            throw new IllegalArgumentException("Parameter cacheName is required and cannot be null.");
        }
        if (storageTargetName == null) {
            throw new IllegalArgumentException("Parameter storageTargetName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Observable<Response<ResponseBody>> observable = service.delete(resourceGroupName, this.client.subscriptionId(), cacheName, storageTargetName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<Object>() { }.getType());
    }

    /**
     * Removes a storage target from a cache.  This operation is allowed at any time, but if the cache is down or unhealthy, the actual removal of the storage target may be delayed until the cache is healthy again.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of cache.
     * @param storageTargetName Name of storage target.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object beginDelete(String resourceGroupName, String cacheName, String storageTargetName) {
        return beginDeleteWithServiceResponseAsync(resourceGroupName, cacheName, storageTargetName).toBlocking().single().body();
    }

    /**
     * Removes a storage target from a cache.  This operation is allowed at any time, but if the cache is down or unhealthy, the actual removal of the storage target may be delayed until the cache is healthy again.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of cache.
     * @param storageTargetName Name of storage target.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> beginDeleteAsync(String resourceGroupName, String cacheName, String storageTargetName, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(beginDeleteWithServiceResponseAsync(resourceGroupName, cacheName, storageTargetName), serviceCallback);
    }

    /**
     * Removes a storage target from a cache.  This operation is allowed at any time, but if the cache is down or unhealthy, the actual removal of the storage target may be delayed until the cache is healthy again.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of cache.
     * @param storageTargetName Name of storage target.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> beginDeleteAsync(String resourceGroupName, String cacheName, String storageTargetName) {
        return beginDeleteWithServiceResponseAsync(resourceGroupName, cacheName, storageTargetName).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Removes a storage target from a cache.  This operation is allowed at any time, but if the cache is down or unhealthy, the actual removal of the storage target may be delayed until the cache is healthy again.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of cache.
     * @param storageTargetName Name of storage target.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> beginDeleteWithServiceResponseAsync(String resourceGroupName, String cacheName, String storageTargetName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (cacheName == null) {
            throw new IllegalArgumentException("Parameter cacheName is required and cannot be null.");
        }
        if (storageTargetName == null) {
            throw new IllegalArgumentException("Parameter storageTargetName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.beginDelete(resourceGroupName, this.client.subscriptionId(), cacheName, storageTargetName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = beginDeleteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> beginDeleteDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .register(202, new TypeToken<Object>() { }.getType())
                .register(204, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Returns a storage target from a cache.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of cache.
     * @param storageTargetName Name of storage target.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StorageTargetInner object if successful.
     */
    public StorageTargetInner get(String resourceGroupName, String cacheName, String storageTargetName) {
        return getWithServiceResponseAsync(resourceGroupName, cacheName, storageTargetName).toBlocking().single().body();
    }

    /**
     * Returns a storage target from a cache.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of cache.
     * @param storageTargetName Name of storage target.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StorageTargetInner> getAsync(String resourceGroupName, String cacheName, String storageTargetName, final ServiceCallback<StorageTargetInner> serviceCallback) {
        return ServiceFuture.fromResponse(getWithServiceResponseAsync(resourceGroupName, cacheName, storageTargetName), serviceCallback);
    }

    /**
     * Returns a storage target from a cache.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of cache.
     * @param storageTargetName Name of storage target.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StorageTargetInner object
     */
    public Observable<StorageTargetInner> getAsync(String resourceGroupName, String cacheName, String storageTargetName) {
        return getWithServiceResponseAsync(resourceGroupName, cacheName, storageTargetName).map(new Func1<ServiceResponse<StorageTargetInner>, StorageTargetInner>() {
            @Override
            public StorageTargetInner call(ServiceResponse<StorageTargetInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Returns a storage target from a cache.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of cache.
     * @param storageTargetName Name of storage target.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StorageTargetInner object
     */
    public Observable<ServiceResponse<StorageTargetInner>> getWithServiceResponseAsync(String resourceGroupName, String cacheName, String storageTargetName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (cacheName == null) {
            throw new IllegalArgumentException("Parameter cacheName is required and cannot be null.");
        }
        if (storageTargetName == null) {
            throw new IllegalArgumentException("Parameter storageTargetName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.get(resourceGroupName, this.client.subscriptionId(), cacheName, storageTargetName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StorageTargetInner>>>() {
                @Override
                public Observable<ServiceResponse<StorageTargetInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StorageTargetInner> clientResponse = getDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StorageTargetInner> getDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<StorageTargetInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<StorageTargetInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Create/update a storage target.  This operation is allowed at any time, but if the cache is down or unhealthy, the actual creation/modification of the storage target may be delayed until the cache is healthy again.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of cache.
     * @param storageTargetName Name of storage target.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StorageTargetInner object if successful.
     */
    public StorageTargetInner create(String resourceGroupName, String cacheName, String storageTargetName) {
        return createWithServiceResponseAsync(resourceGroupName, cacheName, storageTargetName).toBlocking().last().body();
    }

    /**
     * Create/update a storage target.  This operation is allowed at any time, but if the cache is down or unhealthy, the actual creation/modification of the storage target may be delayed until the cache is healthy again.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of cache.
     * @param storageTargetName Name of storage target.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StorageTargetInner> createAsync(String resourceGroupName, String cacheName, String storageTargetName, final ServiceCallback<StorageTargetInner> serviceCallback) {
        return ServiceFuture.fromResponse(createWithServiceResponseAsync(resourceGroupName, cacheName, storageTargetName), serviceCallback);
    }

    /**
     * Create/update a storage target.  This operation is allowed at any time, but if the cache is down or unhealthy, the actual creation/modification of the storage target may be delayed until the cache is healthy again.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of cache.
     * @param storageTargetName Name of storage target.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<StorageTargetInner> createAsync(String resourceGroupName, String cacheName, String storageTargetName) {
        return createWithServiceResponseAsync(resourceGroupName, cacheName, storageTargetName).map(new Func1<ServiceResponse<StorageTargetInner>, StorageTargetInner>() {
            @Override
            public StorageTargetInner call(ServiceResponse<StorageTargetInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Create/update a storage target.  This operation is allowed at any time, but if the cache is down or unhealthy, the actual creation/modification of the storage target may be delayed until the cache is healthy again.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of cache.
     * @param storageTargetName Name of storage target.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<StorageTargetInner>> createWithServiceResponseAsync(String resourceGroupName, String cacheName, String storageTargetName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (cacheName == null) {
            throw new IllegalArgumentException("Parameter cacheName is required and cannot be null.");
        }
        if (storageTargetName == null) {
            throw new IllegalArgumentException("Parameter storageTargetName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final StorageTargetInner storagetarget = null;
        Observable<Response<ResponseBody>> observable = service.create(resourceGroupName, this.client.subscriptionId(), cacheName, storageTargetName, this.client.apiVersion(), storagetarget, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultAsync(observable, new TypeToken<StorageTargetInner>() { }.getType());
    }
    /**
     * Create/update a storage target.  This operation is allowed at any time, but if the cache is down or unhealthy, the actual creation/modification of the storage target may be delayed until the cache is healthy again.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of cache.
     * @param storageTargetName Name of storage target.
     * @param storagetarget Object containing the definition of a storage target.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StorageTargetInner object if successful.
     */
    public StorageTargetInner create(String resourceGroupName, String cacheName, String storageTargetName, StorageTargetInner storagetarget) {
        return createWithServiceResponseAsync(resourceGroupName, cacheName, storageTargetName, storagetarget).toBlocking().last().body();
    }

    /**
     * Create/update a storage target.  This operation is allowed at any time, but if the cache is down or unhealthy, the actual creation/modification of the storage target may be delayed until the cache is healthy again.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of cache.
     * @param storageTargetName Name of storage target.
     * @param storagetarget Object containing the definition of a storage target.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StorageTargetInner> createAsync(String resourceGroupName, String cacheName, String storageTargetName, StorageTargetInner storagetarget, final ServiceCallback<StorageTargetInner> serviceCallback) {
        return ServiceFuture.fromResponse(createWithServiceResponseAsync(resourceGroupName, cacheName, storageTargetName, storagetarget), serviceCallback);
    }

    /**
     * Create/update a storage target.  This operation is allowed at any time, but if the cache is down or unhealthy, the actual creation/modification of the storage target may be delayed until the cache is healthy again.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of cache.
     * @param storageTargetName Name of storage target.
     * @param storagetarget Object containing the definition of a storage target.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<StorageTargetInner> createAsync(String resourceGroupName, String cacheName, String storageTargetName, StorageTargetInner storagetarget) {
        return createWithServiceResponseAsync(resourceGroupName, cacheName, storageTargetName, storagetarget).map(new Func1<ServiceResponse<StorageTargetInner>, StorageTargetInner>() {
            @Override
            public StorageTargetInner call(ServiceResponse<StorageTargetInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Create/update a storage target.  This operation is allowed at any time, but if the cache is down or unhealthy, the actual creation/modification of the storage target may be delayed until the cache is healthy again.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of cache.
     * @param storageTargetName Name of storage target.
     * @param storagetarget Object containing the definition of a storage target.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<StorageTargetInner>> createWithServiceResponseAsync(String resourceGroupName, String cacheName, String storageTargetName, StorageTargetInner storagetarget) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (cacheName == null) {
            throw new IllegalArgumentException("Parameter cacheName is required and cannot be null.");
        }
        if (storageTargetName == null) {
            throw new IllegalArgumentException("Parameter storageTargetName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(storagetarget);
        Observable<Response<ResponseBody>> observable = service.create(resourceGroupName, this.client.subscriptionId(), cacheName, storageTargetName, this.client.apiVersion(), storagetarget, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultAsync(observable, new TypeToken<StorageTargetInner>() { }.getType());
    }

    /**
     * Create/update a storage target.  This operation is allowed at any time, but if the cache is down or unhealthy, the actual creation/modification of the storage target may be delayed until the cache is healthy again.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of cache.
     * @param storageTargetName Name of storage target.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StorageTargetInner object if successful.
     */
    public StorageTargetInner beginCreate(String resourceGroupName, String cacheName, String storageTargetName) {
        return beginCreateWithServiceResponseAsync(resourceGroupName, cacheName, storageTargetName).toBlocking().single().body();
    }

    /**
     * Create/update a storage target.  This operation is allowed at any time, but if the cache is down or unhealthy, the actual creation/modification of the storage target may be delayed until the cache is healthy again.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of cache.
     * @param storageTargetName Name of storage target.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StorageTargetInner> beginCreateAsync(String resourceGroupName, String cacheName, String storageTargetName, final ServiceCallback<StorageTargetInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginCreateWithServiceResponseAsync(resourceGroupName, cacheName, storageTargetName), serviceCallback);
    }

    /**
     * Create/update a storage target.  This operation is allowed at any time, but if the cache is down or unhealthy, the actual creation/modification of the storage target may be delayed until the cache is healthy again.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of cache.
     * @param storageTargetName Name of storage target.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StorageTargetInner object
     */
    public Observable<StorageTargetInner> beginCreateAsync(String resourceGroupName, String cacheName, String storageTargetName) {
        return beginCreateWithServiceResponseAsync(resourceGroupName, cacheName, storageTargetName).map(new Func1<ServiceResponse<StorageTargetInner>, StorageTargetInner>() {
            @Override
            public StorageTargetInner call(ServiceResponse<StorageTargetInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Create/update a storage target.  This operation is allowed at any time, but if the cache is down or unhealthy, the actual creation/modification of the storage target may be delayed until the cache is healthy again.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of cache.
     * @param storageTargetName Name of storage target.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StorageTargetInner object
     */
    public Observable<ServiceResponse<StorageTargetInner>> beginCreateWithServiceResponseAsync(String resourceGroupName, String cacheName, String storageTargetName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (cacheName == null) {
            throw new IllegalArgumentException("Parameter cacheName is required and cannot be null.");
        }
        if (storageTargetName == null) {
            throw new IllegalArgumentException("Parameter storageTargetName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final StorageTargetInner storagetarget = null;
        return service.beginCreate(resourceGroupName, this.client.subscriptionId(), cacheName, storageTargetName, this.client.apiVersion(), storagetarget, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StorageTargetInner>>>() {
                @Override
                public Observable<ServiceResponse<StorageTargetInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StorageTargetInner> clientResponse = beginCreateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Create/update a storage target.  This operation is allowed at any time, but if the cache is down or unhealthy, the actual creation/modification of the storage target may be delayed until the cache is healthy again.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of cache.
     * @param storageTargetName Name of storage target.
     * @param storagetarget Object containing the definition of a storage target.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StorageTargetInner object if successful.
     */
    public StorageTargetInner beginCreate(String resourceGroupName, String cacheName, String storageTargetName, StorageTargetInner storagetarget) {
        return beginCreateWithServiceResponseAsync(resourceGroupName, cacheName, storageTargetName, storagetarget).toBlocking().single().body();
    }

    /**
     * Create/update a storage target.  This operation is allowed at any time, but if the cache is down or unhealthy, the actual creation/modification of the storage target may be delayed until the cache is healthy again.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of cache.
     * @param storageTargetName Name of storage target.
     * @param storagetarget Object containing the definition of a storage target.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StorageTargetInner> beginCreateAsync(String resourceGroupName, String cacheName, String storageTargetName, StorageTargetInner storagetarget, final ServiceCallback<StorageTargetInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginCreateWithServiceResponseAsync(resourceGroupName, cacheName, storageTargetName, storagetarget), serviceCallback);
    }

    /**
     * Create/update a storage target.  This operation is allowed at any time, but if the cache is down or unhealthy, the actual creation/modification of the storage target may be delayed until the cache is healthy again.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of cache.
     * @param storageTargetName Name of storage target.
     * @param storagetarget Object containing the definition of a storage target.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StorageTargetInner object
     */
    public Observable<StorageTargetInner> beginCreateAsync(String resourceGroupName, String cacheName, String storageTargetName, StorageTargetInner storagetarget) {
        return beginCreateWithServiceResponseAsync(resourceGroupName, cacheName, storageTargetName, storagetarget).map(new Func1<ServiceResponse<StorageTargetInner>, StorageTargetInner>() {
            @Override
            public StorageTargetInner call(ServiceResponse<StorageTargetInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Create/update a storage target.  This operation is allowed at any time, but if the cache is down or unhealthy, the actual creation/modification of the storage target may be delayed until the cache is healthy again.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of cache.
     * @param storageTargetName Name of storage target.
     * @param storagetarget Object containing the definition of a storage target.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StorageTargetInner object
     */
    public Observable<ServiceResponse<StorageTargetInner>> beginCreateWithServiceResponseAsync(String resourceGroupName, String cacheName, String storageTargetName, StorageTargetInner storagetarget) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (cacheName == null) {
            throw new IllegalArgumentException("Parameter cacheName is required and cannot be null.");
        }
        if (storageTargetName == null) {
            throw new IllegalArgumentException("Parameter storageTargetName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(storagetarget);
        return service.beginCreate(resourceGroupName, this.client.subscriptionId(), cacheName, storageTargetName, this.client.apiVersion(), storagetarget, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StorageTargetInner>>>() {
                @Override
                public Observable<ServiceResponse<StorageTargetInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StorageTargetInner> clientResponse = beginCreateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StorageTargetInner> beginCreateDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<StorageTargetInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<StorageTargetInner>() { }.getType())
                .register(201, new TypeToken<StorageTargetInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Update a storage target.  This operation is allowed at any time, but if the cache is down or unhealthy, the actual creation/modification of the storage target may be delayed until the cache is healthy again.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of cache.
     * @param storageTargetName Name of storage target.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StorageTargetInner object if successful.
     */
    public StorageTargetInner update(String resourceGroupName, String cacheName, String storageTargetName) {
        return updateWithServiceResponseAsync(resourceGroupName, cacheName, storageTargetName).toBlocking().single().body();
    }

    /**
     * Update a storage target.  This operation is allowed at any time, but if the cache is down or unhealthy, the actual creation/modification of the storage target may be delayed until the cache is healthy again.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of cache.
     * @param storageTargetName Name of storage target.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StorageTargetInner> updateAsync(String resourceGroupName, String cacheName, String storageTargetName, final ServiceCallback<StorageTargetInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateWithServiceResponseAsync(resourceGroupName, cacheName, storageTargetName), serviceCallback);
    }

    /**
     * Update a storage target.  This operation is allowed at any time, but if the cache is down or unhealthy, the actual creation/modification of the storage target may be delayed until the cache is healthy again.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of cache.
     * @param storageTargetName Name of storage target.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StorageTargetInner object
     */
    public Observable<StorageTargetInner> updateAsync(String resourceGroupName, String cacheName, String storageTargetName) {
        return updateWithServiceResponseAsync(resourceGroupName, cacheName, storageTargetName).map(new Func1<ServiceResponse<StorageTargetInner>, StorageTargetInner>() {
            @Override
            public StorageTargetInner call(ServiceResponse<StorageTargetInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Update a storage target.  This operation is allowed at any time, but if the cache is down or unhealthy, the actual creation/modification of the storage target may be delayed until the cache is healthy again.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of cache.
     * @param storageTargetName Name of storage target.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StorageTargetInner object
     */
    public Observable<ServiceResponse<StorageTargetInner>> updateWithServiceResponseAsync(String resourceGroupName, String cacheName, String storageTargetName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (cacheName == null) {
            throw new IllegalArgumentException("Parameter cacheName is required and cannot be null.");
        }
        if (storageTargetName == null) {
            throw new IllegalArgumentException("Parameter storageTargetName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final StorageTargetInner storagetarget = null;
        return service.update(resourceGroupName, this.client.subscriptionId(), cacheName, storageTargetName, this.client.apiVersion(), storagetarget, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StorageTargetInner>>>() {
                @Override
                public Observable<ServiceResponse<StorageTargetInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StorageTargetInner> clientResponse = updateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Update a storage target.  This operation is allowed at any time, but if the cache is down or unhealthy, the actual creation/modification of the storage target may be delayed until the cache is healthy again.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of cache.
     * @param storageTargetName Name of storage target.
     * @param storagetarget Object containing the definition of a storage target.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StorageTargetInner object if successful.
     */
    public StorageTargetInner update(String resourceGroupName, String cacheName, String storageTargetName, StorageTargetInner storagetarget) {
        return updateWithServiceResponseAsync(resourceGroupName, cacheName, storageTargetName, storagetarget).toBlocking().single().body();
    }

    /**
     * Update a storage target.  This operation is allowed at any time, but if the cache is down or unhealthy, the actual creation/modification of the storage target may be delayed until the cache is healthy again.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of cache.
     * @param storageTargetName Name of storage target.
     * @param storagetarget Object containing the definition of a storage target.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StorageTargetInner> updateAsync(String resourceGroupName, String cacheName, String storageTargetName, StorageTargetInner storagetarget, final ServiceCallback<StorageTargetInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateWithServiceResponseAsync(resourceGroupName, cacheName, storageTargetName, storagetarget), serviceCallback);
    }

    /**
     * Update a storage target.  This operation is allowed at any time, but if the cache is down or unhealthy, the actual creation/modification of the storage target may be delayed until the cache is healthy again.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of cache.
     * @param storageTargetName Name of storage target.
     * @param storagetarget Object containing the definition of a storage target.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StorageTargetInner object
     */
    public Observable<StorageTargetInner> updateAsync(String resourceGroupName, String cacheName, String storageTargetName, StorageTargetInner storagetarget) {
        return updateWithServiceResponseAsync(resourceGroupName, cacheName, storageTargetName, storagetarget).map(new Func1<ServiceResponse<StorageTargetInner>, StorageTargetInner>() {
            @Override
            public StorageTargetInner call(ServiceResponse<StorageTargetInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Update a storage target.  This operation is allowed at any time, but if the cache is down or unhealthy, the actual creation/modification of the storage target may be delayed until the cache is healthy again.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of cache.
     * @param storageTargetName Name of storage target.
     * @param storagetarget Object containing the definition of a storage target.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StorageTargetInner object
     */
    public Observable<ServiceResponse<StorageTargetInner>> updateWithServiceResponseAsync(String resourceGroupName, String cacheName, String storageTargetName, StorageTargetInner storagetarget) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (cacheName == null) {
            throw new IllegalArgumentException("Parameter cacheName is required and cannot be null.");
        }
        if (storageTargetName == null) {
            throw new IllegalArgumentException("Parameter storageTargetName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(storagetarget);
        return service.update(resourceGroupName, this.client.subscriptionId(), cacheName, storageTargetName, this.client.apiVersion(), storagetarget, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StorageTargetInner>>>() {
                @Override
                public Observable<ServiceResponse<StorageTargetInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StorageTargetInner> clientResponse = updateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StorageTargetInner> updateDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<StorageTargetInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<StorageTargetInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Returns the StorageTargets for this cache in the subscription and resource group.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;StorageTargetInner&gt; object if successful.
     */
    public PagedList<StorageTargetInner> listByCacheNext(final String nextPageLink) {
        ServiceResponse<Page<StorageTargetInner>> response = listByCacheNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<StorageTargetInner>(response.body()) {
            @Override
            public Page<StorageTargetInner> nextPage(String nextPageLink) {
                return listByCacheNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Returns the StorageTargets for this cache in the subscription and resource group.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<StorageTargetInner>> listByCacheNextAsync(final String nextPageLink, final ServiceFuture<List<StorageTargetInner>> serviceFuture, final ListOperationCallback<StorageTargetInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByCacheNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<StorageTargetInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<StorageTargetInner>>> call(String nextPageLink) {
                    return listByCacheNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Returns the StorageTargets for this cache in the subscription and resource group.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;StorageTargetInner&gt; object
     */
    public Observable<Page<StorageTargetInner>> listByCacheNextAsync(final String nextPageLink) {
        return listByCacheNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<StorageTargetInner>>, Page<StorageTargetInner>>() {
                @Override
                public Page<StorageTargetInner> call(ServiceResponse<Page<StorageTargetInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Returns the StorageTargets for this cache in the subscription and resource group.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;StorageTargetInner&gt; object
     */
    public Observable<ServiceResponse<Page<StorageTargetInner>>> listByCacheNextWithServiceResponseAsync(final String nextPageLink) {
        return listByCacheNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<StorageTargetInner>>, Observable<ServiceResponse<Page<StorageTargetInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<StorageTargetInner>>> call(ServiceResponse<Page<StorageTargetInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByCacheNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Returns the StorageTargets for this cache in the subscription and resource group.
     *
    ServiceResponse<PageImpl<StorageTargetInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;StorageTargetInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<StorageTargetInner>>> listByCacheNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listByCacheNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<StorageTargetInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<StorageTargetInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<StorageTargetInner>> result = listByCacheNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<StorageTargetInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<StorageTargetInner>> listByCacheNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<StorageTargetInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<StorageTargetInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

}
