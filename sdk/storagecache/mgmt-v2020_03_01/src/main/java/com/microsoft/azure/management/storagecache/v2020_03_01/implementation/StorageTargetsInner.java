/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.management.storagecache.v2020_03_01.implementation;

import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.AzureServiceFuture;
import com.microsoft.azure.CloudException;
import com.microsoft.azure.ListOperationCallback;
import com.microsoft.azure.Page;
import com.microsoft.azure.PagedList;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.List;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.Path;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.http.Url;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in StorageTargets.
 */
public class StorageTargetsInner {
    /** The Retrofit service to perform REST calls. */
    private StorageTargetsService service;
    /** The service client containing this operation class. */
    private StorageCacheManagementClientImpl client;

    /**
     * Initializes an instance of StorageTargetsInner.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public StorageTargetsInner(Retrofit retrofit, StorageCacheManagementClientImpl client) {
        this.service = retrofit.create(StorageTargetsService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for StorageTargets to be
     * used by Retrofit to perform actually REST calls.
     */
    interface StorageTargetsService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.storagecache.v2020_03_01.StorageTargets listByCache" })
        @GET("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StorageCache/caches/{cacheName}/storageTargets")
        Observable<Response<ResponseBody>> listByCache(@Path("resourceGroupName") String resourceGroupName, @Path("subscriptionId") String subscriptionId, @Path("cacheName") String cacheName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.storagecache.v2020_03_01.StorageTargets delete" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StorageCache/caches/{cacheName}/storageTargets/{storageTargetName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> delete(@Path("resourceGroupName") String resourceGroupName, @Path("subscriptionId") String subscriptionId, @Path("cacheName") String cacheName, @Path("storageTargetName") String storageTargetName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.storagecache.v2020_03_01.StorageTargets beginDelete" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StorageCache/caches/{cacheName}/storageTargets/{storageTargetName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> beginDelete(@Path("resourceGroupName") String resourceGroupName, @Path("subscriptionId") String subscriptionId, @Path("cacheName") String cacheName, @Path("storageTargetName") String storageTargetName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.storagecache.v2020_03_01.StorageTargets get" })
        @GET("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StorageCache/caches/{cacheName}/storageTargets/{storageTargetName}")
        Observable<Response<ResponseBody>> get(@Path("resourceGroupName") String resourceGroupName, @Path("subscriptionId") String subscriptionId, @Path("cacheName") String cacheName, @Path("storageTargetName") String storageTargetName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.storagecache.v2020_03_01.StorageTargets createOrUpdate" })
        @PUT("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StorageCache/caches/{cacheName}/storageTargets/{storageTargetName}")
        Observable<Response<ResponseBody>> createOrUpdate(@Path("resourceGroupName") String resourceGroupName, @Path("subscriptionId") String subscriptionId, @Path("cacheName") String cacheName, @Path("storageTargetName") String storageTargetName, @Query("api-version") String apiVersion, @Body StorageTargetInner storagetarget, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.storagecache.v2020_03_01.StorageTargets beginCreateOrUpdate" })
        @PUT("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StorageCache/caches/{cacheName}/storageTargets/{storageTargetName}")
        Observable<Response<ResponseBody>> beginCreateOrUpdate(@Path("resourceGroupName") String resourceGroupName, @Path("subscriptionId") String subscriptionId, @Path("cacheName") String cacheName, @Path("storageTargetName") String storageTargetName, @Query("api-version") String apiVersion, @Body StorageTargetInner storagetarget, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.storagecache.v2020_03_01.StorageTargets listByCacheNext" })
        @GET
        Observable<Response<ResponseBody>> listByCacheNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

    }

    /**
     * Returns a list of Storage Targets for the specified Cache.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of Cache. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;StorageTargetInner&gt; object if successful.
     */
    public PagedList<StorageTargetInner> listByCache(final String resourceGroupName, final String cacheName) {
        ServiceResponse<Page<StorageTargetInner>> response = listByCacheSinglePageAsync(resourceGroupName, cacheName).toBlocking().single();
        return new PagedList<StorageTargetInner>(response.body()) {
            @Override
            public Page<StorageTargetInner> nextPage(String nextPageLink) {
                return listByCacheNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Returns a list of Storage Targets for the specified Cache.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of Cache. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<StorageTargetInner>> listByCacheAsync(final String resourceGroupName, final String cacheName, final ListOperationCallback<StorageTargetInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByCacheSinglePageAsync(resourceGroupName, cacheName),
            new Func1<String, Observable<ServiceResponse<Page<StorageTargetInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<StorageTargetInner>>> call(String nextPageLink) {
                    return listByCacheNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Returns a list of Storage Targets for the specified Cache.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of Cache. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;StorageTargetInner&gt; object
     */
    public Observable<Page<StorageTargetInner>> listByCacheAsync(final String resourceGroupName, final String cacheName) {
        return listByCacheWithServiceResponseAsync(resourceGroupName, cacheName)
            .map(new Func1<ServiceResponse<Page<StorageTargetInner>>, Page<StorageTargetInner>>() {
                @Override
                public Page<StorageTargetInner> call(ServiceResponse<Page<StorageTargetInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Returns a list of Storage Targets for the specified Cache.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of Cache. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;StorageTargetInner&gt; object
     */
    public Observable<ServiceResponse<Page<StorageTargetInner>>> listByCacheWithServiceResponseAsync(final String resourceGroupName, final String cacheName) {
        return listByCacheSinglePageAsync(resourceGroupName, cacheName)
            .concatMap(new Func1<ServiceResponse<Page<StorageTargetInner>>, Observable<ServiceResponse<Page<StorageTargetInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<StorageTargetInner>>> call(ServiceResponse<Page<StorageTargetInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByCacheNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Returns a list of Storage Targets for the specified Cache.
     *
    ServiceResponse<PageImpl<StorageTargetInner>> * @param resourceGroupName Target resource group.
    ServiceResponse<PageImpl<StorageTargetInner>> * @param cacheName Name of Cache. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;StorageTargetInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<StorageTargetInner>>> listByCacheSinglePageAsync(final String resourceGroupName, final String cacheName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (cacheName == null) {
            throw new IllegalArgumentException("Parameter cacheName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listByCache(resourceGroupName, this.client.subscriptionId(), cacheName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<StorageTargetInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<StorageTargetInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<StorageTargetInner>> result = listByCacheDelegate(response);
                        return Observable.just(new ServiceResponse<Page<StorageTargetInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<StorageTargetInner>> listByCacheDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<StorageTargetInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<StorageTargetInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Removes a Storage Target from a Cache. This operation is allowed at any time, but if the Cache is down or unhealthy, the actual removal of the Storage Target may be delayed until the Cache is healthy again. Note that if the Cache has data to flush to the Storage Target, the data will be flushed before the Storage Target will be deleted.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of Cache. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @param storageTargetName Name of Storage Target.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object delete(String resourceGroupName, String cacheName, String storageTargetName) {
        return deleteWithServiceResponseAsync(resourceGroupName, cacheName, storageTargetName).toBlocking().last().body();
    }

    /**
     * Removes a Storage Target from a Cache. This operation is allowed at any time, but if the Cache is down or unhealthy, the actual removal of the Storage Target may be delayed until the Cache is healthy again. Note that if the Cache has data to flush to the Storage Target, the data will be flushed before the Storage Target will be deleted.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of Cache. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @param storageTargetName Name of Storage Target.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> deleteAsync(String resourceGroupName, String cacheName, String storageTargetName, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(deleteWithServiceResponseAsync(resourceGroupName, cacheName, storageTargetName), serviceCallback);
    }

    /**
     * Removes a Storage Target from a Cache. This operation is allowed at any time, but if the Cache is down or unhealthy, the actual removal of the Storage Target may be delayed until the Cache is healthy again. Note that if the Cache has data to flush to the Storage Target, the data will be flushed before the Storage Target will be deleted.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of Cache. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @param storageTargetName Name of Storage Target.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<Object> deleteAsync(String resourceGroupName, String cacheName, String storageTargetName) {
        return deleteWithServiceResponseAsync(resourceGroupName, cacheName, storageTargetName).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Removes a Storage Target from a Cache. This operation is allowed at any time, but if the Cache is down or unhealthy, the actual removal of the Storage Target may be delayed until the Cache is healthy again. Note that if the Cache has data to flush to the Storage Target, the data will be flushed before the Storage Target will be deleted.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of Cache. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @param storageTargetName Name of Storage Target.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<Object>> deleteWithServiceResponseAsync(String resourceGroupName, String cacheName, String storageTargetName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (cacheName == null) {
            throw new IllegalArgumentException("Parameter cacheName is required and cannot be null.");
        }
        if (storageTargetName == null) {
            throw new IllegalArgumentException("Parameter storageTargetName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Observable<Response<ResponseBody>> observable = service.delete(resourceGroupName, this.client.subscriptionId(), cacheName, storageTargetName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<Object>() { }.getType());
    }

    /**
     * Removes a Storage Target from a Cache. This operation is allowed at any time, but if the Cache is down or unhealthy, the actual removal of the Storage Target may be delayed until the Cache is healthy again. Note that if the Cache has data to flush to the Storage Target, the data will be flushed before the Storage Target will be deleted.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of Cache. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @param storageTargetName Name of Storage Target.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object beginDelete(String resourceGroupName, String cacheName, String storageTargetName) {
        return beginDeleteWithServiceResponseAsync(resourceGroupName, cacheName, storageTargetName).toBlocking().single().body();
    }

    /**
     * Removes a Storage Target from a Cache. This operation is allowed at any time, but if the Cache is down or unhealthy, the actual removal of the Storage Target may be delayed until the Cache is healthy again. Note that if the Cache has data to flush to the Storage Target, the data will be flushed before the Storage Target will be deleted.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of Cache. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @param storageTargetName Name of Storage Target.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> beginDeleteAsync(String resourceGroupName, String cacheName, String storageTargetName, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(beginDeleteWithServiceResponseAsync(resourceGroupName, cacheName, storageTargetName), serviceCallback);
    }

    /**
     * Removes a Storage Target from a Cache. This operation is allowed at any time, but if the Cache is down or unhealthy, the actual removal of the Storage Target may be delayed until the Cache is healthy again. Note that if the Cache has data to flush to the Storage Target, the data will be flushed before the Storage Target will be deleted.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of Cache. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @param storageTargetName Name of Storage Target.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> beginDeleteAsync(String resourceGroupName, String cacheName, String storageTargetName) {
        return beginDeleteWithServiceResponseAsync(resourceGroupName, cacheName, storageTargetName).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Removes a Storage Target from a Cache. This operation is allowed at any time, but if the Cache is down or unhealthy, the actual removal of the Storage Target may be delayed until the Cache is healthy again. Note that if the Cache has data to flush to the Storage Target, the data will be flushed before the Storage Target will be deleted.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of Cache. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @param storageTargetName Name of Storage Target.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> beginDeleteWithServiceResponseAsync(String resourceGroupName, String cacheName, String storageTargetName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (cacheName == null) {
            throw new IllegalArgumentException("Parameter cacheName is required and cannot be null.");
        }
        if (storageTargetName == null) {
            throw new IllegalArgumentException("Parameter storageTargetName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.beginDelete(resourceGroupName, this.client.subscriptionId(), cacheName, storageTargetName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = beginDeleteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> beginDeleteDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .register(202, new TypeToken<Object>() { }.getType())
                .register(204, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Returns a Storage Target from a Cache.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of Cache. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @param storageTargetName Name of the Storage Target. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StorageTargetInner object if successful.
     */
    public StorageTargetInner get(String resourceGroupName, String cacheName, String storageTargetName) {
        return getWithServiceResponseAsync(resourceGroupName, cacheName, storageTargetName).toBlocking().single().body();
    }

    /**
     * Returns a Storage Target from a Cache.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of Cache. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @param storageTargetName Name of the Storage Target. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StorageTargetInner> getAsync(String resourceGroupName, String cacheName, String storageTargetName, final ServiceCallback<StorageTargetInner> serviceCallback) {
        return ServiceFuture.fromResponse(getWithServiceResponseAsync(resourceGroupName, cacheName, storageTargetName), serviceCallback);
    }

    /**
     * Returns a Storage Target from a Cache.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of Cache. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @param storageTargetName Name of the Storage Target. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StorageTargetInner object
     */
    public Observable<StorageTargetInner> getAsync(String resourceGroupName, String cacheName, String storageTargetName) {
        return getWithServiceResponseAsync(resourceGroupName, cacheName, storageTargetName).map(new Func1<ServiceResponse<StorageTargetInner>, StorageTargetInner>() {
            @Override
            public StorageTargetInner call(ServiceResponse<StorageTargetInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Returns a Storage Target from a Cache.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of Cache. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @param storageTargetName Name of the Storage Target. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StorageTargetInner object
     */
    public Observable<ServiceResponse<StorageTargetInner>> getWithServiceResponseAsync(String resourceGroupName, String cacheName, String storageTargetName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (cacheName == null) {
            throw new IllegalArgumentException("Parameter cacheName is required and cannot be null.");
        }
        if (storageTargetName == null) {
            throw new IllegalArgumentException("Parameter storageTargetName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.get(resourceGroupName, this.client.subscriptionId(), cacheName, storageTargetName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StorageTargetInner>>>() {
                @Override
                public Observable<ServiceResponse<StorageTargetInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StorageTargetInner> clientResponse = getDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StorageTargetInner> getDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<StorageTargetInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<StorageTargetInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Create or update a Storage Target. This operation is allowed at any time, but if the Cache is down or unhealthy, the actual creation/modification of the Storage Target may be delayed until the Cache is healthy again.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of Cache. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @param storageTargetName Name of the Storage Target. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StorageTargetInner object if successful.
     */
    public StorageTargetInner createOrUpdate(String resourceGroupName, String cacheName, String storageTargetName) {
        return createOrUpdateWithServiceResponseAsync(resourceGroupName, cacheName, storageTargetName).toBlocking().last().body();
    }

    /**
     * Create or update a Storage Target. This operation is allowed at any time, but if the Cache is down or unhealthy, the actual creation/modification of the Storage Target may be delayed until the Cache is healthy again.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of Cache. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @param storageTargetName Name of the Storage Target. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StorageTargetInner> createOrUpdateAsync(String resourceGroupName, String cacheName, String storageTargetName, final ServiceCallback<StorageTargetInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateWithServiceResponseAsync(resourceGroupName, cacheName, storageTargetName), serviceCallback);
    }

    /**
     * Create or update a Storage Target. This operation is allowed at any time, but if the Cache is down or unhealthy, the actual creation/modification of the Storage Target may be delayed until the Cache is healthy again.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of Cache. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @param storageTargetName Name of the Storage Target. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<StorageTargetInner> createOrUpdateAsync(String resourceGroupName, String cacheName, String storageTargetName) {
        return createOrUpdateWithServiceResponseAsync(resourceGroupName, cacheName, storageTargetName).map(new Func1<ServiceResponse<StorageTargetInner>, StorageTargetInner>() {
            @Override
            public StorageTargetInner call(ServiceResponse<StorageTargetInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Create or update a Storage Target. This operation is allowed at any time, but if the Cache is down or unhealthy, the actual creation/modification of the Storage Target may be delayed until the Cache is healthy again.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of Cache. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @param storageTargetName Name of the Storage Target. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<StorageTargetInner>> createOrUpdateWithServiceResponseAsync(String resourceGroupName, String cacheName, String storageTargetName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (cacheName == null) {
            throw new IllegalArgumentException("Parameter cacheName is required and cannot be null.");
        }
        if (storageTargetName == null) {
            throw new IllegalArgumentException("Parameter storageTargetName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final StorageTargetInner storagetarget = null;
        Observable<Response<ResponseBody>> observable = service.createOrUpdate(resourceGroupName, this.client.subscriptionId(), cacheName, storageTargetName, this.client.apiVersion(), storagetarget, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultAsync(observable, new TypeToken<StorageTargetInner>() { }.getType());
    }
    /**
     * Create or update a Storage Target. This operation is allowed at any time, but if the Cache is down or unhealthy, the actual creation/modification of the Storage Target may be delayed until the Cache is healthy again.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of Cache. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @param storageTargetName Name of the Storage Target. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @param storagetarget Object containing the definition of a Storage Target.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StorageTargetInner object if successful.
     */
    public StorageTargetInner createOrUpdate(String resourceGroupName, String cacheName, String storageTargetName, StorageTargetInner storagetarget) {
        return createOrUpdateWithServiceResponseAsync(resourceGroupName, cacheName, storageTargetName, storagetarget).toBlocking().last().body();
    }

    /**
     * Create or update a Storage Target. This operation is allowed at any time, but if the Cache is down or unhealthy, the actual creation/modification of the Storage Target may be delayed until the Cache is healthy again.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of Cache. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @param storageTargetName Name of the Storage Target. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @param storagetarget Object containing the definition of a Storage Target.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StorageTargetInner> createOrUpdateAsync(String resourceGroupName, String cacheName, String storageTargetName, StorageTargetInner storagetarget, final ServiceCallback<StorageTargetInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateWithServiceResponseAsync(resourceGroupName, cacheName, storageTargetName, storagetarget), serviceCallback);
    }

    /**
     * Create or update a Storage Target. This operation is allowed at any time, but if the Cache is down or unhealthy, the actual creation/modification of the Storage Target may be delayed until the Cache is healthy again.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of Cache. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @param storageTargetName Name of the Storage Target. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @param storagetarget Object containing the definition of a Storage Target.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<StorageTargetInner> createOrUpdateAsync(String resourceGroupName, String cacheName, String storageTargetName, StorageTargetInner storagetarget) {
        return createOrUpdateWithServiceResponseAsync(resourceGroupName, cacheName, storageTargetName, storagetarget).map(new Func1<ServiceResponse<StorageTargetInner>, StorageTargetInner>() {
            @Override
            public StorageTargetInner call(ServiceResponse<StorageTargetInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Create or update a Storage Target. This operation is allowed at any time, but if the Cache is down or unhealthy, the actual creation/modification of the Storage Target may be delayed until the Cache is healthy again.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of Cache. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @param storageTargetName Name of the Storage Target. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @param storagetarget Object containing the definition of a Storage Target.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<StorageTargetInner>> createOrUpdateWithServiceResponseAsync(String resourceGroupName, String cacheName, String storageTargetName, StorageTargetInner storagetarget) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (cacheName == null) {
            throw new IllegalArgumentException("Parameter cacheName is required and cannot be null.");
        }
        if (storageTargetName == null) {
            throw new IllegalArgumentException("Parameter storageTargetName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(storagetarget);
        Observable<Response<ResponseBody>> observable = service.createOrUpdate(resourceGroupName, this.client.subscriptionId(), cacheName, storageTargetName, this.client.apiVersion(), storagetarget, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultAsync(observable, new TypeToken<StorageTargetInner>() { }.getType());
    }

    /**
     * Create or update a Storage Target. This operation is allowed at any time, but if the Cache is down or unhealthy, the actual creation/modification of the Storage Target may be delayed until the Cache is healthy again.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of Cache. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @param storageTargetName Name of the Storage Target. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StorageTargetInner object if successful.
     */
    public StorageTargetInner beginCreateOrUpdate(String resourceGroupName, String cacheName, String storageTargetName) {
        return beginCreateOrUpdateWithServiceResponseAsync(resourceGroupName, cacheName, storageTargetName).toBlocking().single().body();
    }

    /**
     * Create or update a Storage Target. This operation is allowed at any time, but if the Cache is down or unhealthy, the actual creation/modification of the Storage Target may be delayed until the Cache is healthy again.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of Cache. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @param storageTargetName Name of the Storage Target. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StorageTargetInner> beginCreateOrUpdateAsync(String resourceGroupName, String cacheName, String storageTargetName, final ServiceCallback<StorageTargetInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginCreateOrUpdateWithServiceResponseAsync(resourceGroupName, cacheName, storageTargetName), serviceCallback);
    }

    /**
     * Create or update a Storage Target. This operation is allowed at any time, but if the Cache is down or unhealthy, the actual creation/modification of the Storage Target may be delayed until the Cache is healthy again.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of Cache. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @param storageTargetName Name of the Storage Target. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StorageTargetInner object
     */
    public Observable<StorageTargetInner> beginCreateOrUpdateAsync(String resourceGroupName, String cacheName, String storageTargetName) {
        return beginCreateOrUpdateWithServiceResponseAsync(resourceGroupName, cacheName, storageTargetName).map(new Func1<ServiceResponse<StorageTargetInner>, StorageTargetInner>() {
            @Override
            public StorageTargetInner call(ServiceResponse<StorageTargetInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Create or update a Storage Target. This operation is allowed at any time, but if the Cache is down or unhealthy, the actual creation/modification of the Storage Target may be delayed until the Cache is healthy again.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of Cache. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @param storageTargetName Name of the Storage Target. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StorageTargetInner object
     */
    public Observable<ServiceResponse<StorageTargetInner>> beginCreateOrUpdateWithServiceResponseAsync(String resourceGroupName, String cacheName, String storageTargetName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (cacheName == null) {
            throw new IllegalArgumentException("Parameter cacheName is required and cannot be null.");
        }
        if (storageTargetName == null) {
            throw new IllegalArgumentException("Parameter storageTargetName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final StorageTargetInner storagetarget = null;
        return service.beginCreateOrUpdate(resourceGroupName, this.client.subscriptionId(), cacheName, storageTargetName, this.client.apiVersion(), storagetarget, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StorageTargetInner>>>() {
                @Override
                public Observable<ServiceResponse<StorageTargetInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StorageTargetInner> clientResponse = beginCreateOrUpdateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Create or update a Storage Target. This operation is allowed at any time, but if the Cache is down or unhealthy, the actual creation/modification of the Storage Target may be delayed until the Cache is healthy again.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of Cache. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @param storageTargetName Name of the Storage Target. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @param storagetarget Object containing the definition of a Storage Target.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StorageTargetInner object if successful.
     */
    public StorageTargetInner beginCreateOrUpdate(String resourceGroupName, String cacheName, String storageTargetName, StorageTargetInner storagetarget) {
        return beginCreateOrUpdateWithServiceResponseAsync(resourceGroupName, cacheName, storageTargetName, storagetarget).toBlocking().single().body();
    }

    /**
     * Create or update a Storage Target. This operation is allowed at any time, but if the Cache is down or unhealthy, the actual creation/modification of the Storage Target may be delayed until the Cache is healthy again.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of Cache. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @param storageTargetName Name of the Storage Target. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @param storagetarget Object containing the definition of a Storage Target.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StorageTargetInner> beginCreateOrUpdateAsync(String resourceGroupName, String cacheName, String storageTargetName, StorageTargetInner storagetarget, final ServiceCallback<StorageTargetInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginCreateOrUpdateWithServiceResponseAsync(resourceGroupName, cacheName, storageTargetName, storagetarget), serviceCallback);
    }

    /**
     * Create or update a Storage Target. This operation is allowed at any time, but if the Cache is down or unhealthy, the actual creation/modification of the Storage Target may be delayed until the Cache is healthy again.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of Cache. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @param storageTargetName Name of the Storage Target. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @param storagetarget Object containing the definition of a Storage Target.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StorageTargetInner object
     */
    public Observable<StorageTargetInner> beginCreateOrUpdateAsync(String resourceGroupName, String cacheName, String storageTargetName, StorageTargetInner storagetarget) {
        return beginCreateOrUpdateWithServiceResponseAsync(resourceGroupName, cacheName, storageTargetName, storagetarget).map(new Func1<ServiceResponse<StorageTargetInner>, StorageTargetInner>() {
            @Override
            public StorageTargetInner call(ServiceResponse<StorageTargetInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Create or update a Storage Target. This operation is allowed at any time, but if the Cache is down or unhealthy, the actual creation/modification of the Storage Target may be delayed until the Cache is healthy again.
     *
     * @param resourceGroupName Target resource group.
     * @param cacheName Name of Cache. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @param storageTargetName Name of the Storage Target. Length of name must be not greater than 80 and chars must be in list of [-0-9a-zA-Z_] char class.
     * @param storagetarget Object containing the definition of a Storage Target.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StorageTargetInner object
     */
    public Observable<ServiceResponse<StorageTargetInner>> beginCreateOrUpdateWithServiceResponseAsync(String resourceGroupName, String cacheName, String storageTargetName, StorageTargetInner storagetarget) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (cacheName == null) {
            throw new IllegalArgumentException("Parameter cacheName is required and cannot be null.");
        }
        if (storageTargetName == null) {
            throw new IllegalArgumentException("Parameter storageTargetName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(storagetarget);
        return service.beginCreateOrUpdate(resourceGroupName, this.client.subscriptionId(), cacheName, storageTargetName, this.client.apiVersion(), storagetarget, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StorageTargetInner>>>() {
                @Override
                public Observable<ServiceResponse<StorageTargetInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StorageTargetInner> clientResponse = beginCreateOrUpdateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StorageTargetInner> beginCreateOrUpdateDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<StorageTargetInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<StorageTargetInner>() { }.getType())
                .register(201, new TypeToken<StorageTargetInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Returns a list of Storage Targets for the specified Cache.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;StorageTargetInner&gt; object if successful.
     */
    public PagedList<StorageTargetInner> listByCacheNext(final String nextPageLink) {
        ServiceResponse<Page<StorageTargetInner>> response = listByCacheNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<StorageTargetInner>(response.body()) {
            @Override
            public Page<StorageTargetInner> nextPage(String nextPageLink) {
                return listByCacheNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Returns a list of Storage Targets for the specified Cache.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<StorageTargetInner>> listByCacheNextAsync(final String nextPageLink, final ServiceFuture<List<StorageTargetInner>> serviceFuture, final ListOperationCallback<StorageTargetInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByCacheNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<StorageTargetInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<StorageTargetInner>>> call(String nextPageLink) {
                    return listByCacheNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Returns a list of Storage Targets for the specified Cache.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;StorageTargetInner&gt; object
     */
    public Observable<Page<StorageTargetInner>> listByCacheNextAsync(final String nextPageLink) {
        return listByCacheNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<StorageTargetInner>>, Page<StorageTargetInner>>() {
                @Override
                public Page<StorageTargetInner> call(ServiceResponse<Page<StorageTargetInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Returns a list of Storage Targets for the specified Cache.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;StorageTargetInner&gt; object
     */
    public Observable<ServiceResponse<Page<StorageTargetInner>>> listByCacheNextWithServiceResponseAsync(final String nextPageLink) {
        return listByCacheNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<StorageTargetInner>>, Observable<ServiceResponse<Page<StorageTargetInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<StorageTargetInner>>> call(ServiceResponse<Page<StorageTargetInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByCacheNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Returns a list of Storage Targets for the specified Cache.
     *
    ServiceResponse<PageImpl<StorageTargetInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;StorageTargetInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<StorageTargetInner>>> listByCacheNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listByCacheNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<StorageTargetInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<StorageTargetInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<StorageTargetInner>> result = listByCacheNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<StorageTargetInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<StorageTargetInner>> listByCacheNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<StorageTargetInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<StorageTargetInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

}
