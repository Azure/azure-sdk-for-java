// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.storagecache.fluent.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.management.Resource;
import com.azure.core.management.SystemData;
import com.azure.resourcemanager.storagecache.models.ConflictResolutionMode;
import com.azure.resourcemanager.storagecache.models.ImportJobProvisioningStateType;
import com.azure.resourcemanager.storagecache.models.ImportStatusType;
import com.fasterxml.jackson.annotation.JsonProperty;
import java.time.OffsetDateTime;
import java.util.List;
import java.util.Map;

/**
 * An import job instance. Follows Azure Resource Manager standards:
 * https://github.com/Azure/azure-resource-manager-rpc/blob/master/v1.0/resource-api-reference.md.
 */
@Fluent
public final class ImportJobInner extends Resource {
    /*
     * Properties of the import job.
     */
    @JsonProperty(value = "properties")
    private ImportJobProperties innerProperties;

    /*
     * Azure Resource Manager metadata containing createdBy and modifiedBy information.
     */
    @JsonProperty(value = "systemData", access = JsonProperty.Access.WRITE_ONLY)
    private SystemData systemData;

    /**
     * Creates an instance of ImportJobInner class.
     */
    public ImportJobInner() {
    }

    /**
     * Get the innerProperties property: Properties of the import job.
     * 
     * @return the innerProperties value.
     */
    private ImportJobProperties innerProperties() {
        return this.innerProperties;
    }

    /**
     * Get the systemData property: Azure Resource Manager metadata containing createdBy and modifiedBy information.
     * 
     * @return the systemData value.
     */
    public SystemData systemData() {
        return this.systemData;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public ImportJobInner withLocation(String location) {
        super.withLocation(location);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public ImportJobInner withTags(Map<String, String> tags) {
        super.withTags(tags);
        return this;
    }

    /**
     * Get the provisioningState property: ARM provisioning state.
     * 
     * @return the provisioningState value.
     */
    public ImportJobProvisioningStateType provisioningState() {
        return this.innerProperties() == null ? null : this.innerProperties().provisioningState();
    }

    /**
     * Get the importPrefixes property: An array of blob paths/prefixes that get imported into the cluster namespace. It
     * has '/' as the default value.
     * 
     * @return the importPrefixes value.
     */
    public List<String> importPrefixes() {
        return this.innerProperties() == null ? null : this.innerProperties().importPrefixes();
    }

    /**
     * Set the importPrefixes property: An array of blob paths/prefixes that get imported into the cluster namespace. It
     * has '/' as the default value.
     * 
     * @param importPrefixes the importPrefixes value to set.
     * @return the ImportJobInner object itself.
     */
    public ImportJobInner withImportPrefixes(List<String> importPrefixes) {
        if (this.innerProperties() == null) {
            this.innerProperties = new ImportJobProperties();
        }
        this.innerProperties().withImportPrefixes(importPrefixes);
        return this;
    }

    /**
     * Get the conflictResolutionMode property: How the import job will handle conflicts. For example, if the import job
     * is trying to bring in a directory, but a file is at that path, how it handles it. Fail indicates that the import
     * job should stop immediately and not do anything with the conflict. Skip indicates that it should pass over the
     * conflict. OverwriteIfDirty causes the import job to delete and re-import the file or directory if it is a
     * conflicting type, is dirty, or was not previously imported. OverwriteAlways extends OverwriteIfDirty to include
     * releasing files that had been restored but were not dirty. Please reference
     * https://learn.microsoft.com/en-us/azure/azure-managed-lustre/ for a thorough explanation of these resolution
     * modes.
     * 
     * @return the conflictResolutionMode value.
     */
    public ConflictResolutionMode conflictResolutionMode() {
        return this.innerProperties() == null ? null : this.innerProperties().conflictResolutionMode();
    }

    /**
     * Set the conflictResolutionMode property: How the import job will handle conflicts. For example, if the import job
     * is trying to bring in a directory, but a file is at that path, how it handles it. Fail indicates that the import
     * job should stop immediately and not do anything with the conflict. Skip indicates that it should pass over the
     * conflict. OverwriteIfDirty causes the import job to delete and re-import the file or directory if it is a
     * conflicting type, is dirty, or was not previously imported. OverwriteAlways extends OverwriteIfDirty to include
     * releasing files that had been restored but were not dirty. Please reference
     * https://learn.microsoft.com/en-us/azure/azure-managed-lustre/ for a thorough explanation of these resolution
     * modes.
     * 
     * @param conflictResolutionMode the conflictResolutionMode value to set.
     * @return the ImportJobInner object itself.
     */
    public ImportJobInner withConflictResolutionMode(ConflictResolutionMode conflictResolutionMode) {
        if (this.innerProperties() == null) {
            this.innerProperties = new ImportJobProperties();
        }
        this.innerProperties().withConflictResolutionMode(conflictResolutionMode);
        return this;
    }

    /**
     * Get the maximumErrors property: Total non-conflict oriented errors the import job will tolerate before exiting
     * with failure. -1 means infinite. 0 means exit immediately and is the default.
     * 
     * @return the maximumErrors value.
     */
    public Integer maximumErrors() {
        return this.innerProperties() == null ? null : this.innerProperties().maximumErrors();
    }

    /**
     * Set the maximumErrors property: Total non-conflict oriented errors the import job will tolerate before exiting
     * with failure. -1 means infinite. 0 means exit immediately and is the default.
     * 
     * @param maximumErrors the maximumErrors value to set.
     * @return the ImportJobInner object itself.
     */
    public ImportJobInner withMaximumErrors(Integer maximumErrors) {
        if (this.innerProperties() == null) {
            this.innerProperties = new ImportJobProperties();
        }
        this.innerProperties().withMaximumErrors(maximumErrors);
        return this;
    }

    /**
     * Get the state property: The state of the import job. InProgress indicates the import is still running. Canceled
     * indicates it has been canceled by the user. Completed indicates import finished, successfully importing all
     * discovered blobs into the Lustre namespace. CompletedPartial indicates the import finished but some blobs either
     * were found to be conflicting and could not be imported or other errors were encountered. Failed means the import
     * was unable to complete due to a fatal error.
     * 
     * @return the state value.
     */
    public ImportStatusType state() {
        return this.innerProperties() == null ? null : this.innerProperties().state();
    }

    /**
     * Get the statusMessage property: The status message of the import job.
     * 
     * @return the statusMessage value.
     */
    public String statusMessage() {
        return this.innerProperties() == null ? null : this.innerProperties().statusMessage();
    }

    /**
     * Get the totalBlobsWalked property: The total blob objects walked.
     * 
     * @return the totalBlobsWalked value.
     */
    public Long totalBlobsWalked() {
        return this.innerProperties() == null ? null : this.innerProperties().totalBlobsWalked();
    }

    /**
     * Get the blobsWalkedPerSecond property: A recent and frequently updated rate of blobs walked per second.
     * 
     * @return the blobsWalkedPerSecond value.
     */
    public Long blobsWalkedPerSecond() {
        return this.innerProperties() == null ? null : this.innerProperties().blobsWalkedPerSecond();
    }

    /**
     * Get the totalBlobsImported property: The total blobs that have been imported since import began.
     * 
     * @return the totalBlobsImported value.
     */
    public Long totalBlobsImported() {
        return this.innerProperties() == null ? null : this.innerProperties().totalBlobsImported();
    }

    /**
     * Get the blobsImportedPerSecond property: A recent and frequently updated rate of total files, directories, and
     * symlinks imported per second.
     * 
     * @return the blobsImportedPerSecond value.
     */
    public Long blobsImportedPerSecond() {
        return this.innerProperties() == null ? null : this.innerProperties().blobsImportedPerSecond();
    }

    /**
     * Get the lastCompletionTime property: The time of the last completed archive operation.
     * 
     * @return the lastCompletionTime value.
     */
    public OffsetDateTime lastCompletionTime() {
        return this.innerProperties() == null ? null : this.innerProperties().lastCompletionTime();
    }

    /**
     * Get the lastStartedTime property: The time the latest archive operation started.
     * 
     * @return the lastStartedTime value.
     */
    public OffsetDateTime lastStartedTime() {
        return this.innerProperties() == null ? null : this.innerProperties().lastStartedTime();
    }

    /**
     * Get the totalErrors property: Number of errors in the import job.
     * 
     * @return the totalErrors value.
     */
    public Integer totalErrors() {
        return this.innerProperties() == null ? null : this.innerProperties().totalErrors();
    }

    /**
     * Get the totalConflicts property: Number of conflicts in the import job.
     * 
     * @return the totalConflicts value.
     */
    public Integer totalConflicts() {
        return this.innerProperties() == null ? null : this.innerProperties().totalConflicts();
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (innerProperties() != null) {
            innerProperties().validate();
        }
    }
}
