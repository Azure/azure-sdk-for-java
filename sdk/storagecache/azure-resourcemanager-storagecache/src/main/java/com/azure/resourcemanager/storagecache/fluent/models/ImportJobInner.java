// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.storagecache.fluent.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.management.Resource;
import com.azure.core.management.SystemData;
import com.azure.json.JsonReader;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.storagecache.models.ConflictResolutionMode;
import com.azure.resourcemanager.storagecache.models.ImportJobAdminStatus;
import com.azure.resourcemanager.storagecache.models.ImportJobProvisioningStateType;
import com.azure.resourcemanager.storagecache.models.ImportStatusType;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.List;
import java.util.Map;

/**
 * An import job instance. Follows Azure Resource Manager standards:
 * https://github.com/Azure/azure-resource-manager-rpc/blob/master/v1.0/resource-api-reference.md.
 */
@Fluent
public final class ImportJobInner extends Resource {
    /*
     * Properties of the import job.
     */
    private ImportJobProperties innerProperties;

    /*
     * Azure Resource Manager metadata containing createdBy and modifiedBy information.
     */
    private SystemData systemData;

    /*
     * The type of the resource.
     */
    private String type;

    /*
     * The name of the resource.
     */
    private String name;

    /*
     * Fully qualified resource Id for the resource.
     */
    private String id;

    /**
     * Creates an instance of ImportJobInner class.
     */
    public ImportJobInner() {
    }

    /**
     * Get the innerProperties property: Properties of the import job.
     * 
     * @return the innerProperties value.
     */
    private ImportJobProperties innerProperties() {
        return this.innerProperties;
    }

    /**
     * Get the systemData property: Azure Resource Manager metadata containing createdBy and modifiedBy information.
     * 
     * @return the systemData value.
     */
    public SystemData systemData() {
        return this.systemData;
    }

    /**
     * Get the type property: The type of the resource.
     * 
     * @return the type value.
     */
    @Override
    public String type() {
        return this.type;
    }

    /**
     * Get the name property: The name of the resource.
     * 
     * @return the name value.
     */
    @Override
    public String name() {
        return this.name;
    }

    /**
     * Get the id property: Fully qualified resource Id for the resource.
     * 
     * @return the id value.
     */
    @Override
    public String id() {
        return this.id;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public ImportJobInner withLocation(String location) {
        super.withLocation(location);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public ImportJobInner withTags(Map<String, String> tags) {
        super.withTags(tags);
        return this;
    }

    /**
     * Get the provisioningState property: ARM provisioning state.
     * 
     * @return the provisioningState value.
     */
    public ImportJobProvisioningStateType provisioningState() {
        return this.innerProperties() == null ? null : this.innerProperties().provisioningState();
    }

    /**
     * Get the adminStatus property: The administrative status of the import job. Possible values: 'Active', 'Cancel'.
     * Passing in a value of 'Cancel' will cancel the current active import job. By default it is set to 'Active'.
     * 
     * @return the adminStatus value.
     */
    public ImportJobAdminStatus adminStatus() {
        return this.innerProperties() == null ? null : this.innerProperties().adminStatus();
    }

    /**
     * Set the adminStatus property: The administrative status of the import job. Possible values: 'Active', 'Cancel'.
     * Passing in a value of 'Cancel' will cancel the current active import job. By default it is set to 'Active'.
     * 
     * @param adminStatus the adminStatus value to set.
     * @return the ImportJobInner object itself.
     */
    public ImportJobInner withAdminStatus(ImportJobAdminStatus adminStatus) {
        if (this.innerProperties() == null) {
            this.innerProperties = new ImportJobProperties();
        }
        this.innerProperties().withAdminStatus(adminStatus);
        return this;
    }

    /**
     * Get the importPrefixes property: An array of blob paths/prefixes that get imported into the cluster namespace. It
     * has '/' as the default value.
     * 
     * @return the importPrefixes value.
     */
    public List<String> importPrefixes() {
        return this.innerProperties() == null ? null : this.innerProperties().importPrefixes();
    }

    /**
     * Set the importPrefixes property: An array of blob paths/prefixes that get imported into the cluster namespace. It
     * has '/' as the default value.
     * 
     * @param importPrefixes the importPrefixes value to set.
     * @return the ImportJobInner object itself.
     */
    public ImportJobInner withImportPrefixes(List<String> importPrefixes) {
        if (this.innerProperties() == null) {
            this.innerProperties = new ImportJobProperties();
        }
        this.innerProperties().withImportPrefixes(importPrefixes);
        return this;
    }

    /**
     * Get the conflictResolutionMode property: How the import job will handle conflicts. For example, if the import job
     * is trying to bring in a directory, but a file is at that path, how it handles it. Fail indicates that the import
     * job should stop immediately and not do anything with the conflict. Skip indicates that it should pass over the
     * conflict. OverwriteIfDirty causes the import job to delete and re-import the file or directory if it is a
     * conflicting type, is dirty, or was not previously imported. OverwriteAlways extends OverwriteIfDirty to include
     * releasing files that had been restored but were not dirty. Please reference
     * https://learn.microsoft.com/en-us/azure/azure-managed-lustre/ for a thorough explanation of these resolution
     * modes.
     * 
     * @return the conflictResolutionMode value.
     */
    public ConflictResolutionMode conflictResolutionMode() {
        return this.innerProperties() == null ? null : this.innerProperties().conflictResolutionMode();
    }

    /**
     * Set the conflictResolutionMode property: How the import job will handle conflicts. For example, if the import job
     * is trying to bring in a directory, but a file is at that path, how it handles it. Fail indicates that the import
     * job should stop immediately and not do anything with the conflict. Skip indicates that it should pass over the
     * conflict. OverwriteIfDirty causes the import job to delete and re-import the file or directory if it is a
     * conflicting type, is dirty, or was not previously imported. OverwriteAlways extends OverwriteIfDirty to include
     * releasing files that had been restored but were not dirty. Please reference
     * https://learn.microsoft.com/en-us/azure/azure-managed-lustre/ for a thorough explanation of these resolution
     * modes.
     * 
     * @param conflictResolutionMode the conflictResolutionMode value to set.
     * @return the ImportJobInner object itself.
     */
    public ImportJobInner withConflictResolutionMode(ConflictResolutionMode conflictResolutionMode) {
        if (this.innerProperties() == null) {
            this.innerProperties = new ImportJobProperties();
        }
        this.innerProperties().withConflictResolutionMode(conflictResolutionMode);
        return this;
    }

    /**
     * Get the maximumErrors property: Total non-conflict oriented errors the import job will tolerate before exiting
     * with failure. -1 means infinite. 0 means exit immediately and is the default.
     * 
     * @return the maximumErrors value.
     */
    public Integer maximumErrors() {
        return this.innerProperties() == null ? null : this.innerProperties().maximumErrors();
    }

    /**
     * Set the maximumErrors property: Total non-conflict oriented errors the import job will tolerate before exiting
     * with failure. -1 means infinite. 0 means exit immediately and is the default.
     * 
     * @param maximumErrors the maximumErrors value to set.
     * @return the ImportJobInner object itself.
     */
    public ImportJobInner withMaximumErrors(Integer maximumErrors) {
        if (this.innerProperties() == null) {
            this.innerProperties = new ImportJobProperties();
        }
        this.innerProperties().withMaximumErrors(maximumErrors);
        return this;
    }

    /**
     * Get the state property: The operational state of the import job. InProgress indicates the import is still
     * running. Canceled indicates it has been canceled by the user. Completed indicates import finished, successfully
     * importing all discovered blobs into the Lustre namespace. CompletedPartial indicates the import finished but some
     * blobs either were found to be conflicting and could not be imported or other errors were encountered. Failed
     * means the import was unable to complete due to a fatal error.
     * 
     * @return the state value.
     */
    public ImportStatusType state() {
        return this.innerProperties() == null ? null : this.innerProperties().state();
    }

    /**
     * Get the statusMessage property: The status message of the import job.
     * 
     * @return the statusMessage value.
     */
    public String statusMessage() {
        return this.innerProperties() == null ? null : this.innerProperties().statusMessage();
    }

    /**
     * Get the totalBlobsWalked property: The total blob objects walked.
     * 
     * @return the totalBlobsWalked value.
     */
    public Long totalBlobsWalked() {
        return this.innerProperties() == null ? null : this.innerProperties().totalBlobsWalked();
    }

    /**
     * Get the blobsWalkedPerSecond property: A recent and frequently updated rate of blobs walked per second.
     * 
     * @return the blobsWalkedPerSecond value.
     */
    public Long blobsWalkedPerSecond() {
        return this.innerProperties() == null ? null : this.innerProperties().blobsWalkedPerSecond();
    }

    /**
     * Get the totalBlobsImported property: The total blobs that have been imported since import began.
     * 
     * @return the totalBlobsImported value.
     */
    public Long totalBlobsImported() {
        return this.innerProperties() == null ? null : this.innerProperties().totalBlobsImported();
    }

    /**
     * Get the importedFiles property: New or modified files that have been imported into the filesystem.
     * 
     * @return the importedFiles value.
     */
    public Long importedFiles() {
        return this.innerProperties() == null ? null : this.innerProperties().importedFiles();
    }

    /**
     * Get the importedDirectories property: New or modified directories that have been imported into the filesystem.
     * 
     * @return the importedDirectories value.
     */
    public Long importedDirectories() {
        return this.innerProperties() == null ? null : this.innerProperties().importedDirectories();
    }

    /**
     * Get the importedSymlinks property: Newly added symbolic links into the filesystem.
     * 
     * @return the importedSymlinks value.
     */
    public Long importedSymlinks() {
        return this.innerProperties() == null ? null : this.innerProperties().importedSymlinks();
    }

    /**
     * Get the preexistingFiles property: Files that already exist in the filesystem and have not been modified.
     * 
     * @return the preexistingFiles value.
     */
    public Long preexistingFiles() {
        return this.innerProperties() == null ? null : this.innerProperties().preexistingFiles();
    }

    /**
     * Get the preexistingDirectories property: Directories that already exist in the filesystem and have not been
     * modified.
     * 
     * @return the preexistingDirectories value.
     */
    public Long preexistingDirectories() {
        return this.innerProperties() == null ? null : this.innerProperties().preexistingDirectories();
    }

    /**
     * Get the preexistingSymlinks property: Symbolic links that already exist in the filesystem and have not been
     * modified.
     * 
     * @return the preexistingSymlinks value.
     */
    public Long preexistingSymlinks() {
        return this.innerProperties() == null ? null : this.innerProperties().preexistingSymlinks();
    }

    /**
     * Get the blobsImportedPerSecond property: A recent and frequently updated rate of total files, directories, and
     * symlinks imported per second.
     * 
     * @return the blobsImportedPerSecond value.
     */
    public Long blobsImportedPerSecond() {
        return this.innerProperties() == null ? null : this.innerProperties().blobsImportedPerSecond();
    }

    /**
     * Get the lastCompletionTime property: The time (in UTC) of the last completed import job.
     * 
     * @return the lastCompletionTime value.
     */
    public OffsetDateTime lastCompletionTime() {
        return this.innerProperties() == null ? null : this.innerProperties().lastCompletionTime();
    }

    /**
     * Get the lastStartedTime property: The time (in UTC) the latest import job started.
     * 
     * @return the lastStartedTime value.
     */
    public OffsetDateTime lastStartedTime() {
        return this.innerProperties() == null ? null : this.innerProperties().lastStartedTime();
    }

    /**
     * Get the totalErrors property: Number of errors in the import job.
     * 
     * @return the totalErrors value.
     */
    public Integer totalErrors() {
        return this.innerProperties() == null ? null : this.innerProperties().totalErrors();
    }

    /**
     * Get the totalConflicts property: Number of conflicts in the import job.
     * 
     * @return the totalConflicts value.
     */
    public Integer totalConflicts() {
        return this.innerProperties() == null ? null : this.innerProperties().totalConflicts();
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (innerProperties() != null) {
            innerProperties().validate();
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("location", location());
        jsonWriter.writeMapField("tags", tags(), (writer, element) -> writer.writeString(element));
        jsonWriter.writeJsonField("properties", this.innerProperties);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of ImportJobInner from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of ImportJobInner if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the ImportJobInner.
     */
    public static ImportJobInner fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            ImportJobInner deserializedImportJobInner = new ImportJobInner();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("id".equals(fieldName)) {
                    deserializedImportJobInner.id = reader.getString();
                } else if ("name".equals(fieldName)) {
                    deserializedImportJobInner.name = reader.getString();
                } else if ("type".equals(fieldName)) {
                    deserializedImportJobInner.type = reader.getString();
                } else if ("location".equals(fieldName)) {
                    deserializedImportJobInner.withLocation(reader.getString());
                } else if ("tags".equals(fieldName)) {
                    Map<String, String> tags = reader.readMap(reader1 -> reader1.getString());
                    deserializedImportJobInner.withTags(tags);
                } else if ("properties".equals(fieldName)) {
                    deserializedImportJobInner.innerProperties = ImportJobProperties.fromJson(reader);
                } else if ("systemData".equals(fieldName)) {
                    deserializedImportJobInner.systemData = SystemData.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedImportJobInner;
        });
    }
}
