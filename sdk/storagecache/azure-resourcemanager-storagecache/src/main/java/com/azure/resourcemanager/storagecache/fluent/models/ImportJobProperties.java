// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.storagecache.fluent.models;

import com.azure.core.annotation.Fluent;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.storagecache.models.ConflictResolutionMode;
import com.azure.resourcemanager.storagecache.models.ImportJobAdminStatus;
import com.azure.resourcemanager.storagecache.models.ImportJobProvisioningStateType;
import com.azure.resourcemanager.storagecache.models.ImportStatusType;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.List;

/**
 * Properties of the import job.
 */
@Fluent
public final class ImportJobProperties implements JsonSerializable<ImportJobProperties> {
    /*
     * ARM provisioning state.
     */
    private ImportJobProvisioningStateType provisioningState;

    /*
     * The administrative status of the import job. Possible values: 'Active', 'Cancel'. Passing in a value of 'Cancel'
     * will cancel the current active import job. By default it is set to 'Active'.
     */
    private ImportJobAdminStatus adminStatus;

    /*
     * An array of blob paths/prefixes that get imported into the cluster namespace. It has '/' as the default value.
     */
    private List<String> importPrefixes;

    /*
     * How the import job will handle conflicts. For example, if the import job is trying to bring in a directory, but a
     * file is at that path, how it handles it. Fail indicates that the import job should stop immediately and not do
     * anything with the conflict. Skip indicates that it should pass over the conflict. OverwriteIfDirty causes the
     * import job to delete and re-import the file or directory if it is a conflicting type, is dirty, or was not
     * previously imported. OverwriteAlways extends OverwriteIfDirty to include releasing files that had been restored
     * but were not dirty. Please reference https://learn.microsoft.com/en-us/azure/azure-managed-lustre/ for a thorough
     * explanation of these resolution modes.
     */
    private ConflictResolutionMode conflictResolutionMode;

    /*
     * Total non-conflict oriented errors the import job will tolerate before exiting with failure. -1 means infinite. 0
     * means exit immediately and is the default.
     */
    private Integer maximumErrors;

    /*
     * The status of the import
     */
    private ImportJobPropertiesStatus innerStatus;

    /**
     * Creates an instance of ImportJobProperties class.
     */
    public ImportJobProperties() {
    }

    /**
     * Get the provisioningState property: ARM provisioning state.
     * 
     * @return the provisioningState value.
     */
    public ImportJobProvisioningStateType provisioningState() {
        return this.provisioningState;
    }

    /**
     * Get the adminStatus property: The administrative status of the import job. Possible values: 'Active', 'Cancel'.
     * Passing in a value of 'Cancel' will cancel the current active import job. By default it is set to 'Active'.
     * 
     * @return the adminStatus value.
     */
    public ImportJobAdminStatus adminStatus() {
        return this.adminStatus;
    }

    /**
     * Set the adminStatus property: The administrative status of the import job. Possible values: 'Active', 'Cancel'.
     * Passing in a value of 'Cancel' will cancel the current active import job. By default it is set to 'Active'.
     * 
     * @param adminStatus the adminStatus value to set.
     * @return the ImportJobProperties object itself.
     */
    public ImportJobProperties withAdminStatus(ImportJobAdminStatus adminStatus) {
        this.adminStatus = adminStatus;
        return this;
    }

    /**
     * Get the importPrefixes property: An array of blob paths/prefixes that get imported into the cluster namespace. It
     * has '/' as the default value.
     * 
     * @return the importPrefixes value.
     */
    public List<String> importPrefixes() {
        return this.importPrefixes;
    }

    /**
     * Set the importPrefixes property: An array of blob paths/prefixes that get imported into the cluster namespace. It
     * has '/' as the default value.
     * 
     * @param importPrefixes the importPrefixes value to set.
     * @return the ImportJobProperties object itself.
     */
    public ImportJobProperties withImportPrefixes(List<String> importPrefixes) {
        this.importPrefixes = importPrefixes;
        return this;
    }

    /**
     * Get the conflictResolutionMode property: How the import job will handle conflicts. For example, if the import job
     * is trying to bring in a directory, but a file is at that path, how it handles it. Fail indicates that the import
     * job should stop immediately and not do anything with the conflict. Skip indicates that it should pass over the
     * conflict. OverwriteIfDirty causes the import job to delete and re-import the file or directory if it is a
     * conflicting type, is dirty, or was not previously imported. OverwriteAlways extends OverwriteIfDirty to include
     * releasing files that had been restored but were not dirty. Please reference
     * https://learn.microsoft.com/en-us/azure/azure-managed-lustre/ for a thorough explanation of these resolution
     * modes.
     * 
     * @return the conflictResolutionMode value.
     */
    public ConflictResolutionMode conflictResolutionMode() {
        return this.conflictResolutionMode;
    }

    /**
     * Set the conflictResolutionMode property: How the import job will handle conflicts. For example, if the import job
     * is trying to bring in a directory, but a file is at that path, how it handles it. Fail indicates that the import
     * job should stop immediately and not do anything with the conflict. Skip indicates that it should pass over the
     * conflict. OverwriteIfDirty causes the import job to delete and re-import the file or directory if it is a
     * conflicting type, is dirty, or was not previously imported. OverwriteAlways extends OverwriteIfDirty to include
     * releasing files that had been restored but were not dirty. Please reference
     * https://learn.microsoft.com/en-us/azure/azure-managed-lustre/ for a thorough explanation of these resolution
     * modes.
     * 
     * @param conflictResolutionMode the conflictResolutionMode value to set.
     * @return the ImportJobProperties object itself.
     */
    public ImportJobProperties withConflictResolutionMode(ConflictResolutionMode conflictResolutionMode) {
        this.conflictResolutionMode = conflictResolutionMode;
        return this;
    }

    /**
     * Get the maximumErrors property: Total non-conflict oriented errors the import job will tolerate before exiting
     * with failure. -1 means infinite. 0 means exit immediately and is the default.
     * 
     * @return the maximumErrors value.
     */
    public Integer maximumErrors() {
        return this.maximumErrors;
    }

    /**
     * Set the maximumErrors property: Total non-conflict oriented errors the import job will tolerate before exiting
     * with failure. -1 means infinite. 0 means exit immediately and is the default.
     * 
     * @param maximumErrors the maximumErrors value to set.
     * @return the ImportJobProperties object itself.
     */
    public ImportJobProperties withMaximumErrors(Integer maximumErrors) {
        this.maximumErrors = maximumErrors;
        return this;
    }

    /**
     * Get the innerStatus property: The status of the import.
     * 
     * @return the innerStatus value.
     */
    private ImportJobPropertiesStatus innerStatus() {
        return this.innerStatus;
    }

    /**
     * Get the state property: The operational state of the import job. InProgress indicates the import is still
     * running. Canceled indicates it has been canceled by the user. Completed indicates import finished, successfully
     * importing all discovered blobs into the Lustre namespace. CompletedPartial indicates the import finished but some
     * blobs either were found to be conflicting and could not be imported or other errors were encountered. Failed
     * means the import was unable to complete due to a fatal error.
     * 
     * @return the state value.
     */
    public ImportStatusType state() {
        return this.innerStatus() == null ? null : this.innerStatus().state();
    }

    /**
     * Get the statusMessage property: The status message of the import job.
     * 
     * @return the statusMessage value.
     */
    public String statusMessage() {
        return this.innerStatus() == null ? null : this.innerStatus().statusMessage();
    }

    /**
     * Get the totalBlobsWalked property: The total blob objects walked.
     * 
     * @return the totalBlobsWalked value.
     */
    public Long totalBlobsWalked() {
        return this.innerStatus() == null ? null : this.innerStatus().totalBlobsWalked();
    }

    /**
     * Get the blobsWalkedPerSecond property: A recent and frequently updated rate of blobs walked per second.
     * 
     * @return the blobsWalkedPerSecond value.
     */
    public Long blobsWalkedPerSecond() {
        return this.innerStatus() == null ? null : this.innerStatus().blobsWalkedPerSecond();
    }

    /**
     * Get the totalBlobsImported property: The total blobs that have been imported since import began.
     * 
     * @return the totalBlobsImported value.
     */
    public Long totalBlobsImported() {
        return this.innerStatus() == null ? null : this.innerStatus().totalBlobsImported();
    }

    /**
     * Get the importedFiles property: New or modified files that have been imported into the filesystem.
     * 
     * @return the importedFiles value.
     */
    public Long importedFiles() {
        return this.innerStatus() == null ? null : this.innerStatus().importedFiles();
    }

    /**
     * Get the importedDirectories property: New or modified directories that have been imported into the filesystem.
     * 
     * @return the importedDirectories value.
     */
    public Long importedDirectories() {
        return this.innerStatus() == null ? null : this.innerStatus().importedDirectories();
    }

    /**
     * Get the importedSymlinks property: Newly added symbolic links into the filesystem.
     * 
     * @return the importedSymlinks value.
     */
    public Long importedSymlinks() {
        return this.innerStatus() == null ? null : this.innerStatus().importedSymlinks();
    }

    /**
     * Get the preexistingFiles property: Files that already exist in the filesystem and have not been modified.
     * 
     * @return the preexistingFiles value.
     */
    public Long preexistingFiles() {
        return this.innerStatus() == null ? null : this.innerStatus().preexistingFiles();
    }

    /**
     * Get the preexistingDirectories property: Directories that already exist in the filesystem and have not been
     * modified.
     * 
     * @return the preexistingDirectories value.
     */
    public Long preexistingDirectories() {
        return this.innerStatus() == null ? null : this.innerStatus().preexistingDirectories();
    }

    /**
     * Get the preexistingSymlinks property: Symbolic links that already exist in the filesystem and have not been
     * modified.
     * 
     * @return the preexistingSymlinks value.
     */
    public Long preexistingSymlinks() {
        return this.innerStatus() == null ? null : this.innerStatus().preexistingSymlinks();
    }

    /**
     * Get the blobsImportedPerSecond property: A recent and frequently updated rate of total files, directories, and
     * symlinks imported per second.
     * 
     * @return the blobsImportedPerSecond value.
     */
    public Long blobsImportedPerSecond() {
        return this.innerStatus() == null ? null : this.innerStatus().blobsImportedPerSecond();
    }

    /**
     * Get the lastCompletionTime property: The time (in UTC) of the last completed import job.
     * 
     * @return the lastCompletionTime value.
     */
    public OffsetDateTime lastCompletionTime() {
        return this.innerStatus() == null ? null : this.innerStatus().lastCompletionTime();
    }

    /**
     * Get the lastStartedTime property: The time (in UTC) the latest import job started.
     * 
     * @return the lastStartedTime value.
     */
    public OffsetDateTime lastStartedTime() {
        return this.innerStatus() == null ? null : this.innerStatus().lastStartedTime();
    }

    /**
     * Get the totalErrors property: Number of errors in the import job.
     * 
     * @return the totalErrors value.
     */
    public Integer totalErrors() {
        return this.innerStatus() == null ? null : this.innerStatus().totalErrors();
    }

    /**
     * Get the totalConflicts property: Number of conflicts in the import job.
     * 
     * @return the totalConflicts value.
     */
    public Integer totalConflicts() {
        return this.innerStatus() == null ? null : this.innerStatus().totalConflicts();
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (innerStatus() != null) {
            innerStatus().validate();
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("adminStatus", this.adminStatus == null ? null : this.adminStatus.toString());
        jsonWriter.writeArrayField("importPrefixes", this.importPrefixes,
            (writer, element) -> writer.writeString(element));
        jsonWriter.writeStringField("conflictResolutionMode",
            this.conflictResolutionMode == null ? null : this.conflictResolutionMode.toString());
        jsonWriter.writeNumberField("maximumErrors", this.maximumErrors);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of ImportJobProperties from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of ImportJobProperties if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IOException If an error occurs while reading the ImportJobProperties.
     */
    public static ImportJobProperties fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            ImportJobProperties deserializedImportJobProperties = new ImportJobProperties();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("provisioningState".equals(fieldName)) {
                    deserializedImportJobProperties.provisioningState
                        = ImportJobProvisioningStateType.fromString(reader.getString());
                } else if ("adminStatus".equals(fieldName)) {
                    deserializedImportJobProperties.adminStatus = ImportJobAdminStatus.fromString(reader.getString());
                } else if ("importPrefixes".equals(fieldName)) {
                    List<String> importPrefixes = reader.readArray(reader1 -> reader1.getString());
                    deserializedImportJobProperties.importPrefixes = importPrefixes;
                } else if ("conflictResolutionMode".equals(fieldName)) {
                    deserializedImportJobProperties.conflictResolutionMode
                        = ConflictResolutionMode.fromString(reader.getString());
                } else if ("maximumErrors".equals(fieldName)) {
                    deserializedImportJobProperties.maximumErrors = reader.getNullable(JsonReader::getInt);
                } else if ("status".equals(fieldName)) {
                    deserializedImportJobProperties.innerStatus = ImportJobPropertiesStatus.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedImportJobProperties;
        });
    }
}
