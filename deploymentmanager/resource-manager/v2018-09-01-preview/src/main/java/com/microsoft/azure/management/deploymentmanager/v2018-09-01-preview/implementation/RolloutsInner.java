/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.management.deploymentmanager.v2018-09-01-preview.implementation;

import com.microsoft.azure.arm.collection.InnerSupportsGet;
import com.microsoft.azure.arm.collection.InnerSupportsDelete;
import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.CloudException;
import com.microsoft.azure.management.deploymentmanager.v2018-09-01-preview.RolloutsCreateOrUpdateHeaders;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.ServiceResponseWithHeaders;
import com.microsoft.rest.Validator;
import java.io.IOException;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in Rollouts.
 */
public class RolloutsInner implements InnerSupportsGet<RolloutInner>, InnerSupportsDelete<Void> {
    /** The Retrofit service to perform REST calls. */
    private RolloutsService service;
    /** The service client containing this operation class. */
    private AzureDeploymentManagerImpl client;

    /**
     * Initializes an instance of RolloutsInner.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public RolloutsInner(Retrofit retrofit, AzureDeploymentManagerImpl client) {
        this.service = retrofit.create(RolloutsService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for Rollouts to be
     * used by Retrofit to perform actually REST calls.
     */
    interface RolloutsService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.deploymentmanager.v2018-09-01-preview.Rollouts createOrUpdate" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeploymentManager/rollouts/{rolloutName}")
        Observable<Response<ResponseBody>> createOrUpdate(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("rolloutName") String rolloutName, @Query("api-version") String apiVersion, @Body RolloutRequestInner rolloutRequest, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.deploymentmanager.v2018-09-01-preview.Rollouts beginCreateOrUpdate" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeploymentManager/rollouts/{rolloutName}")
        Observable<Response<ResponseBody>> beginCreateOrUpdate(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("rolloutName") String rolloutName, @Query("api-version") String apiVersion, @Body RolloutRequestInner rolloutRequest, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.deploymentmanager.v2018-09-01-preview.Rollouts getByResourceGroup" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeploymentManager/rollouts/{rolloutName}")
        Observable<Response<ResponseBody>> getByResourceGroup(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("rolloutName") String rolloutName, @Query("api-version") String apiVersion, @Query("retryAttempt") Integer retryAttempt, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.deploymentmanager.v2018-09-01-preview.Rollouts delete" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeploymentManager/rollouts/{rolloutName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> delete(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("rolloutName") String rolloutName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.deploymentmanager.v2018-09-01-preview.Rollouts cancel" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeploymentManager/rollouts/{rolloutName}/cancel")
        Observable<Response<ResponseBody>> cancel(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("rolloutName") String rolloutName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.deploymentmanager.v2018-09-01-preview.Rollouts restart" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeploymentManager/rollouts/{rolloutName}/restart")
        Observable<Response<ResponseBody>> restart(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("rolloutName") String rolloutName, @Query("skipSucceeded") Boolean skipSucceeded, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

    }

    /**
     * Creates or updates a rollout.
     * This is an asynchronous operation and can be polled to completion using the location header returned by this operation.
     *
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param rolloutName The rollout name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RolloutRequestInner object if successful.
     */
    public RolloutRequestInner createOrUpdate(String resourceGroupName, String rolloutName) {
        return createOrUpdateWithServiceResponseAsync(resourceGroupName, rolloutName).toBlocking().last().body();
    }

    /**
     * Creates or updates a rollout.
     * This is an asynchronous operation and can be polled to completion using the location header returned by this operation.
     *
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param rolloutName The rollout name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RolloutRequestInner> createOrUpdateAsync(String resourceGroupName, String rolloutName, final ServiceCallback<RolloutRequestInner> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createOrUpdateWithServiceResponseAsync(resourceGroupName, rolloutName), serviceCallback);
    }

    /**
     * Creates or updates a rollout.
     * This is an asynchronous operation and can be polled to completion using the location header returned by this operation.
     *
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param rolloutName The rollout name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<RolloutRequestInner> createOrUpdateAsync(String resourceGroupName, String rolloutName) {
        return createOrUpdateWithServiceResponseAsync(resourceGroupName, rolloutName).map(new Func1<ServiceResponseWithHeaders<RolloutRequestInner, RolloutsCreateOrUpdateHeaders>, RolloutRequestInner>() {
            @Override
            public RolloutRequestInner call(ServiceResponseWithHeaders<RolloutRequestInner, RolloutsCreateOrUpdateHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates or updates a rollout.
     * This is an asynchronous operation and can be polled to completion using the location header returned by this operation.
     *
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param rolloutName The rollout name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponseWithHeaders<RolloutRequestInner, RolloutsCreateOrUpdateHeaders>> createOrUpdateWithServiceResponseAsync(String resourceGroupName, String rolloutName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (rolloutName == null) {
            throw new IllegalArgumentException("Parameter rolloutName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final RolloutRequestInner rolloutRequest = null;
        Observable<Response<ResponseBody>> observable = service.createOrUpdate(this.client.subscriptionId(), resourceGroupName, rolloutName, this.client.apiVersion(), rolloutRequest, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultWithHeadersAsync(observable, new TypeToken<RolloutRequestInner>() { }.getType(), RolloutsCreateOrUpdateHeaders.class);
    }
    /**
     * Creates or updates a rollout.
     * This is an asynchronous operation and can be polled to completion using the location header returned by this operation.
     *
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param rolloutName The rollout name.
     * @param rolloutRequest Source rollout request object that defines the rollout.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RolloutRequestInner object if successful.
     */
    public RolloutRequestInner createOrUpdate(String resourceGroupName, String rolloutName, RolloutRequestInner rolloutRequest) {
        return createOrUpdateWithServiceResponseAsync(resourceGroupName, rolloutName, rolloutRequest).toBlocking().last().body();
    }

    /**
     * Creates or updates a rollout.
     * This is an asynchronous operation and can be polled to completion using the location header returned by this operation.
     *
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param rolloutName The rollout name.
     * @param rolloutRequest Source rollout request object that defines the rollout.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RolloutRequestInner> createOrUpdateAsync(String resourceGroupName, String rolloutName, RolloutRequestInner rolloutRequest, final ServiceCallback<RolloutRequestInner> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createOrUpdateWithServiceResponseAsync(resourceGroupName, rolloutName, rolloutRequest), serviceCallback);
    }

    /**
     * Creates or updates a rollout.
     * This is an asynchronous operation and can be polled to completion using the location header returned by this operation.
     *
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param rolloutName The rollout name.
     * @param rolloutRequest Source rollout request object that defines the rollout.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<RolloutRequestInner> createOrUpdateAsync(String resourceGroupName, String rolloutName, RolloutRequestInner rolloutRequest) {
        return createOrUpdateWithServiceResponseAsync(resourceGroupName, rolloutName, rolloutRequest).map(new Func1<ServiceResponseWithHeaders<RolloutRequestInner, RolloutsCreateOrUpdateHeaders>, RolloutRequestInner>() {
            @Override
            public RolloutRequestInner call(ServiceResponseWithHeaders<RolloutRequestInner, RolloutsCreateOrUpdateHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates or updates a rollout.
     * This is an asynchronous operation and can be polled to completion using the location header returned by this operation.
     *
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param rolloutName The rollout name.
     * @param rolloutRequest Source rollout request object that defines the rollout.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponseWithHeaders<RolloutRequestInner, RolloutsCreateOrUpdateHeaders>> createOrUpdateWithServiceResponseAsync(String resourceGroupName, String rolloutName, RolloutRequestInner rolloutRequest) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (rolloutName == null) {
            throw new IllegalArgumentException("Parameter rolloutName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(rolloutRequest);
        Observable<Response<ResponseBody>> observable = service.createOrUpdate(this.client.subscriptionId(), resourceGroupName, rolloutName, this.client.apiVersion(), rolloutRequest, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultWithHeadersAsync(observable, new TypeToken<RolloutRequestInner>() { }.getType(), RolloutsCreateOrUpdateHeaders.class);
    }

    /**
     * Creates or updates a rollout.
     * This is an asynchronous operation and can be polled to completion using the location header returned by this operation.
     *
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param rolloutName The rollout name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RolloutRequestInner object if successful.
     */
    public RolloutRequestInner beginCreateOrUpdate(String resourceGroupName, String rolloutName) {
        return beginCreateOrUpdateWithServiceResponseAsync(resourceGroupName, rolloutName).toBlocking().single().body();
    }

    /**
     * Creates or updates a rollout.
     * This is an asynchronous operation and can be polled to completion using the location header returned by this operation.
     *
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param rolloutName The rollout name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RolloutRequestInner> beginCreateOrUpdateAsync(String resourceGroupName, String rolloutName, final ServiceCallback<RolloutRequestInner> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(beginCreateOrUpdateWithServiceResponseAsync(resourceGroupName, rolloutName), serviceCallback);
    }

    /**
     * Creates or updates a rollout.
     * This is an asynchronous operation and can be polled to completion using the location header returned by this operation.
     *
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param rolloutName The rollout name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RolloutRequestInner object
     */
    public Observable<RolloutRequestInner> beginCreateOrUpdateAsync(String resourceGroupName, String rolloutName) {
        return beginCreateOrUpdateWithServiceResponseAsync(resourceGroupName, rolloutName).map(new Func1<ServiceResponseWithHeaders<RolloutRequestInner, RolloutsCreateOrUpdateHeaders>, RolloutRequestInner>() {
            @Override
            public RolloutRequestInner call(ServiceResponseWithHeaders<RolloutRequestInner, RolloutsCreateOrUpdateHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates or updates a rollout.
     * This is an asynchronous operation and can be polled to completion using the location header returned by this operation.
     *
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param rolloutName The rollout name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RolloutRequestInner object
     */
    public Observable<ServiceResponseWithHeaders<RolloutRequestInner, RolloutsCreateOrUpdateHeaders>> beginCreateOrUpdateWithServiceResponseAsync(String resourceGroupName, String rolloutName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (rolloutName == null) {
            throw new IllegalArgumentException("Parameter rolloutName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final RolloutRequestInner rolloutRequest = null;
        return service.beginCreateOrUpdate(this.client.subscriptionId(), resourceGroupName, rolloutName, this.client.apiVersion(), rolloutRequest, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<RolloutRequestInner, RolloutsCreateOrUpdateHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<RolloutRequestInner, RolloutsCreateOrUpdateHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<RolloutRequestInner, RolloutsCreateOrUpdateHeaders> clientResponse = beginCreateOrUpdateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Creates or updates a rollout.
     * This is an asynchronous operation and can be polled to completion using the location header returned by this operation.
     *
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param rolloutName The rollout name.
     * @param rolloutRequest Source rollout request object that defines the rollout.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RolloutRequestInner object if successful.
     */
    public RolloutRequestInner beginCreateOrUpdate(String resourceGroupName, String rolloutName, RolloutRequestInner rolloutRequest) {
        return beginCreateOrUpdateWithServiceResponseAsync(resourceGroupName, rolloutName, rolloutRequest).toBlocking().single().body();
    }

    /**
     * Creates or updates a rollout.
     * This is an asynchronous operation and can be polled to completion using the location header returned by this operation.
     *
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param rolloutName The rollout name.
     * @param rolloutRequest Source rollout request object that defines the rollout.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RolloutRequestInner> beginCreateOrUpdateAsync(String resourceGroupName, String rolloutName, RolloutRequestInner rolloutRequest, final ServiceCallback<RolloutRequestInner> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(beginCreateOrUpdateWithServiceResponseAsync(resourceGroupName, rolloutName, rolloutRequest), serviceCallback);
    }

    /**
     * Creates or updates a rollout.
     * This is an asynchronous operation and can be polled to completion using the location header returned by this operation.
     *
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param rolloutName The rollout name.
     * @param rolloutRequest Source rollout request object that defines the rollout.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RolloutRequestInner object
     */
    public Observable<RolloutRequestInner> beginCreateOrUpdateAsync(String resourceGroupName, String rolloutName, RolloutRequestInner rolloutRequest) {
        return beginCreateOrUpdateWithServiceResponseAsync(resourceGroupName, rolloutName, rolloutRequest).map(new Func1<ServiceResponseWithHeaders<RolloutRequestInner, RolloutsCreateOrUpdateHeaders>, RolloutRequestInner>() {
            @Override
            public RolloutRequestInner call(ServiceResponseWithHeaders<RolloutRequestInner, RolloutsCreateOrUpdateHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates or updates a rollout.
     * This is an asynchronous operation and can be polled to completion using the location header returned by this operation.
     *
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param rolloutName The rollout name.
     * @param rolloutRequest Source rollout request object that defines the rollout.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RolloutRequestInner object
     */
    public Observable<ServiceResponseWithHeaders<RolloutRequestInner, RolloutsCreateOrUpdateHeaders>> beginCreateOrUpdateWithServiceResponseAsync(String resourceGroupName, String rolloutName, RolloutRequestInner rolloutRequest) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (rolloutName == null) {
            throw new IllegalArgumentException("Parameter rolloutName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(rolloutRequest);
        return service.beginCreateOrUpdate(this.client.subscriptionId(), resourceGroupName, rolloutName, this.client.apiVersion(), rolloutRequest, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<RolloutRequestInner, RolloutsCreateOrUpdateHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<RolloutRequestInner, RolloutsCreateOrUpdateHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<RolloutRequestInner, RolloutsCreateOrUpdateHeaders> clientResponse = beginCreateOrUpdateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<RolloutRequestInner, RolloutsCreateOrUpdateHeaders> beginCreateOrUpdateDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<RolloutRequestInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(201, new TypeToken<RolloutRequestInner>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, RolloutsCreateOrUpdateHeaders.class);
    }

    /**
     * Gets detailed information of a rollout.
     *
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param rolloutName The rollout name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RolloutInner object if successful.
     */
    public RolloutInner getByResourceGroup(String resourceGroupName, String rolloutName) {
        return getByResourceGroupWithServiceResponseAsync(resourceGroupName, rolloutName).toBlocking().single().body();
    }

    /**
     * Gets detailed information of a rollout.
     *
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param rolloutName The rollout name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RolloutInner> getByResourceGroupAsync(String resourceGroupName, String rolloutName, final ServiceCallback<RolloutInner> serviceCallback) {
        return ServiceFuture.fromResponse(getByResourceGroupWithServiceResponseAsync(resourceGroupName, rolloutName), serviceCallback);
    }

    /**
     * Gets detailed information of a rollout.
     *
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param rolloutName The rollout name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RolloutInner object
     */
    public Observable<RolloutInner> getByResourceGroupAsync(String resourceGroupName, String rolloutName) {
        return getByResourceGroupWithServiceResponseAsync(resourceGroupName, rolloutName).map(new Func1<ServiceResponse<RolloutInner>, RolloutInner>() {
            @Override
            public RolloutInner call(ServiceResponse<RolloutInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets detailed information of a rollout.
     *
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param rolloutName The rollout name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RolloutInner object
     */
    public Observable<ServiceResponse<RolloutInner>> getByResourceGroupWithServiceResponseAsync(String resourceGroupName, String rolloutName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (rolloutName == null) {
            throw new IllegalArgumentException("Parameter rolloutName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final Integer retryAttempt = null;
        return service.getByResourceGroup(this.client.subscriptionId(), resourceGroupName, rolloutName, this.client.apiVersion(), retryAttempt, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RolloutInner>>>() {
                @Override
                public Observable<ServiceResponse<RolloutInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RolloutInner> clientResponse = getByResourceGroupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets detailed information of a rollout.
     *
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param rolloutName The rollout name.
     * @param retryAttempt Rollout retry attempt ordinal to get the result of. If not specified, result of the latest attempt will be returned.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RolloutInner object if successful.
     */
    public RolloutInner getByResourceGroup(String resourceGroupName, String rolloutName, Integer retryAttempt) {
        return getByResourceGroupWithServiceResponseAsync(resourceGroupName, rolloutName, retryAttempt).toBlocking().single().body();
    }

    /**
     * Gets detailed information of a rollout.
     *
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param rolloutName The rollout name.
     * @param retryAttempt Rollout retry attempt ordinal to get the result of. If not specified, result of the latest attempt will be returned.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RolloutInner> getByResourceGroupAsync(String resourceGroupName, String rolloutName, Integer retryAttempt, final ServiceCallback<RolloutInner> serviceCallback) {
        return ServiceFuture.fromResponse(getByResourceGroupWithServiceResponseAsync(resourceGroupName, rolloutName, retryAttempt), serviceCallback);
    }

    /**
     * Gets detailed information of a rollout.
     *
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param rolloutName The rollout name.
     * @param retryAttempt Rollout retry attempt ordinal to get the result of. If not specified, result of the latest attempt will be returned.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RolloutInner object
     */
    public Observable<RolloutInner> getByResourceGroupAsync(String resourceGroupName, String rolloutName, Integer retryAttempt) {
        return getByResourceGroupWithServiceResponseAsync(resourceGroupName, rolloutName, retryAttempt).map(new Func1<ServiceResponse<RolloutInner>, RolloutInner>() {
            @Override
            public RolloutInner call(ServiceResponse<RolloutInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets detailed information of a rollout.
     *
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param rolloutName The rollout name.
     * @param retryAttempt Rollout retry attempt ordinal to get the result of. If not specified, result of the latest attempt will be returned.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RolloutInner object
     */
    public Observable<ServiceResponse<RolloutInner>> getByResourceGroupWithServiceResponseAsync(String resourceGroupName, String rolloutName, Integer retryAttempt) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (rolloutName == null) {
            throw new IllegalArgumentException("Parameter rolloutName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getByResourceGroup(this.client.subscriptionId(), resourceGroupName, rolloutName, this.client.apiVersion(), retryAttempt, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RolloutInner>>>() {
                @Override
                public Observable<ServiceResponse<RolloutInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RolloutInner> clientResponse = getByResourceGroupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RolloutInner> getByResourceGroupDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<RolloutInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<RolloutInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a rollout resource.
     * Only rollouts in terminal state can be deleted.
     *
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param rolloutName The rollout name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void delete(String resourceGroupName, String rolloutName) {
        deleteWithServiceResponseAsync(resourceGroupName, rolloutName).toBlocking().single().body();
    }

    /**
     * Deletes a rollout resource.
     * Only rollouts in terminal state can be deleted.
     *
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param rolloutName The rollout name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteAsync(String resourceGroupName, String rolloutName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteWithServiceResponseAsync(resourceGroupName, rolloutName), serviceCallback);
    }

    /**
     * Deletes a rollout resource.
     * Only rollouts in terminal state can be deleted.
     *
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param rolloutName The rollout name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteAsync(String resourceGroupName, String rolloutName) {
        return deleteWithServiceResponseAsync(resourceGroupName, rolloutName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a rollout resource.
     * Only rollouts in terminal state can be deleted.
     *
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param rolloutName The rollout name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteWithServiceResponseAsync(String resourceGroupName, String rolloutName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (rolloutName == null) {
            throw new IllegalArgumentException("Parameter rolloutName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.delete(this.client.subscriptionId(), resourceGroupName, rolloutName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Stops a running rollout.
     * Only running rollouts can be canceled.
     *
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param rolloutName The rollout name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RolloutInner object if successful.
     */
    public RolloutInner cancel(String resourceGroupName, String rolloutName) {
        return cancelWithServiceResponseAsync(resourceGroupName, rolloutName).toBlocking().single().body();
    }

    /**
     * Stops a running rollout.
     * Only running rollouts can be canceled.
     *
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param rolloutName The rollout name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RolloutInner> cancelAsync(String resourceGroupName, String rolloutName, final ServiceCallback<RolloutInner> serviceCallback) {
        return ServiceFuture.fromResponse(cancelWithServiceResponseAsync(resourceGroupName, rolloutName), serviceCallback);
    }

    /**
     * Stops a running rollout.
     * Only running rollouts can be canceled.
     *
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param rolloutName The rollout name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RolloutInner object
     */
    public Observable<RolloutInner> cancelAsync(String resourceGroupName, String rolloutName) {
        return cancelWithServiceResponseAsync(resourceGroupName, rolloutName).map(new Func1<ServiceResponse<RolloutInner>, RolloutInner>() {
            @Override
            public RolloutInner call(ServiceResponse<RolloutInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Stops a running rollout.
     * Only running rollouts can be canceled.
     *
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param rolloutName The rollout name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RolloutInner object
     */
    public Observable<ServiceResponse<RolloutInner>> cancelWithServiceResponseAsync(String resourceGroupName, String rolloutName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (rolloutName == null) {
            throw new IllegalArgumentException("Parameter rolloutName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.cancel(this.client.subscriptionId(), resourceGroupName, rolloutName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RolloutInner>>>() {
                @Override
                public Observable<ServiceResponse<RolloutInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RolloutInner> clientResponse = cancelDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RolloutInner> cancelDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<RolloutInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<RolloutInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Restarts a failed rollout and optionally skips all succeeded steps.
     * Only failed rollouts can be restarted.
     *
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param rolloutName The rollout name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RolloutInner object if successful.
     */
    public RolloutInner restart(String resourceGroupName, String rolloutName) {
        return restartWithServiceResponseAsync(resourceGroupName, rolloutName).toBlocking().single().body();
    }

    /**
     * Restarts a failed rollout and optionally skips all succeeded steps.
     * Only failed rollouts can be restarted.
     *
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param rolloutName The rollout name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RolloutInner> restartAsync(String resourceGroupName, String rolloutName, final ServiceCallback<RolloutInner> serviceCallback) {
        return ServiceFuture.fromResponse(restartWithServiceResponseAsync(resourceGroupName, rolloutName), serviceCallback);
    }

    /**
     * Restarts a failed rollout and optionally skips all succeeded steps.
     * Only failed rollouts can be restarted.
     *
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param rolloutName The rollout name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RolloutInner object
     */
    public Observable<RolloutInner> restartAsync(String resourceGroupName, String rolloutName) {
        return restartWithServiceResponseAsync(resourceGroupName, rolloutName).map(new Func1<ServiceResponse<RolloutInner>, RolloutInner>() {
            @Override
            public RolloutInner call(ServiceResponse<RolloutInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Restarts a failed rollout and optionally skips all succeeded steps.
     * Only failed rollouts can be restarted.
     *
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param rolloutName The rollout name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RolloutInner object
     */
    public Observable<ServiceResponse<RolloutInner>> restartWithServiceResponseAsync(String resourceGroupName, String rolloutName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (rolloutName == null) {
            throw new IllegalArgumentException("Parameter rolloutName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final Boolean skipSucceeded = null;
        return service.restart(this.client.subscriptionId(), resourceGroupName, rolloutName, skipSucceeded, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RolloutInner>>>() {
                @Override
                public Observable<ServiceResponse<RolloutInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RolloutInner> clientResponse = restartDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Restarts a failed rollout and optionally skips all succeeded steps.
     * Only failed rollouts can be restarted.
     *
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param rolloutName The rollout name.
     * @param skipSucceeded If true, will skip all succeeded steps so far in the rollout. If false, will execute the entire rollout again regardless of the current state of individual resources. Defaults to false if not specified.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RolloutInner object if successful.
     */
    public RolloutInner restart(String resourceGroupName, String rolloutName, Boolean skipSucceeded) {
        return restartWithServiceResponseAsync(resourceGroupName, rolloutName, skipSucceeded).toBlocking().single().body();
    }

    /**
     * Restarts a failed rollout and optionally skips all succeeded steps.
     * Only failed rollouts can be restarted.
     *
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param rolloutName The rollout name.
     * @param skipSucceeded If true, will skip all succeeded steps so far in the rollout. If false, will execute the entire rollout again regardless of the current state of individual resources. Defaults to false if not specified.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RolloutInner> restartAsync(String resourceGroupName, String rolloutName, Boolean skipSucceeded, final ServiceCallback<RolloutInner> serviceCallback) {
        return ServiceFuture.fromResponse(restartWithServiceResponseAsync(resourceGroupName, rolloutName, skipSucceeded), serviceCallback);
    }

    /**
     * Restarts a failed rollout and optionally skips all succeeded steps.
     * Only failed rollouts can be restarted.
     *
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param rolloutName The rollout name.
     * @param skipSucceeded If true, will skip all succeeded steps so far in the rollout. If false, will execute the entire rollout again regardless of the current state of individual resources. Defaults to false if not specified.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RolloutInner object
     */
    public Observable<RolloutInner> restartAsync(String resourceGroupName, String rolloutName, Boolean skipSucceeded) {
        return restartWithServiceResponseAsync(resourceGroupName, rolloutName, skipSucceeded).map(new Func1<ServiceResponse<RolloutInner>, RolloutInner>() {
            @Override
            public RolloutInner call(ServiceResponse<RolloutInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Restarts a failed rollout and optionally skips all succeeded steps.
     * Only failed rollouts can be restarted.
     *
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param rolloutName The rollout name.
     * @param skipSucceeded If true, will skip all succeeded steps so far in the rollout. If false, will execute the entire rollout again regardless of the current state of individual resources. Defaults to false if not specified.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RolloutInner object
     */
    public Observable<ServiceResponse<RolloutInner>> restartWithServiceResponseAsync(String resourceGroupName, String rolloutName, Boolean skipSucceeded) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (rolloutName == null) {
            throw new IllegalArgumentException("Parameter rolloutName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.restart(this.client.subscriptionId(), resourceGroupName, rolloutName, skipSucceeded, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RolloutInner>>>() {
                @Override
                public Observable<ServiceResponse<RolloutInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RolloutInner> clientResponse = restartDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RolloutInner> restartDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<RolloutInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<RolloutInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

}
