/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.management.labservices.v2018_10_15.implementation;

import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.CloudException;
import com.microsoft.azure.management.labservices.v2018_10_15.EnvironmentOperationsPayload;
import com.microsoft.azure.management.labservices.v2018_10_15.ListEnvironmentsPayload;
import com.microsoft.azure.management.labservices.v2018_10_15.OperationBatchStatusPayload;
import com.microsoft.azure.management.labservices.v2018_10_15.OperationStatusPayload;
import com.microsoft.azure.management.labservices.v2018_10_15.PersonalPreferencesOperationsPayload;
import com.microsoft.azure.management.labservices.v2018_10_15.RegisterPayload;
import com.microsoft.azure.management.labservices.v2018_10_15.ResetPasswordPayload;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.List;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in GlobalUsers.
 */
public class GlobalUsersInner {
    /** The Retrofit service to perform REST calls. */
    private GlobalUsersService service;
    /** The service client containing this operation class. */
    private ManagedLabsClientImpl client;

    /**
     * Initializes an instance of GlobalUsersInner.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public GlobalUsersInner(Retrofit retrofit, ManagedLabsClientImpl client) {
        this.service = retrofit.create(GlobalUsersService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for GlobalUsers to be
     * used by Retrofit to perform actually REST calls.
     */
    interface GlobalUsersService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.labservices.v2018_10_15.GlobalUsers getEnvironment" })
        @POST("providers/Microsoft.LabServices/users/{userName}/getEnvironment")
        Observable<Response<ResponseBody>> getEnvironment(@Path("userName") String userName, @Query("$expand") String expand, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body EnvironmentOperationsPayload environmentOperationsPayload, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.labservices.v2018_10_15.GlobalUsers getOperationBatchStatus" })
        @POST("providers/Microsoft.LabServices/users/{userName}/getOperationBatchStatus")
        Observable<Response<ResponseBody>> getOperationBatchStatus(@Path("userName") String userName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body OperationBatchStatusPayload operationBatchStatusPayload, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.labservices.v2018_10_15.GlobalUsers getOperationStatus" })
        @POST("providers/Microsoft.LabServices/users/{userName}/getOperationStatus")
        Observable<Response<ResponseBody>> getOperationStatus(@Path("userName") String userName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body OperationStatusPayload operationStatusPayload, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.labservices.v2018_10_15.GlobalUsers getPersonalPreferences" })
        @POST("providers/Microsoft.LabServices/users/{userName}/getPersonalPreferences")
        Observable<Response<ResponseBody>> getPersonalPreferences(@Path("userName") String userName, @Body PersonalPreferencesOperationsPayload personalPreferencesOperationsPayload, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.labservices.v2018_10_15.GlobalUsers listEnvironments" })
        @POST("providers/Microsoft.LabServices/users/{userName}/listEnvironments")
        Observable<Response<ResponseBody>> listEnvironments(@Path("userName") String userName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body ListEnvironmentsPayload listEnvironmentsPayload, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.labservices.v2018_10_15.GlobalUsers listLabs" })
        @POST("providers/Microsoft.LabServices/users/{userName}/listLabs")
        Observable<Response<ResponseBody>> listLabs(@Path("userName") String userName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.labservices.v2018_10_15.GlobalUsers register" })
        @POST("providers/Microsoft.LabServices/users/{userName}/register")
        Observable<Response<ResponseBody>> register(@Path("userName") String userName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body RegisterPayload registerPayload, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.labservices.v2018_10_15.GlobalUsers resetPassword" })
        @POST("providers/Microsoft.LabServices/users/{userName}/resetPassword")
        Observable<Response<ResponseBody>> resetPassword(@Path("userName") String userName, @Body ResetPasswordPayload resetPasswordPayload, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.labservices.v2018_10_15.GlobalUsers beginResetPassword" })
        @POST("providers/Microsoft.LabServices/users/{userName}/resetPassword")
        Observable<Response<ResponseBody>> beginResetPassword(@Path("userName") String userName, @Body ResetPasswordPayload resetPasswordPayload, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.labservices.v2018_10_15.GlobalUsers startEnvironment" })
        @POST("providers/Microsoft.LabServices/users/{userName}/startEnvironment")
        Observable<Response<ResponseBody>> startEnvironment(@Path("userName") String userName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body EnvironmentOperationsPayload environmentOperationsPayload, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.labservices.v2018_10_15.GlobalUsers beginStartEnvironment" })
        @POST("providers/Microsoft.LabServices/users/{userName}/startEnvironment")
        Observable<Response<ResponseBody>> beginStartEnvironment(@Path("userName") String userName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body EnvironmentOperationsPayload environmentOperationsPayload, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.labservices.v2018_10_15.GlobalUsers stopEnvironment" })
        @POST("providers/Microsoft.LabServices/users/{userName}/stopEnvironment")
        Observable<Response<ResponseBody>> stopEnvironment(@Path("userName") String userName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body EnvironmentOperationsPayload environmentOperationsPayload, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.labservices.v2018_10_15.GlobalUsers beginStopEnvironment" })
        @POST("providers/Microsoft.LabServices/users/{userName}/stopEnvironment")
        Observable<Response<ResponseBody>> beginStopEnvironment(@Path("userName") String userName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body EnvironmentOperationsPayload environmentOperationsPayload, @Header("User-Agent") String userAgent);

    }

    /**
     * Gets the virtual machine details.
     *
     * @param userName The name of the user.
     * @param environmentId The resourceId of the environment
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the GetEnvironmentResponseInner object if successful.
     */
    public GetEnvironmentResponseInner getEnvironment(String userName, String environmentId) {
        return getEnvironmentWithServiceResponseAsync(userName, environmentId).toBlocking().single().body();
    }

    /**
     * Gets the virtual machine details.
     *
     * @param userName The name of the user.
     * @param environmentId The resourceId of the environment
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<GetEnvironmentResponseInner> getEnvironmentAsync(String userName, String environmentId, final ServiceCallback<GetEnvironmentResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(getEnvironmentWithServiceResponseAsync(userName, environmentId), serviceCallback);
    }

    /**
     * Gets the virtual machine details.
     *
     * @param userName The name of the user.
     * @param environmentId The resourceId of the environment
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the GetEnvironmentResponseInner object
     */
    public Observable<GetEnvironmentResponseInner> getEnvironmentAsync(String userName, String environmentId) {
        return getEnvironmentWithServiceResponseAsync(userName, environmentId).map(new Func1<ServiceResponse<GetEnvironmentResponseInner>, GetEnvironmentResponseInner>() {
            @Override
            public GetEnvironmentResponseInner call(ServiceResponse<GetEnvironmentResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the virtual machine details.
     *
     * @param userName The name of the user.
     * @param environmentId The resourceId of the environment
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the GetEnvironmentResponseInner object
     */
    public Observable<ServiceResponse<GetEnvironmentResponseInner>> getEnvironmentWithServiceResponseAsync(String userName, String environmentId) {
        if (userName == null) {
            throw new IllegalArgumentException("Parameter userName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        if (environmentId == null) {
            throw new IllegalArgumentException("Parameter environmentId is required and cannot be null.");
        }
        final String expand = null;
        EnvironmentOperationsPayload environmentOperationsPayload = new EnvironmentOperationsPayload();
        environmentOperationsPayload.withEnvironmentId(environmentId);
        return service.getEnvironment(userName, expand, this.client.apiVersion(), this.client.acceptLanguage(), environmentOperationsPayload, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<GetEnvironmentResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<GetEnvironmentResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<GetEnvironmentResponseInner> clientResponse = getEnvironmentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the virtual machine details.
     *
     * @param userName The name of the user.
     * @param environmentId The resourceId of the environment
     * @param expand Specify the $expand query. Example: 'properties($expand=environment)'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the GetEnvironmentResponseInner object if successful.
     */
    public GetEnvironmentResponseInner getEnvironment(String userName, String environmentId, String expand) {
        return getEnvironmentWithServiceResponseAsync(userName, environmentId, expand).toBlocking().single().body();
    }

    /**
     * Gets the virtual machine details.
     *
     * @param userName The name of the user.
     * @param environmentId The resourceId of the environment
     * @param expand Specify the $expand query. Example: 'properties($expand=environment)'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<GetEnvironmentResponseInner> getEnvironmentAsync(String userName, String environmentId, String expand, final ServiceCallback<GetEnvironmentResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(getEnvironmentWithServiceResponseAsync(userName, environmentId, expand), serviceCallback);
    }

    /**
     * Gets the virtual machine details.
     *
     * @param userName The name of the user.
     * @param environmentId The resourceId of the environment
     * @param expand Specify the $expand query. Example: 'properties($expand=environment)'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the GetEnvironmentResponseInner object
     */
    public Observable<GetEnvironmentResponseInner> getEnvironmentAsync(String userName, String environmentId, String expand) {
        return getEnvironmentWithServiceResponseAsync(userName, environmentId, expand).map(new Func1<ServiceResponse<GetEnvironmentResponseInner>, GetEnvironmentResponseInner>() {
            @Override
            public GetEnvironmentResponseInner call(ServiceResponse<GetEnvironmentResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the virtual machine details.
     *
     * @param userName The name of the user.
     * @param environmentId The resourceId of the environment
     * @param expand Specify the $expand query. Example: 'properties($expand=environment)'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the GetEnvironmentResponseInner object
     */
    public Observable<ServiceResponse<GetEnvironmentResponseInner>> getEnvironmentWithServiceResponseAsync(String userName, String environmentId, String expand) {
        if (userName == null) {
            throw new IllegalArgumentException("Parameter userName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        if (environmentId == null) {
            throw new IllegalArgumentException("Parameter environmentId is required and cannot be null.");
        }
        EnvironmentOperationsPayload environmentOperationsPayload = new EnvironmentOperationsPayload();
        environmentOperationsPayload.withEnvironmentId(environmentId);
        return service.getEnvironment(userName, expand, this.client.apiVersion(), this.client.acceptLanguage(), environmentOperationsPayload, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<GetEnvironmentResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<GetEnvironmentResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<GetEnvironmentResponseInner> clientResponse = getEnvironmentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<GetEnvironmentResponseInner> getEnvironmentDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<GetEnvironmentResponseInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<GetEnvironmentResponseInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get batch operation status.
     *
     * @param userName The name of the user.
     * @param urls The operation url of long running operation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationBatchStatusResponseInner object if successful.
     */
    public OperationBatchStatusResponseInner getOperationBatchStatus(String userName, List<String> urls) {
        return getOperationBatchStatusWithServiceResponseAsync(userName, urls).toBlocking().single().body();
    }

    /**
     * Get batch operation status.
     *
     * @param userName The name of the user.
     * @param urls The operation url of long running operation
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationBatchStatusResponseInner> getOperationBatchStatusAsync(String userName, List<String> urls, final ServiceCallback<OperationBatchStatusResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(getOperationBatchStatusWithServiceResponseAsync(userName, urls), serviceCallback);
    }

    /**
     * Get batch operation status.
     *
     * @param userName The name of the user.
     * @param urls The operation url of long running operation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationBatchStatusResponseInner object
     */
    public Observable<OperationBatchStatusResponseInner> getOperationBatchStatusAsync(String userName, List<String> urls) {
        return getOperationBatchStatusWithServiceResponseAsync(userName, urls).map(new Func1<ServiceResponse<OperationBatchStatusResponseInner>, OperationBatchStatusResponseInner>() {
            @Override
            public OperationBatchStatusResponseInner call(ServiceResponse<OperationBatchStatusResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get batch operation status.
     *
     * @param userName The name of the user.
     * @param urls The operation url of long running operation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationBatchStatusResponseInner object
     */
    public Observable<ServiceResponse<OperationBatchStatusResponseInner>> getOperationBatchStatusWithServiceResponseAsync(String userName, List<String> urls) {
        if (userName == null) {
            throw new IllegalArgumentException("Parameter userName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        if (urls == null) {
            throw new IllegalArgumentException("Parameter urls is required and cannot be null.");
        }
        Validator.validate(urls);
        OperationBatchStatusPayload operationBatchStatusPayload = new OperationBatchStatusPayload();
        operationBatchStatusPayload.withUrls(urls);
        return service.getOperationBatchStatus(userName, this.client.apiVersion(), this.client.acceptLanguage(), operationBatchStatusPayload, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationBatchStatusResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<OperationBatchStatusResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationBatchStatusResponseInner> clientResponse = getOperationBatchStatusDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationBatchStatusResponseInner> getOperationBatchStatusDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationBatchStatusResponseInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationBatchStatusResponseInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the status of long running operation.
     *
     * @param userName The name of the user.
     * @param operationUrl The operation url of long running operation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatusResponseInner object if successful.
     */
    public OperationStatusResponseInner getOperationStatus(String userName, String operationUrl) {
        return getOperationStatusWithServiceResponseAsync(userName, operationUrl).toBlocking().single().body();
    }

    /**
     * Gets the status of long running operation.
     *
     * @param userName The name of the user.
     * @param operationUrl The operation url of long running operation
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatusResponseInner> getOperationStatusAsync(String userName, String operationUrl, final ServiceCallback<OperationStatusResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(getOperationStatusWithServiceResponseAsync(userName, operationUrl), serviceCallback);
    }

    /**
     * Gets the status of long running operation.
     *
     * @param userName The name of the user.
     * @param operationUrl The operation url of long running operation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatusResponseInner object
     */
    public Observable<OperationStatusResponseInner> getOperationStatusAsync(String userName, String operationUrl) {
        return getOperationStatusWithServiceResponseAsync(userName, operationUrl).map(new Func1<ServiceResponse<OperationStatusResponseInner>, OperationStatusResponseInner>() {
            @Override
            public OperationStatusResponseInner call(ServiceResponse<OperationStatusResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the status of long running operation.
     *
     * @param userName The name of the user.
     * @param operationUrl The operation url of long running operation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatusResponseInner object
     */
    public Observable<ServiceResponse<OperationStatusResponseInner>> getOperationStatusWithServiceResponseAsync(String userName, String operationUrl) {
        if (userName == null) {
            throw new IllegalArgumentException("Parameter userName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        if (operationUrl == null) {
            throw new IllegalArgumentException("Parameter operationUrl is required and cannot be null.");
        }
        OperationStatusPayload operationStatusPayload = new OperationStatusPayload();
        operationStatusPayload.withOperationUrl(operationUrl);
        return service.getOperationStatus(userName, this.client.apiVersion(), this.client.acceptLanguage(), operationStatusPayload, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatusResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatusResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatusResponseInner> clientResponse = getOperationStatusDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatusResponseInner> getOperationStatusDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatusResponseInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatusResponseInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get personal preferences for a user.
     *
     * @param userName The name of the user.
     * @param personalPreferencesOperationsPayload Represents payload for any Environment operations like get, start, stop, connect
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the GetPersonalPreferencesResponseInner object if successful.
     */
    public GetPersonalPreferencesResponseInner getPersonalPreferences(String userName, PersonalPreferencesOperationsPayload personalPreferencesOperationsPayload) {
        return getPersonalPreferencesWithServiceResponseAsync(userName, personalPreferencesOperationsPayload).toBlocking().single().body();
    }

    /**
     * Get personal preferences for a user.
     *
     * @param userName The name of the user.
     * @param personalPreferencesOperationsPayload Represents payload for any Environment operations like get, start, stop, connect
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<GetPersonalPreferencesResponseInner> getPersonalPreferencesAsync(String userName, PersonalPreferencesOperationsPayload personalPreferencesOperationsPayload, final ServiceCallback<GetPersonalPreferencesResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(getPersonalPreferencesWithServiceResponseAsync(userName, personalPreferencesOperationsPayload), serviceCallback);
    }

    /**
     * Get personal preferences for a user.
     *
     * @param userName The name of the user.
     * @param personalPreferencesOperationsPayload Represents payload for any Environment operations like get, start, stop, connect
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the GetPersonalPreferencesResponseInner object
     */
    public Observable<GetPersonalPreferencesResponseInner> getPersonalPreferencesAsync(String userName, PersonalPreferencesOperationsPayload personalPreferencesOperationsPayload) {
        return getPersonalPreferencesWithServiceResponseAsync(userName, personalPreferencesOperationsPayload).map(new Func1<ServiceResponse<GetPersonalPreferencesResponseInner>, GetPersonalPreferencesResponseInner>() {
            @Override
            public GetPersonalPreferencesResponseInner call(ServiceResponse<GetPersonalPreferencesResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get personal preferences for a user.
     *
     * @param userName The name of the user.
     * @param personalPreferencesOperationsPayload Represents payload for any Environment operations like get, start, stop, connect
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the GetPersonalPreferencesResponseInner object
     */
    public Observable<ServiceResponse<GetPersonalPreferencesResponseInner>> getPersonalPreferencesWithServiceResponseAsync(String userName, PersonalPreferencesOperationsPayload personalPreferencesOperationsPayload) {
        if (userName == null) {
            throw new IllegalArgumentException("Parameter userName is required and cannot be null.");
        }
        if (personalPreferencesOperationsPayload == null) {
            throw new IllegalArgumentException("Parameter personalPreferencesOperationsPayload is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(personalPreferencesOperationsPayload);
        return service.getPersonalPreferences(userName, personalPreferencesOperationsPayload, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<GetPersonalPreferencesResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<GetPersonalPreferencesResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<GetPersonalPreferencesResponseInner> clientResponse = getPersonalPreferencesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<GetPersonalPreferencesResponseInner> getPersonalPreferencesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<GetPersonalPreferencesResponseInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<GetPersonalPreferencesResponseInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List Environments for the user.
     *
     * @param userName The name of the user.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ListEnvironmentsResponseInner object if successful.
     */
    public ListEnvironmentsResponseInner listEnvironments(String userName) {
        return listEnvironmentsWithServiceResponseAsync(userName).toBlocking().single().body();
    }

    /**
     * List Environments for the user.
     *
     * @param userName The name of the user.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ListEnvironmentsResponseInner> listEnvironmentsAsync(String userName, final ServiceCallback<ListEnvironmentsResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(listEnvironmentsWithServiceResponseAsync(userName), serviceCallback);
    }

    /**
     * List Environments for the user.
     *
     * @param userName The name of the user.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ListEnvironmentsResponseInner object
     */
    public Observable<ListEnvironmentsResponseInner> listEnvironmentsAsync(String userName) {
        return listEnvironmentsWithServiceResponseAsync(userName).map(new Func1<ServiceResponse<ListEnvironmentsResponseInner>, ListEnvironmentsResponseInner>() {
            @Override
            public ListEnvironmentsResponseInner call(ServiceResponse<ListEnvironmentsResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * List Environments for the user.
     *
     * @param userName The name of the user.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ListEnvironmentsResponseInner object
     */
    public Observable<ServiceResponse<ListEnvironmentsResponseInner>> listEnvironmentsWithServiceResponseAsync(String userName) {
        if (userName == null) {
            throw new IllegalArgumentException("Parameter userName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String labId = null;
        ListEnvironmentsPayload listEnvironmentsPayload = new ListEnvironmentsPayload();
        listEnvironmentsPayload.withLabId(null);
        return service.listEnvironments(userName, this.client.apiVersion(), this.client.acceptLanguage(), listEnvironmentsPayload, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ListEnvironmentsResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<ListEnvironmentsResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ListEnvironmentsResponseInner> clientResponse = listEnvironmentsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * List Environments for the user.
     *
     * @param userName The name of the user.
     * @param labId The resource Id of the lab
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ListEnvironmentsResponseInner object if successful.
     */
    public ListEnvironmentsResponseInner listEnvironments(String userName, String labId) {
        return listEnvironmentsWithServiceResponseAsync(userName, labId).toBlocking().single().body();
    }

    /**
     * List Environments for the user.
     *
     * @param userName The name of the user.
     * @param labId The resource Id of the lab
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ListEnvironmentsResponseInner> listEnvironmentsAsync(String userName, String labId, final ServiceCallback<ListEnvironmentsResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(listEnvironmentsWithServiceResponseAsync(userName, labId), serviceCallback);
    }

    /**
     * List Environments for the user.
     *
     * @param userName The name of the user.
     * @param labId The resource Id of the lab
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ListEnvironmentsResponseInner object
     */
    public Observable<ListEnvironmentsResponseInner> listEnvironmentsAsync(String userName, String labId) {
        return listEnvironmentsWithServiceResponseAsync(userName, labId).map(new Func1<ServiceResponse<ListEnvironmentsResponseInner>, ListEnvironmentsResponseInner>() {
            @Override
            public ListEnvironmentsResponseInner call(ServiceResponse<ListEnvironmentsResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * List Environments for the user.
     *
     * @param userName The name of the user.
     * @param labId The resource Id of the lab
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ListEnvironmentsResponseInner object
     */
    public Observable<ServiceResponse<ListEnvironmentsResponseInner>> listEnvironmentsWithServiceResponseAsync(String userName, String labId) {
        if (userName == null) {
            throw new IllegalArgumentException("Parameter userName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        ListEnvironmentsPayload listEnvironmentsPayload = new ListEnvironmentsPayload();
        listEnvironmentsPayload.withLabId(labId);
        return service.listEnvironments(userName, this.client.apiVersion(), this.client.acceptLanguage(), listEnvironmentsPayload, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ListEnvironmentsResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<ListEnvironmentsResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ListEnvironmentsResponseInner> clientResponse = listEnvironmentsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ListEnvironmentsResponseInner> listEnvironmentsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ListEnvironmentsResponseInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ListEnvironmentsResponseInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List labs for the user.
     *
     * @param userName The name of the user.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ListLabsResponseInner object if successful.
     */
    public ListLabsResponseInner listLabs(String userName) {
        return listLabsWithServiceResponseAsync(userName).toBlocking().single().body();
    }

    /**
     * List labs for the user.
     *
     * @param userName The name of the user.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ListLabsResponseInner> listLabsAsync(String userName, final ServiceCallback<ListLabsResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(listLabsWithServiceResponseAsync(userName), serviceCallback);
    }

    /**
     * List labs for the user.
     *
     * @param userName The name of the user.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ListLabsResponseInner object
     */
    public Observable<ListLabsResponseInner> listLabsAsync(String userName) {
        return listLabsWithServiceResponseAsync(userName).map(new Func1<ServiceResponse<ListLabsResponseInner>, ListLabsResponseInner>() {
            @Override
            public ListLabsResponseInner call(ServiceResponse<ListLabsResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * List labs for the user.
     *
     * @param userName The name of the user.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ListLabsResponseInner object
     */
    public Observable<ServiceResponse<ListLabsResponseInner>> listLabsWithServiceResponseAsync(String userName) {
        if (userName == null) {
            throw new IllegalArgumentException("Parameter userName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listLabs(userName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ListLabsResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<ListLabsResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ListLabsResponseInner> clientResponse = listLabsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ListLabsResponseInner> listLabsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ListLabsResponseInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ListLabsResponseInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Register a user to a managed lab.
     *
     * @param userName The name of the user.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void register(String userName) {
        registerWithServiceResponseAsync(userName).toBlocking().single().body();
    }

    /**
     * Register a user to a managed lab.
     *
     * @param userName The name of the user.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> registerAsync(String userName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(registerWithServiceResponseAsync(userName), serviceCallback);
    }

    /**
     * Register a user to a managed lab.
     *
     * @param userName The name of the user.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> registerAsync(String userName) {
        return registerWithServiceResponseAsync(userName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Register a user to a managed lab.
     *
     * @param userName The name of the user.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> registerWithServiceResponseAsync(String userName) {
        if (userName == null) {
            throw new IllegalArgumentException("Parameter userName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String registrationCode = null;
        RegisterPayload registerPayload = new RegisterPayload();
        registerPayload.withRegistrationCode(null);
        return service.register(userName, this.client.apiVersion(), this.client.acceptLanguage(), registerPayload, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = registerDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Register a user to a managed lab.
     *
     * @param userName The name of the user.
     * @param registrationCode The registration code of the lab.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void register(String userName, String registrationCode) {
        registerWithServiceResponseAsync(userName, registrationCode).toBlocking().single().body();
    }

    /**
     * Register a user to a managed lab.
     *
     * @param userName The name of the user.
     * @param registrationCode The registration code of the lab.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> registerAsync(String userName, String registrationCode, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(registerWithServiceResponseAsync(userName, registrationCode), serviceCallback);
    }

    /**
     * Register a user to a managed lab.
     *
     * @param userName The name of the user.
     * @param registrationCode The registration code of the lab.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> registerAsync(String userName, String registrationCode) {
        return registerWithServiceResponseAsync(userName, registrationCode).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Register a user to a managed lab.
     *
     * @param userName The name of the user.
     * @param registrationCode The registration code of the lab.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> registerWithServiceResponseAsync(String userName, String registrationCode) {
        if (userName == null) {
            throw new IllegalArgumentException("Parameter userName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        RegisterPayload registerPayload = new RegisterPayload();
        registerPayload.withRegistrationCode(registrationCode);
        return service.register(userName, this.client.apiVersion(), this.client.acceptLanguage(), registerPayload, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = registerDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> registerDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Resets the user password on an environment This operation can take a while to complete.
     *
     * @param userName The name of the user.
     * @param resetPasswordPayload Represents the payload for resetting passwords.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void resetPassword(String userName, ResetPasswordPayload resetPasswordPayload) {
        resetPasswordWithServiceResponseAsync(userName, resetPasswordPayload).toBlocking().last().body();
    }

    /**
     * Resets the user password on an environment This operation can take a while to complete.
     *
     * @param userName The name of the user.
     * @param resetPasswordPayload Represents the payload for resetting passwords.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> resetPasswordAsync(String userName, ResetPasswordPayload resetPasswordPayload, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(resetPasswordWithServiceResponseAsync(userName, resetPasswordPayload), serviceCallback);
    }

    /**
     * Resets the user password on an environment This operation can take a while to complete.
     *
     * @param userName The name of the user.
     * @param resetPasswordPayload Represents the payload for resetting passwords.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<Void> resetPasswordAsync(String userName, ResetPasswordPayload resetPasswordPayload) {
        return resetPasswordWithServiceResponseAsync(userName, resetPasswordPayload).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Resets the user password on an environment This operation can take a while to complete.
     *
     * @param userName The name of the user.
     * @param resetPasswordPayload Represents the payload for resetting passwords.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<Void>> resetPasswordWithServiceResponseAsync(String userName, ResetPasswordPayload resetPasswordPayload) {
        if (userName == null) {
            throw new IllegalArgumentException("Parameter userName is required and cannot be null.");
        }
        if (resetPasswordPayload == null) {
            throw new IllegalArgumentException("Parameter resetPasswordPayload is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(resetPasswordPayload);
        Observable<Response<ResponseBody>> observable = service.resetPassword(userName, resetPasswordPayload, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<Void>() { }.getType());
    }

    /**
     * Resets the user password on an environment This operation can take a while to complete.
     *
     * @param userName The name of the user.
     * @param resetPasswordPayload Represents the payload for resetting passwords.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void beginResetPassword(String userName, ResetPasswordPayload resetPasswordPayload) {
        beginResetPasswordWithServiceResponseAsync(userName, resetPasswordPayload).toBlocking().single().body();
    }

    /**
     * Resets the user password on an environment This operation can take a while to complete.
     *
     * @param userName The name of the user.
     * @param resetPasswordPayload Represents the payload for resetting passwords.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> beginResetPasswordAsync(String userName, ResetPasswordPayload resetPasswordPayload, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(beginResetPasswordWithServiceResponseAsync(userName, resetPasswordPayload), serviceCallback);
    }

    /**
     * Resets the user password on an environment This operation can take a while to complete.
     *
     * @param userName The name of the user.
     * @param resetPasswordPayload Represents the payload for resetting passwords.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> beginResetPasswordAsync(String userName, ResetPasswordPayload resetPasswordPayload) {
        return beginResetPasswordWithServiceResponseAsync(userName, resetPasswordPayload).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Resets the user password on an environment This operation can take a while to complete.
     *
     * @param userName The name of the user.
     * @param resetPasswordPayload Represents the payload for resetting passwords.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> beginResetPasswordWithServiceResponseAsync(String userName, ResetPasswordPayload resetPasswordPayload) {
        if (userName == null) {
            throw new IllegalArgumentException("Parameter userName is required and cannot be null.");
        }
        if (resetPasswordPayload == null) {
            throw new IllegalArgumentException("Parameter resetPasswordPayload is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(resetPasswordPayload);
        return service.beginResetPassword(userName, resetPasswordPayload, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = beginResetPasswordDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> beginResetPasswordDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Starts an environment by starting all resources inside the environment. This operation can take a while to complete.
     *
     * @param userName The name of the user.
     * @param environmentId The resourceId of the environment
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void startEnvironment(String userName, String environmentId) {
        startEnvironmentWithServiceResponseAsync(userName, environmentId).toBlocking().last().body();
    }

    /**
     * Starts an environment by starting all resources inside the environment. This operation can take a while to complete.
     *
     * @param userName The name of the user.
     * @param environmentId The resourceId of the environment
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> startEnvironmentAsync(String userName, String environmentId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(startEnvironmentWithServiceResponseAsync(userName, environmentId), serviceCallback);
    }

    /**
     * Starts an environment by starting all resources inside the environment. This operation can take a while to complete.
     *
     * @param userName The name of the user.
     * @param environmentId The resourceId of the environment
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<Void> startEnvironmentAsync(String userName, String environmentId) {
        return startEnvironmentWithServiceResponseAsync(userName, environmentId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Starts an environment by starting all resources inside the environment. This operation can take a while to complete.
     *
     * @param userName The name of the user.
     * @param environmentId The resourceId of the environment
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<Void>> startEnvironmentWithServiceResponseAsync(String userName, String environmentId) {
        if (userName == null) {
            throw new IllegalArgumentException("Parameter userName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        if (environmentId == null) {
            throw new IllegalArgumentException("Parameter environmentId is required and cannot be null.");
        }
        EnvironmentOperationsPayload environmentOperationsPayload = new EnvironmentOperationsPayload();
        environmentOperationsPayload.withEnvironmentId(environmentId);
        Observable<Response<ResponseBody>> observable = service.startEnvironment(userName, this.client.apiVersion(), this.client.acceptLanguage(), environmentOperationsPayload, this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<Void>() { }.getType());
    }

    /**
     * Starts an environment by starting all resources inside the environment. This operation can take a while to complete.
     *
     * @param userName The name of the user.
     * @param environmentId The resourceId of the environment
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void beginStartEnvironment(String userName, String environmentId) {
        beginStartEnvironmentWithServiceResponseAsync(userName, environmentId).toBlocking().single().body();
    }

    /**
     * Starts an environment by starting all resources inside the environment. This operation can take a while to complete.
     *
     * @param userName The name of the user.
     * @param environmentId The resourceId of the environment
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> beginStartEnvironmentAsync(String userName, String environmentId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(beginStartEnvironmentWithServiceResponseAsync(userName, environmentId), serviceCallback);
    }

    /**
     * Starts an environment by starting all resources inside the environment. This operation can take a while to complete.
     *
     * @param userName The name of the user.
     * @param environmentId The resourceId of the environment
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> beginStartEnvironmentAsync(String userName, String environmentId) {
        return beginStartEnvironmentWithServiceResponseAsync(userName, environmentId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Starts an environment by starting all resources inside the environment. This operation can take a while to complete.
     *
     * @param userName The name of the user.
     * @param environmentId The resourceId of the environment
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> beginStartEnvironmentWithServiceResponseAsync(String userName, String environmentId) {
        if (userName == null) {
            throw new IllegalArgumentException("Parameter userName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        if (environmentId == null) {
            throw new IllegalArgumentException("Parameter environmentId is required and cannot be null.");
        }
        EnvironmentOperationsPayload environmentOperationsPayload = new EnvironmentOperationsPayload();
        environmentOperationsPayload.withEnvironmentId(environmentId);
        return service.beginStartEnvironment(userName, this.client.apiVersion(), this.client.acceptLanguage(), environmentOperationsPayload, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = beginStartEnvironmentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> beginStartEnvironmentDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Stops an environment by stopping all resources inside the environment This operation can take a while to complete.
     *
     * @param userName The name of the user.
     * @param environmentId The resourceId of the environment
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void stopEnvironment(String userName, String environmentId) {
        stopEnvironmentWithServiceResponseAsync(userName, environmentId).toBlocking().last().body();
    }

    /**
     * Stops an environment by stopping all resources inside the environment This operation can take a while to complete.
     *
     * @param userName The name of the user.
     * @param environmentId The resourceId of the environment
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> stopEnvironmentAsync(String userName, String environmentId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(stopEnvironmentWithServiceResponseAsync(userName, environmentId), serviceCallback);
    }

    /**
     * Stops an environment by stopping all resources inside the environment This operation can take a while to complete.
     *
     * @param userName The name of the user.
     * @param environmentId The resourceId of the environment
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<Void> stopEnvironmentAsync(String userName, String environmentId) {
        return stopEnvironmentWithServiceResponseAsync(userName, environmentId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Stops an environment by stopping all resources inside the environment This operation can take a while to complete.
     *
     * @param userName The name of the user.
     * @param environmentId The resourceId of the environment
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<Void>> stopEnvironmentWithServiceResponseAsync(String userName, String environmentId) {
        if (userName == null) {
            throw new IllegalArgumentException("Parameter userName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        if (environmentId == null) {
            throw new IllegalArgumentException("Parameter environmentId is required and cannot be null.");
        }
        EnvironmentOperationsPayload environmentOperationsPayload = new EnvironmentOperationsPayload();
        environmentOperationsPayload.withEnvironmentId(environmentId);
        Observable<Response<ResponseBody>> observable = service.stopEnvironment(userName, this.client.apiVersion(), this.client.acceptLanguage(), environmentOperationsPayload, this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<Void>() { }.getType());
    }

    /**
     * Stops an environment by stopping all resources inside the environment This operation can take a while to complete.
     *
     * @param userName The name of the user.
     * @param environmentId The resourceId of the environment
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void beginStopEnvironment(String userName, String environmentId) {
        beginStopEnvironmentWithServiceResponseAsync(userName, environmentId).toBlocking().single().body();
    }

    /**
     * Stops an environment by stopping all resources inside the environment This operation can take a while to complete.
     *
     * @param userName The name of the user.
     * @param environmentId The resourceId of the environment
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> beginStopEnvironmentAsync(String userName, String environmentId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(beginStopEnvironmentWithServiceResponseAsync(userName, environmentId), serviceCallback);
    }

    /**
     * Stops an environment by stopping all resources inside the environment This operation can take a while to complete.
     *
     * @param userName The name of the user.
     * @param environmentId The resourceId of the environment
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> beginStopEnvironmentAsync(String userName, String environmentId) {
        return beginStopEnvironmentWithServiceResponseAsync(userName, environmentId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Stops an environment by stopping all resources inside the environment This operation can take a while to complete.
     *
     * @param userName The name of the user.
     * @param environmentId The resourceId of the environment
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> beginStopEnvironmentWithServiceResponseAsync(String userName, String environmentId) {
        if (userName == null) {
            throw new IllegalArgumentException("Parameter userName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        if (environmentId == null) {
            throw new IllegalArgumentException("Parameter environmentId is required and cannot be null.");
        }
        EnvironmentOperationsPayload environmentOperationsPayload = new EnvironmentOperationsPayload();
        environmentOperationsPayload.withEnvironmentId(environmentId);
        return service.beginStopEnvironment(userName, this.client.apiVersion(), this.client.acceptLanguage(), environmentOperationsPayload, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = beginStopEnvironmentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> beginStopEnvironmentDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

}
