/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.management.hybriddata;

import com.fasterxml.jackson.annotation.JsonProperty;

/**
 * Encryption Key.
 */
public class Key {
    /**
     * Modulus of the encryption key.
     */
    @JsonProperty(value = "keyModulus", required = true)
    private String keyModulus;

    /**
     * Exponent of the encryption key.
     */
    @JsonProperty(value = "keyExponent", required = true)
    private String keyExponent;

    /**
     * The maximum byte size that can be encrypted by the key. For a key size
     * larger than the size, break into chunks and encrypt each chunk, append
     * each encrypted chunk with : to mark the end of the chunk.
     */
    @JsonProperty(value = "encryptionChunkSizeInBytes", required = true)
    private int encryptionChunkSizeInBytes;

    /**
     * Get modulus of the encryption key.
     *
     * @return the keyModulus value
     */
    public String keyModulus() {
        return this.keyModulus;
    }

    /**
     * Set modulus of the encryption key.
     *
     * @param keyModulus the keyModulus value to set
     * @return the Key object itself.
     */
    public Key withKeyModulus(String keyModulus) {
        this.keyModulus = keyModulus;
        return this;
    }

    /**
     * Get exponent of the encryption key.
     *
     * @return the keyExponent value
     */
    public String keyExponent() {
        return this.keyExponent;
    }

    /**
     * Set exponent of the encryption key.
     *
     * @param keyExponent the keyExponent value to set
     * @return the Key object itself.
     */
    public Key withKeyExponent(String keyExponent) {
        this.keyExponent = keyExponent;
        return this;
    }

    /**
     * Get the maximum byte size that can be encrypted by the key. For a key size larger than the size, break into chunks and encrypt each chunk, append each encrypted chunk with : to mark the end of the chunk.
     *
     * @return the encryptionChunkSizeInBytes value
     */
    public int encryptionChunkSizeInBytes() {
        return this.encryptionChunkSizeInBytes;
    }

    /**
     * Set the maximum byte size that can be encrypted by the key. For a key size larger than the size, break into chunks and encrypt each chunk, append each encrypted chunk with : to mark the end of the chunk.
     *
     * @param encryptionChunkSizeInBytes the encryptionChunkSizeInBytes value to set
     * @return the Key object itself.
     */
    public Key withEncryptionChunkSizeInBytes(int encryptionChunkSizeInBytes) {
        this.encryptionChunkSizeInBytes = encryptionChunkSizeInBytes;
        return this;
    }

}
