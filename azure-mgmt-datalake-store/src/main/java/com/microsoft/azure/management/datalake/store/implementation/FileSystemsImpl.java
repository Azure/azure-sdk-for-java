/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.management.datalake.store.implementation;

import retrofit2.Retrofit;
import com.microsoft.azure.management.datalake.store.FileSystems;
import com.google.common.base.Joiner;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.AzureServiceResponseBuilder;
import com.microsoft.azure.management.datalake.store.models.AclStatusResult;
import com.microsoft.azure.management.datalake.store.models.AdlsErrorException;
import com.microsoft.azure.management.datalake.store.models.AppendModeType;
import com.microsoft.azure.management.datalake.store.models.ContentSummaryResult;
import com.microsoft.azure.management.datalake.store.models.FileOperationResult;
import com.microsoft.azure.management.datalake.store.models.FileStatusesResult;
import com.microsoft.azure.management.datalake.store.models.FileStatusResult;
import com.microsoft.rest.serializer.CollectionFormat;
import com.microsoft.rest.ServiceCall;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.InputStream;
import java.io.IOException;
import java.util.List;
import okhttp3.MediaType;
import okhttp3.RequestBody;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.http.Streaming;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in FileSystems.
 */
public final class FileSystemsImpl implements FileSystems {
    /** The Retrofit service to perform REST calls. */
    private FileSystemsService service;
    /** The service client containing this operation class. */
    private DataLakeStoreFileSystemManagementClientImpl client;

    /**
     * Initializes an instance of FileSystemsImpl.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public FileSystemsImpl(Retrofit retrofit, DataLakeStoreFileSystemManagementClientImpl client) {
        this.service = retrofit.create(FileSystemsService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for FileSystems to be
     * used by Retrofit to perform actually REST calls.
     */
    interface FileSystemsService {
        @Headers("Content-Type: application/octet-stream")
        @POST("WebHdfsExt/{filePath}")
        Observable<Response<ResponseBody>> concurrentAppend(@Path("filePath") String filePath, @Body RequestBody streamContents, @Query("appendMode") AppendModeType appendMode, @Query("op") String op, @Header("Transfer-Encoding") String transferEncoding, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("webhdfs/v1/{path}")
        Observable<Response<ResponseBody>> checkAccess(@Path("path") String path, @Query("fsaction") String fsaction, @Query("op") String op, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("webhdfs/v1/{path}")
        Observable<Response<ResponseBody>> mkdirs(@Path("path") String path, @Query("op") String op, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("webhdfs/v1/{destinationPath}")
        Observable<Response<ResponseBody>> concat(@Path("destinationPath") String destinationPath, @Query("sources") String sources, @Query("op") String op, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/octet-stream")
        @POST("webhdfs/v1/{msConcatDestinationPath}")
        Observable<Response<ResponseBody>> msConcat(@Path("msConcatDestinationPath") String msConcatDestinationPath, @Query("deleteSourceDirectory") Boolean deleteSourceDirectory, @Body RequestBody streamContents, @Query("op") String op, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("webhdfs/v1/{listFilePath}")
        Observable<Response<ResponseBody>> listFileStatus(@Path("listFilePath") String listFilePath, @Query("listSize") Integer listSize, @Query("listAfter") String listAfter, @Query("listBefore") String listBefore, @Query("op") String op, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("webhdfs/va/{getContentSummaryFilePath}")
        Observable<Response<ResponseBody>> getContentSummary(@Path("getContentSummaryFilePath") String getContentSummaryFilePath, @Query("op") String op, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("webhdfs/v1/{getFilePath}")
        Observable<Response<ResponseBody>> getFileStatus(@Path("getFilePath") String getFilePath, @Query("op") String op, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/octet-stream")
        @POST("webhdfs/v1/{directFilePath}")
        Observable<Response<ResponseBody>> append(@Path("directFilePath") String directFilePath, @Body RequestBody streamContents, @Query("offset") Long offset, @Query("op") String op, @Query("append") String append, @Header("Transfer-Encoding") String transferEncoding, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/octet-stream")
        @PUT("webhdfs/v1/{directFilePath}")
        Observable<Response<ResponseBody>> create(@Path("directFilePath") String directFilePath, @Body RequestBody streamContents, @Query("overwrite") Boolean overwrite, @Query("op") String op, @Query("write") String write, @Header("Transfer-Encoding") String transferEncoding, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("webhdfs/v1/{directFilePath}")
        @Streaming
        Observable<Response<ResponseBody>> open(@Path("directFilePath") String directFilePath, @Query("length") Long length, @Query("offset") Long offset, @Query("op") String op, @Query("read") String read, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("webhdfs/v1/{setAclFilePath}")
        Observable<Response<ResponseBody>> setAcl(@Path("setAclFilePath") String setAclFilePath, @Query("aclspec") String aclspec, @Query("op") String op, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("webhdfs/v1/{modifyAclFilePath}")
        Observable<Response<ResponseBody>> modifyAclEntries(@Path("modifyAclFilePath") String modifyAclFilePath, @Query("aclspec") String aclspec, @Query("op") String op, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("webhdfs/v1/{removeAclFilePath}")
        Observable<Response<ResponseBody>> removeAclEntries(@Path("removeAclFilePath") String removeAclFilePath, @Query("aclspec") String aclspec, @Query("op") String op, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("webhdfs/v1/{aclFilePath}")
        Observable<Response<ResponseBody>> getAclStatus(@Path("aclFilePath") String aclFilePath, @Query("op") String op, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "webhdfs/v1/{filePath}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> delete(@Path("filePath") String filePath, @Query("recursive") Boolean recursive, @Query("op") String op, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("webhdfs/v1/{renameFilePath}")
        Observable<Response<ResponseBody>> rename(@Path("renameFilePath") String renameFilePath, @Query("destination") String destination, @Query("op") String op, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("webhdfs/v1/{setOwnerFilePath}")
        Observable<Response<ResponseBody>> setOwner(@Path("setOwnerFilePath") String setOwnerFilePath, @Query("owner") String owner, @Query("group") String group, @Query("op") String op, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("webhdfs/v1/{setPermissionFilePath}")
        Observable<Response<ResponseBody>> setPermission(@Path("setPermissionFilePath") String setPermissionFilePath, @Query("permission") String permission, @Query("op") String op, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

    }

    /**
     * Appends to the specified file. This method supports multiple concurrent appends to the file. NOTE: Concurrent append and normal (serial) append CANNOT be used interchangeably. Once a file has been appended to using either append option, it can only be appended to using that append option.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param filePath The Data Lake Store path (starting with '/') of the file to which to append using concurrent append.
     * @param streamContents The file contents to include when appending to the file.
     * @throws AdlsErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public ServiceResponse<Void> concurrentAppend(String accountName, String filePath, byte[] streamContents) throws AdlsErrorException, IOException, IllegalArgumentException {
        return concurrentAppendAsync(accountName, filePath, streamContents).toBlocking().single();
    }

    /**
     * Appends to the specified file. This method supports multiple concurrent appends to the file. NOTE: Concurrent append and normal (serial) append CANNOT be used interchangeably. Once a file has been appended to using either append option, it can only be appended to using that append option.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param filePath The Data Lake Store path (starting with '/') of the file to which to append using concurrent append.
     * @param streamContents The file contents to include when appending to the file.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> concurrentAppendAsync(String accountName, String filePath, byte[] streamContents, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(concurrentAppendAsync(accountName, filePath, streamContents), serviceCallback);
    }

    /**
     * Appends to the specified file. This method supports multiple concurrent appends to the file. NOTE: Concurrent append and normal (serial) append CANNOT be used interchangeably. Once a file has been appended to using either append option, it can only be appended to using that append option.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param filePath The Data Lake Store path (starting with '/') of the file to which to append using concurrent append.
     * @param streamContents The file contents to include when appending to the file.
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> concurrentAppendAsync(String accountName, String filePath, byte[] streamContents) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlsFileSystemDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlsFileSystemDnsSuffix() is required and cannot be null.");
        }
        if (filePath == null) {
            throw new IllegalArgumentException("Parameter filePath is required and cannot be null.");
        }
        if (streamContents == null) {
            throw new IllegalArgumentException("Parameter streamContents is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String op = "CONCURRENTAPPEND";
        final String transferEncoding = "chunked";
        final AppendModeType appendMode = null;
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlsFileSystemDnsSuffix}", this.client.adlsFileSystemDnsSuffix());
        RequestBody streamContentsConverted = RequestBody.create(MediaType.parse("application/octet-stream"), streamContents);
        return service.concurrentAppend(filePath, streamContentsConverted, appendMode, op, transferEncoding, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = concurrentAppendDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Appends to the specified file. This method supports multiple concurrent appends to the file. NOTE: Concurrent append and normal (serial) append CANNOT be used interchangeably. Once a file has been appended to using either append option, it can only be appended to using that append option.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param filePath The Data Lake Store path (starting with '/') of the file to which to append using concurrent append.
     * @param streamContents The file contents to include when appending to the file.
     * @param appendMode Indicates the concurrent append call should create the file if it doesn't exist or just open the existing file for append. Possible values include: 'autocreate'
     * @throws AdlsErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public ServiceResponse<Void> concurrentAppend(String accountName, String filePath, byte[] streamContents, AppendModeType appendMode) throws AdlsErrorException, IOException, IllegalArgumentException {
        return concurrentAppendAsync(accountName, filePath, streamContents, appendMode).toBlocking().single();
    }

    /**
     * Appends to the specified file. This method supports multiple concurrent appends to the file. NOTE: Concurrent append and normal (serial) append CANNOT be used interchangeably. Once a file has been appended to using either append option, it can only be appended to using that append option.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param filePath The Data Lake Store path (starting with '/') of the file to which to append using concurrent append.
     * @param streamContents The file contents to include when appending to the file.
     * @param appendMode Indicates the concurrent append call should create the file if it doesn't exist or just open the existing file for append. Possible values include: 'autocreate'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> concurrentAppendAsync(String accountName, String filePath, byte[] streamContents, AppendModeType appendMode, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(concurrentAppendAsync(accountName, filePath, streamContents, appendMode), serviceCallback);
    }

    /**
     * Appends to the specified file. This method supports multiple concurrent appends to the file. NOTE: Concurrent append and normal (serial) append CANNOT be used interchangeably. Once a file has been appended to using either append option, it can only be appended to using that append option.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param filePath The Data Lake Store path (starting with '/') of the file to which to append using concurrent append.
     * @param streamContents The file contents to include when appending to the file.
     * @param appendMode Indicates the concurrent append call should create the file if it doesn't exist or just open the existing file for append. Possible values include: 'autocreate'
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> concurrentAppendAsync(String accountName, String filePath, byte[] streamContents, AppendModeType appendMode) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlsFileSystemDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlsFileSystemDnsSuffix() is required and cannot be null.");
        }
        if (filePath == null) {
            throw new IllegalArgumentException("Parameter filePath is required and cannot be null.");
        }
        if (streamContents == null) {
            throw new IllegalArgumentException("Parameter streamContents is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String op = "CONCURRENTAPPEND";
        final String transferEncoding = "chunked";
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlsFileSystemDnsSuffix}", this.client.adlsFileSystemDnsSuffix());
        RequestBody streamContentsConverted = RequestBody.create(MediaType.parse("application/octet-stream"), streamContents);
        return service.concurrentAppend(filePath, streamContentsConverted, appendMode, op, transferEncoding, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = concurrentAppendDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> concurrentAppendDelegate(Response<ResponseBody> response) throws AdlsErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Void, AdlsErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(AdlsErrorException.class)
                .build(response);
    }

    /**
     * Checks if the specified access is available at the given path.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param path The Data Lake Store path (starting with '/') of the file or directory for which to check access.
     * @throws AdlsErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public ServiceResponse<Void> checkAccess(String accountName, String path) throws AdlsErrorException, IOException, IllegalArgumentException {
        return checkAccessAsync(accountName, path).toBlocking().single();
    }

    /**
     * Checks if the specified access is available at the given path.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param path The Data Lake Store path (starting with '/') of the file or directory for which to check access.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> checkAccessAsync(String accountName, String path, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(checkAccessAsync(accountName, path), serviceCallback);
    }

    /**
     * Checks if the specified access is available at the given path.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param path The Data Lake Store path (starting with '/') of the file or directory for which to check access.
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> checkAccessAsync(String accountName, String path) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlsFileSystemDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlsFileSystemDnsSuffix() is required and cannot be null.");
        }
        if (path == null) {
            throw new IllegalArgumentException("Parameter path is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String op = "CHECKACCESS";
        final String fsaction = null;
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlsFileSystemDnsSuffix}", this.client.adlsFileSystemDnsSuffix());
        return service.checkAccess(path, fsaction, op, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = checkAccessDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Checks if the specified access is available at the given path.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param path The Data Lake Store path (starting with '/') of the file or directory for which to check access.
     * @param fsaction File system operation read/write/execute in string form, matching regex pattern '[rwx-]{3}'
     * @throws AdlsErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public ServiceResponse<Void> checkAccess(String accountName, String path, String fsaction) throws AdlsErrorException, IOException, IllegalArgumentException {
        return checkAccessAsync(accountName, path, fsaction).toBlocking().single();
    }

    /**
     * Checks if the specified access is available at the given path.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param path The Data Lake Store path (starting with '/') of the file or directory for which to check access.
     * @param fsaction File system operation read/write/execute in string form, matching regex pattern '[rwx-]{3}'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> checkAccessAsync(String accountName, String path, String fsaction, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(checkAccessAsync(accountName, path, fsaction), serviceCallback);
    }

    /**
     * Checks if the specified access is available at the given path.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param path The Data Lake Store path (starting with '/') of the file or directory for which to check access.
     * @param fsaction File system operation read/write/execute in string form, matching regex pattern '[rwx-]{3}'
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> checkAccessAsync(String accountName, String path, String fsaction) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlsFileSystemDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlsFileSystemDnsSuffix() is required and cannot be null.");
        }
        if (path == null) {
            throw new IllegalArgumentException("Parameter path is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String op = "CHECKACCESS";
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlsFileSystemDnsSuffix}", this.client.adlsFileSystemDnsSuffix());
        return service.checkAccess(path, fsaction, op, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = checkAccessDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> checkAccessDelegate(Response<ResponseBody> response) throws AdlsErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Void, AdlsErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(AdlsErrorException.class)
                .build(response);
    }

    /**
     * Creates a directory.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param path The Data Lake Store path (starting with '/') of the directory to create.
     * @throws AdlsErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the FileOperationResult object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<FileOperationResult> mkdirs(String accountName, String path) throws AdlsErrorException, IOException, IllegalArgumentException {
        return mkdirsAsync(accountName, path).toBlocking().single();
    }

    /**
     * Creates a directory.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param path The Data Lake Store path (starting with '/') of the directory to create.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<FileOperationResult> mkdirsAsync(String accountName, String path, final ServiceCallback<FileOperationResult> serviceCallback) {
        return ServiceCall.create(mkdirsAsync(accountName, path), serviceCallback);
    }

    /**
     * Creates a directory.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param path The Data Lake Store path (starting with '/') of the directory to create.
     * @return the observable to the FileOperationResult object
     */
    public Observable<ServiceResponse<FileOperationResult>> mkdirsAsync(String accountName, String path) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlsFileSystemDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlsFileSystemDnsSuffix() is required and cannot be null.");
        }
        if (path == null) {
            throw new IllegalArgumentException("Parameter path is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String op = "MKDIRS";
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlsFileSystemDnsSuffix}", this.client.adlsFileSystemDnsSuffix());
        return service.mkdirs(path, op, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<FileOperationResult>>>() {
                @Override
                public Observable<ServiceResponse<FileOperationResult>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<FileOperationResult> clientResponse = mkdirsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<FileOperationResult> mkdirsDelegate(Response<ResponseBody> response) throws AdlsErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<FileOperationResult, AdlsErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<FileOperationResult>() { }.getType())
                .registerError(AdlsErrorException.class)
                .build(response);
    }

    /**
     * Concatenates the list of source files into the destination file, removing all source files upon success.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param destinationPath The Data Lake Store path (starting with '/') of the destination file resulting from the concatenation.
     * @param sources A list of comma seperated Data Lake Store paths (starting with '/') of the files to concatenate, in the order in which they should be concatenated.
     * @throws AdlsErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public ServiceResponse<Void> concat(String accountName, String destinationPath, List<String> sources) throws AdlsErrorException, IOException, IllegalArgumentException {
        return concatAsync(accountName, destinationPath, sources).toBlocking().single();
    }

    /**
     * Concatenates the list of source files into the destination file, removing all source files upon success.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param destinationPath The Data Lake Store path (starting with '/') of the destination file resulting from the concatenation.
     * @param sources A list of comma seperated Data Lake Store paths (starting with '/') of the files to concatenate, in the order in which they should be concatenated.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> concatAsync(String accountName, String destinationPath, List<String> sources, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(concatAsync(accountName, destinationPath, sources), serviceCallback);
    }

    /**
     * Concatenates the list of source files into the destination file, removing all source files upon success.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param destinationPath The Data Lake Store path (starting with '/') of the destination file resulting from the concatenation.
     * @param sources A list of comma seperated Data Lake Store paths (starting with '/') of the files to concatenate, in the order in which they should be concatenated.
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> concatAsync(String accountName, String destinationPath, List<String> sources) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlsFileSystemDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlsFileSystemDnsSuffix() is required and cannot be null.");
        }
        if (destinationPath == null) {
            throw new IllegalArgumentException("Parameter destinationPath is required and cannot be null.");
        }
        if (sources == null) {
            throw new IllegalArgumentException("Parameter sources is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(sources);
        final String op = "CONCAT";
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlsFileSystemDnsSuffix}", this.client.adlsFileSystemDnsSuffix());
        String sourcesConverted = this.client.mapperAdapter().serializeList(sources, CollectionFormat.CSV);
        return service.concat(destinationPath, sourcesConverted, op, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = concatDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> concatDelegate(Response<ResponseBody> response) throws AdlsErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Void, AdlsErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(AdlsErrorException.class)
                .build(response);
    }

    /**
     * Concatenates the list of source files into the destination file, deleting all source files upon success. This method accepts more source file paths than the Concat method. This method and the parameters it accepts are subject to change for usability in an upcoming version.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param msConcatDestinationPath The Data Lake Store path (starting with '/') of the destination file resulting from the concatenation.
     * @param streamContents A list of Data Lake Store paths (starting with '/') of the source files. Must be in the format: sources=&lt;comma separated list&gt;
     * @throws AdlsErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public ServiceResponse<Void> msConcat(String accountName, String msConcatDestinationPath, byte[] streamContents) throws AdlsErrorException, IOException, IllegalArgumentException {
        return msConcatAsync(accountName, msConcatDestinationPath, streamContents).toBlocking().single();
    }

    /**
     * Concatenates the list of source files into the destination file, deleting all source files upon success. This method accepts more source file paths than the Concat method. This method and the parameters it accepts are subject to change for usability in an upcoming version.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param msConcatDestinationPath The Data Lake Store path (starting with '/') of the destination file resulting from the concatenation.
     * @param streamContents A list of Data Lake Store paths (starting with '/') of the source files. Must be in the format: sources=&lt;comma separated list&gt;
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> msConcatAsync(String accountName, String msConcatDestinationPath, byte[] streamContents, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(msConcatAsync(accountName, msConcatDestinationPath, streamContents), serviceCallback);
    }

    /**
     * Concatenates the list of source files into the destination file, deleting all source files upon success. This method accepts more source file paths than the Concat method. This method and the parameters it accepts are subject to change for usability in an upcoming version.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param msConcatDestinationPath The Data Lake Store path (starting with '/') of the destination file resulting from the concatenation.
     * @param streamContents A list of Data Lake Store paths (starting with '/') of the source files. Must be in the format: sources=&lt;comma separated list&gt;
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> msConcatAsync(String accountName, String msConcatDestinationPath, byte[] streamContents) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlsFileSystemDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlsFileSystemDnsSuffix() is required and cannot be null.");
        }
        if (msConcatDestinationPath == null) {
            throw new IllegalArgumentException("Parameter msConcatDestinationPath is required and cannot be null.");
        }
        if (streamContents == null) {
            throw new IllegalArgumentException("Parameter streamContents is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String op = "MSCONCAT";
        final Boolean deleteSourceDirectory = null;
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlsFileSystemDnsSuffix}", this.client.adlsFileSystemDnsSuffix());
        RequestBody streamContentsConverted = RequestBody.create(MediaType.parse("application/octet-stream"), streamContents);
        return service.msConcat(msConcatDestinationPath, deleteSourceDirectory, streamContentsConverted, op, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = msConcatDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Concatenates the list of source files into the destination file, deleting all source files upon success. This method accepts more source file paths than the Concat method. This method and the parameters it accepts are subject to change for usability in an upcoming version.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param msConcatDestinationPath The Data Lake Store path (starting with '/') of the destination file resulting from the concatenation.
     * @param streamContents A list of Data Lake Store paths (starting with '/') of the source files. Must be in the format: sources=&lt;comma separated list&gt;
     * @param deleteSourceDirectory Indicates that as an optimization instead of deleting each individual source stream, delete the source stream folder if all streams are in the same folder instead. This results in a substantial performance improvement when the only streams in the folder are part of the concatenation operation. WARNING: This includes the deletion of any other files that are not source files. Only set this to true when source files are the only files in the source directory.
     * @throws AdlsErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public ServiceResponse<Void> msConcat(String accountName, String msConcatDestinationPath, byte[] streamContents, Boolean deleteSourceDirectory) throws AdlsErrorException, IOException, IllegalArgumentException {
        return msConcatAsync(accountName, msConcatDestinationPath, streamContents, deleteSourceDirectory).toBlocking().single();
    }

    /**
     * Concatenates the list of source files into the destination file, deleting all source files upon success. This method accepts more source file paths than the Concat method. This method and the parameters it accepts are subject to change for usability in an upcoming version.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param msConcatDestinationPath The Data Lake Store path (starting with '/') of the destination file resulting from the concatenation.
     * @param streamContents A list of Data Lake Store paths (starting with '/') of the source files. Must be in the format: sources=&lt;comma separated list&gt;
     * @param deleteSourceDirectory Indicates that as an optimization instead of deleting each individual source stream, delete the source stream folder if all streams are in the same folder instead. This results in a substantial performance improvement when the only streams in the folder are part of the concatenation operation. WARNING: This includes the deletion of any other files that are not source files. Only set this to true when source files are the only files in the source directory.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> msConcatAsync(String accountName, String msConcatDestinationPath, byte[] streamContents, Boolean deleteSourceDirectory, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(msConcatAsync(accountName, msConcatDestinationPath, streamContents, deleteSourceDirectory), serviceCallback);
    }

    /**
     * Concatenates the list of source files into the destination file, deleting all source files upon success. This method accepts more source file paths than the Concat method. This method and the parameters it accepts are subject to change for usability in an upcoming version.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param msConcatDestinationPath The Data Lake Store path (starting with '/') of the destination file resulting from the concatenation.
     * @param streamContents A list of Data Lake Store paths (starting with '/') of the source files. Must be in the format: sources=&lt;comma separated list&gt;
     * @param deleteSourceDirectory Indicates that as an optimization instead of deleting each individual source stream, delete the source stream folder if all streams are in the same folder instead. This results in a substantial performance improvement when the only streams in the folder are part of the concatenation operation. WARNING: This includes the deletion of any other files that are not source files. Only set this to true when source files are the only files in the source directory.
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> msConcatAsync(String accountName, String msConcatDestinationPath, byte[] streamContents, Boolean deleteSourceDirectory) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlsFileSystemDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlsFileSystemDnsSuffix() is required and cannot be null.");
        }
        if (msConcatDestinationPath == null) {
            throw new IllegalArgumentException("Parameter msConcatDestinationPath is required and cannot be null.");
        }
        if (streamContents == null) {
            throw new IllegalArgumentException("Parameter streamContents is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String op = "MSCONCAT";
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlsFileSystemDnsSuffix}", this.client.adlsFileSystemDnsSuffix());
        RequestBody streamContentsConverted = RequestBody.create(MediaType.parse("application/octet-stream"), streamContents);
        return service.msConcat(msConcatDestinationPath, deleteSourceDirectory, streamContentsConverted, op, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = msConcatDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> msConcatDelegate(Response<ResponseBody> response) throws AdlsErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Void, AdlsErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(AdlsErrorException.class)
                .build(response);
    }

    /**
     * Get the list of file status objects specified by the file path, with optional pagination parameters.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param listFilePath The Data Lake Store path (starting with '/') of the directory to list.
     * @throws AdlsErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the FileStatusesResult object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<FileStatusesResult> listFileStatus(String accountName, String listFilePath) throws AdlsErrorException, IOException, IllegalArgumentException {
        return listFileStatusAsync(accountName, listFilePath).toBlocking().single();
    }

    /**
     * Get the list of file status objects specified by the file path, with optional pagination parameters.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param listFilePath The Data Lake Store path (starting with '/') of the directory to list.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<FileStatusesResult> listFileStatusAsync(String accountName, String listFilePath, final ServiceCallback<FileStatusesResult> serviceCallback) {
        return ServiceCall.create(listFileStatusAsync(accountName, listFilePath), serviceCallback);
    }

    /**
     * Get the list of file status objects specified by the file path, with optional pagination parameters.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param listFilePath The Data Lake Store path (starting with '/') of the directory to list.
     * @return the observable to the FileStatusesResult object
     */
    public Observable<ServiceResponse<FileStatusesResult>> listFileStatusAsync(String accountName, String listFilePath) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlsFileSystemDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlsFileSystemDnsSuffix() is required and cannot be null.");
        }
        if (listFilePath == null) {
            throw new IllegalArgumentException("Parameter listFilePath is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String op = "MSLISTSTATUS";
        final Integer listSize = null;
        final String listAfter = null;
        final String listBefore = null;
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlsFileSystemDnsSuffix}", this.client.adlsFileSystemDnsSuffix());
        return service.listFileStatus(listFilePath, listSize, listAfter, listBefore, op, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<FileStatusesResult>>>() {
                @Override
                public Observable<ServiceResponse<FileStatusesResult>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<FileStatusesResult> clientResponse = listFileStatusDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get the list of file status objects specified by the file path, with optional pagination parameters.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param listFilePath The Data Lake Store path (starting with '/') of the directory to list.
     * @param listSize Gets or sets the number of items to return. Optional.
     * @param listAfter Gets or sets the item or lexographical index after which to begin returning results. For example, a file list of 'a','b','d' and listAfter='b' will return 'd', and a listAfter='c' will also return 'd'. Optional.
     * @param listBefore Gets or sets the item or lexographical index before which to begin returning results. For example, a file list of 'a','b','d' and listBefore='d' will return 'a','b', and a listBefore='c' will also return 'a','b'. Optional.
     * @throws AdlsErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the FileStatusesResult object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<FileStatusesResult> listFileStatus(String accountName, String listFilePath, Integer listSize, String listAfter, String listBefore) throws AdlsErrorException, IOException, IllegalArgumentException {
        return listFileStatusAsync(accountName, listFilePath, listSize, listAfter, listBefore).toBlocking().single();
    }

    /**
     * Get the list of file status objects specified by the file path, with optional pagination parameters.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param listFilePath The Data Lake Store path (starting with '/') of the directory to list.
     * @param listSize Gets or sets the number of items to return. Optional.
     * @param listAfter Gets or sets the item or lexographical index after which to begin returning results. For example, a file list of 'a','b','d' and listAfter='b' will return 'd', and a listAfter='c' will also return 'd'. Optional.
     * @param listBefore Gets or sets the item or lexographical index before which to begin returning results. For example, a file list of 'a','b','d' and listBefore='d' will return 'a','b', and a listBefore='c' will also return 'a','b'. Optional.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<FileStatusesResult> listFileStatusAsync(String accountName, String listFilePath, Integer listSize, String listAfter, String listBefore, final ServiceCallback<FileStatusesResult> serviceCallback) {
        return ServiceCall.create(listFileStatusAsync(accountName, listFilePath, listSize, listAfter, listBefore), serviceCallback);
    }

    /**
     * Get the list of file status objects specified by the file path, with optional pagination parameters.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param listFilePath The Data Lake Store path (starting with '/') of the directory to list.
     * @param listSize Gets or sets the number of items to return. Optional.
     * @param listAfter Gets or sets the item or lexographical index after which to begin returning results. For example, a file list of 'a','b','d' and listAfter='b' will return 'd', and a listAfter='c' will also return 'd'. Optional.
     * @param listBefore Gets or sets the item or lexographical index before which to begin returning results. For example, a file list of 'a','b','d' and listBefore='d' will return 'a','b', and a listBefore='c' will also return 'a','b'. Optional.
     * @return the observable to the FileStatusesResult object
     */
    public Observable<ServiceResponse<FileStatusesResult>> listFileStatusAsync(String accountName, String listFilePath, Integer listSize, String listAfter, String listBefore) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlsFileSystemDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlsFileSystemDnsSuffix() is required and cannot be null.");
        }
        if (listFilePath == null) {
            throw new IllegalArgumentException("Parameter listFilePath is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String op = "MSLISTSTATUS";
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlsFileSystemDnsSuffix}", this.client.adlsFileSystemDnsSuffix());
        return service.listFileStatus(listFilePath, listSize, listAfter, listBefore, op, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<FileStatusesResult>>>() {
                @Override
                public Observable<ServiceResponse<FileStatusesResult>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<FileStatusesResult> clientResponse = listFileStatusDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<FileStatusesResult> listFileStatusDelegate(Response<ResponseBody> response) throws AdlsErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<FileStatusesResult, AdlsErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<FileStatusesResult>() { }.getType())
                .registerError(AdlsErrorException.class)
                .build(response);
    }

    /**
     * Gets the file content summary object specified by the file path.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param getContentSummaryFilePath The Data Lake Store path (starting with '/') of the file for which to retrieve the summary.
     * @throws AdlsErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the ContentSummaryResult object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<ContentSummaryResult> getContentSummary(String accountName, String getContentSummaryFilePath) throws AdlsErrorException, IOException, IllegalArgumentException {
        return getContentSummaryAsync(accountName, getContentSummaryFilePath).toBlocking().single();
    }

    /**
     * Gets the file content summary object specified by the file path.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param getContentSummaryFilePath The Data Lake Store path (starting with '/') of the file for which to retrieve the summary.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<ContentSummaryResult> getContentSummaryAsync(String accountName, String getContentSummaryFilePath, final ServiceCallback<ContentSummaryResult> serviceCallback) {
        return ServiceCall.create(getContentSummaryAsync(accountName, getContentSummaryFilePath), serviceCallback);
    }

    /**
     * Gets the file content summary object specified by the file path.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param getContentSummaryFilePath The Data Lake Store path (starting with '/') of the file for which to retrieve the summary.
     * @return the observable to the ContentSummaryResult object
     */
    public Observable<ServiceResponse<ContentSummaryResult>> getContentSummaryAsync(String accountName, String getContentSummaryFilePath) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlsFileSystemDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlsFileSystemDnsSuffix() is required and cannot be null.");
        }
        if (getContentSummaryFilePath == null) {
            throw new IllegalArgumentException("Parameter getContentSummaryFilePath is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String op = "GETCONTENTSUMMARY";
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlsFileSystemDnsSuffix}", this.client.adlsFileSystemDnsSuffix());
        return service.getContentSummary(getContentSummaryFilePath, op, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ContentSummaryResult>>>() {
                @Override
                public Observable<ServiceResponse<ContentSummaryResult>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ContentSummaryResult> clientResponse = getContentSummaryDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ContentSummaryResult> getContentSummaryDelegate(Response<ResponseBody> response) throws AdlsErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<ContentSummaryResult, AdlsErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<ContentSummaryResult>() { }.getType())
                .registerError(AdlsErrorException.class)
                .build(response);
    }

    /**
     * Get the file status object specified by the file path.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param getFilePath The Data Lake Store path (starting with '/') of the file or directory for which to retrieve the status.
     * @throws AdlsErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the FileStatusResult object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<FileStatusResult> getFileStatus(String accountName, String getFilePath) throws AdlsErrorException, IOException, IllegalArgumentException {
        return getFileStatusAsync(accountName, getFilePath).toBlocking().single();
    }

    /**
     * Get the file status object specified by the file path.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param getFilePath The Data Lake Store path (starting with '/') of the file or directory for which to retrieve the status.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<FileStatusResult> getFileStatusAsync(String accountName, String getFilePath, final ServiceCallback<FileStatusResult> serviceCallback) {
        return ServiceCall.create(getFileStatusAsync(accountName, getFilePath), serviceCallback);
    }

    /**
     * Get the file status object specified by the file path.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param getFilePath The Data Lake Store path (starting with '/') of the file or directory for which to retrieve the status.
     * @return the observable to the FileStatusResult object
     */
    public Observable<ServiceResponse<FileStatusResult>> getFileStatusAsync(String accountName, String getFilePath) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlsFileSystemDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlsFileSystemDnsSuffix() is required and cannot be null.");
        }
        if (getFilePath == null) {
            throw new IllegalArgumentException("Parameter getFilePath is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String op = "GETFILESTATUS";
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlsFileSystemDnsSuffix}", this.client.adlsFileSystemDnsSuffix());
        return service.getFileStatus(getFilePath, op, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<FileStatusResult>>>() {
                @Override
                public Observable<ServiceResponse<FileStatusResult>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<FileStatusResult> clientResponse = getFileStatusDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<FileStatusResult> getFileStatusDelegate(Response<ResponseBody> response) throws AdlsErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<FileStatusResult, AdlsErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<FileStatusResult>() { }.getType())
                .registerError(AdlsErrorException.class)
                .build(response);
    }

    /**
     * Appends to the specified file. This method does not support multiple concurrent appends to the file. NOTE: Concurrent append and normal (serial) append CANNOT be used interchangeably. Once a file has been appended to using either append option, it can only be appended to using that append option. Use the ConcurrentAppend option if you would like support for concurrent appends.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param directFilePath The Data Lake Store path (starting with '/') of the file to which to append.
     * @param streamContents The file contents to include when appending to the file.
     * @throws AdlsErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public ServiceResponse<Void> append(String accountName, String directFilePath, byte[] streamContents) throws AdlsErrorException, IOException, IllegalArgumentException {
        return appendAsync(accountName, directFilePath, streamContents).toBlocking().single();
    }

    /**
     * Appends to the specified file. This method does not support multiple concurrent appends to the file. NOTE: Concurrent append and normal (serial) append CANNOT be used interchangeably. Once a file has been appended to using either append option, it can only be appended to using that append option. Use the ConcurrentAppend option if you would like support for concurrent appends.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param directFilePath The Data Lake Store path (starting with '/') of the file to which to append.
     * @param streamContents The file contents to include when appending to the file.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> appendAsync(String accountName, String directFilePath, byte[] streamContents, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(appendAsync(accountName, directFilePath, streamContents), serviceCallback);
    }

    /**
     * Appends to the specified file. This method does not support multiple concurrent appends to the file. NOTE: Concurrent append and normal (serial) append CANNOT be used interchangeably. Once a file has been appended to using either append option, it can only be appended to using that append option. Use the ConcurrentAppend option if you would like support for concurrent appends.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param directFilePath The Data Lake Store path (starting with '/') of the file to which to append.
     * @param streamContents The file contents to include when appending to the file.
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> appendAsync(String accountName, String directFilePath, byte[] streamContents) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlsFileSystemDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlsFileSystemDnsSuffix() is required and cannot be null.");
        }
        if (directFilePath == null) {
            throw new IllegalArgumentException("Parameter directFilePath is required and cannot be null.");
        }
        if (streamContents == null) {
            throw new IllegalArgumentException("Parameter streamContents is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String op = "APPEND";
        final String append = "true";
        final String transferEncoding = "chunked";
        final Long offset = null;
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlsFileSystemDnsSuffix}", this.client.adlsFileSystemDnsSuffix());
        RequestBody streamContentsConverted = RequestBody.create(MediaType.parse("application/octet-stream"), streamContents);
        return service.append(directFilePath, streamContentsConverted, offset, op, append, transferEncoding, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = appendDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Appends to the specified file. This method does not support multiple concurrent appends to the file. NOTE: Concurrent append and normal (serial) append CANNOT be used interchangeably. Once a file has been appended to using either append option, it can only be appended to using that append option. Use the ConcurrentAppend option if you would like support for concurrent appends.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param directFilePath The Data Lake Store path (starting with '/') of the file to which to append.
     * @param streamContents The file contents to include when appending to the file.
     * @param offset The optional offset in the stream to begin the append operation. Default is to append at the end of the stream.
     * @throws AdlsErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public ServiceResponse<Void> append(String accountName, String directFilePath, byte[] streamContents, Long offset) throws AdlsErrorException, IOException, IllegalArgumentException {
        return appendAsync(accountName, directFilePath, streamContents, offset).toBlocking().single();
    }

    /**
     * Appends to the specified file. This method does not support multiple concurrent appends to the file. NOTE: Concurrent append and normal (serial) append CANNOT be used interchangeably. Once a file has been appended to using either append option, it can only be appended to using that append option. Use the ConcurrentAppend option if you would like support for concurrent appends.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param directFilePath The Data Lake Store path (starting with '/') of the file to which to append.
     * @param streamContents The file contents to include when appending to the file.
     * @param offset The optional offset in the stream to begin the append operation. Default is to append at the end of the stream.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> appendAsync(String accountName, String directFilePath, byte[] streamContents, Long offset, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(appendAsync(accountName, directFilePath, streamContents, offset), serviceCallback);
    }

    /**
     * Appends to the specified file. This method does not support multiple concurrent appends to the file. NOTE: Concurrent append and normal (serial) append CANNOT be used interchangeably. Once a file has been appended to using either append option, it can only be appended to using that append option. Use the ConcurrentAppend option if you would like support for concurrent appends.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param directFilePath The Data Lake Store path (starting with '/') of the file to which to append.
     * @param streamContents The file contents to include when appending to the file.
     * @param offset The optional offset in the stream to begin the append operation. Default is to append at the end of the stream.
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> appendAsync(String accountName, String directFilePath, byte[] streamContents, Long offset) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlsFileSystemDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlsFileSystemDnsSuffix() is required and cannot be null.");
        }
        if (directFilePath == null) {
            throw new IllegalArgumentException("Parameter directFilePath is required and cannot be null.");
        }
        if (streamContents == null) {
            throw new IllegalArgumentException("Parameter streamContents is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String op = "APPEND";
        final String append = "true";
        final String transferEncoding = "chunked";
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlsFileSystemDnsSuffix}", this.client.adlsFileSystemDnsSuffix());
        RequestBody streamContentsConverted = RequestBody.create(MediaType.parse("application/octet-stream"), streamContents);
        return service.append(directFilePath, streamContentsConverted, offset, op, append, transferEncoding, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = appendDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> appendDelegate(Response<ResponseBody> response) throws AdlsErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Void, AdlsErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(AdlsErrorException.class)
                .build(response);
    }

    /**
     * Creates a file with optionally specified content.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param directFilePath The Data Lake Store path (starting with '/') of the file to create.
     * @throws AdlsErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public ServiceResponse<Void> create(String accountName, String directFilePath) throws AdlsErrorException, IOException, IllegalArgumentException {
        return createAsync(accountName, directFilePath).toBlocking().single();
    }

    /**
     * Creates a file with optionally specified content.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param directFilePath The Data Lake Store path (starting with '/') of the file to create.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> createAsync(String accountName, String directFilePath, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(createAsync(accountName, directFilePath), serviceCallback);
    }

    /**
     * Creates a file with optionally specified content.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param directFilePath The Data Lake Store path (starting with '/') of the file to create.
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> createAsync(String accountName, String directFilePath) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlsFileSystemDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlsFileSystemDnsSuffix() is required and cannot be null.");
        }
        if (directFilePath == null) {
            throw new IllegalArgumentException("Parameter directFilePath is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String op = "CREATE";
        final String write = "true";
        final String transferEncoding = "chunked";
        final byte[] streamContents = new byte[0];
        final Boolean overwrite = null;
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlsFileSystemDnsSuffix}", this.client.adlsFileSystemDnsSuffix());
        RequestBody streamContentsConverted = RequestBody.create(MediaType.parse("application/octet-stream"), new byte[0]);
        if (streamContents != null) {
            streamContentsConverted = RequestBody.create(MediaType.parse("application/octet-stream"), streamContents);
        }
        return service.create(directFilePath, streamContentsConverted, overwrite, op, write, transferEncoding, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = createDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Creates a file with optionally specified content.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param directFilePath The Data Lake Store path (starting with '/') of the file to create.
     * @param streamContents The file contents to include when creating the file. This parameter is optional, resulting in an empty file if not specified.
     * @param overwrite The indication of if the file should be overwritten.
     * @throws AdlsErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public ServiceResponse<Void> create(String accountName, String directFilePath, byte[] streamContents, Boolean overwrite) throws AdlsErrorException, IOException, IllegalArgumentException {
        return createAsync(accountName, directFilePath, streamContents, overwrite).toBlocking().single();
    }

    /**
     * Creates a file with optionally specified content.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param directFilePath The Data Lake Store path (starting with '/') of the file to create.
     * @param streamContents The file contents to include when creating the file. This parameter is optional, resulting in an empty file if not specified.
     * @param overwrite The indication of if the file should be overwritten.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> createAsync(String accountName, String directFilePath, byte[] streamContents, Boolean overwrite, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(createAsync(accountName, directFilePath, streamContents, overwrite), serviceCallback);
    }

    /**
     * Creates a file with optionally specified content.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param directFilePath The Data Lake Store path (starting with '/') of the file to create.
     * @param streamContents The file contents to include when creating the file. This parameter is optional, resulting in an empty file if not specified.
     * @param overwrite The indication of if the file should be overwritten.
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> createAsync(String accountName, String directFilePath, byte[] streamContents, Boolean overwrite) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlsFileSystemDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlsFileSystemDnsSuffix() is required and cannot be null.");
        }
        if (directFilePath == null) {
            throw new IllegalArgumentException("Parameter directFilePath is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String op = "CREATE";
        final String write = "true";
        final String transferEncoding = "chunked";
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlsFileSystemDnsSuffix}", this.client.adlsFileSystemDnsSuffix());
        RequestBody streamContentsConverted = RequestBody.create(MediaType.parse("application/octet-stream"), new byte[0]);
        if (streamContents != null) {
            streamContentsConverted = RequestBody.create(MediaType.parse("application/octet-stream"), streamContents);
        }
        return service.create(directFilePath, streamContentsConverted, overwrite, op, write, transferEncoding, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = createDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> createDelegate(Response<ResponseBody> response) throws AdlsErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Void, AdlsErrorException>(this.client.mapperAdapter())
                .register(201, new TypeToken<Void>() { }.getType())
                .registerError(AdlsErrorException.class)
                .build(response);
    }

    /**
     * Opens and reads from the specified file.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param directFilePath The Data Lake Store path (starting with '/') of the file to open.
     * @throws AdlsErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the InputStream object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<InputStream> open(String accountName, String directFilePath) throws AdlsErrorException, IOException, IllegalArgumentException {
        return openAsync(accountName, directFilePath).toBlocking().single();
    }

    /**
     * Opens and reads from the specified file.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param directFilePath The Data Lake Store path (starting with '/') of the file to open.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<InputStream> openAsync(String accountName, String directFilePath, final ServiceCallback<InputStream> serviceCallback) {
        return ServiceCall.create(openAsync(accountName, directFilePath), serviceCallback);
    }

    /**
     * Opens and reads from the specified file.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param directFilePath The Data Lake Store path (starting with '/') of the file to open.
     * @return the observable to the InputStream object
     */
    public Observable<ServiceResponse<InputStream>> openAsync(String accountName, String directFilePath) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlsFileSystemDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlsFileSystemDnsSuffix() is required and cannot be null.");
        }
        if (directFilePath == null) {
            throw new IllegalArgumentException("Parameter directFilePath is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String op = "OPEN";
        final String read = "true";
        final Long length = null;
        final Long offset = null;
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlsFileSystemDnsSuffix}", this.client.adlsFileSystemDnsSuffix());
        return service.open(directFilePath, length, offset, op, read, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<InputStream>>>() {
                @Override
                public Observable<ServiceResponse<InputStream>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<InputStream> clientResponse = openDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Opens and reads from the specified file.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param directFilePath The Data Lake Store path (starting with '/') of the file to open.
     * @param length the Long value
     * @param offset the Long value
     * @throws AdlsErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the InputStream object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<InputStream> open(String accountName, String directFilePath, Long length, Long offset) throws AdlsErrorException, IOException, IllegalArgumentException {
        return openAsync(accountName, directFilePath, length, offset).toBlocking().single();
    }

    /**
     * Opens and reads from the specified file.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param directFilePath The Data Lake Store path (starting with '/') of the file to open.
     * @param length the Long value
     * @param offset the Long value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<InputStream> openAsync(String accountName, String directFilePath, Long length, Long offset, final ServiceCallback<InputStream> serviceCallback) {
        return ServiceCall.create(openAsync(accountName, directFilePath, length, offset), serviceCallback);
    }

    /**
     * Opens and reads from the specified file.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param directFilePath The Data Lake Store path (starting with '/') of the file to open.
     * @param length the Long value
     * @param offset the Long value
     * @return the observable to the InputStream object
     */
    public Observable<ServiceResponse<InputStream>> openAsync(String accountName, String directFilePath, Long length, Long offset) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlsFileSystemDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlsFileSystemDnsSuffix() is required and cannot be null.");
        }
        if (directFilePath == null) {
            throw new IllegalArgumentException("Parameter directFilePath is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String op = "OPEN";
        final String read = "true";
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlsFileSystemDnsSuffix}", this.client.adlsFileSystemDnsSuffix());
        return service.open(directFilePath, length, offset, op, read, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<InputStream>>>() {
                @Override
                public Observable<ServiceResponse<InputStream>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<InputStream> clientResponse = openDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<InputStream> openDelegate(Response<ResponseBody> response) throws AdlsErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<InputStream, AdlsErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<InputStream>() { }.getType())
                .registerError(AdlsErrorException.class)
                .build(response);
    }

    /**
     * Sets the Access Control List (ACL) for a file or folder.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param setAclFilePath The Data Lake Store path (starting with '/') of the file or directory on which to set the ACL.
     * @param aclspec The ACL spec included in ACL creation operations in the format '[default:]user|group|other::r|-w|-x|-'
     * @throws AdlsErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public ServiceResponse<Void> setAcl(String accountName, String setAclFilePath, String aclspec) throws AdlsErrorException, IOException, IllegalArgumentException {
        return setAclAsync(accountName, setAclFilePath, aclspec).toBlocking().single();
    }

    /**
     * Sets the Access Control List (ACL) for a file or folder.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param setAclFilePath The Data Lake Store path (starting with '/') of the file or directory on which to set the ACL.
     * @param aclspec The ACL spec included in ACL creation operations in the format '[default:]user|group|other::r|-w|-x|-'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> setAclAsync(String accountName, String setAclFilePath, String aclspec, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(setAclAsync(accountName, setAclFilePath, aclspec), serviceCallback);
    }

    /**
     * Sets the Access Control List (ACL) for a file or folder.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param setAclFilePath The Data Lake Store path (starting with '/') of the file or directory on which to set the ACL.
     * @param aclspec The ACL spec included in ACL creation operations in the format '[default:]user|group|other::r|-w|-x|-'
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> setAclAsync(String accountName, String setAclFilePath, String aclspec) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlsFileSystemDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlsFileSystemDnsSuffix() is required and cannot be null.");
        }
        if (setAclFilePath == null) {
            throw new IllegalArgumentException("Parameter setAclFilePath is required and cannot be null.");
        }
        if (aclspec == null) {
            throw new IllegalArgumentException("Parameter aclspec is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String op = "SETACL";
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlsFileSystemDnsSuffix}", this.client.adlsFileSystemDnsSuffix());
        return service.setAcl(setAclFilePath, aclspec, op, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = setAclDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> setAclDelegate(Response<ResponseBody> response) throws AdlsErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Void, AdlsErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(AdlsErrorException.class)
                .build(response);
    }

    /**
     * Modifies existing Access Control List (ACL) entries on a file or folder.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param modifyAclFilePath The Data Lake Store path (starting with '/') of the file or directory with the ACL being modified.
     * @param aclspec The ACL specification included in ACL modification operations in the format '[default:]user|group|other::r|-w|-x|-'
     * @throws AdlsErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public ServiceResponse<Void> modifyAclEntries(String accountName, String modifyAclFilePath, String aclspec) throws AdlsErrorException, IOException, IllegalArgumentException {
        return modifyAclEntriesAsync(accountName, modifyAclFilePath, aclspec).toBlocking().single();
    }

    /**
     * Modifies existing Access Control List (ACL) entries on a file or folder.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param modifyAclFilePath The Data Lake Store path (starting with '/') of the file or directory with the ACL being modified.
     * @param aclspec The ACL specification included in ACL modification operations in the format '[default:]user|group|other::r|-w|-x|-'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> modifyAclEntriesAsync(String accountName, String modifyAclFilePath, String aclspec, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(modifyAclEntriesAsync(accountName, modifyAclFilePath, aclspec), serviceCallback);
    }

    /**
     * Modifies existing Access Control List (ACL) entries on a file or folder.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param modifyAclFilePath The Data Lake Store path (starting with '/') of the file or directory with the ACL being modified.
     * @param aclspec The ACL specification included in ACL modification operations in the format '[default:]user|group|other::r|-w|-x|-'
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> modifyAclEntriesAsync(String accountName, String modifyAclFilePath, String aclspec) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlsFileSystemDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlsFileSystemDnsSuffix() is required and cannot be null.");
        }
        if (modifyAclFilePath == null) {
            throw new IllegalArgumentException("Parameter modifyAclFilePath is required and cannot be null.");
        }
        if (aclspec == null) {
            throw new IllegalArgumentException("Parameter aclspec is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String op = "MODIFYACLENTRIES";
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlsFileSystemDnsSuffix}", this.client.adlsFileSystemDnsSuffix());
        return service.modifyAclEntries(modifyAclFilePath, aclspec, op, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = modifyAclEntriesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> modifyAclEntriesDelegate(Response<ResponseBody> response) throws AdlsErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Void, AdlsErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(AdlsErrorException.class)
                .build(response);
    }

    /**
     * Removes existing Access Control List (ACL) entries for a file or folder.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param removeAclFilePath The Data Lake Store path (starting with '/') of the file or directory with the ACL being removed.
     * @param aclspec The ACL spec included in ACL removal operations in the format '[default:]user|group|other'
     * @throws AdlsErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public ServiceResponse<Void> removeAclEntries(String accountName, String removeAclFilePath, String aclspec) throws AdlsErrorException, IOException, IllegalArgumentException {
        return removeAclEntriesAsync(accountName, removeAclFilePath, aclspec).toBlocking().single();
    }

    /**
     * Removes existing Access Control List (ACL) entries for a file or folder.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param removeAclFilePath The Data Lake Store path (starting with '/') of the file or directory with the ACL being removed.
     * @param aclspec The ACL spec included in ACL removal operations in the format '[default:]user|group|other'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> removeAclEntriesAsync(String accountName, String removeAclFilePath, String aclspec, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(removeAclEntriesAsync(accountName, removeAclFilePath, aclspec), serviceCallback);
    }

    /**
     * Removes existing Access Control List (ACL) entries for a file or folder.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param removeAclFilePath The Data Lake Store path (starting with '/') of the file or directory with the ACL being removed.
     * @param aclspec The ACL spec included in ACL removal operations in the format '[default:]user|group|other'
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> removeAclEntriesAsync(String accountName, String removeAclFilePath, String aclspec) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlsFileSystemDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlsFileSystemDnsSuffix() is required and cannot be null.");
        }
        if (removeAclFilePath == null) {
            throw new IllegalArgumentException("Parameter removeAclFilePath is required and cannot be null.");
        }
        if (aclspec == null) {
            throw new IllegalArgumentException("Parameter aclspec is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String op = "REMOVEACLENTRIES";
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlsFileSystemDnsSuffix}", this.client.adlsFileSystemDnsSuffix());
        return service.removeAclEntries(removeAclFilePath, aclspec, op, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = removeAclEntriesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> removeAclEntriesDelegate(Response<ResponseBody> response) throws AdlsErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Void, AdlsErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(AdlsErrorException.class)
                .build(response);
    }

    /**
     * Gets Access Control List (ACL) entries for the specified file or directory.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param aclFilePath The Data Lake Store path (starting with '/') of the file or directory for which to get the ACL.
     * @throws AdlsErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the AclStatusResult object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<AclStatusResult> getAclStatus(String accountName, String aclFilePath) throws AdlsErrorException, IOException, IllegalArgumentException {
        return getAclStatusAsync(accountName, aclFilePath).toBlocking().single();
    }

    /**
     * Gets Access Control List (ACL) entries for the specified file or directory.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param aclFilePath The Data Lake Store path (starting with '/') of the file or directory for which to get the ACL.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<AclStatusResult> getAclStatusAsync(String accountName, String aclFilePath, final ServiceCallback<AclStatusResult> serviceCallback) {
        return ServiceCall.create(getAclStatusAsync(accountName, aclFilePath), serviceCallback);
    }

    /**
     * Gets Access Control List (ACL) entries for the specified file or directory.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param aclFilePath The Data Lake Store path (starting with '/') of the file or directory for which to get the ACL.
     * @return the observable to the AclStatusResult object
     */
    public Observable<ServiceResponse<AclStatusResult>> getAclStatusAsync(String accountName, String aclFilePath) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlsFileSystemDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlsFileSystemDnsSuffix() is required and cannot be null.");
        }
        if (aclFilePath == null) {
            throw new IllegalArgumentException("Parameter aclFilePath is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String op = "GETACLSTATUS";
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlsFileSystemDnsSuffix}", this.client.adlsFileSystemDnsSuffix());
        return service.getAclStatus(aclFilePath, op, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<AclStatusResult>>>() {
                @Override
                public Observable<ServiceResponse<AclStatusResult>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<AclStatusResult> clientResponse = getAclStatusDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<AclStatusResult> getAclStatusDelegate(Response<ResponseBody> response) throws AdlsErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<AclStatusResult, AdlsErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<AclStatusResult>() { }.getType())
                .registerError(AdlsErrorException.class)
                .build(response);
    }

    /**
     * Deletes the requested file or directory, optionally recursively.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param filePath The Data Lake Store path (starting with '/') of the file or directory to delete.
     * @throws AdlsErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the FileOperationResult object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<FileOperationResult> delete(String accountName, String filePath) throws AdlsErrorException, IOException, IllegalArgumentException {
        return deleteAsync(accountName, filePath).toBlocking().single();
    }

    /**
     * Deletes the requested file or directory, optionally recursively.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param filePath The Data Lake Store path (starting with '/') of the file or directory to delete.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<FileOperationResult> deleteAsync(String accountName, String filePath, final ServiceCallback<FileOperationResult> serviceCallback) {
        return ServiceCall.create(deleteAsync(accountName, filePath), serviceCallback);
    }

    /**
     * Deletes the requested file or directory, optionally recursively.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param filePath The Data Lake Store path (starting with '/') of the file or directory to delete.
     * @return the observable to the FileOperationResult object
     */
    public Observable<ServiceResponse<FileOperationResult>> deleteAsync(String accountName, String filePath) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlsFileSystemDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlsFileSystemDnsSuffix() is required and cannot be null.");
        }
        if (filePath == null) {
            throw new IllegalArgumentException("Parameter filePath is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String op = "DELETE";
        final Boolean recursive = null;
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlsFileSystemDnsSuffix}", this.client.adlsFileSystemDnsSuffix());
        return service.delete(filePath, recursive, op, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<FileOperationResult>>>() {
                @Override
                public Observable<ServiceResponse<FileOperationResult>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<FileOperationResult> clientResponse = deleteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Deletes the requested file or directory, optionally recursively.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param filePath The Data Lake Store path (starting with '/') of the file or directory to delete.
     * @param recursive The optional switch indicating if the delete should be recursive
     * @throws AdlsErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the FileOperationResult object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<FileOperationResult> delete(String accountName, String filePath, Boolean recursive) throws AdlsErrorException, IOException, IllegalArgumentException {
        return deleteAsync(accountName, filePath, recursive).toBlocking().single();
    }

    /**
     * Deletes the requested file or directory, optionally recursively.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param filePath The Data Lake Store path (starting with '/') of the file or directory to delete.
     * @param recursive The optional switch indicating if the delete should be recursive
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<FileOperationResult> deleteAsync(String accountName, String filePath, Boolean recursive, final ServiceCallback<FileOperationResult> serviceCallback) {
        return ServiceCall.create(deleteAsync(accountName, filePath, recursive), serviceCallback);
    }

    /**
     * Deletes the requested file or directory, optionally recursively.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param filePath The Data Lake Store path (starting with '/') of the file or directory to delete.
     * @param recursive The optional switch indicating if the delete should be recursive
     * @return the observable to the FileOperationResult object
     */
    public Observable<ServiceResponse<FileOperationResult>> deleteAsync(String accountName, String filePath, Boolean recursive) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlsFileSystemDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlsFileSystemDnsSuffix() is required and cannot be null.");
        }
        if (filePath == null) {
            throw new IllegalArgumentException("Parameter filePath is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String op = "DELETE";
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlsFileSystemDnsSuffix}", this.client.adlsFileSystemDnsSuffix());
        return service.delete(filePath, recursive, op, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<FileOperationResult>>>() {
                @Override
                public Observable<ServiceResponse<FileOperationResult>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<FileOperationResult> clientResponse = deleteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<FileOperationResult> deleteDelegate(Response<ResponseBody> response) throws AdlsErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<FileOperationResult, AdlsErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<FileOperationResult>() { }.getType())
                .registerError(AdlsErrorException.class)
                .build(response);
    }

    /**
     * Rename a file or directory.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param renameFilePath The Data Lake Store path (starting with '/') of the file or directory to move/rename.
     * @param destination The path to move/rename the file or folder to
     * @throws AdlsErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the FileOperationResult object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<FileOperationResult> rename(String accountName, String renameFilePath, String destination) throws AdlsErrorException, IOException, IllegalArgumentException {
        return renameAsync(accountName, renameFilePath, destination).toBlocking().single();
    }

    /**
     * Rename a file or directory.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param renameFilePath The Data Lake Store path (starting with '/') of the file or directory to move/rename.
     * @param destination The path to move/rename the file or folder to
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<FileOperationResult> renameAsync(String accountName, String renameFilePath, String destination, final ServiceCallback<FileOperationResult> serviceCallback) {
        return ServiceCall.create(renameAsync(accountName, renameFilePath, destination), serviceCallback);
    }

    /**
     * Rename a file or directory.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param renameFilePath The Data Lake Store path (starting with '/') of the file or directory to move/rename.
     * @param destination The path to move/rename the file or folder to
     * @return the observable to the FileOperationResult object
     */
    public Observable<ServiceResponse<FileOperationResult>> renameAsync(String accountName, String renameFilePath, String destination) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlsFileSystemDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlsFileSystemDnsSuffix() is required and cannot be null.");
        }
        if (renameFilePath == null) {
            throw new IllegalArgumentException("Parameter renameFilePath is required and cannot be null.");
        }
        if (destination == null) {
            throw new IllegalArgumentException("Parameter destination is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String op = "RENAME";
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlsFileSystemDnsSuffix}", this.client.adlsFileSystemDnsSuffix());
        return service.rename(renameFilePath, destination, op, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<FileOperationResult>>>() {
                @Override
                public Observable<ServiceResponse<FileOperationResult>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<FileOperationResult> clientResponse = renameDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<FileOperationResult> renameDelegate(Response<ResponseBody> response) throws AdlsErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<FileOperationResult, AdlsErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<FileOperationResult>() { }.getType())
                .registerError(AdlsErrorException.class)
                .build(response);
    }

    /**
     * Sets the owner of a file or directory.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param setOwnerFilePath The Data Lake Store path (starting with '/') of the file or directory for which to set the owner.
     * @throws AdlsErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public ServiceResponse<Void> setOwner(String accountName, String setOwnerFilePath) throws AdlsErrorException, IOException, IllegalArgumentException {
        return setOwnerAsync(accountName, setOwnerFilePath).toBlocking().single();
    }

    /**
     * Sets the owner of a file or directory.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param setOwnerFilePath The Data Lake Store path (starting with '/') of the file or directory for which to set the owner.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> setOwnerAsync(String accountName, String setOwnerFilePath, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(setOwnerAsync(accountName, setOwnerFilePath), serviceCallback);
    }

    /**
     * Sets the owner of a file or directory.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param setOwnerFilePath The Data Lake Store path (starting with '/') of the file or directory for which to set the owner.
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> setOwnerAsync(String accountName, String setOwnerFilePath) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlsFileSystemDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlsFileSystemDnsSuffix() is required and cannot be null.");
        }
        if (setOwnerFilePath == null) {
            throw new IllegalArgumentException("Parameter setOwnerFilePath is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String op = "SETOWNER";
        final String owner = null;
        final String group = null;
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlsFileSystemDnsSuffix}", this.client.adlsFileSystemDnsSuffix());
        return service.setOwner(setOwnerFilePath, owner, group, op, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = setOwnerDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Sets the owner of a file or directory.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param setOwnerFilePath The Data Lake Store path (starting with '/') of the file or directory for which to set the owner.
     * @param owner The AAD Object ID of the user owner of the file or directory. If empty, the property will remain unchanged.
     * @param group The AAD Object ID of the group owner of the file or directory. If empty, the property will remain unchanged.
     * @throws AdlsErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public ServiceResponse<Void> setOwner(String accountName, String setOwnerFilePath, String owner, String group) throws AdlsErrorException, IOException, IllegalArgumentException {
        return setOwnerAsync(accountName, setOwnerFilePath, owner, group).toBlocking().single();
    }

    /**
     * Sets the owner of a file or directory.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param setOwnerFilePath The Data Lake Store path (starting with '/') of the file or directory for which to set the owner.
     * @param owner The AAD Object ID of the user owner of the file or directory. If empty, the property will remain unchanged.
     * @param group The AAD Object ID of the group owner of the file or directory. If empty, the property will remain unchanged.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> setOwnerAsync(String accountName, String setOwnerFilePath, String owner, String group, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(setOwnerAsync(accountName, setOwnerFilePath, owner, group), serviceCallback);
    }

    /**
     * Sets the owner of a file or directory.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param setOwnerFilePath The Data Lake Store path (starting with '/') of the file or directory for which to set the owner.
     * @param owner The AAD Object ID of the user owner of the file or directory. If empty, the property will remain unchanged.
     * @param group The AAD Object ID of the group owner of the file or directory. If empty, the property will remain unchanged.
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> setOwnerAsync(String accountName, String setOwnerFilePath, String owner, String group) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlsFileSystemDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlsFileSystemDnsSuffix() is required and cannot be null.");
        }
        if (setOwnerFilePath == null) {
            throw new IllegalArgumentException("Parameter setOwnerFilePath is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String op = "SETOWNER";
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlsFileSystemDnsSuffix}", this.client.adlsFileSystemDnsSuffix());
        return service.setOwner(setOwnerFilePath, owner, group, op, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = setOwnerDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> setOwnerDelegate(Response<ResponseBody> response) throws AdlsErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Void, AdlsErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(AdlsErrorException.class)
                .build(response);
    }

    /**
     * Sets the permission of the file or folder.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param setPermissionFilePath The Data Lake Store path (starting with '/') of the file or directory for which to set the permission.
     * @throws AdlsErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public ServiceResponse<Void> setPermission(String accountName, String setPermissionFilePath) throws AdlsErrorException, IOException, IllegalArgumentException {
        return setPermissionAsync(accountName, setPermissionFilePath).toBlocking().single();
    }

    /**
     * Sets the permission of the file or folder.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param setPermissionFilePath The Data Lake Store path (starting with '/') of the file or directory for which to set the permission.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> setPermissionAsync(String accountName, String setPermissionFilePath, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(setPermissionAsync(accountName, setPermissionFilePath), serviceCallback);
    }

    /**
     * Sets the permission of the file or folder.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param setPermissionFilePath The Data Lake Store path (starting with '/') of the file or directory for which to set the permission.
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> setPermissionAsync(String accountName, String setPermissionFilePath) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlsFileSystemDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlsFileSystemDnsSuffix() is required and cannot be null.");
        }
        if (setPermissionFilePath == null) {
            throw new IllegalArgumentException("Parameter setPermissionFilePath is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String op = "SETPERMISSION";
        final String permission = null;
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlsFileSystemDnsSuffix}", this.client.adlsFileSystemDnsSuffix());
        return service.setPermission(setPermissionFilePath, permission, op, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = setPermissionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Sets the permission of the file or folder.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param setPermissionFilePath The Data Lake Store path (starting with '/') of the file or directory for which to set the permission.
     * @param permission A string representation of the permission (i.e 'rwx'). If empty, this property remains unchanged.
     * @throws AdlsErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public ServiceResponse<Void> setPermission(String accountName, String setPermissionFilePath, String permission) throws AdlsErrorException, IOException, IllegalArgumentException {
        return setPermissionAsync(accountName, setPermissionFilePath, permission).toBlocking().single();
    }

    /**
     * Sets the permission of the file or folder.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param setPermissionFilePath The Data Lake Store path (starting with '/') of the file or directory for which to set the permission.
     * @param permission A string representation of the permission (i.e 'rwx'). If empty, this property remains unchanged.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> setPermissionAsync(String accountName, String setPermissionFilePath, String permission, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(setPermissionAsync(accountName, setPermissionFilePath, permission), serviceCallback);
    }

    /**
     * Sets the permission of the file or folder.
     *
     * @param accountName The Azure Data Lake Store account to execute filesystem operations on.
     * @param setPermissionFilePath The Data Lake Store path (starting with '/') of the file or directory for which to set the permission.
     * @param permission A string representation of the permission (i.e 'rwx'). If empty, this property remains unchanged.
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> setPermissionAsync(String accountName, String setPermissionFilePath, String permission) {
        if (accountName == null) {
            throw new IllegalArgumentException("Parameter accountName is required and cannot be null.");
        }
        if (this.client.adlsFileSystemDnsSuffix() == null) {
            throw new IllegalArgumentException("Parameter this.client.adlsFileSystemDnsSuffix() is required and cannot be null.");
        }
        if (setPermissionFilePath == null) {
            throw new IllegalArgumentException("Parameter setPermissionFilePath is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String op = "SETPERMISSION";
        String parameterizedHost = Joiner.on(", ").join("{accountName}", accountName, "{adlsFileSystemDnsSuffix}", this.client.adlsFileSystemDnsSuffix());
        return service.setPermission(setPermissionFilePath, permission, op, this.client.apiVersion(), this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = setPermissionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> setPermissionDelegate(Response<ResponseBody> response) throws AdlsErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Void, AdlsErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(AdlsErrorException.class)
                .build(response);
    }

}
