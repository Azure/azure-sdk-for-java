/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.management.billing.v2018_05_31_preview.implementation;

import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.management.billing.v2018_05_31_preview.ErrorResponseException;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import java.io.IOException;
import okhttp3.ResponseBody;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.Path;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in BillingAccounts.
 */
public class BillingAccountsInner {
    /** The Retrofit service to perform REST calls. */
    private BillingAccountsService service;
    /** The service client containing this operation class. */
    private BillingManagementClientImpl client;

    /**
     * Initializes an instance of BillingAccountsInner.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public BillingAccountsInner(Retrofit retrofit, BillingManagementClientImpl client) {
        this.service = retrofit.create(BillingAccountsService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for BillingAccounts to be
     * used by Retrofit to perform actually REST calls.
     */
    interface BillingAccountsService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2018_05_31_preview.BillingAccounts list" })
        @GET("providers/Microsoft.Billing/billingAccounts")
        Observable<Response<ResponseBody>> list(@Query("api-version") String apiVersion, @Query("$expand") String expand, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2018_05_31_preview.BillingAccounts listWithCreateProjectPermission" })
        @GET("providers/Microsoft.Billing/listBillingAccountsWithCreateProjectPermission")
        Observable<Response<ResponseBody>> listWithCreateProjectPermission(@Query("api-version") String apiVersion, @Query("$expand") String expand, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2018_05_31_preview.BillingAccounts get" })
        @GET("providers/Microsoft.Billing/billingAccounts/{billingAccountId}")
        Observable<Response<ResponseBody>> get(@Path("billingAccountId") String billingAccountId, @Query("api-version") String apiVersion, @Query("$expand") String expand, @Query("$filter") String filter, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

    }

    /**
     * Lists all billing accounts for a user which he has access to.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BillingAccountListResultInner object if successful.
     */
    public BillingAccountListResultInner list() {
        return listWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Lists all billing accounts for a user which he has access to.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BillingAccountListResultInner> listAsync(final ServiceCallback<BillingAccountListResultInner> serviceCallback) {
        return ServiceFuture.fromResponse(listWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Lists all billing accounts for a user which he has access to.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BillingAccountListResultInner object
     */
    public Observable<BillingAccountListResultInner> listAsync() {
        return listWithServiceResponseAsync().map(new Func1<ServiceResponse<BillingAccountListResultInner>, BillingAccountListResultInner>() {
            @Override
            public BillingAccountListResultInner call(ServiceResponse<BillingAccountListResultInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Lists all billing accounts for a user which he has access to.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BillingAccountListResultInner object
     */
    public Observable<ServiceResponse<BillingAccountListResultInner>> listWithServiceResponseAsync() {
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String expand = null;
        return service.list(this.client.apiVersion(), expand, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BillingAccountListResultInner>>>() {
                @Override
                public Observable<ServiceResponse<BillingAccountListResultInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BillingAccountListResultInner> clientResponse = listDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Lists all billing accounts for a user which he has access to.
     *
     * @param expand May be used to expand the projects and billingProfiles.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BillingAccountListResultInner object if successful.
     */
    public BillingAccountListResultInner list(String expand) {
        return listWithServiceResponseAsync(expand).toBlocking().single().body();
    }

    /**
     * Lists all billing accounts for a user which he has access to.
     *
     * @param expand May be used to expand the projects and billingProfiles.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BillingAccountListResultInner> listAsync(String expand, final ServiceCallback<BillingAccountListResultInner> serviceCallback) {
        return ServiceFuture.fromResponse(listWithServiceResponseAsync(expand), serviceCallback);
    }

    /**
     * Lists all billing accounts for a user which he has access to.
     *
     * @param expand May be used to expand the projects and billingProfiles.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BillingAccountListResultInner object
     */
    public Observable<BillingAccountListResultInner> listAsync(String expand) {
        return listWithServiceResponseAsync(expand).map(new Func1<ServiceResponse<BillingAccountListResultInner>, BillingAccountListResultInner>() {
            @Override
            public BillingAccountListResultInner call(ServiceResponse<BillingAccountListResultInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Lists all billing accounts for a user which he has access to.
     *
     * @param expand May be used to expand the projects and billingProfiles.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BillingAccountListResultInner object
     */
    public Observable<ServiceResponse<BillingAccountListResultInner>> listWithServiceResponseAsync(String expand) {
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.list(this.client.apiVersion(), expand, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BillingAccountListResultInner>>>() {
                @Override
                public Observable<ServiceResponse<BillingAccountListResultInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BillingAccountListResultInner> clientResponse = listDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BillingAccountListResultInner> listDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<BillingAccountListResultInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BillingAccountListResultInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Lists all billing accounts with create project permission for a user.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BillingAccountListResultInner object if successful.
     */
    public BillingAccountListResultInner listWithCreateProjectPermission() {
        return listWithCreateProjectPermissionWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Lists all billing accounts with create project permission for a user.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BillingAccountListResultInner> listWithCreateProjectPermissionAsync(final ServiceCallback<BillingAccountListResultInner> serviceCallback) {
        return ServiceFuture.fromResponse(listWithCreateProjectPermissionWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Lists all billing accounts with create project permission for a user.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BillingAccountListResultInner object
     */
    public Observable<BillingAccountListResultInner> listWithCreateProjectPermissionAsync() {
        return listWithCreateProjectPermissionWithServiceResponseAsync().map(new Func1<ServiceResponse<BillingAccountListResultInner>, BillingAccountListResultInner>() {
            @Override
            public BillingAccountListResultInner call(ServiceResponse<BillingAccountListResultInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Lists all billing accounts with create project permission for a user.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BillingAccountListResultInner object
     */
    public Observable<ServiceResponse<BillingAccountListResultInner>> listWithCreateProjectPermissionWithServiceResponseAsync() {
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String expand = null;
        return service.listWithCreateProjectPermission(this.client.apiVersion(), expand, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BillingAccountListResultInner>>>() {
                @Override
                public Observable<ServiceResponse<BillingAccountListResultInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BillingAccountListResultInner> clientResponse = listWithCreateProjectPermissionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Lists all billing accounts with create project permission for a user.
     *
     * @param expand May be used to expand the projects and billingProfiles.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BillingAccountListResultInner object if successful.
     */
    public BillingAccountListResultInner listWithCreateProjectPermission(String expand) {
        return listWithCreateProjectPermissionWithServiceResponseAsync(expand).toBlocking().single().body();
    }

    /**
     * Lists all billing accounts with create project permission for a user.
     *
     * @param expand May be used to expand the projects and billingProfiles.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BillingAccountListResultInner> listWithCreateProjectPermissionAsync(String expand, final ServiceCallback<BillingAccountListResultInner> serviceCallback) {
        return ServiceFuture.fromResponse(listWithCreateProjectPermissionWithServiceResponseAsync(expand), serviceCallback);
    }

    /**
     * Lists all billing accounts with create project permission for a user.
     *
     * @param expand May be used to expand the projects and billingProfiles.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BillingAccountListResultInner object
     */
    public Observable<BillingAccountListResultInner> listWithCreateProjectPermissionAsync(String expand) {
        return listWithCreateProjectPermissionWithServiceResponseAsync(expand).map(new Func1<ServiceResponse<BillingAccountListResultInner>, BillingAccountListResultInner>() {
            @Override
            public BillingAccountListResultInner call(ServiceResponse<BillingAccountListResultInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Lists all billing accounts with create project permission for a user.
     *
     * @param expand May be used to expand the projects and billingProfiles.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BillingAccountListResultInner object
     */
    public Observable<ServiceResponse<BillingAccountListResultInner>> listWithCreateProjectPermissionWithServiceResponseAsync(String expand) {
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listWithCreateProjectPermission(this.client.apiVersion(), expand, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BillingAccountListResultInner>>>() {
                @Override
                public Observable<ServiceResponse<BillingAccountListResultInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BillingAccountListResultInner> clientResponse = listWithCreateProjectPermissionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BillingAccountListResultInner> listWithCreateProjectPermissionDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<BillingAccountListResultInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BillingAccountListResultInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Get the billing account by id.
     *
     * @param billingAccountId billing Account Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BillingAccountInner object if successful.
     */
    public BillingAccountInner get(String billingAccountId) {
        return getWithServiceResponseAsync(billingAccountId).toBlocking().single().body();
    }

    /**
     * Get the billing account by id.
     *
     * @param billingAccountId billing Account Id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BillingAccountInner> getAsync(String billingAccountId, final ServiceCallback<BillingAccountInner> serviceCallback) {
        return ServiceFuture.fromResponse(getWithServiceResponseAsync(billingAccountId), serviceCallback);
    }

    /**
     * Get the billing account by id.
     *
     * @param billingAccountId billing Account Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BillingAccountInner object
     */
    public Observable<BillingAccountInner> getAsync(String billingAccountId) {
        return getWithServiceResponseAsync(billingAccountId).map(new Func1<ServiceResponse<BillingAccountInner>, BillingAccountInner>() {
            @Override
            public BillingAccountInner call(ServiceResponse<BillingAccountInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get the billing account by id.
     *
     * @param billingAccountId billing Account Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BillingAccountInner object
     */
    public Observable<ServiceResponse<BillingAccountInner>> getWithServiceResponseAsync(String billingAccountId) {
        if (billingAccountId == null) {
            throw new IllegalArgumentException("Parameter billingAccountId is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String expand = null;
        final String filter = null;
        return service.get(billingAccountId, this.client.apiVersion(), expand, filter, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BillingAccountInner>>>() {
                @Override
                public Observable<ServiceResponse<BillingAccountInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BillingAccountInner> clientResponse = getDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get the billing account by id.
     *
     * @param billingAccountId billing Account Id.
     * @param expand May be used to expand the projects and billingProfiles.
     * @param filter May be used to filter by permission. The filter supports 'eq', 'lt', 'gt', 'le', 'ge', and 'and'. It does not currently support 'ne', 'or', or 'not'. Tag filter is a key value pair string where key and value is separated by a colon (:).
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BillingAccountInner object if successful.
     */
    public BillingAccountInner get(String billingAccountId, String expand, String filter) {
        return getWithServiceResponseAsync(billingAccountId, expand, filter).toBlocking().single().body();
    }

    /**
     * Get the billing account by id.
     *
     * @param billingAccountId billing Account Id.
     * @param expand May be used to expand the projects and billingProfiles.
     * @param filter May be used to filter by permission. The filter supports 'eq', 'lt', 'gt', 'le', 'ge', and 'and'. It does not currently support 'ne', 'or', or 'not'. Tag filter is a key value pair string where key and value is separated by a colon (:).
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BillingAccountInner> getAsync(String billingAccountId, String expand, String filter, final ServiceCallback<BillingAccountInner> serviceCallback) {
        return ServiceFuture.fromResponse(getWithServiceResponseAsync(billingAccountId, expand, filter), serviceCallback);
    }

    /**
     * Get the billing account by id.
     *
     * @param billingAccountId billing Account Id.
     * @param expand May be used to expand the projects and billingProfiles.
     * @param filter May be used to filter by permission. The filter supports 'eq', 'lt', 'gt', 'le', 'ge', and 'and'. It does not currently support 'ne', 'or', or 'not'. Tag filter is a key value pair string where key and value is separated by a colon (:).
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BillingAccountInner object
     */
    public Observable<BillingAccountInner> getAsync(String billingAccountId, String expand, String filter) {
        return getWithServiceResponseAsync(billingAccountId, expand, filter).map(new Func1<ServiceResponse<BillingAccountInner>, BillingAccountInner>() {
            @Override
            public BillingAccountInner call(ServiceResponse<BillingAccountInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get the billing account by id.
     *
     * @param billingAccountId billing Account Id.
     * @param expand May be used to expand the projects and billingProfiles.
     * @param filter May be used to filter by permission. The filter supports 'eq', 'lt', 'gt', 'le', 'ge', and 'and'. It does not currently support 'ne', 'or', or 'not'. Tag filter is a key value pair string where key and value is separated by a colon (:).
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BillingAccountInner object
     */
    public Observable<ServiceResponse<BillingAccountInner>> getWithServiceResponseAsync(String billingAccountId, String expand, String filter) {
        if (billingAccountId == null) {
            throw new IllegalArgumentException("Parameter billingAccountId is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.get(billingAccountId, this.client.apiVersion(), expand, filter, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BillingAccountInner>>>() {
                @Override
                public Observable<ServiceResponse<BillingAccountInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BillingAccountInner> clientResponse = getDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BillingAccountInner> getDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<BillingAccountInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BillingAccountInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

}
