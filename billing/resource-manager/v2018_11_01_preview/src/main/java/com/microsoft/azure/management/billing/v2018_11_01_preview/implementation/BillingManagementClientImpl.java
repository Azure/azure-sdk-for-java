/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.management.billing.v2018_11_01_preview.implementation;

import com.google.common.reflect.TypeToken;
import com.microsoft.azure.AzureClient;
import com.microsoft.azure.AzureServiceClient;
import com.microsoft.azure.management.billing.v2018_11_01_preview.ErrorResponseException;
import com.microsoft.azure.management.billing.v2018_11_01_preview.UpdateAutoRenew;
import com.microsoft.azure.management.billing.v2018_11_01_preview.UpdateAutoRenewRequest;
import com.microsoft.rest.credentials.ServiceClientCredentials;
import com.microsoft.rest.RestClient;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import java.io.IOException;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * Initializes a new instance of the BillingManagementClientImpl class.
 */
public class BillingManagementClientImpl extends AzureServiceClient {
    /** The Retrofit service to perform REST calls. */
    private BillingManagementClientService service;
    /** the {@link AzureClient} used for long running operations. */
    private AzureClient azureClient;

    /**
     * Gets the {@link AzureClient} used for long running operations.
     * @return the azure client;
     */
    public AzureClient getAzureClient() {
        return this.azureClient;
    }

    /** Version of the API to be used with the client request. The current version is 2018-11-01-preview. */
    private String apiVersion;

    /**
     * Gets Version of the API to be used with the client request. The current version is 2018-11-01-preview.
     *
     * @return the apiVersion value.
     */
    public String apiVersion() {
        return this.apiVersion;
    }

    /** Azure Subscription ID. */
    private String subscriptionId;

    /**
     * Gets Azure Subscription ID.
     *
     * @return the subscriptionId value.
     */
    public String subscriptionId() {
        return this.subscriptionId;
    }

    /**
     * Sets Azure Subscription ID.
     *
     * @param subscriptionId the subscriptionId value.
     * @return the service client itself
     */
    public BillingManagementClientImpl withSubscriptionId(String subscriptionId) {
        this.subscriptionId = subscriptionId;
        return this;
    }

    /** The preferred language for the response. */
    private String acceptLanguage;

    /**
     * Gets The preferred language for the response.
     *
     * @return the acceptLanguage value.
     */
    public String acceptLanguage() {
        return this.acceptLanguage;
    }

    /**
     * Sets The preferred language for the response.
     *
     * @param acceptLanguage the acceptLanguage value.
     * @return the service client itself
     */
    public BillingManagementClientImpl withAcceptLanguage(String acceptLanguage) {
        this.acceptLanguage = acceptLanguage;
        return this;
    }

    /** The retry timeout in seconds for Long Running Operations. Default value is 30. */
    private int longRunningOperationRetryTimeout;

    /**
     * Gets The retry timeout in seconds for Long Running Operations. Default value is 30.
     *
     * @return the longRunningOperationRetryTimeout value.
     */
    public int longRunningOperationRetryTimeout() {
        return this.longRunningOperationRetryTimeout;
    }

    /**
     * Sets The retry timeout in seconds for Long Running Operations. Default value is 30.
     *
     * @param longRunningOperationRetryTimeout the longRunningOperationRetryTimeout value.
     * @return the service client itself
     */
    public BillingManagementClientImpl withLongRunningOperationRetryTimeout(int longRunningOperationRetryTimeout) {
        this.longRunningOperationRetryTimeout = longRunningOperationRetryTimeout;
        return this;
    }

    /** Whether a unique x-ms-client-request-id should be generated. When set to true a unique x-ms-client-request-id value is generated and included in each request. Default is true. */
    private boolean generateClientRequestId;

    /**
     * Gets Whether a unique x-ms-client-request-id should be generated. When set to true a unique x-ms-client-request-id value is generated and included in each request. Default is true.
     *
     * @return the generateClientRequestId value.
     */
    public boolean generateClientRequestId() {
        return this.generateClientRequestId;
    }

    /**
     * Sets Whether a unique x-ms-client-request-id should be generated. When set to true a unique x-ms-client-request-id value is generated and included in each request. Default is true.
     *
     * @param generateClientRequestId the generateClientRequestId value.
     * @return the service client itself
     */
    public BillingManagementClientImpl withGenerateClientRequestId(boolean generateClientRequestId) {
        this.generateClientRequestId = generateClientRequestId;
        return this;
    }

    /**
     * The BillingAccountsInner object to access its operations.
     */
    private BillingAccountsInner billingAccounts;

    /**
     * Gets the BillingAccountsInner object to access its operations.
     * @return the BillingAccountsInner object.
     */
    public BillingAccountsInner billingAccounts() {
        return this.billingAccounts;
    }

    /**
     * The BillingAccountsWithCreateInvoiceSectionPermissionsInner object to access its operations.
     */
    private BillingAccountsWithCreateInvoiceSectionPermissionsInner billingAccountsWithCreateInvoiceSectionPermissions;

    /**
     * Gets the BillingAccountsWithCreateInvoiceSectionPermissionsInner object to access its operations.
     * @return the BillingAccountsWithCreateInvoiceSectionPermissionsInner object.
     */
    public BillingAccountsWithCreateInvoiceSectionPermissionsInner billingAccountsWithCreateInvoiceSectionPermissions() {
        return this.billingAccountsWithCreateInvoiceSectionPermissions;
    }

    /**
     * The AvailableBalanceByBillingProfilesInner object to access its operations.
     */
    private AvailableBalanceByBillingProfilesInner availableBalanceByBillingProfiles;

    /**
     * Gets the AvailableBalanceByBillingProfilesInner object to access its operations.
     * @return the AvailableBalanceByBillingProfilesInner object.
     */
    public AvailableBalanceByBillingProfilesInner availableBalanceByBillingProfiles() {
        return this.availableBalanceByBillingProfiles;
    }

    /**
     * The PaymentMethodsByBillingProfilesInner object to access its operations.
     */
    private PaymentMethodsByBillingProfilesInner paymentMethodsByBillingProfiles;

    /**
     * Gets the PaymentMethodsByBillingProfilesInner object to access its operations.
     * @return the PaymentMethodsByBillingProfilesInner object.
     */
    public PaymentMethodsByBillingProfilesInner paymentMethodsByBillingProfiles() {
        return this.paymentMethodsByBillingProfiles;
    }

    /**
     * The BillingProfilesByBillingAccountIdsInner object to access its operations.
     */
    private BillingProfilesByBillingAccountIdsInner billingProfilesByBillingAccountIds;

    /**
     * Gets the BillingProfilesByBillingAccountIdsInner object to access its operations.
     * @return the BillingProfilesByBillingAccountIdsInner object.
     */
    public BillingProfilesByBillingAccountIdsInner billingProfilesByBillingAccountIds() {
        return this.billingProfilesByBillingAccountIds;
    }

    /**
     * The BillingProfilesInner object to access its operations.
     */
    private BillingProfilesInner billingProfiles;

    /**
     * Gets the BillingProfilesInner object to access its operations.
     * @return the BillingProfilesInner object.
     */
    public BillingProfilesInner billingProfiles() {
        return this.billingProfiles;
    }

    /**
     * The InvoiceSectionsByBillingAccountIdsInner object to access its operations.
     */
    private InvoiceSectionsByBillingAccountIdsInner invoiceSectionsByBillingAccountIds;

    /**
     * Gets the InvoiceSectionsByBillingAccountIdsInner object to access its operations.
     * @return the InvoiceSectionsByBillingAccountIdsInner object.
     */
    public InvoiceSectionsByBillingAccountIdsInner invoiceSectionsByBillingAccountIds() {
        return this.invoiceSectionsByBillingAccountIds;
    }

    /**
     * The InvoiceSectionsInner object to access its operations.
     */
    private InvoiceSectionsInner invoiceSections;

    /**
     * Gets the InvoiceSectionsInner object to access its operations.
     * @return the InvoiceSectionsInner object.
     */
    public InvoiceSectionsInner invoiceSections() {
        return this.invoiceSections;
    }

    /**
     * The InvoiceSectionsWithCreateSubscriptionPermissionsInner object to access its operations.
     */
    private InvoiceSectionsWithCreateSubscriptionPermissionsInner invoiceSectionsWithCreateSubscriptionPermissions;

    /**
     * Gets the InvoiceSectionsWithCreateSubscriptionPermissionsInner object to access its operations.
     * @return the InvoiceSectionsWithCreateSubscriptionPermissionsInner object.
     */
    public InvoiceSectionsWithCreateSubscriptionPermissionsInner invoiceSectionsWithCreateSubscriptionPermissions() {
        return this.invoiceSectionsWithCreateSubscriptionPermissions;
    }

    /**
     * The DepartmentsByBillingAccountIdsInner object to access its operations.
     */
    private DepartmentsByBillingAccountIdsInner departmentsByBillingAccountIds;

    /**
     * Gets the DepartmentsByBillingAccountIdsInner object to access its operations.
     * @return the DepartmentsByBillingAccountIdsInner object.
     */
    public DepartmentsByBillingAccountIdsInner departmentsByBillingAccountIds() {
        return this.departmentsByBillingAccountIds;
    }

    /**
     * The DepartmentsInner object to access its operations.
     */
    private DepartmentsInner departments;

    /**
     * Gets the DepartmentsInner object to access its operations.
     * @return the DepartmentsInner object.
     */
    public DepartmentsInner departments() {
        return this.departments;
    }

    /**
     * The EnrollmentAccountsByBillingAccountIdsInner object to access its operations.
     */
    private EnrollmentAccountsByBillingAccountIdsInner enrollmentAccountsByBillingAccountIds;

    /**
     * Gets the EnrollmentAccountsByBillingAccountIdsInner object to access its operations.
     * @return the EnrollmentAccountsByBillingAccountIdsInner object.
     */
    public EnrollmentAccountsByBillingAccountIdsInner enrollmentAccountsByBillingAccountIds() {
        return this.enrollmentAccountsByBillingAccountIds;
    }

    /**
     * The EnrollmentAccountsInner object to access its operations.
     */
    private EnrollmentAccountsInner enrollmentAccounts;

    /**
     * Gets the EnrollmentAccountsInner object to access its operations.
     * @return the EnrollmentAccountsInner object.
     */
    public EnrollmentAccountsInner enrollmentAccounts() {
        return this.enrollmentAccounts;
    }

    /**
     * The InvoicesByBillingAccountsInner object to access its operations.
     */
    private InvoicesByBillingAccountsInner invoicesByBillingAccounts;

    /**
     * Gets the InvoicesByBillingAccountsInner object to access its operations.
     * @return the InvoicesByBillingAccountsInner object.
     */
    public InvoicesByBillingAccountsInner invoicesByBillingAccounts() {
        return this.invoicesByBillingAccounts;
    }

    /**
     * The InvoicePricesheetsInner object to access its operations.
     */
    private InvoicePricesheetsInner invoicePricesheets;

    /**
     * Gets the InvoicePricesheetsInner object to access its operations.
     * @return the InvoicePricesheetsInner object.
     */
    public InvoicePricesheetsInner invoicePricesheets() {
        return this.invoicePricesheets;
    }

    /**
     * The InvoicesByBillingProfilesInner object to access its operations.
     */
    private InvoicesByBillingProfilesInner invoicesByBillingProfiles;

    /**
     * Gets the InvoicesByBillingProfilesInner object to access its operations.
     * @return the InvoicesByBillingProfilesInner object.
     */
    public InvoicesByBillingProfilesInner invoicesByBillingProfiles() {
        return this.invoicesByBillingProfiles;
    }

    /**
     * The InvoicesInner object to access its operations.
     */
    private InvoicesInner invoices;

    /**
     * Gets the InvoicesInner object to access its operations.
     * @return the InvoicesInner object.
     */
    public InvoicesInner invoices() {
        return this.invoices;
    }

    /**
     * The ProductsByBillingSubscriptionsInner object to access its operations.
     */
    private ProductsByBillingSubscriptionsInner productsByBillingSubscriptions;

    /**
     * Gets the ProductsByBillingSubscriptionsInner object to access its operations.
     * @return the ProductsByBillingSubscriptionsInner object.
     */
    public ProductsByBillingSubscriptionsInner productsByBillingSubscriptions() {
        return this.productsByBillingSubscriptions;
    }

    /**
     * The BillingSubscriptionsByBillingProfilesInner object to access its operations.
     */
    private BillingSubscriptionsByBillingProfilesInner billingSubscriptionsByBillingProfiles;

    /**
     * Gets the BillingSubscriptionsByBillingProfilesInner object to access its operations.
     * @return the BillingSubscriptionsByBillingProfilesInner object.
     */
    public BillingSubscriptionsByBillingProfilesInner billingSubscriptionsByBillingProfiles() {
        return this.billingSubscriptionsByBillingProfiles;
    }

    /**
     * The BillingSubscriptionsByInvoiceSectionsInner object to access its operations.
     */
    private BillingSubscriptionsByInvoiceSectionsInner billingSubscriptionsByInvoiceSections;

    /**
     * Gets the BillingSubscriptionsByInvoiceSectionsInner object to access its operations.
     * @return the BillingSubscriptionsByInvoiceSectionsInner object.
     */
    public BillingSubscriptionsByInvoiceSectionsInner billingSubscriptionsByInvoiceSections() {
        return this.billingSubscriptionsByInvoiceSections;
    }

    /**
     * The BillingSubscriptionsInner object to access its operations.
     */
    private BillingSubscriptionsInner billingSubscriptions;

    /**
     * Gets the BillingSubscriptionsInner object to access its operations.
     * @return the BillingSubscriptionsInner object.
     */
    public BillingSubscriptionsInner billingSubscriptions() {
        return this.billingSubscriptions;
    }

    /**
     * The ProductsByBillingAccountsInner object to access its operations.
     */
    private ProductsByBillingAccountsInner productsByBillingAccounts;

    /**
     * Gets the ProductsByBillingAccountsInner object to access its operations.
     * @return the ProductsByBillingAccountsInner object.
     */
    public ProductsByBillingAccountsInner productsByBillingAccounts() {
        return this.productsByBillingAccounts;
    }

    /**
     * The ProductsByInvoiceSectionsInner object to access its operations.
     */
    private ProductsByInvoiceSectionsInner productsByInvoiceSections;

    /**
     * Gets the ProductsByInvoiceSectionsInner object to access its operations.
     * @return the ProductsByInvoiceSectionsInner object.
     */
    public ProductsByInvoiceSectionsInner productsByInvoiceSections() {
        return this.productsByInvoiceSections;
    }

    /**
     * The ProductsInner object to access its operations.
     */
    private ProductsInner products;

    /**
     * Gets the ProductsInner object to access its operations.
     * @return the ProductsInner object.
     */
    public ProductsInner products() {
        return this.products;
    }

    /**
     * The TransactionsByBillingAccountsInner object to access its operations.
     */
    private TransactionsByBillingAccountsInner transactionsByBillingAccounts;

    /**
     * Gets the TransactionsByBillingAccountsInner object to access its operations.
     * @return the TransactionsByBillingAccountsInner object.
     */
    public TransactionsByBillingAccountsInner transactionsByBillingAccounts() {
        return this.transactionsByBillingAccounts;
    }

    /**
     * The PolicysInner object to access its operations.
     */
    private PolicysInner policys;

    /**
     * Gets the PolicysInner object to access its operations.
     * @return the PolicysInner object.
     */
    public PolicysInner policys() {
        return this.policys;
    }

    /**
     * The BillingPropertysInner object to access its operations.
     */
    private BillingPropertysInner billingPropertys;

    /**
     * Gets the BillingPropertysInner object to access its operations.
     * @return the BillingPropertysInner object.
     */
    public BillingPropertysInner billingPropertys() {
        return this.billingPropertys;
    }

    /**
     * The OperationsInner object to access its operations.
     */
    private OperationsInner operations;

    /**
     * Gets the OperationsInner object to access its operations.
     * @return the OperationsInner object.
     */
    public OperationsInner operations() {
        return this.operations;
    }

    /**
     * Initializes an instance of BillingManagementClient client.
     *
     * @param credentials the management credentials for Azure
     */
    public BillingManagementClientImpl(ServiceClientCredentials credentials) {
        this("https://management.azure.com", credentials);
    }

    /**
     * Initializes an instance of BillingManagementClient client.
     *
     * @param baseUrl the base URL of the host
     * @param credentials the management credentials for Azure
     */
    public BillingManagementClientImpl(String baseUrl, ServiceClientCredentials credentials) {
        super(baseUrl, credentials);
        initialize();
    }

    /**
     * Initializes an instance of BillingManagementClient client.
     *
     * @param restClient the REST client to connect to Azure.
     */
    public BillingManagementClientImpl(RestClient restClient) {
        super(restClient);
        initialize();
    }

    protected void initialize() {
        this.apiVersion = "2018-11-01-preview";
        this.acceptLanguage = "en-US";
        this.longRunningOperationRetryTimeout = 30;
        this.generateClientRequestId = true;
        this.billingAccounts = new BillingAccountsInner(restClient().retrofit(), this);
        this.billingAccountsWithCreateInvoiceSectionPermissions = new BillingAccountsWithCreateInvoiceSectionPermissionsInner(restClient().retrofit(), this);
        this.availableBalanceByBillingProfiles = new AvailableBalanceByBillingProfilesInner(restClient().retrofit(), this);
        this.paymentMethodsByBillingProfiles = new PaymentMethodsByBillingProfilesInner(restClient().retrofit(), this);
        this.billingProfilesByBillingAccountIds = new BillingProfilesByBillingAccountIdsInner(restClient().retrofit(), this);
        this.billingProfiles = new BillingProfilesInner(restClient().retrofit(), this);
        this.invoiceSectionsByBillingAccountIds = new InvoiceSectionsByBillingAccountIdsInner(restClient().retrofit(), this);
        this.invoiceSections = new InvoiceSectionsInner(restClient().retrofit(), this);
        this.invoiceSectionsWithCreateSubscriptionPermissions = new InvoiceSectionsWithCreateSubscriptionPermissionsInner(restClient().retrofit(), this);
        this.departmentsByBillingAccountIds = new DepartmentsByBillingAccountIdsInner(restClient().retrofit(), this);
        this.departments = new DepartmentsInner(restClient().retrofit(), this);
        this.enrollmentAccountsByBillingAccountIds = new EnrollmentAccountsByBillingAccountIdsInner(restClient().retrofit(), this);
        this.enrollmentAccounts = new EnrollmentAccountsInner(restClient().retrofit(), this);
        this.invoicesByBillingAccounts = new InvoicesByBillingAccountsInner(restClient().retrofit(), this);
        this.invoicePricesheets = new InvoicePricesheetsInner(restClient().retrofit(), this);
        this.invoicesByBillingProfiles = new InvoicesByBillingProfilesInner(restClient().retrofit(), this);
        this.invoices = new InvoicesInner(restClient().retrofit(), this);
        this.productsByBillingSubscriptions = new ProductsByBillingSubscriptionsInner(restClient().retrofit(), this);
        this.billingSubscriptionsByBillingProfiles = new BillingSubscriptionsByBillingProfilesInner(restClient().retrofit(), this);
        this.billingSubscriptionsByInvoiceSections = new BillingSubscriptionsByInvoiceSectionsInner(restClient().retrofit(), this);
        this.billingSubscriptions = new BillingSubscriptionsInner(restClient().retrofit(), this);
        this.productsByBillingAccounts = new ProductsByBillingAccountsInner(restClient().retrofit(), this);
        this.productsByInvoiceSections = new ProductsByInvoiceSectionsInner(restClient().retrofit(), this);
        this.products = new ProductsInner(restClient().retrofit(), this);
        this.transactionsByBillingAccounts = new TransactionsByBillingAccountsInner(restClient().retrofit(), this);
        this.policys = new PolicysInner(restClient().retrofit(), this);
        this.billingPropertys = new BillingPropertysInner(restClient().retrofit(), this);
        this.operations = new OperationsInner(restClient().retrofit(), this);
        this.azureClient = new AzureClient(this);
        initializeService();
    }

    /**
     * Gets the User-Agent header for the client.
     *
     * @return the user agent string.
     */
    @Override
    public String userAgent() {
        return String.format("%s (%s, %s, auto-generated)", super.userAgent(), "BillingManagementClient", "2018-11-01-preview");
    }

    private void initializeService() {
        service = restClient().retrofit().create(BillingManagementClientService.class);
    }

    /**
     * The interface defining all the services for BillingManagementClient to be
     * used by Retrofit to perform actually REST calls.
     */
    interface BillingManagementClientService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2018_11_01_preview.BillingManagementClient transactionsByBillingProfile" })
        @GET("providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/transactions")
        Observable<Response<ResponseBody>> transactionsByBillingProfile(@Path("billingAccountId") String billingAccountId, @Path("billingProfileId") String billingProfileId, @Query("api-version") String apiVersion, @Query("startDate") String startDate, @Query("endDate") String endDate, @Query("$filter") String filter, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2018_11_01_preview.BillingManagementClient updateAutoRenewForBillingAccount" })
        @POST("providers/Microsoft.Billing/billingAccounts/{billingAccountId}/products/{productName}/updateAutoRenew")
        Observable<Response<ResponseBody>> updateAutoRenewForBillingAccount(@Path("billingAccountId") String billingAccountId, @Path("productName") String productName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body UpdateAutoRenewRequest body, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2018_11_01_preview.BillingManagementClient updateAutoRenewForInvoiceSection" })
        @POST("providers/Microsoft.Billing/billingAccounts/{billingAccountId}/invoiceSections/{invoiceSectionId}/products/{productName}/updateAutoRenew")
        Observable<Response<ResponseBody>> updateAutoRenewForInvoiceSection(@Path("billingAccountId") String billingAccountId, @Path("invoiceSectionId") String invoiceSectionId, @Path("productName") String productName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body UpdateAutoRenewRequest body, @Header("User-Agent") String userAgent);

    }

    /**
     * Lists the transactions by billingProfileId for given start date and end date.
     *
     * @param billingAccountId billing Account Id.
     * @param billingProfileId Billing Profile Id.
     * @param startDate Start date
     * @param endDate End date
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TransactionsListResultInner object if successful.
     */
    public TransactionsListResultInner transactionsByBillingProfile(String billingAccountId, String billingProfileId, String startDate, String endDate) {
        return transactionsByBillingProfileWithServiceResponseAsync(billingAccountId, billingProfileId, startDate, endDate).toBlocking().single().body();
    }

    /**
     * Lists the transactions by billingProfileId for given start date and end date.
     *
     * @param billingAccountId billing Account Id.
     * @param billingProfileId Billing Profile Id.
     * @param startDate Start date
     * @param endDate End date
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TransactionsListResultInner> transactionsByBillingProfileAsync(String billingAccountId, String billingProfileId, String startDate, String endDate, final ServiceCallback<TransactionsListResultInner> serviceCallback) {
        return ServiceFuture.fromResponse(transactionsByBillingProfileWithServiceResponseAsync(billingAccountId, billingProfileId, startDate, endDate), serviceCallback);
    }

    /**
     * Lists the transactions by billingProfileId for given start date and end date.
     *
     * @param billingAccountId billing Account Id.
     * @param billingProfileId Billing Profile Id.
     * @param startDate Start date
     * @param endDate End date
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransactionsListResultInner object
     */
    public Observable<TransactionsListResultInner> transactionsByBillingProfileAsync(String billingAccountId, String billingProfileId, String startDate, String endDate) {
        return transactionsByBillingProfileWithServiceResponseAsync(billingAccountId, billingProfileId, startDate, endDate).map(new Func1<ServiceResponse<TransactionsListResultInner>, TransactionsListResultInner>() {
            @Override
            public TransactionsListResultInner call(ServiceResponse<TransactionsListResultInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Lists the transactions by billingProfileId for given start date and end date.
     *
     * @param billingAccountId billing Account Id.
     * @param billingProfileId Billing Profile Id.
     * @param startDate Start date
     * @param endDate End date
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransactionsListResultInner object
     */
    public Observable<ServiceResponse<TransactionsListResultInner>> transactionsByBillingProfileWithServiceResponseAsync(String billingAccountId, String billingProfileId, String startDate, String endDate) {
        if (billingAccountId == null) {
            throw new IllegalArgumentException("Parameter billingAccountId is required and cannot be null.");
        }
        if (billingProfileId == null) {
            throw new IllegalArgumentException("Parameter billingProfileId is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        final String filter = null;
        return service.transactionsByBillingProfile(billingAccountId, billingProfileId, this.apiVersion(), startDate, endDate, filter, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<TransactionsListResultInner>>>() {
                @Override
                public Observable<ServiceResponse<TransactionsListResultInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<TransactionsListResultInner> clientResponse = transactionsByBillingProfileDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Lists the transactions by billingProfileId for given start date and end date.
     *
     * @param billingAccountId billing Account Id.
     * @param billingProfileId Billing Profile Id.
     * @param startDate Start date
     * @param endDate End date
     * @param filter May be used to filter by transaction kind. The filter supports 'eq', 'lt', 'gt', 'le', 'ge', and 'and'. It does not currently support 'ne', 'or', or 'not'. Tag filter is a key value pair string where key and value is separated by a colon (:).
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TransactionsListResultInner object if successful.
     */
    public TransactionsListResultInner transactionsByBillingProfile(String billingAccountId, String billingProfileId, String startDate, String endDate, String filter) {
        return transactionsByBillingProfileWithServiceResponseAsync(billingAccountId, billingProfileId, startDate, endDate, filter).toBlocking().single().body();
    }

    /**
     * Lists the transactions by billingProfileId for given start date and end date.
     *
     * @param billingAccountId billing Account Id.
     * @param billingProfileId Billing Profile Id.
     * @param startDate Start date
     * @param endDate End date
     * @param filter May be used to filter by transaction kind. The filter supports 'eq', 'lt', 'gt', 'le', 'ge', and 'and'. It does not currently support 'ne', 'or', or 'not'. Tag filter is a key value pair string where key and value is separated by a colon (:).
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TransactionsListResultInner> transactionsByBillingProfileAsync(String billingAccountId, String billingProfileId, String startDate, String endDate, String filter, final ServiceCallback<TransactionsListResultInner> serviceCallback) {
        return ServiceFuture.fromResponse(transactionsByBillingProfileWithServiceResponseAsync(billingAccountId, billingProfileId, startDate, endDate, filter), serviceCallback);
    }

    /**
     * Lists the transactions by billingProfileId for given start date and end date.
     *
     * @param billingAccountId billing Account Id.
     * @param billingProfileId Billing Profile Id.
     * @param startDate Start date
     * @param endDate End date
     * @param filter May be used to filter by transaction kind. The filter supports 'eq', 'lt', 'gt', 'le', 'ge', and 'and'. It does not currently support 'ne', 'or', or 'not'. Tag filter is a key value pair string where key and value is separated by a colon (:).
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransactionsListResultInner object
     */
    public Observable<TransactionsListResultInner> transactionsByBillingProfileAsync(String billingAccountId, String billingProfileId, String startDate, String endDate, String filter) {
        return transactionsByBillingProfileWithServiceResponseAsync(billingAccountId, billingProfileId, startDate, endDate, filter).map(new Func1<ServiceResponse<TransactionsListResultInner>, TransactionsListResultInner>() {
            @Override
            public TransactionsListResultInner call(ServiceResponse<TransactionsListResultInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Lists the transactions by billingProfileId for given start date and end date.
     *
     * @param billingAccountId billing Account Id.
     * @param billingProfileId Billing Profile Id.
     * @param startDate Start date
     * @param endDate End date
     * @param filter May be used to filter by transaction kind. The filter supports 'eq', 'lt', 'gt', 'le', 'ge', and 'and'. It does not currently support 'ne', 'or', or 'not'. Tag filter is a key value pair string where key and value is separated by a colon (:).
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransactionsListResultInner object
     */
    public Observable<ServiceResponse<TransactionsListResultInner>> transactionsByBillingProfileWithServiceResponseAsync(String billingAccountId, String billingProfileId, String startDate, String endDate, String filter) {
        if (billingAccountId == null) {
            throw new IllegalArgumentException("Parameter billingAccountId is required and cannot be null.");
        }
        if (billingProfileId == null) {
            throw new IllegalArgumentException("Parameter billingProfileId is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        return service.transactionsByBillingProfile(billingAccountId, billingProfileId, this.apiVersion(), startDate, endDate, filter, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<TransactionsListResultInner>>>() {
                @Override
                public Observable<ServiceResponse<TransactionsListResultInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<TransactionsListResultInner> clientResponse = transactionsByBillingProfileDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<TransactionsListResultInner> transactionsByBillingProfileDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<TransactionsListResultInner, ErrorResponseException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<TransactionsListResultInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Cancel product by product id.
     *
     * @param billingAccountId billing Account Id.
     * @param productName Invoide Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UpdateAutoRenewOperationSummaryInner object if successful.
     */
    public UpdateAutoRenewOperationSummaryInner updateAutoRenewForBillingAccount(String billingAccountId, String productName) {
        return updateAutoRenewForBillingAccountWithServiceResponseAsync(billingAccountId, productName).toBlocking().single().body();
    }

    /**
     * Cancel product by product id.
     *
     * @param billingAccountId billing Account Id.
     * @param productName Invoide Id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UpdateAutoRenewOperationSummaryInner> updateAutoRenewForBillingAccountAsync(String billingAccountId, String productName, final ServiceCallback<UpdateAutoRenewOperationSummaryInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateAutoRenewForBillingAccountWithServiceResponseAsync(billingAccountId, productName), serviceCallback);
    }

    /**
     * Cancel product by product id.
     *
     * @param billingAccountId billing Account Id.
     * @param productName Invoide Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UpdateAutoRenewOperationSummaryInner object
     */
    public Observable<UpdateAutoRenewOperationSummaryInner> updateAutoRenewForBillingAccountAsync(String billingAccountId, String productName) {
        return updateAutoRenewForBillingAccountWithServiceResponseAsync(billingAccountId, productName).map(new Func1<ServiceResponse<UpdateAutoRenewOperationSummaryInner>, UpdateAutoRenewOperationSummaryInner>() {
            @Override
            public UpdateAutoRenewOperationSummaryInner call(ServiceResponse<UpdateAutoRenewOperationSummaryInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Cancel product by product id.
     *
     * @param billingAccountId billing Account Id.
     * @param productName Invoide Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UpdateAutoRenewOperationSummaryInner object
     */
    public Observable<ServiceResponse<UpdateAutoRenewOperationSummaryInner>> updateAutoRenewForBillingAccountWithServiceResponseAsync(String billingAccountId, String productName) {
        if (billingAccountId == null) {
            throw new IllegalArgumentException("Parameter billingAccountId is required and cannot be null.");
        }
        if (productName == null) {
            throw new IllegalArgumentException("Parameter productName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        final UpdateAutoRenew autoRenew = null;
        UpdateAutoRenewRequest body = new UpdateAutoRenewRequest();
        body.withAutoRenew(null);
        return service.updateAutoRenewForBillingAccount(billingAccountId, productName, this.apiVersion(), this.acceptLanguage(), body, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UpdateAutoRenewOperationSummaryInner>>>() {
                @Override
                public Observable<ServiceResponse<UpdateAutoRenewOperationSummaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UpdateAutoRenewOperationSummaryInner> clientResponse = updateAutoRenewForBillingAccountDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Cancel product by product id.
     *
     * @param billingAccountId billing Account Id.
     * @param productName Invoide Id.
     * @param autoRenew Request parameters to update auto renew policy a product. Possible values include: 'true', 'false'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UpdateAutoRenewOperationSummaryInner object if successful.
     */
    public UpdateAutoRenewOperationSummaryInner updateAutoRenewForBillingAccount(String billingAccountId, String productName, UpdateAutoRenew autoRenew) {
        return updateAutoRenewForBillingAccountWithServiceResponseAsync(billingAccountId, productName, autoRenew).toBlocking().single().body();
    }

    /**
     * Cancel product by product id.
     *
     * @param billingAccountId billing Account Id.
     * @param productName Invoide Id.
     * @param autoRenew Request parameters to update auto renew policy a product. Possible values include: 'true', 'false'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UpdateAutoRenewOperationSummaryInner> updateAutoRenewForBillingAccountAsync(String billingAccountId, String productName, UpdateAutoRenew autoRenew, final ServiceCallback<UpdateAutoRenewOperationSummaryInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateAutoRenewForBillingAccountWithServiceResponseAsync(billingAccountId, productName, autoRenew), serviceCallback);
    }

    /**
     * Cancel product by product id.
     *
     * @param billingAccountId billing Account Id.
     * @param productName Invoide Id.
     * @param autoRenew Request parameters to update auto renew policy a product. Possible values include: 'true', 'false'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UpdateAutoRenewOperationSummaryInner object
     */
    public Observable<UpdateAutoRenewOperationSummaryInner> updateAutoRenewForBillingAccountAsync(String billingAccountId, String productName, UpdateAutoRenew autoRenew) {
        return updateAutoRenewForBillingAccountWithServiceResponseAsync(billingAccountId, productName, autoRenew).map(new Func1<ServiceResponse<UpdateAutoRenewOperationSummaryInner>, UpdateAutoRenewOperationSummaryInner>() {
            @Override
            public UpdateAutoRenewOperationSummaryInner call(ServiceResponse<UpdateAutoRenewOperationSummaryInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Cancel product by product id.
     *
     * @param billingAccountId billing Account Id.
     * @param productName Invoide Id.
     * @param autoRenew Request parameters to update auto renew policy a product. Possible values include: 'true', 'false'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UpdateAutoRenewOperationSummaryInner object
     */
    public Observable<ServiceResponse<UpdateAutoRenewOperationSummaryInner>> updateAutoRenewForBillingAccountWithServiceResponseAsync(String billingAccountId, String productName, UpdateAutoRenew autoRenew) {
        if (billingAccountId == null) {
            throw new IllegalArgumentException("Parameter billingAccountId is required and cannot be null.");
        }
        if (productName == null) {
            throw new IllegalArgumentException("Parameter productName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        UpdateAutoRenewRequest body = new UpdateAutoRenewRequest();
        body.withAutoRenew(autoRenew);
        return service.updateAutoRenewForBillingAccount(billingAccountId, productName, this.apiVersion(), this.acceptLanguage(), body, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UpdateAutoRenewOperationSummaryInner>>>() {
                @Override
                public Observable<ServiceResponse<UpdateAutoRenewOperationSummaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UpdateAutoRenewOperationSummaryInner> clientResponse = updateAutoRenewForBillingAccountDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<UpdateAutoRenewOperationSummaryInner> updateAutoRenewForBillingAccountDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<UpdateAutoRenewOperationSummaryInner, ErrorResponseException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<UpdateAutoRenewOperationSummaryInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Cancel auto renew for product by product id.
     *
     * @param billingAccountId billing Account Id.
     * @param invoiceSectionId InvoiceSection Id.
     * @param productName Invoide Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UpdateAutoRenewOperationSummaryInner object if successful.
     */
    public UpdateAutoRenewOperationSummaryInner updateAutoRenewForInvoiceSection(String billingAccountId, String invoiceSectionId, String productName) {
        return updateAutoRenewForInvoiceSectionWithServiceResponseAsync(billingAccountId, invoiceSectionId, productName).toBlocking().single().body();
    }

    /**
     * Cancel auto renew for product by product id.
     *
     * @param billingAccountId billing Account Id.
     * @param invoiceSectionId InvoiceSection Id.
     * @param productName Invoide Id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UpdateAutoRenewOperationSummaryInner> updateAutoRenewForInvoiceSectionAsync(String billingAccountId, String invoiceSectionId, String productName, final ServiceCallback<UpdateAutoRenewOperationSummaryInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateAutoRenewForInvoiceSectionWithServiceResponseAsync(billingAccountId, invoiceSectionId, productName), serviceCallback);
    }

    /**
     * Cancel auto renew for product by product id.
     *
     * @param billingAccountId billing Account Id.
     * @param invoiceSectionId InvoiceSection Id.
     * @param productName Invoide Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UpdateAutoRenewOperationSummaryInner object
     */
    public Observable<UpdateAutoRenewOperationSummaryInner> updateAutoRenewForInvoiceSectionAsync(String billingAccountId, String invoiceSectionId, String productName) {
        return updateAutoRenewForInvoiceSectionWithServiceResponseAsync(billingAccountId, invoiceSectionId, productName).map(new Func1<ServiceResponse<UpdateAutoRenewOperationSummaryInner>, UpdateAutoRenewOperationSummaryInner>() {
            @Override
            public UpdateAutoRenewOperationSummaryInner call(ServiceResponse<UpdateAutoRenewOperationSummaryInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Cancel auto renew for product by product id.
     *
     * @param billingAccountId billing Account Id.
     * @param invoiceSectionId InvoiceSection Id.
     * @param productName Invoide Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UpdateAutoRenewOperationSummaryInner object
     */
    public Observable<ServiceResponse<UpdateAutoRenewOperationSummaryInner>> updateAutoRenewForInvoiceSectionWithServiceResponseAsync(String billingAccountId, String invoiceSectionId, String productName) {
        if (billingAccountId == null) {
            throw new IllegalArgumentException("Parameter billingAccountId is required and cannot be null.");
        }
        if (invoiceSectionId == null) {
            throw new IllegalArgumentException("Parameter invoiceSectionId is required and cannot be null.");
        }
        if (productName == null) {
            throw new IllegalArgumentException("Parameter productName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        final UpdateAutoRenew autoRenew = null;
        UpdateAutoRenewRequest body = new UpdateAutoRenewRequest();
        body.withAutoRenew(null);
        return service.updateAutoRenewForInvoiceSection(billingAccountId, invoiceSectionId, productName, this.apiVersion(), this.acceptLanguage(), body, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UpdateAutoRenewOperationSummaryInner>>>() {
                @Override
                public Observable<ServiceResponse<UpdateAutoRenewOperationSummaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UpdateAutoRenewOperationSummaryInner> clientResponse = updateAutoRenewForInvoiceSectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Cancel auto renew for product by product id.
     *
     * @param billingAccountId billing Account Id.
     * @param invoiceSectionId InvoiceSection Id.
     * @param productName Invoide Id.
     * @param autoRenew Request parameters to update auto renew policy a product. Possible values include: 'true', 'false'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UpdateAutoRenewOperationSummaryInner object if successful.
     */
    public UpdateAutoRenewOperationSummaryInner updateAutoRenewForInvoiceSection(String billingAccountId, String invoiceSectionId, String productName, UpdateAutoRenew autoRenew) {
        return updateAutoRenewForInvoiceSectionWithServiceResponseAsync(billingAccountId, invoiceSectionId, productName, autoRenew).toBlocking().single().body();
    }

    /**
     * Cancel auto renew for product by product id.
     *
     * @param billingAccountId billing Account Id.
     * @param invoiceSectionId InvoiceSection Id.
     * @param productName Invoide Id.
     * @param autoRenew Request parameters to update auto renew policy a product. Possible values include: 'true', 'false'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UpdateAutoRenewOperationSummaryInner> updateAutoRenewForInvoiceSectionAsync(String billingAccountId, String invoiceSectionId, String productName, UpdateAutoRenew autoRenew, final ServiceCallback<UpdateAutoRenewOperationSummaryInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateAutoRenewForInvoiceSectionWithServiceResponseAsync(billingAccountId, invoiceSectionId, productName, autoRenew), serviceCallback);
    }

    /**
     * Cancel auto renew for product by product id.
     *
     * @param billingAccountId billing Account Id.
     * @param invoiceSectionId InvoiceSection Id.
     * @param productName Invoide Id.
     * @param autoRenew Request parameters to update auto renew policy a product. Possible values include: 'true', 'false'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UpdateAutoRenewOperationSummaryInner object
     */
    public Observable<UpdateAutoRenewOperationSummaryInner> updateAutoRenewForInvoiceSectionAsync(String billingAccountId, String invoiceSectionId, String productName, UpdateAutoRenew autoRenew) {
        return updateAutoRenewForInvoiceSectionWithServiceResponseAsync(billingAccountId, invoiceSectionId, productName, autoRenew).map(new Func1<ServiceResponse<UpdateAutoRenewOperationSummaryInner>, UpdateAutoRenewOperationSummaryInner>() {
            @Override
            public UpdateAutoRenewOperationSummaryInner call(ServiceResponse<UpdateAutoRenewOperationSummaryInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Cancel auto renew for product by product id.
     *
     * @param billingAccountId billing Account Id.
     * @param invoiceSectionId InvoiceSection Id.
     * @param productName Invoide Id.
     * @param autoRenew Request parameters to update auto renew policy a product. Possible values include: 'true', 'false'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UpdateAutoRenewOperationSummaryInner object
     */
    public Observable<ServiceResponse<UpdateAutoRenewOperationSummaryInner>> updateAutoRenewForInvoiceSectionWithServiceResponseAsync(String billingAccountId, String invoiceSectionId, String productName, UpdateAutoRenew autoRenew) {
        if (billingAccountId == null) {
            throw new IllegalArgumentException("Parameter billingAccountId is required and cannot be null.");
        }
        if (invoiceSectionId == null) {
            throw new IllegalArgumentException("Parameter invoiceSectionId is required and cannot be null.");
        }
        if (productName == null) {
            throw new IllegalArgumentException("Parameter productName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        UpdateAutoRenewRequest body = new UpdateAutoRenewRequest();
        body.withAutoRenew(autoRenew);
        return service.updateAutoRenewForInvoiceSection(billingAccountId, invoiceSectionId, productName, this.apiVersion(), this.acceptLanguage(), body, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UpdateAutoRenewOperationSummaryInner>>>() {
                @Override
                public Observable<ServiceResponse<UpdateAutoRenewOperationSummaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UpdateAutoRenewOperationSummaryInner> clientResponse = updateAutoRenewForInvoiceSectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<UpdateAutoRenewOperationSummaryInner> updateAutoRenewForInvoiceSectionDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<UpdateAutoRenewOperationSummaryInner, ErrorResponseException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<UpdateAutoRenewOperationSummaryInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

}
