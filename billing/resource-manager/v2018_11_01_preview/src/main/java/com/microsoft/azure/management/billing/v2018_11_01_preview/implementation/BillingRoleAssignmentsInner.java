/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.management.billing.v2018_11_01_preview.implementation;

import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.management.billing.v2018_11_01_preview.BillingRoleAssignmentPayload;
import com.microsoft.azure.management.billing.v2018_11_01_preview.ErrorResponseException;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.IOException;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in BillingRoleAssignments.
 */
public class BillingRoleAssignmentsInner {
    /** The Retrofit service to perform REST calls. */
    private BillingRoleAssignmentsService service;
    /** The service client containing this operation class. */
    private BillingManagementClientImpl client;

    /**
     * Initializes an instance of BillingRoleAssignmentsInner.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public BillingRoleAssignmentsInner(Retrofit retrofit, BillingManagementClientImpl client) {
        this.service = retrofit.create(BillingRoleAssignmentsService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for BillingRoleAssignments to be
     * used by Retrofit to perform actually REST calls.
     */
    interface BillingRoleAssignmentsService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2018_11_01_preview.BillingRoleAssignments getByBillingAccount" })
        @GET("providers/Microsoft.Billing/billingAccounts/{billingAccountName}/providers/Microsoft.Billing/billingRoleAssignments/{billingRoleAssignmentName}")
        Observable<Response<ResponseBody>> getByBillingAccount(@Path("billingAccountName") String billingAccountName, @Path("billingRoleAssignmentName") String billingRoleAssignmentName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2018_11_01_preview.BillingRoleAssignments deleteByBillingAccountName" })
        @HTTP(path = "providers/Microsoft.Billing/billingAccounts/{billingAccountName}/providers/Microsoft.Billing/billingRoleAssignments/{billingRoleAssignmentName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteByBillingAccountName(@Path("billingAccountName") String billingAccountName, @Path("billingRoleAssignmentName") String billingRoleAssignmentName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2018_11_01_preview.BillingRoleAssignments getByInvoiceSectionName" })
        @GET("providers/Microsoft.Billing/billingAccounts/{billingAccountName}/invoiceSections/{invoiceSectionName}/providers/Microsoft.Billing/billingRoleAssignments/{billingRoleAssignmentName}")
        Observable<Response<ResponseBody>> getByInvoiceSectionName(@Path("billingAccountName") String billingAccountName, @Path("invoiceSectionName") String invoiceSectionName, @Path("billingRoleAssignmentName") String billingRoleAssignmentName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2018_11_01_preview.BillingRoleAssignments deleteByInvoiceSectionName" })
        @HTTP(path = "providers/Microsoft.Billing/billingAccounts/{billingAccountName}/invoiceSections/{invoiceSectionName}/providers/Microsoft.Billing/billingRoleAssignments/{billingRoleAssignmentName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteByInvoiceSectionName(@Path("billingAccountName") String billingAccountName, @Path("invoiceSectionName") String invoiceSectionName, @Path("billingRoleAssignmentName") String billingRoleAssignmentName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2018_11_01_preview.BillingRoleAssignments getByBillingProfileName" })
        @GET("providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingProfiles/{billingProfileName}/providers/Microsoft.Billing/billingRoleAssignments/{billingRoleAssignmentName}")
        Observable<Response<ResponseBody>> getByBillingProfileName(@Path("billingAccountName") String billingAccountName, @Path("billingProfileName") String billingProfileName, @Path("billingRoleAssignmentName") String billingRoleAssignmentName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2018_11_01_preview.BillingRoleAssignments deleteByBillingProfileName" })
        @HTTP(path = "providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingProfiles/{billingProfileName}/providers/Microsoft.Billing/billingRoleAssignments/{billingRoleAssignmentName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteByBillingProfileName(@Path("billingAccountName") String billingAccountName, @Path("billingProfileName") String billingProfileName, @Path("billingRoleAssignmentName") String billingRoleAssignmentName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2018_11_01_preview.BillingRoleAssignments listByBillingAccountName" })
        @GET("providers/Microsoft.Billing/billingAccounts/{billingAccountName}/providers/Microsoft.Billing/billingRoleAssignments")
        Observable<Response<ResponseBody>> listByBillingAccountName(@Path("billingAccountName") String billingAccountName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2018_11_01_preview.BillingRoleAssignments addByBillingAccountName" })
        @POST("providers/Microsoft.Billing/billingAccounts/{billingAccountName}/providers/Microsoft.Billing/createBillingRoleAssignment")
        Observable<Response<ResponseBody>> addByBillingAccountName(@Path("billingAccountName") String billingAccountName, @Query("api-version") String apiVersion, @Body BillingRoleAssignmentPayload parameters, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2018_11_01_preview.BillingRoleAssignments listByInvoiceSectionName" })
        @GET("providers/Microsoft.Billing/billingAccounts/{billingAccountName}/invoiceSections/{invoiceSectionName}/providers/Microsoft.Billing/billingRoleAssignments")
        Observable<Response<ResponseBody>> listByInvoiceSectionName(@Path("billingAccountName") String billingAccountName, @Path("invoiceSectionName") String invoiceSectionName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2018_11_01_preview.BillingRoleAssignments addByInvoiceSectionName" })
        @POST("providers/Microsoft.Billing/billingAccounts/{billingAccountName}/invoiceSections/{invoiceSectionName}/providers/Microsoft.Billing/createBillingRoleAssignment")
        Observable<Response<ResponseBody>> addByInvoiceSectionName(@Path("billingAccountName") String billingAccountName, @Path("invoiceSectionName") String invoiceSectionName, @Query("api-version") String apiVersion, @Body BillingRoleAssignmentPayload parameters, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2018_11_01_preview.BillingRoleAssignments listByBillingProfileName" })
        @GET("providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingProfiles/{billingProfileName}/providers/Microsoft.Billing/billingRoleAssignments")
        Observable<Response<ResponseBody>> listByBillingProfileName(@Path("billingAccountName") String billingAccountName, @Path("billingProfileName") String billingProfileName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.billing.v2018_11_01_preview.BillingRoleAssignments addByBillingProfileName" })
        @POST("providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingProfiles/{billingProfileName}/providers/Microsoft.Billing/createBillingRoleAssignment")
        Observable<Response<ResponseBody>> addByBillingProfileName(@Path("billingAccountName") String billingAccountName, @Path("billingProfileName") String billingProfileName, @Query("api-version") String apiVersion, @Body BillingRoleAssignmentPayload parameters, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

    }

    /**
     * Get the role assignment for the caller.
     *
     * @param billingAccountName Billing Account Id.
     * @param billingRoleAssignmentName role assignment id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BillingRoleAssignmentInner object if successful.
     */
    public BillingRoleAssignmentInner getByBillingAccount(String billingAccountName, String billingRoleAssignmentName) {
        return getByBillingAccountWithServiceResponseAsync(billingAccountName, billingRoleAssignmentName).toBlocking().single().body();
    }

    /**
     * Get the role assignment for the caller.
     *
     * @param billingAccountName Billing Account Id.
     * @param billingRoleAssignmentName role assignment id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BillingRoleAssignmentInner> getByBillingAccountAsync(String billingAccountName, String billingRoleAssignmentName, final ServiceCallback<BillingRoleAssignmentInner> serviceCallback) {
        return ServiceFuture.fromResponse(getByBillingAccountWithServiceResponseAsync(billingAccountName, billingRoleAssignmentName), serviceCallback);
    }

    /**
     * Get the role assignment for the caller.
     *
     * @param billingAccountName Billing Account Id.
     * @param billingRoleAssignmentName role assignment id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BillingRoleAssignmentInner object
     */
    public Observable<BillingRoleAssignmentInner> getByBillingAccountAsync(String billingAccountName, String billingRoleAssignmentName) {
        return getByBillingAccountWithServiceResponseAsync(billingAccountName, billingRoleAssignmentName).map(new Func1<ServiceResponse<BillingRoleAssignmentInner>, BillingRoleAssignmentInner>() {
            @Override
            public BillingRoleAssignmentInner call(ServiceResponse<BillingRoleAssignmentInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get the role assignment for the caller.
     *
     * @param billingAccountName Billing Account Id.
     * @param billingRoleAssignmentName role assignment id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BillingRoleAssignmentInner object
     */
    public Observable<ServiceResponse<BillingRoleAssignmentInner>> getByBillingAccountWithServiceResponseAsync(String billingAccountName, String billingRoleAssignmentName) {
        if (billingAccountName == null) {
            throw new IllegalArgumentException("Parameter billingAccountName is required and cannot be null.");
        }
        if (billingRoleAssignmentName == null) {
            throw new IllegalArgumentException("Parameter billingRoleAssignmentName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getByBillingAccount(billingAccountName, billingRoleAssignmentName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BillingRoleAssignmentInner>>>() {
                @Override
                public Observable<ServiceResponse<BillingRoleAssignmentInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BillingRoleAssignmentInner> clientResponse = getByBillingAccountDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BillingRoleAssignmentInner> getByBillingAccountDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<BillingRoleAssignmentInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BillingRoleAssignmentInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Delete the role assignment on this billing account.
     *
     * @param billingAccountName Billing Account Id.
     * @param billingRoleAssignmentName role assignment id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BillingRoleAssignmentInner object if successful.
     */
    public BillingRoleAssignmentInner deleteByBillingAccountName(String billingAccountName, String billingRoleAssignmentName) {
        return deleteByBillingAccountNameWithServiceResponseAsync(billingAccountName, billingRoleAssignmentName).toBlocking().single().body();
    }

    /**
     * Delete the role assignment on this billing account.
     *
     * @param billingAccountName Billing Account Id.
     * @param billingRoleAssignmentName role assignment id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BillingRoleAssignmentInner> deleteByBillingAccountNameAsync(String billingAccountName, String billingRoleAssignmentName, final ServiceCallback<BillingRoleAssignmentInner> serviceCallback) {
        return ServiceFuture.fromResponse(deleteByBillingAccountNameWithServiceResponseAsync(billingAccountName, billingRoleAssignmentName), serviceCallback);
    }

    /**
     * Delete the role assignment on this billing account.
     *
     * @param billingAccountName Billing Account Id.
     * @param billingRoleAssignmentName role assignment id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BillingRoleAssignmentInner object
     */
    public Observable<BillingRoleAssignmentInner> deleteByBillingAccountNameAsync(String billingAccountName, String billingRoleAssignmentName) {
        return deleteByBillingAccountNameWithServiceResponseAsync(billingAccountName, billingRoleAssignmentName).map(new Func1<ServiceResponse<BillingRoleAssignmentInner>, BillingRoleAssignmentInner>() {
            @Override
            public BillingRoleAssignmentInner call(ServiceResponse<BillingRoleAssignmentInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete the role assignment on this billing account.
     *
     * @param billingAccountName Billing Account Id.
     * @param billingRoleAssignmentName role assignment id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BillingRoleAssignmentInner object
     */
    public Observable<ServiceResponse<BillingRoleAssignmentInner>> deleteByBillingAccountNameWithServiceResponseAsync(String billingAccountName, String billingRoleAssignmentName) {
        if (billingAccountName == null) {
            throw new IllegalArgumentException("Parameter billingAccountName is required and cannot be null.");
        }
        if (billingRoleAssignmentName == null) {
            throw new IllegalArgumentException("Parameter billingRoleAssignmentName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteByBillingAccountName(billingAccountName, billingRoleAssignmentName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BillingRoleAssignmentInner>>>() {
                @Override
                public Observable<ServiceResponse<BillingRoleAssignmentInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BillingRoleAssignmentInner> clientResponse = deleteByBillingAccountNameDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BillingRoleAssignmentInner> deleteByBillingAccountNameDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<BillingRoleAssignmentInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BillingRoleAssignmentInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Get the role assignment for the caller on the invoice Section.
     *
     * @param billingAccountName Billing Account Id.
     * @param invoiceSectionName InvoiceSection Id.
     * @param billingRoleAssignmentName role assignment id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BillingRoleAssignmentInner object if successful.
     */
    public BillingRoleAssignmentInner getByInvoiceSectionName(String billingAccountName, String invoiceSectionName, String billingRoleAssignmentName) {
        return getByInvoiceSectionNameWithServiceResponseAsync(billingAccountName, invoiceSectionName, billingRoleAssignmentName).toBlocking().single().body();
    }

    /**
     * Get the role assignment for the caller on the invoice Section.
     *
     * @param billingAccountName Billing Account Id.
     * @param invoiceSectionName InvoiceSection Id.
     * @param billingRoleAssignmentName role assignment id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BillingRoleAssignmentInner> getByInvoiceSectionNameAsync(String billingAccountName, String invoiceSectionName, String billingRoleAssignmentName, final ServiceCallback<BillingRoleAssignmentInner> serviceCallback) {
        return ServiceFuture.fromResponse(getByInvoiceSectionNameWithServiceResponseAsync(billingAccountName, invoiceSectionName, billingRoleAssignmentName), serviceCallback);
    }

    /**
     * Get the role assignment for the caller on the invoice Section.
     *
     * @param billingAccountName Billing Account Id.
     * @param invoiceSectionName InvoiceSection Id.
     * @param billingRoleAssignmentName role assignment id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BillingRoleAssignmentInner object
     */
    public Observable<BillingRoleAssignmentInner> getByInvoiceSectionNameAsync(String billingAccountName, String invoiceSectionName, String billingRoleAssignmentName) {
        return getByInvoiceSectionNameWithServiceResponseAsync(billingAccountName, invoiceSectionName, billingRoleAssignmentName).map(new Func1<ServiceResponse<BillingRoleAssignmentInner>, BillingRoleAssignmentInner>() {
            @Override
            public BillingRoleAssignmentInner call(ServiceResponse<BillingRoleAssignmentInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get the role assignment for the caller on the invoice Section.
     *
     * @param billingAccountName Billing Account Id.
     * @param invoiceSectionName InvoiceSection Id.
     * @param billingRoleAssignmentName role assignment id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BillingRoleAssignmentInner object
     */
    public Observable<ServiceResponse<BillingRoleAssignmentInner>> getByInvoiceSectionNameWithServiceResponseAsync(String billingAccountName, String invoiceSectionName, String billingRoleAssignmentName) {
        if (billingAccountName == null) {
            throw new IllegalArgumentException("Parameter billingAccountName is required and cannot be null.");
        }
        if (invoiceSectionName == null) {
            throw new IllegalArgumentException("Parameter invoiceSectionName is required and cannot be null.");
        }
        if (billingRoleAssignmentName == null) {
            throw new IllegalArgumentException("Parameter billingRoleAssignmentName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getByInvoiceSectionName(billingAccountName, invoiceSectionName, billingRoleAssignmentName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BillingRoleAssignmentInner>>>() {
                @Override
                public Observable<ServiceResponse<BillingRoleAssignmentInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BillingRoleAssignmentInner> clientResponse = getByInvoiceSectionNameDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BillingRoleAssignmentInner> getByInvoiceSectionNameDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<BillingRoleAssignmentInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BillingRoleAssignmentInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Delete the role assignment on the invoice Section.
     *
     * @param billingAccountName Billing Account Id.
     * @param invoiceSectionName InvoiceSection Id.
     * @param billingRoleAssignmentName role assignment id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BillingRoleAssignmentInner object if successful.
     */
    public BillingRoleAssignmentInner deleteByInvoiceSectionName(String billingAccountName, String invoiceSectionName, String billingRoleAssignmentName) {
        return deleteByInvoiceSectionNameWithServiceResponseAsync(billingAccountName, invoiceSectionName, billingRoleAssignmentName).toBlocking().single().body();
    }

    /**
     * Delete the role assignment on the invoice Section.
     *
     * @param billingAccountName Billing Account Id.
     * @param invoiceSectionName InvoiceSection Id.
     * @param billingRoleAssignmentName role assignment id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BillingRoleAssignmentInner> deleteByInvoiceSectionNameAsync(String billingAccountName, String invoiceSectionName, String billingRoleAssignmentName, final ServiceCallback<BillingRoleAssignmentInner> serviceCallback) {
        return ServiceFuture.fromResponse(deleteByInvoiceSectionNameWithServiceResponseAsync(billingAccountName, invoiceSectionName, billingRoleAssignmentName), serviceCallback);
    }

    /**
     * Delete the role assignment on the invoice Section.
     *
     * @param billingAccountName Billing Account Id.
     * @param invoiceSectionName InvoiceSection Id.
     * @param billingRoleAssignmentName role assignment id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BillingRoleAssignmentInner object
     */
    public Observable<BillingRoleAssignmentInner> deleteByInvoiceSectionNameAsync(String billingAccountName, String invoiceSectionName, String billingRoleAssignmentName) {
        return deleteByInvoiceSectionNameWithServiceResponseAsync(billingAccountName, invoiceSectionName, billingRoleAssignmentName).map(new Func1<ServiceResponse<BillingRoleAssignmentInner>, BillingRoleAssignmentInner>() {
            @Override
            public BillingRoleAssignmentInner call(ServiceResponse<BillingRoleAssignmentInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete the role assignment on the invoice Section.
     *
     * @param billingAccountName Billing Account Id.
     * @param invoiceSectionName InvoiceSection Id.
     * @param billingRoleAssignmentName role assignment id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BillingRoleAssignmentInner object
     */
    public Observable<ServiceResponse<BillingRoleAssignmentInner>> deleteByInvoiceSectionNameWithServiceResponseAsync(String billingAccountName, String invoiceSectionName, String billingRoleAssignmentName) {
        if (billingAccountName == null) {
            throw new IllegalArgumentException("Parameter billingAccountName is required and cannot be null.");
        }
        if (invoiceSectionName == null) {
            throw new IllegalArgumentException("Parameter invoiceSectionName is required and cannot be null.");
        }
        if (billingRoleAssignmentName == null) {
            throw new IllegalArgumentException("Parameter billingRoleAssignmentName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteByInvoiceSectionName(billingAccountName, invoiceSectionName, billingRoleAssignmentName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BillingRoleAssignmentInner>>>() {
                @Override
                public Observable<ServiceResponse<BillingRoleAssignmentInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BillingRoleAssignmentInner> clientResponse = deleteByInvoiceSectionNameDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BillingRoleAssignmentInner> deleteByInvoiceSectionNameDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<BillingRoleAssignmentInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BillingRoleAssignmentInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Get the role assignment for the caller on the Billing Profile.
     *
     * @param billingAccountName Billing Account Id.
     * @param billingProfileName Billing Profile Id.
     * @param billingRoleAssignmentName role assignment id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BillingRoleAssignmentInner object if successful.
     */
    public BillingRoleAssignmentInner getByBillingProfileName(String billingAccountName, String billingProfileName, String billingRoleAssignmentName) {
        return getByBillingProfileNameWithServiceResponseAsync(billingAccountName, billingProfileName, billingRoleAssignmentName).toBlocking().single().body();
    }

    /**
     * Get the role assignment for the caller on the Billing Profile.
     *
     * @param billingAccountName Billing Account Id.
     * @param billingProfileName Billing Profile Id.
     * @param billingRoleAssignmentName role assignment id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BillingRoleAssignmentInner> getByBillingProfileNameAsync(String billingAccountName, String billingProfileName, String billingRoleAssignmentName, final ServiceCallback<BillingRoleAssignmentInner> serviceCallback) {
        return ServiceFuture.fromResponse(getByBillingProfileNameWithServiceResponseAsync(billingAccountName, billingProfileName, billingRoleAssignmentName), serviceCallback);
    }

    /**
     * Get the role assignment for the caller on the Billing Profile.
     *
     * @param billingAccountName Billing Account Id.
     * @param billingProfileName Billing Profile Id.
     * @param billingRoleAssignmentName role assignment id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BillingRoleAssignmentInner object
     */
    public Observable<BillingRoleAssignmentInner> getByBillingProfileNameAsync(String billingAccountName, String billingProfileName, String billingRoleAssignmentName) {
        return getByBillingProfileNameWithServiceResponseAsync(billingAccountName, billingProfileName, billingRoleAssignmentName).map(new Func1<ServiceResponse<BillingRoleAssignmentInner>, BillingRoleAssignmentInner>() {
            @Override
            public BillingRoleAssignmentInner call(ServiceResponse<BillingRoleAssignmentInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get the role assignment for the caller on the Billing Profile.
     *
     * @param billingAccountName Billing Account Id.
     * @param billingProfileName Billing Profile Id.
     * @param billingRoleAssignmentName role assignment id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BillingRoleAssignmentInner object
     */
    public Observable<ServiceResponse<BillingRoleAssignmentInner>> getByBillingProfileNameWithServiceResponseAsync(String billingAccountName, String billingProfileName, String billingRoleAssignmentName) {
        if (billingAccountName == null) {
            throw new IllegalArgumentException("Parameter billingAccountName is required and cannot be null.");
        }
        if (billingProfileName == null) {
            throw new IllegalArgumentException("Parameter billingProfileName is required and cannot be null.");
        }
        if (billingRoleAssignmentName == null) {
            throw new IllegalArgumentException("Parameter billingRoleAssignmentName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getByBillingProfileName(billingAccountName, billingProfileName, billingRoleAssignmentName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BillingRoleAssignmentInner>>>() {
                @Override
                public Observable<ServiceResponse<BillingRoleAssignmentInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BillingRoleAssignmentInner> clientResponse = getByBillingProfileNameDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BillingRoleAssignmentInner> getByBillingProfileNameDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<BillingRoleAssignmentInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BillingRoleAssignmentInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Delete the role assignment on this Billing Profile.
     *
     * @param billingAccountName Billing Account Id.
     * @param billingProfileName Billing Profile Id.
     * @param billingRoleAssignmentName role assignment id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BillingRoleAssignmentInner object if successful.
     */
    public BillingRoleAssignmentInner deleteByBillingProfileName(String billingAccountName, String billingProfileName, String billingRoleAssignmentName) {
        return deleteByBillingProfileNameWithServiceResponseAsync(billingAccountName, billingProfileName, billingRoleAssignmentName).toBlocking().single().body();
    }

    /**
     * Delete the role assignment on this Billing Profile.
     *
     * @param billingAccountName Billing Account Id.
     * @param billingProfileName Billing Profile Id.
     * @param billingRoleAssignmentName role assignment id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BillingRoleAssignmentInner> deleteByBillingProfileNameAsync(String billingAccountName, String billingProfileName, String billingRoleAssignmentName, final ServiceCallback<BillingRoleAssignmentInner> serviceCallback) {
        return ServiceFuture.fromResponse(deleteByBillingProfileNameWithServiceResponseAsync(billingAccountName, billingProfileName, billingRoleAssignmentName), serviceCallback);
    }

    /**
     * Delete the role assignment on this Billing Profile.
     *
     * @param billingAccountName Billing Account Id.
     * @param billingProfileName Billing Profile Id.
     * @param billingRoleAssignmentName role assignment id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BillingRoleAssignmentInner object
     */
    public Observable<BillingRoleAssignmentInner> deleteByBillingProfileNameAsync(String billingAccountName, String billingProfileName, String billingRoleAssignmentName) {
        return deleteByBillingProfileNameWithServiceResponseAsync(billingAccountName, billingProfileName, billingRoleAssignmentName).map(new Func1<ServiceResponse<BillingRoleAssignmentInner>, BillingRoleAssignmentInner>() {
            @Override
            public BillingRoleAssignmentInner call(ServiceResponse<BillingRoleAssignmentInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete the role assignment on this Billing Profile.
     *
     * @param billingAccountName Billing Account Id.
     * @param billingProfileName Billing Profile Id.
     * @param billingRoleAssignmentName role assignment id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BillingRoleAssignmentInner object
     */
    public Observable<ServiceResponse<BillingRoleAssignmentInner>> deleteByBillingProfileNameWithServiceResponseAsync(String billingAccountName, String billingProfileName, String billingRoleAssignmentName) {
        if (billingAccountName == null) {
            throw new IllegalArgumentException("Parameter billingAccountName is required and cannot be null.");
        }
        if (billingProfileName == null) {
            throw new IllegalArgumentException("Parameter billingProfileName is required and cannot be null.");
        }
        if (billingRoleAssignmentName == null) {
            throw new IllegalArgumentException("Parameter billingRoleAssignmentName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.deleteByBillingProfileName(billingAccountName, billingProfileName, billingRoleAssignmentName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BillingRoleAssignmentInner>>>() {
                @Override
                public Observable<ServiceResponse<BillingRoleAssignmentInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BillingRoleAssignmentInner> clientResponse = deleteByBillingProfileNameDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BillingRoleAssignmentInner> deleteByBillingProfileNameDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<BillingRoleAssignmentInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BillingRoleAssignmentInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Get the role assignments on the Billing Account.
     *
     * @param billingAccountName Billing Account Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BillingRoleAssignmentListResultInner object if successful.
     */
    public BillingRoleAssignmentListResultInner listByBillingAccountName(String billingAccountName) {
        return listByBillingAccountNameWithServiceResponseAsync(billingAccountName).toBlocking().single().body();
    }

    /**
     * Get the role assignments on the Billing Account.
     *
     * @param billingAccountName Billing Account Id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BillingRoleAssignmentListResultInner> listByBillingAccountNameAsync(String billingAccountName, final ServiceCallback<BillingRoleAssignmentListResultInner> serviceCallback) {
        return ServiceFuture.fromResponse(listByBillingAccountNameWithServiceResponseAsync(billingAccountName), serviceCallback);
    }

    /**
     * Get the role assignments on the Billing Account.
     *
     * @param billingAccountName Billing Account Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BillingRoleAssignmentListResultInner object
     */
    public Observable<BillingRoleAssignmentListResultInner> listByBillingAccountNameAsync(String billingAccountName) {
        return listByBillingAccountNameWithServiceResponseAsync(billingAccountName).map(new Func1<ServiceResponse<BillingRoleAssignmentListResultInner>, BillingRoleAssignmentListResultInner>() {
            @Override
            public BillingRoleAssignmentListResultInner call(ServiceResponse<BillingRoleAssignmentListResultInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get the role assignments on the Billing Account.
     *
     * @param billingAccountName Billing Account Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BillingRoleAssignmentListResultInner object
     */
    public Observable<ServiceResponse<BillingRoleAssignmentListResultInner>> listByBillingAccountNameWithServiceResponseAsync(String billingAccountName) {
        if (billingAccountName == null) {
            throw new IllegalArgumentException("Parameter billingAccountName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listByBillingAccountName(billingAccountName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BillingRoleAssignmentListResultInner>>>() {
                @Override
                public Observable<ServiceResponse<BillingRoleAssignmentListResultInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BillingRoleAssignmentListResultInner> clientResponse = listByBillingAccountNameDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BillingRoleAssignmentListResultInner> listByBillingAccountNameDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<BillingRoleAssignmentListResultInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BillingRoleAssignmentListResultInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * The operation to add a role assignment to a billing account.
     *
     * @param billingAccountName Billing Account Id.
     * @param parameters Parameters supplied to add a role assignment.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BillingRoleAssignmentListResultInner object if successful.
     */
    public BillingRoleAssignmentListResultInner addByBillingAccountName(String billingAccountName, BillingRoleAssignmentPayload parameters) {
        return addByBillingAccountNameWithServiceResponseAsync(billingAccountName, parameters).toBlocking().single().body();
    }

    /**
     * The operation to add a role assignment to a billing account.
     *
     * @param billingAccountName Billing Account Id.
     * @param parameters Parameters supplied to add a role assignment.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BillingRoleAssignmentListResultInner> addByBillingAccountNameAsync(String billingAccountName, BillingRoleAssignmentPayload parameters, final ServiceCallback<BillingRoleAssignmentListResultInner> serviceCallback) {
        return ServiceFuture.fromResponse(addByBillingAccountNameWithServiceResponseAsync(billingAccountName, parameters), serviceCallback);
    }

    /**
     * The operation to add a role assignment to a billing account.
     *
     * @param billingAccountName Billing Account Id.
     * @param parameters Parameters supplied to add a role assignment.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BillingRoleAssignmentListResultInner object
     */
    public Observable<BillingRoleAssignmentListResultInner> addByBillingAccountNameAsync(String billingAccountName, BillingRoleAssignmentPayload parameters) {
        return addByBillingAccountNameWithServiceResponseAsync(billingAccountName, parameters).map(new Func1<ServiceResponse<BillingRoleAssignmentListResultInner>, BillingRoleAssignmentListResultInner>() {
            @Override
            public BillingRoleAssignmentListResultInner call(ServiceResponse<BillingRoleAssignmentListResultInner> response) {
                return response.body();
            }
        });
    }

    /**
     * The operation to add a role assignment to a billing account.
     *
     * @param billingAccountName Billing Account Id.
     * @param parameters Parameters supplied to add a role assignment.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BillingRoleAssignmentListResultInner object
     */
    public Observable<ServiceResponse<BillingRoleAssignmentListResultInner>> addByBillingAccountNameWithServiceResponseAsync(String billingAccountName, BillingRoleAssignmentPayload parameters) {
        if (billingAccountName == null) {
            throw new IllegalArgumentException("Parameter billingAccountName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        if (parameters == null) {
            throw new IllegalArgumentException("Parameter parameters is required and cannot be null.");
        }
        Validator.validate(parameters);
        return service.addByBillingAccountName(billingAccountName, this.client.apiVersion(), parameters, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BillingRoleAssignmentListResultInner>>>() {
                @Override
                public Observable<ServiceResponse<BillingRoleAssignmentListResultInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BillingRoleAssignmentListResultInner> clientResponse = addByBillingAccountNameDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BillingRoleAssignmentListResultInner> addByBillingAccountNameDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<BillingRoleAssignmentListResultInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(201, new TypeToken<BillingRoleAssignmentListResultInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Get the role assignments on the invoice Section.
     *
     * @param billingAccountName Billing Account Id.
     * @param invoiceSectionName InvoiceSection Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BillingRoleAssignmentListResultInner object if successful.
     */
    public BillingRoleAssignmentListResultInner listByInvoiceSectionName(String billingAccountName, String invoiceSectionName) {
        return listByInvoiceSectionNameWithServiceResponseAsync(billingAccountName, invoiceSectionName).toBlocking().single().body();
    }

    /**
     * Get the role assignments on the invoice Section.
     *
     * @param billingAccountName Billing Account Id.
     * @param invoiceSectionName InvoiceSection Id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BillingRoleAssignmentListResultInner> listByInvoiceSectionNameAsync(String billingAccountName, String invoiceSectionName, final ServiceCallback<BillingRoleAssignmentListResultInner> serviceCallback) {
        return ServiceFuture.fromResponse(listByInvoiceSectionNameWithServiceResponseAsync(billingAccountName, invoiceSectionName), serviceCallback);
    }

    /**
     * Get the role assignments on the invoice Section.
     *
     * @param billingAccountName Billing Account Id.
     * @param invoiceSectionName InvoiceSection Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BillingRoleAssignmentListResultInner object
     */
    public Observable<BillingRoleAssignmentListResultInner> listByInvoiceSectionNameAsync(String billingAccountName, String invoiceSectionName) {
        return listByInvoiceSectionNameWithServiceResponseAsync(billingAccountName, invoiceSectionName).map(new Func1<ServiceResponse<BillingRoleAssignmentListResultInner>, BillingRoleAssignmentListResultInner>() {
            @Override
            public BillingRoleAssignmentListResultInner call(ServiceResponse<BillingRoleAssignmentListResultInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get the role assignments on the invoice Section.
     *
     * @param billingAccountName Billing Account Id.
     * @param invoiceSectionName InvoiceSection Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BillingRoleAssignmentListResultInner object
     */
    public Observable<ServiceResponse<BillingRoleAssignmentListResultInner>> listByInvoiceSectionNameWithServiceResponseAsync(String billingAccountName, String invoiceSectionName) {
        if (billingAccountName == null) {
            throw new IllegalArgumentException("Parameter billingAccountName is required and cannot be null.");
        }
        if (invoiceSectionName == null) {
            throw new IllegalArgumentException("Parameter invoiceSectionName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listByInvoiceSectionName(billingAccountName, invoiceSectionName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BillingRoleAssignmentListResultInner>>>() {
                @Override
                public Observable<ServiceResponse<BillingRoleAssignmentListResultInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BillingRoleAssignmentListResultInner> clientResponse = listByInvoiceSectionNameDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BillingRoleAssignmentListResultInner> listByInvoiceSectionNameDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<BillingRoleAssignmentListResultInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BillingRoleAssignmentListResultInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * The operation to add a role assignment to a invoice Section.
     *
     * @param billingAccountName Billing Account Id.
     * @param invoiceSectionName InvoiceSection Id.
     * @param parameters Parameters supplied to add a role assignment.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BillingRoleAssignmentListResultInner object if successful.
     */
    public BillingRoleAssignmentListResultInner addByInvoiceSectionName(String billingAccountName, String invoiceSectionName, BillingRoleAssignmentPayload parameters) {
        return addByInvoiceSectionNameWithServiceResponseAsync(billingAccountName, invoiceSectionName, parameters).toBlocking().single().body();
    }

    /**
     * The operation to add a role assignment to a invoice Section.
     *
     * @param billingAccountName Billing Account Id.
     * @param invoiceSectionName InvoiceSection Id.
     * @param parameters Parameters supplied to add a role assignment.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BillingRoleAssignmentListResultInner> addByInvoiceSectionNameAsync(String billingAccountName, String invoiceSectionName, BillingRoleAssignmentPayload parameters, final ServiceCallback<BillingRoleAssignmentListResultInner> serviceCallback) {
        return ServiceFuture.fromResponse(addByInvoiceSectionNameWithServiceResponseAsync(billingAccountName, invoiceSectionName, parameters), serviceCallback);
    }

    /**
     * The operation to add a role assignment to a invoice Section.
     *
     * @param billingAccountName Billing Account Id.
     * @param invoiceSectionName InvoiceSection Id.
     * @param parameters Parameters supplied to add a role assignment.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BillingRoleAssignmentListResultInner object
     */
    public Observable<BillingRoleAssignmentListResultInner> addByInvoiceSectionNameAsync(String billingAccountName, String invoiceSectionName, BillingRoleAssignmentPayload parameters) {
        return addByInvoiceSectionNameWithServiceResponseAsync(billingAccountName, invoiceSectionName, parameters).map(new Func1<ServiceResponse<BillingRoleAssignmentListResultInner>, BillingRoleAssignmentListResultInner>() {
            @Override
            public BillingRoleAssignmentListResultInner call(ServiceResponse<BillingRoleAssignmentListResultInner> response) {
                return response.body();
            }
        });
    }

    /**
     * The operation to add a role assignment to a invoice Section.
     *
     * @param billingAccountName Billing Account Id.
     * @param invoiceSectionName InvoiceSection Id.
     * @param parameters Parameters supplied to add a role assignment.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BillingRoleAssignmentListResultInner object
     */
    public Observable<ServiceResponse<BillingRoleAssignmentListResultInner>> addByInvoiceSectionNameWithServiceResponseAsync(String billingAccountName, String invoiceSectionName, BillingRoleAssignmentPayload parameters) {
        if (billingAccountName == null) {
            throw new IllegalArgumentException("Parameter billingAccountName is required and cannot be null.");
        }
        if (invoiceSectionName == null) {
            throw new IllegalArgumentException("Parameter invoiceSectionName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        if (parameters == null) {
            throw new IllegalArgumentException("Parameter parameters is required and cannot be null.");
        }
        Validator.validate(parameters);
        return service.addByInvoiceSectionName(billingAccountName, invoiceSectionName, this.client.apiVersion(), parameters, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BillingRoleAssignmentListResultInner>>>() {
                @Override
                public Observable<ServiceResponse<BillingRoleAssignmentListResultInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BillingRoleAssignmentListResultInner> clientResponse = addByInvoiceSectionNameDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BillingRoleAssignmentListResultInner> addByInvoiceSectionNameDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<BillingRoleAssignmentListResultInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(201, new TypeToken<BillingRoleAssignmentListResultInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Get the role assignments on the Billing Profile.
     *
     * @param billingAccountName Billing Account Id.
     * @param billingProfileName Billing Profile Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BillingRoleAssignmentListResultInner object if successful.
     */
    public BillingRoleAssignmentListResultInner listByBillingProfileName(String billingAccountName, String billingProfileName) {
        return listByBillingProfileNameWithServiceResponseAsync(billingAccountName, billingProfileName).toBlocking().single().body();
    }

    /**
     * Get the role assignments on the Billing Profile.
     *
     * @param billingAccountName Billing Account Id.
     * @param billingProfileName Billing Profile Id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BillingRoleAssignmentListResultInner> listByBillingProfileNameAsync(String billingAccountName, String billingProfileName, final ServiceCallback<BillingRoleAssignmentListResultInner> serviceCallback) {
        return ServiceFuture.fromResponse(listByBillingProfileNameWithServiceResponseAsync(billingAccountName, billingProfileName), serviceCallback);
    }

    /**
     * Get the role assignments on the Billing Profile.
     *
     * @param billingAccountName Billing Account Id.
     * @param billingProfileName Billing Profile Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BillingRoleAssignmentListResultInner object
     */
    public Observable<BillingRoleAssignmentListResultInner> listByBillingProfileNameAsync(String billingAccountName, String billingProfileName) {
        return listByBillingProfileNameWithServiceResponseAsync(billingAccountName, billingProfileName).map(new Func1<ServiceResponse<BillingRoleAssignmentListResultInner>, BillingRoleAssignmentListResultInner>() {
            @Override
            public BillingRoleAssignmentListResultInner call(ServiceResponse<BillingRoleAssignmentListResultInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get the role assignments on the Billing Profile.
     *
     * @param billingAccountName Billing Account Id.
     * @param billingProfileName Billing Profile Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BillingRoleAssignmentListResultInner object
     */
    public Observable<ServiceResponse<BillingRoleAssignmentListResultInner>> listByBillingProfileNameWithServiceResponseAsync(String billingAccountName, String billingProfileName) {
        if (billingAccountName == null) {
            throw new IllegalArgumentException("Parameter billingAccountName is required and cannot be null.");
        }
        if (billingProfileName == null) {
            throw new IllegalArgumentException("Parameter billingProfileName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listByBillingProfileName(billingAccountName, billingProfileName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BillingRoleAssignmentListResultInner>>>() {
                @Override
                public Observable<ServiceResponse<BillingRoleAssignmentListResultInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BillingRoleAssignmentListResultInner> clientResponse = listByBillingProfileNameDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BillingRoleAssignmentListResultInner> listByBillingProfileNameDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<BillingRoleAssignmentListResultInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BillingRoleAssignmentListResultInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * The operation to add a role assignment to a billing profile.
     *
     * @param billingAccountName Billing Account Id.
     * @param billingProfileName Billing Profile Id.
     * @param parameters Parameters supplied to add a role assignment.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BillingRoleAssignmentListResultInner object if successful.
     */
    public BillingRoleAssignmentListResultInner addByBillingProfileName(String billingAccountName, String billingProfileName, BillingRoleAssignmentPayload parameters) {
        return addByBillingProfileNameWithServiceResponseAsync(billingAccountName, billingProfileName, parameters).toBlocking().single().body();
    }

    /**
     * The operation to add a role assignment to a billing profile.
     *
     * @param billingAccountName Billing Account Id.
     * @param billingProfileName Billing Profile Id.
     * @param parameters Parameters supplied to add a role assignment.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BillingRoleAssignmentListResultInner> addByBillingProfileNameAsync(String billingAccountName, String billingProfileName, BillingRoleAssignmentPayload parameters, final ServiceCallback<BillingRoleAssignmentListResultInner> serviceCallback) {
        return ServiceFuture.fromResponse(addByBillingProfileNameWithServiceResponseAsync(billingAccountName, billingProfileName, parameters), serviceCallback);
    }

    /**
     * The operation to add a role assignment to a billing profile.
     *
     * @param billingAccountName Billing Account Id.
     * @param billingProfileName Billing Profile Id.
     * @param parameters Parameters supplied to add a role assignment.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BillingRoleAssignmentListResultInner object
     */
    public Observable<BillingRoleAssignmentListResultInner> addByBillingProfileNameAsync(String billingAccountName, String billingProfileName, BillingRoleAssignmentPayload parameters) {
        return addByBillingProfileNameWithServiceResponseAsync(billingAccountName, billingProfileName, parameters).map(new Func1<ServiceResponse<BillingRoleAssignmentListResultInner>, BillingRoleAssignmentListResultInner>() {
            @Override
            public BillingRoleAssignmentListResultInner call(ServiceResponse<BillingRoleAssignmentListResultInner> response) {
                return response.body();
            }
        });
    }

    /**
     * The operation to add a role assignment to a billing profile.
     *
     * @param billingAccountName Billing Account Id.
     * @param billingProfileName Billing Profile Id.
     * @param parameters Parameters supplied to add a role assignment.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BillingRoleAssignmentListResultInner object
     */
    public Observable<ServiceResponse<BillingRoleAssignmentListResultInner>> addByBillingProfileNameWithServiceResponseAsync(String billingAccountName, String billingProfileName, BillingRoleAssignmentPayload parameters) {
        if (billingAccountName == null) {
            throw new IllegalArgumentException("Parameter billingAccountName is required and cannot be null.");
        }
        if (billingProfileName == null) {
            throw new IllegalArgumentException("Parameter billingProfileName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        if (parameters == null) {
            throw new IllegalArgumentException("Parameter parameters is required and cannot be null.");
        }
        Validator.validate(parameters);
        return service.addByBillingProfileName(billingAccountName, billingProfileName, this.client.apiVersion(), parameters, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BillingRoleAssignmentListResultInner>>>() {
                @Override
                public Observable<ServiceResponse<BillingRoleAssignmentListResultInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BillingRoleAssignmentListResultInner> clientResponse = addByBillingProfileNameDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BillingRoleAssignmentListResultInner> addByBillingProfileNameDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<BillingRoleAssignmentListResultInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(201, new TypeToken<BillingRoleAssignmentListResultInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

}
