/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.management.cdn.implementation;

import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.AzureServiceCall;
import com.microsoft.azure.AzureServiceResponseBuilder;
import com.microsoft.azure.ListOperationCallback;
import com.microsoft.azure.management.cdn.ErrorResponseException;
import com.microsoft.azure.management.cdn.LoadParameters;
import com.microsoft.azure.management.cdn.PurgeParameters;
import com.microsoft.azure.management.cdn.ValidateCustomDomainInput;
import com.microsoft.azure.Page;
import com.microsoft.azure.PagedList;
import com.microsoft.rest.ServiceCall;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.List;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.PATCH;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in Endpoints.
 */
public final class EndpointsInner {
    /** The Retrofit service to perform REST calls. */
    private EndpointsService service;
    /** The service client containing this operation class. */
    private CdnManagementClientImpl client;

    /**
     * Initializes an instance of EndpointsInner.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public EndpointsInner(Retrofit retrofit, CdnManagementClientImpl client) {
        this.service = retrofit.create(EndpointsService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for Endpoints to be
     * used by Retrofit to perform actually REST calls.
     */
    interface EndpointsService {
        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/endpoints")
        Observable<Response<ResponseBody>> listByProfile(@Path("resourceGroupName") String resourceGroupName, @Path("profileName") String profileName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/endpoints/{endpointName}")
        Observable<Response<ResponseBody>> get(@Path("resourceGroupName") String resourceGroupName, @Path("profileName") String profileName, @Path("endpointName") String endpointName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/endpoints/{endpointName}")
        Observable<Response<ResponseBody>> create(@Path("resourceGroupName") String resourceGroupName, @Path("profileName") String profileName, @Path("endpointName") String endpointName, @Path("subscriptionId") String subscriptionId, @Body EndpointInner endpoint, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/endpoints/{endpointName}")
        Observable<Response<ResponseBody>> beginCreate(@Path("resourceGroupName") String resourceGroupName, @Path("profileName") String profileName, @Path("endpointName") String endpointName, @Path("subscriptionId") String subscriptionId, @Body EndpointInner endpoint, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/endpoints/{endpointName}")
        Observable<Response<ResponseBody>> update(@Path("resourceGroupName") String resourceGroupName, @Path("profileName") String profileName, @Path("endpointName") String endpointName, @Path("subscriptionId") String subscriptionId, @Body EndpointUpdateParametersInner endpointUpdateProperties, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/endpoints/{endpointName}")
        Observable<Response<ResponseBody>> beginUpdate(@Path("resourceGroupName") String resourceGroupName, @Path("profileName") String profileName, @Path("endpointName") String endpointName, @Path("subscriptionId") String subscriptionId, @Body EndpointUpdateParametersInner endpointUpdateProperties, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/endpoints/{endpointName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> delete(@Path("resourceGroupName") String resourceGroupName, @Path("profileName") String profileName, @Path("endpointName") String endpointName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/endpoints/{endpointName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> beginDelete(@Path("resourceGroupName") String resourceGroupName, @Path("profileName") String profileName, @Path("endpointName") String endpointName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/endpoints/{endpointName}/start")
        Observable<Response<ResponseBody>> start(@Path("resourceGroupName") String resourceGroupName, @Path("profileName") String profileName, @Path("endpointName") String endpointName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/endpoints/{endpointName}/start")
        Observable<Response<ResponseBody>> beginStart(@Path("resourceGroupName") String resourceGroupName, @Path("profileName") String profileName, @Path("endpointName") String endpointName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/endpoints/{endpointName}/stop")
        Observable<Response<ResponseBody>> stop(@Path("resourceGroupName") String resourceGroupName, @Path("profileName") String profileName, @Path("endpointName") String endpointName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/endpoints/{endpointName}/stop")
        Observable<Response<ResponseBody>> beginStop(@Path("resourceGroupName") String resourceGroupName, @Path("profileName") String profileName, @Path("endpointName") String endpointName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/endpoints/{endpointName}/purge")
        Observable<Response<ResponseBody>> purgeContent(@Path("resourceGroupName") String resourceGroupName, @Path("profileName") String profileName, @Path("endpointName") String endpointName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body PurgeParameters contentFilePaths, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/endpoints/{endpointName}/purge")
        Observable<Response<ResponseBody>> beginPurgeContent(@Path("resourceGroupName") String resourceGroupName, @Path("profileName") String profileName, @Path("endpointName") String endpointName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body PurgeParameters contentFilePaths, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/endpoints/{endpointName}/load")
        Observable<Response<ResponseBody>> loadContent(@Path("resourceGroupName") String resourceGroupName, @Path("profileName") String profileName, @Path("endpointName") String endpointName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body LoadParameters contentFilePaths, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/endpoints/{endpointName}/load")
        Observable<Response<ResponseBody>> beginLoadContent(@Path("resourceGroupName") String resourceGroupName, @Path("profileName") String profileName, @Path("endpointName") String endpointName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body LoadParameters contentFilePaths, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/endpoints/{endpointName}/validateCustomDomain")
        Observable<Response<ResponseBody>> validateCustomDomain(@Path("resourceGroupName") String resourceGroupName, @Path("profileName") String profileName, @Path("endpointName") String endpointName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body ValidateCustomDomainInput customDomainProperties, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> listByProfileNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

    }

    /**
     * Lists existing CDN endpoints.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @return the PagedList&lt;EndpointInner&gt; object if successful.
     */
    public PagedList<EndpointInner> listByProfile(final String profileName) {
        ServiceResponse<Page<EndpointInner>> response = listByProfileSinglePageAsync(profileName).toBlocking().single();
        return new PagedList<EndpointInner>(response.getBody()) {
            @Override
            public Page<EndpointInner> nextPage(String nextPageLink) {
                return listByProfileNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Lists existing CDN endpoints.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<EndpointInner>> listByProfileAsync(final String profileName, final ListOperationCallback<EndpointInner> serviceCallback) {
        return AzureServiceCall.create(
            listByProfileSinglePageAsync(profileName),
            new Func1<String, Observable<ServiceResponse<Page<EndpointInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<EndpointInner>>> call(String nextPageLink) {
                    return listByProfileNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists existing CDN endpoints.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @return the observable to the PagedList&lt;EndpointInner&gt; object
     */
    public Observable<Page<EndpointInner>> listByProfileAsync(final String profileName) {
        return listByProfileWithServiceResponseAsync(profileName)
            .map(new Func1<ServiceResponse<Page<EndpointInner>>, Page<EndpointInner>>() {
                @Override
                public Page<EndpointInner> call(ServiceResponse<Page<EndpointInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Lists existing CDN endpoints.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @return the observable to the PagedList&lt;EndpointInner&gt; object
     */
    public Observable<ServiceResponse<Page<EndpointInner>>> listByProfileWithServiceResponseAsync(final String profileName) {
        return listByProfileSinglePageAsync(profileName)
            .concatMap(new Func1<ServiceResponse<Page<EndpointInner>>, Observable<ServiceResponse<Page<EndpointInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<EndpointInner>>> call(ServiceResponse<Page<EndpointInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByProfileNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists existing CDN endpoints.
     *
    ServiceResponse<PageImpl<EndpointInner>> * @param profileName Name of the CDN profile which is unique within the resource group.
     * @return the PagedList&lt;EndpointInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<EndpointInner>>> listByProfileSinglePageAsync(final String profileName) {
        if (this.client.resourceGroupName() == null) {
            throw new IllegalArgumentException("Parameter this.client.resourceGroupName() is required and cannot be null.");
        }
        if (profileName == null) {
            throw new IllegalArgumentException("Parameter profileName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listByProfile(this.client.resourceGroupName(), profileName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<EndpointInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<EndpointInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<EndpointInner>> result = listByProfileDelegate(response);
                        return Observable.just(new ServiceResponse<Page<EndpointInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<EndpointInner>> listByProfileDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<EndpointInner>, ErrorResponseException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<EndpointInner>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Gets an existing CDN endpoint with the specified endpoint name under the specified subscription, resource group and profile.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @return the EndpointInner object if successful.
     */
    public EndpointInner get(String profileName, String endpointName) {
        return getWithServiceResponseAsync(profileName, endpointName).toBlocking().single().getBody();
    }

    /**
     * Gets an existing CDN endpoint with the specified endpoint name under the specified subscription, resource group and profile.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<EndpointInner> getAsync(String profileName, String endpointName, final ServiceCallback<EndpointInner> serviceCallback) {
        return ServiceCall.create(getWithServiceResponseAsync(profileName, endpointName), serviceCallback);
    }

    /**
     * Gets an existing CDN endpoint with the specified endpoint name under the specified subscription, resource group and profile.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @return the observable to the EndpointInner object
     */
    public Observable<EndpointInner> getAsync(String profileName, String endpointName) {
        return getWithServiceResponseAsync(profileName, endpointName).map(new Func1<ServiceResponse<EndpointInner>, EndpointInner>() {
            @Override
            public EndpointInner call(ServiceResponse<EndpointInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets an existing CDN endpoint with the specified endpoint name under the specified subscription, resource group and profile.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @return the observable to the EndpointInner object
     */
    public Observable<ServiceResponse<EndpointInner>> getWithServiceResponseAsync(String profileName, String endpointName) {
        if (this.client.resourceGroupName() == null) {
            throw new IllegalArgumentException("Parameter this.client.resourceGroupName() is required and cannot be null.");
        }
        if (profileName == null) {
            throw new IllegalArgumentException("Parameter profileName is required and cannot be null.");
        }
        if (endpointName == null) {
            throw new IllegalArgumentException("Parameter endpointName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.get(this.client.resourceGroupName(), profileName, endpointName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<EndpointInner>>>() {
                @Override
                public Observable<ServiceResponse<EndpointInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<EndpointInner> clientResponse = getDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<EndpointInner> getDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<EndpointInner, ErrorResponseException>(this.client.mapperAdapter())
                .register(200, new TypeToken<EndpointInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Creates a new CDN endpoint with the specified parameters.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param endpoint Endpoint properties
     * @return the EndpointInner object if successful.
     */
    public EndpointInner create(String profileName, String endpointName, EndpointInner endpoint) {
        return createWithServiceResponseAsync(profileName, endpointName, endpoint).toBlocking().last().getBody();
    }

    /**
     * Creates a new CDN endpoint with the specified parameters.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param endpoint Endpoint properties
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<EndpointInner> createAsync(String profileName, String endpointName, EndpointInner endpoint, final ServiceCallback<EndpointInner> serviceCallback) {
        return ServiceCall.create(createWithServiceResponseAsync(profileName, endpointName, endpoint), serviceCallback);
    }

    /**
     * Creates a new CDN endpoint with the specified parameters.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param endpoint Endpoint properties
     * @return the observable for the request
     */
    public Observable<EndpointInner> createAsync(String profileName, String endpointName, EndpointInner endpoint) {
        return createWithServiceResponseAsync(profileName, endpointName, endpoint).map(new Func1<ServiceResponse<EndpointInner>, EndpointInner>() {
            @Override
            public EndpointInner call(ServiceResponse<EndpointInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Creates a new CDN endpoint with the specified parameters.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param endpoint Endpoint properties
     * @return the observable for the request
     */
    public Observable<ServiceResponse<EndpointInner>> createWithServiceResponseAsync(String profileName, String endpointName, EndpointInner endpoint) {
        if (this.client.resourceGroupName() == null) {
            throw new IllegalArgumentException("Parameter this.client.resourceGroupName() is required and cannot be null.");
        }
        if (profileName == null) {
            throw new IllegalArgumentException("Parameter profileName is required and cannot be null.");
        }
        if (endpointName == null) {
            throw new IllegalArgumentException("Parameter endpointName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (endpoint == null) {
            throw new IllegalArgumentException("Parameter endpoint is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(endpoint);
        Observable<Response<ResponseBody>> observable = service.create(this.client.resourceGroupName(), profileName, endpointName, this.client.subscriptionId(), endpoint, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultAsync(observable, new TypeToken<EndpointInner>() { }.getType());
    }

    /**
     * Creates a new CDN endpoint with the specified parameters.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param endpoint Endpoint properties
     * @return the EndpointInner object if successful.
     */
    public EndpointInner beginCreate(String profileName, String endpointName, EndpointInner endpoint) {
        return beginCreateWithServiceResponseAsync(profileName, endpointName, endpoint).toBlocking().single().getBody();
    }

    /**
     * Creates a new CDN endpoint with the specified parameters.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param endpoint Endpoint properties
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<EndpointInner> beginCreateAsync(String profileName, String endpointName, EndpointInner endpoint, final ServiceCallback<EndpointInner> serviceCallback) {
        return ServiceCall.create(beginCreateWithServiceResponseAsync(profileName, endpointName, endpoint), serviceCallback);
    }

    /**
     * Creates a new CDN endpoint with the specified parameters.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param endpoint Endpoint properties
     * @return the observable to the EndpointInner object
     */
    public Observable<EndpointInner> beginCreateAsync(String profileName, String endpointName, EndpointInner endpoint) {
        return beginCreateWithServiceResponseAsync(profileName, endpointName, endpoint).map(new Func1<ServiceResponse<EndpointInner>, EndpointInner>() {
            @Override
            public EndpointInner call(ServiceResponse<EndpointInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Creates a new CDN endpoint with the specified parameters.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param endpoint Endpoint properties
     * @return the observable to the EndpointInner object
     */
    public Observable<ServiceResponse<EndpointInner>> beginCreateWithServiceResponseAsync(String profileName, String endpointName, EndpointInner endpoint) {
        if (this.client.resourceGroupName() == null) {
            throw new IllegalArgumentException("Parameter this.client.resourceGroupName() is required and cannot be null.");
        }
        if (profileName == null) {
            throw new IllegalArgumentException("Parameter profileName is required and cannot be null.");
        }
        if (endpointName == null) {
            throw new IllegalArgumentException("Parameter endpointName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (endpoint == null) {
            throw new IllegalArgumentException("Parameter endpoint is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(endpoint);
        return service.beginCreate(this.client.resourceGroupName(), profileName, endpointName, this.client.subscriptionId(), endpoint, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<EndpointInner>>>() {
                @Override
                public Observable<ServiceResponse<EndpointInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<EndpointInner> clientResponse = beginCreateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<EndpointInner> beginCreateDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<EndpointInner, ErrorResponseException>(this.client.mapperAdapter())
                .register(200, new TypeToken<EndpointInner>() { }.getType())
                .register(201, new TypeToken<EndpointInner>() { }.getType())
                .register(202, new TypeToken<EndpointInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Updates an existing CDN endpoint with the specified parameters. Only tags and OriginHostHeader can be updated after creating an endpoint. To update origins, use the Update Origin operation. To update custom domains, use the Update Custom Domain operation.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param endpointUpdateProperties Endpoint update properties
     * @return the EndpointInner object if successful.
     */
    public EndpointInner update(String profileName, String endpointName, EndpointUpdateParametersInner endpointUpdateProperties) {
        return updateWithServiceResponseAsync(profileName, endpointName, endpointUpdateProperties).toBlocking().last().getBody();
    }

    /**
     * Updates an existing CDN endpoint with the specified parameters. Only tags and OriginHostHeader can be updated after creating an endpoint. To update origins, use the Update Origin operation. To update custom domains, use the Update Custom Domain operation.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param endpointUpdateProperties Endpoint update properties
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<EndpointInner> updateAsync(String profileName, String endpointName, EndpointUpdateParametersInner endpointUpdateProperties, final ServiceCallback<EndpointInner> serviceCallback) {
        return ServiceCall.create(updateWithServiceResponseAsync(profileName, endpointName, endpointUpdateProperties), serviceCallback);
    }

    /**
     * Updates an existing CDN endpoint with the specified parameters. Only tags and OriginHostHeader can be updated after creating an endpoint. To update origins, use the Update Origin operation. To update custom domains, use the Update Custom Domain operation.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param endpointUpdateProperties Endpoint update properties
     * @return the observable for the request
     */
    public Observable<EndpointInner> updateAsync(String profileName, String endpointName, EndpointUpdateParametersInner endpointUpdateProperties) {
        return updateWithServiceResponseAsync(profileName, endpointName, endpointUpdateProperties).map(new Func1<ServiceResponse<EndpointInner>, EndpointInner>() {
            @Override
            public EndpointInner call(ServiceResponse<EndpointInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Updates an existing CDN endpoint with the specified parameters. Only tags and OriginHostHeader can be updated after creating an endpoint. To update origins, use the Update Origin operation. To update custom domains, use the Update Custom Domain operation.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param endpointUpdateProperties Endpoint update properties
     * @return the observable for the request
     */
    public Observable<ServiceResponse<EndpointInner>> updateWithServiceResponseAsync(String profileName, String endpointName, EndpointUpdateParametersInner endpointUpdateProperties) {
        if (this.client.resourceGroupName() == null) {
            throw new IllegalArgumentException("Parameter this.client.resourceGroupName() is required and cannot be null.");
        }
        if (profileName == null) {
            throw new IllegalArgumentException("Parameter profileName is required and cannot be null.");
        }
        if (endpointName == null) {
            throw new IllegalArgumentException("Parameter endpointName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (endpointUpdateProperties == null) {
            throw new IllegalArgumentException("Parameter endpointUpdateProperties is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(endpointUpdateProperties);
        Observable<Response<ResponseBody>> observable = service.update(this.client.resourceGroupName(), profileName, endpointName, this.client.subscriptionId(), endpointUpdateProperties, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultAsync(observable, new TypeToken<EndpointInner>() { }.getType());
    }

    /**
     * Updates an existing CDN endpoint with the specified parameters. Only tags and OriginHostHeader can be updated after creating an endpoint. To update origins, use the Update Origin operation. To update custom domains, use the Update Custom Domain operation.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param endpointUpdateProperties Endpoint update properties
     * @return the EndpointInner object if successful.
     */
    public EndpointInner beginUpdate(String profileName, String endpointName, EndpointUpdateParametersInner endpointUpdateProperties) {
        return beginUpdateWithServiceResponseAsync(profileName, endpointName, endpointUpdateProperties).toBlocking().single().getBody();
    }

    /**
     * Updates an existing CDN endpoint with the specified parameters. Only tags and OriginHostHeader can be updated after creating an endpoint. To update origins, use the Update Origin operation. To update custom domains, use the Update Custom Domain operation.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param endpointUpdateProperties Endpoint update properties
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<EndpointInner> beginUpdateAsync(String profileName, String endpointName, EndpointUpdateParametersInner endpointUpdateProperties, final ServiceCallback<EndpointInner> serviceCallback) {
        return ServiceCall.create(beginUpdateWithServiceResponseAsync(profileName, endpointName, endpointUpdateProperties), serviceCallback);
    }

    /**
     * Updates an existing CDN endpoint with the specified parameters. Only tags and OriginHostHeader can be updated after creating an endpoint. To update origins, use the Update Origin operation. To update custom domains, use the Update Custom Domain operation.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param endpointUpdateProperties Endpoint update properties
     * @return the observable to the EndpointInner object
     */
    public Observable<EndpointInner> beginUpdateAsync(String profileName, String endpointName, EndpointUpdateParametersInner endpointUpdateProperties) {
        return beginUpdateWithServiceResponseAsync(profileName, endpointName, endpointUpdateProperties).map(new Func1<ServiceResponse<EndpointInner>, EndpointInner>() {
            @Override
            public EndpointInner call(ServiceResponse<EndpointInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Updates an existing CDN endpoint with the specified parameters. Only tags and OriginHostHeader can be updated after creating an endpoint. To update origins, use the Update Origin operation. To update custom domains, use the Update Custom Domain operation.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param endpointUpdateProperties Endpoint update properties
     * @return the observable to the EndpointInner object
     */
    public Observable<ServiceResponse<EndpointInner>> beginUpdateWithServiceResponseAsync(String profileName, String endpointName, EndpointUpdateParametersInner endpointUpdateProperties) {
        if (this.client.resourceGroupName() == null) {
            throw new IllegalArgumentException("Parameter this.client.resourceGroupName() is required and cannot be null.");
        }
        if (profileName == null) {
            throw new IllegalArgumentException("Parameter profileName is required and cannot be null.");
        }
        if (endpointName == null) {
            throw new IllegalArgumentException("Parameter endpointName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (endpointUpdateProperties == null) {
            throw new IllegalArgumentException("Parameter endpointUpdateProperties is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(endpointUpdateProperties);
        return service.beginUpdate(this.client.resourceGroupName(), profileName, endpointName, this.client.subscriptionId(), endpointUpdateProperties, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<EndpointInner>>>() {
                @Override
                public Observable<ServiceResponse<EndpointInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<EndpointInner> clientResponse = beginUpdateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<EndpointInner> beginUpdateDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<EndpointInner, ErrorResponseException>(this.client.mapperAdapter())
                .register(200, new TypeToken<EndpointInner>() { }.getType())
                .register(202, new TypeToken<EndpointInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Deletes an existing CDN endpoint with the specified parameters.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     */
    public void delete(String profileName, String endpointName) {
        deleteWithServiceResponseAsync(profileName, endpointName).toBlocking().last().getBody();
    }

    /**
     * Deletes an existing CDN endpoint with the specified parameters.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> deleteAsync(String profileName, String endpointName, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(deleteWithServiceResponseAsync(profileName, endpointName), serviceCallback);
    }

    /**
     * Deletes an existing CDN endpoint with the specified parameters.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @return the observable for the request
     */
    public Observable<Void> deleteAsync(String profileName, String endpointName) {
        return deleteWithServiceResponseAsync(profileName, endpointName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Deletes an existing CDN endpoint with the specified parameters.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @return the observable for the request
     */
    public Observable<ServiceResponse<Void>> deleteWithServiceResponseAsync(String profileName, String endpointName) {
        if (this.client.resourceGroupName() == null) {
            throw new IllegalArgumentException("Parameter this.client.resourceGroupName() is required and cannot be null.");
        }
        if (profileName == null) {
            throw new IllegalArgumentException("Parameter profileName is required and cannot be null.");
        }
        if (endpointName == null) {
            throw new IllegalArgumentException("Parameter endpointName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Observable<Response<ResponseBody>> observable = service.delete(this.client.resourceGroupName(), profileName, endpointName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<Void>() { }.getType());
    }

    /**
     * Deletes an existing CDN endpoint with the specified parameters.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     */
    public void beginDelete(String profileName, String endpointName) {
        beginDeleteWithServiceResponseAsync(profileName, endpointName).toBlocking().single().getBody();
    }

    /**
     * Deletes an existing CDN endpoint with the specified parameters.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> beginDeleteAsync(String profileName, String endpointName, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(beginDeleteWithServiceResponseAsync(profileName, endpointName), serviceCallback);
    }

    /**
     * Deletes an existing CDN endpoint with the specified parameters.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> beginDeleteAsync(String profileName, String endpointName) {
        return beginDeleteWithServiceResponseAsync(profileName, endpointName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Deletes an existing CDN endpoint with the specified parameters.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> beginDeleteWithServiceResponseAsync(String profileName, String endpointName) {
        if (this.client.resourceGroupName() == null) {
            throw new IllegalArgumentException("Parameter this.client.resourceGroupName() is required and cannot be null.");
        }
        if (profileName == null) {
            throw new IllegalArgumentException("Parameter profileName is required and cannot be null.");
        }
        if (endpointName == null) {
            throw new IllegalArgumentException("Parameter endpointName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.beginDelete(this.client.resourceGroupName(), profileName, endpointName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = beginDeleteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> beginDeleteDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Void, ErrorResponseException>(this.client.mapperAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Starts an existing stopped CDN endpoint.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @return the EndpointInner object if successful.
     */
    public EndpointInner start(String profileName, String endpointName) {
        return startWithServiceResponseAsync(profileName, endpointName).toBlocking().last().getBody();
    }

    /**
     * Starts an existing stopped CDN endpoint.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<EndpointInner> startAsync(String profileName, String endpointName, final ServiceCallback<EndpointInner> serviceCallback) {
        return ServiceCall.create(startWithServiceResponseAsync(profileName, endpointName), serviceCallback);
    }

    /**
     * Starts an existing stopped CDN endpoint.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @return the observable for the request
     */
    public Observable<EndpointInner> startAsync(String profileName, String endpointName) {
        return startWithServiceResponseAsync(profileName, endpointName).map(new Func1<ServiceResponse<EndpointInner>, EndpointInner>() {
            @Override
            public EndpointInner call(ServiceResponse<EndpointInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Starts an existing stopped CDN endpoint.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @return the observable for the request
     */
    public Observable<ServiceResponse<EndpointInner>> startWithServiceResponseAsync(String profileName, String endpointName) {
        if (this.client.resourceGroupName() == null) {
            throw new IllegalArgumentException("Parameter this.client.resourceGroupName() is required and cannot be null.");
        }
        if (profileName == null) {
            throw new IllegalArgumentException("Parameter profileName is required and cannot be null.");
        }
        if (endpointName == null) {
            throw new IllegalArgumentException("Parameter endpointName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Observable<Response<ResponseBody>> observable = service.start(this.client.resourceGroupName(), profileName, endpointName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<EndpointInner>() { }.getType());
    }

    /**
     * Starts an existing stopped CDN endpoint.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @return the EndpointInner object if successful.
     */
    public EndpointInner beginStart(String profileName, String endpointName) {
        return beginStartWithServiceResponseAsync(profileName, endpointName).toBlocking().single().getBody();
    }

    /**
     * Starts an existing stopped CDN endpoint.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<EndpointInner> beginStartAsync(String profileName, String endpointName, final ServiceCallback<EndpointInner> serviceCallback) {
        return ServiceCall.create(beginStartWithServiceResponseAsync(profileName, endpointName), serviceCallback);
    }

    /**
     * Starts an existing stopped CDN endpoint.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @return the observable to the EndpointInner object
     */
    public Observable<EndpointInner> beginStartAsync(String profileName, String endpointName) {
        return beginStartWithServiceResponseAsync(profileName, endpointName).map(new Func1<ServiceResponse<EndpointInner>, EndpointInner>() {
            @Override
            public EndpointInner call(ServiceResponse<EndpointInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Starts an existing stopped CDN endpoint.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @return the observable to the EndpointInner object
     */
    public Observable<ServiceResponse<EndpointInner>> beginStartWithServiceResponseAsync(String profileName, String endpointName) {
        if (this.client.resourceGroupName() == null) {
            throw new IllegalArgumentException("Parameter this.client.resourceGroupName() is required and cannot be null.");
        }
        if (profileName == null) {
            throw new IllegalArgumentException("Parameter profileName is required and cannot be null.");
        }
        if (endpointName == null) {
            throw new IllegalArgumentException("Parameter endpointName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.beginStart(this.client.resourceGroupName(), profileName, endpointName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<EndpointInner>>>() {
                @Override
                public Observable<ServiceResponse<EndpointInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<EndpointInner> clientResponse = beginStartDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<EndpointInner> beginStartDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<EndpointInner, ErrorResponseException>(this.client.mapperAdapter())
                .register(202, new TypeToken<EndpointInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Stops an existing running CDN endpoint.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @return the EndpointInner object if successful.
     */
    public EndpointInner stop(String profileName, String endpointName) {
        return stopWithServiceResponseAsync(profileName, endpointName).toBlocking().last().getBody();
    }

    /**
     * Stops an existing running CDN endpoint.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<EndpointInner> stopAsync(String profileName, String endpointName, final ServiceCallback<EndpointInner> serviceCallback) {
        return ServiceCall.create(stopWithServiceResponseAsync(profileName, endpointName), serviceCallback);
    }

    /**
     * Stops an existing running CDN endpoint.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @return the observable for the request
     */
    public Observable<EndpointInner> stopAsync(String profileName, String endpointName) {
        return stopWithServiceResponseAsync(profileName, endpointName).map(new Func1<ServiceResponse<EndpointInner>, EndpointInner>() {
            @Override
            public EndpointInner call(ServiceResponse<EndpointInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Stops an existing running CDN endpoint.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @return the observable for the request
     */
    public Observable<ServiceResponse<EndpointInner>> stopWithServiceResponseAsync(String profileName, String endpointName) {
        if (this.client.resourceGroupName() == null) {
            throw new IllegalArgumentException("Parameter this.client.resourceGroupName() is required and cannot be null.");
        }
        if (profileName == null) {
            throw new IllegalArgumentException("Parameter profileName is required and cannot be null.");
        }
        if (endpointName == null) {
            throw new IllegalArgumentException("Parameter endpointName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Observable<Response<ResponseBody>> observable = service.stop(this.client.resourceGroupName(), profileName, endpointName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<EndpointInner>() { }.getType());
    }

    /**
     * Stops an existing running CDN endpoint.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @return the EndpointInner object if successful.
     */
    public EndpointInner beginStop(String profileName, String endpointName) {
        return beginStopWithServiceResponseAsync(profileName, endpointName).toBlocking().single().getBody();
    }

    /**
     * Stops an existing running CDN endpoint.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<EndpointInner> beginStopAsync(String profileName, String endpointName, final ServiceCallback<EndpointInner> serviceCallback) {
        return ServiceCall.create(beginStopWithServiceResponseAsync(profileName, endpointName), serviceCallback);
    }

    /**
     * Stops an existing running CDN endpoint.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @return the observable to the EndpointInner object
     */
    public Observable<EndpointInner> beginStopAsync(String profileName, String endpointName) {
        return beginStopWithServiceResponseAsync(profileName, endpointName).map(new Func1<ServiceResponse<EndpointInner>, EndpointInner>() {
            @Override
            public EndpointInner call(ServiceResponse<EndpointInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Stops an existing running CDN endpoint.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @return the observable to the EndpointInner object
     */
    public Observable<ServiceResponse<EndpointInner>> beginStopWithServiceResponseAsync(String profileName, String endpointName) {
        if (this.client.resourceGroupName() == null) {
            throw new IllegalArgumentException("Parameter this.client.resourceGroupName() is required and cannot be null.");
        }
        if (profileName == null) {
            throw new IllegalArgumentException("Parameter profileName is required and cannot be null.");
        }
        if (endpointName == null) {
            throw new IllegalArgumentException("Parameter endpointName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.beginStop(this.client.resourceGroupName(), profileName, endpointName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<EndpointInner>>>() {
                @Override
                public Observable<ServiceResponse<EndpointInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<EndpointInner> clientResponse = beginStopDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<EndpointInner> beginStopDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<EndpointInner, ErrorResponseException>(this.client.mapperAdapter())
                .register(202, new TypeToken<EndpointInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Forcibly purges CDN endpoint content.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param contentPaths The path to the content to be purged. Can describe a file path or a wild card directory.
     */
    public void purgeContent(String profileName, String endpointName, List<String> contentPaths) {
        purgeContentWithServiceResponseAsync(profileName, endpointName, contentPaths).toBlocking().last().getBody();
    }

    /**
     * Forcibly purges CDN endpoint content.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param contentPaths The path to the content to be purged. Can describe a file path or a wild card directory.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> purgeContentAsync(String profileName, String endpointName, List<String> contentPaths, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(purgeContentWithServiceResponseAsync(profileName, endpointName, contentPaths), serviceCallback);
    }

    /**
     * Forcibly purges CDN endpoint content.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param contentPaths The path to the content to be purged. Can describe a file path or a wild card directory.
     * @return the observable for the request
     */
    public Observable<Void> purgeContentAsync(String profileName, String endpointName, List<String> contentPaths) {
        return purgeContentWithServiceResponseAsync(profileName, endpointName, contentPaths).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Forcibly purges CDN endpoint content.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param contentPaths The path to the content to be purged. Can describe a file path or a wild card directory.
     * @return the observable for the request
     */
    public Observable<ServiceResponse<Void>> purgeContentWithServiceResponseAsync(String profileName, String endpointName, List<String> contentPaths) {
        if (this.client.resourceGroupName() == null) {
            throw new IllegalArgumentException("Parameter this.client.resourceGroupName() is required and cannot be null.");
        }
        if (profileName == null) {
            throw new IllegalArgumentException("Parameter profileName is required and cannot be null.");
        }
        if (endpointName == null) {
            throw new IllegalArgumentException("Parameter endpointName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        if (contentPaths == null) {
            throw new IllegalArgumentException("Parameter contentPaths is required and cannot be null.");
        }
        Validator.validate(contentPaths);
        PurgeParameters contentFilePaths = new PurgeParameters();
        contentFilePaths.withContentPaths(contentPaths);
        Observable<Response<ResponseBody>> observable = service.purgeContent(this.client.resourceGroupName(), profileName, endpointName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), contentFilePaths, this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<Void>() { }.getType());
    }

    /**
     * Forcibly purges CDN endpoint content.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param contentPaths The path to the content to be purged. Can describe a file path or a wild card directory.
     */
    public void beginPurgeContent(String profileName, String endpointName, List<String> contentPaths) {
        beginPurgeContentWithServiceResponseAsync(profileName, endpointName, contentPaths).toBlocking().single().getBody();
    }

    /**
     * Forcibly purges CDN endpoint content.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param contentPaths The path to the content to be purged. Can describe a file path or a wild card directory.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> beginPurgeContentAsync(String profileName, String endpointName, List<String> contentPaths, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(beginPurgeContentWithServiceResponseAsync(profileName, endpointName, contentPaths), serviceCallback);
    }

    /**
     * Forcibly purges CDN endpoint content.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param contentPaths The path to the content to be purged. Can describe a file path or a wild card directory.
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> beginPurgeContentAsync(String profileName, String endpointName, List<String> contentPaths) {
        return beginPurgeContentWithServiceResponseAsync(profileName, endpointName, contentPaths).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Forcibly purges CDN endpoint content.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param contentPaths The path to the content to be purged. Can describe a file path or a wild card directory.
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> beginPurgeContentWithServiceResponseAsync(String profileName, String endpointName, List<String> contentPaths) {
        if (this.client.resourceGroupName() == null) {
            throw new IllegalArgumentException("Parameter this.client.resourceGroupName() is required and cannot be null.");
        }
        if (profileName == null) {
            throw new IllegalArgumentException("Parameter profileName is required and cannot be null.");
        }
        if (endpointName == null) {
            throw new IllegalArgumentException("Parameter endpointName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        if (contentPaths == null) {
            throw new IllegalArgumentException("Parameter contentPaths is required and cannot be null.");
        }
        Validator.validate(contentPaths);
        PurgeParameters contentFilePaths = new PurgeParameters();
        contentFilePaths.withContentPaths(contentPaths);
        return service.beginPurgeContent(this.client.resourceGroupName(), profileName, endpointName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), contentFilePaths, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = beginPurgeContentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> beginPurgeContentDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Void, ErrorResponseException>(this.client.mapperAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Forcibly pre-loads CDN endpoint content. Available for Verizon Profiles.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param contentPaths The path to the content to be loaded. Should describe a file path.
     */
    public void loadContent(String profileName, String endpointName, List<String> contentPaths) {
        loadContentWithServiceResponseAsync(profileName, endpointName, contentPaths).toBlocking().last().getBody();
    }

    /**
     * Forcibly pre-loads CDN endpoint content. Available for Verizon Profiles.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param contentPaths The path to the content to be loaded. Should describe a file path.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> loadContentAsync(String profileName, String endpointName, List<String> contentPaths, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(loadContentWithServiceResponseAsync(profileName, endpointName, contentPaths), serviceCallback);
    }

    /**
     * Forcibly pre-loads CDN endpoint content. Available for Verizon Profiles.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param contentPaths The path to the content to be loaded. Should describe a file path.
     * @return the observable for the request
     */
    public Observable<Void> loadContentAsync(String profileName, String endpointName, List<String> contentPaths) {
        return loadContentWithServiceResponseAsync(profileName, endpointName, contentPaths).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Forcibly pre-loads CDN endpoint content. Available for Verizon Profiles.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param contentPaths The path to the content to be loaded. Should describe a file path.
     * @return the observable for the request
     */
    public Observable<ServiceResponse<Void>> loadContentWithServiceResponseAsync(String profileName, String endpointName, List<String> contentPaths) {
        if (this.client.resourceGroupName() == null) {
            throw new IllegalArgumentException("Parameter this.client.resourceGroupName() is required and cannot be null.");
        }
        if (profileName == null) {
            throw new IllegalArgumentException("Parameter profileName is required and cannot be null.");
        }
        if (endpointName == null) {
            throw new IllegalArgumentException("Parameter endpointName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        if (contentPaths == null) {
            throw new IllegalArgumentException("Parameter contentPaths is required and cannot be null.");
        }
        Validator.validate(contentPaths);
        LoadParameters contentFilePaths = new LoadParameters();
        contentFilePaths.withContentPaths(contentPaths);
        Observable<Response<ResponseBody>> observable = service.loadContent(this.client.resourceGroupName(), profileName, endpointName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), contentFilePaths, this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<Void>() { }.getType());
    }

    /**
     * Forcibly pre-loads CDN endpoint content. Available for Verizon Profiles.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param contentPaths The path to the content to be loaded. Should describe a file path.
     */
    public void beginLoadContent(String profileName, String endpointName, List<String> contentPaths) {
        beginLoadContentWithServiceResponseAsync(profileName, endpointName, contentPaths).toBlocking().single().getBody();
    }

    /**
     * Forcibly pre-loads CDN endpoint content. Available for Verizon Profiles.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param contentPaths The path to the content to be loaded. Should describe a file path.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> beginLoadContentAsync(String profileName, String endpointName, List<String> contentPaths, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(beginLoadContentWithServiceResponseAsync(profileName, endpointName, contentPaths), serviceCallback);
    }

    /**
     * Forcibly pre-loads CDN endpoint content. Available for Verizon Profiles.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param contentPaths The path to the content to be loaded. Should describe a file path.
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> beginLoadContentAsync(String profileName, String endpointName, List<String> contentPaths) {
        return beginLoadContentWithServiceResponseAsync(profileName, endpointName, contentPaths).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Forcibly pre-loads CDN endpoint content. Available for Verizon Profiles.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param contentPaths The path to the content to be loaded. Should describe a file path.
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> beginLoadContentWithServiceResponseAsync(String profileName, String endpointName, List<String> contentPaths) {
        if (this.client.resourceGroupName() == null) {
            throw new IllegalArgumentException("Parameter this.client.resourceGroupName() is required and cannot be null.");
        }
        if (profileName == null) {
            throw new IllegalArgumentException("Parameter profileName is required and cannot be null.");
        }
        if (endpointName == null) {
            throw new IllegalArgumentException("Parameter endpointName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        if (contentPaths == null) {
            throw new IllegalArgumentException("Parameter contentPaths is required and cannot be null.");
        }
        Validator.validate(contentPaths);
        LoadParameters contentFilePaths = new LoadParameters();
        contentFilePaths.withContentPaths(contentPaths);
        return service.beginLoadContent(this.client.resourceGroupName(), profileName, endpointName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), contentFilePaths, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = beginLoadContentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> beginLoadContentDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Void, ErrorResponseException>(this.client.mapperAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Validates a custom domain mapping to ensure it maps to the correct CNAME in DNS.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param hostName The host name of the custom domain. Must be a domain name.
     * @return the ValidateCustomDomainOutputInner object if successful.
     */
    public ValidateCustomDomainOutputInner validateCustomDomain(String profileName, String endpointName, String hostName) {
        return validateCustomDomainWithServiceResponseAsync(profileName, endpointName, hostName).toBlocking().single().getBody();
    }

    /**
     * Validates a custom domain mapping to ensure it maps to the correct CNAME in DNS.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param hostName The host name of the custom domain. Must be a domain name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<ValidateCustomDomainOutputInner> validateCustomDomainAsync(String profileName, String endpointName, String hostName, final ServiceCallback<ValidateCustomDomainOutputInner> serviceCallback) {
        return ServiceCall.create(validateCustomDomainWithServiceResponseAsync(profileName, endpointName, hostName), serviceCallback);
    }

    /**
     * Validates a custom domain mapping to ensure it maps to the correct CNAME in DNS.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param hostName The host name of the custom domain. Must be a domain name.
     * @return the observable to the ValidateCustomDomainOutputInner object
     */
    public Observable<ValidateCustomDomainOutputInner> validateCustomDomainAsync(String profileName, String endpointName, String hostName) {
        return validateCustomDomainWithServiceResponseAsync(profileName, endpointName, hostName).map(new Func1<ServiceResponse<ValidateCustomDomainOutputInner>, ValidateCustomDomainOutputInner>() {
            @Override
            public ValidateCustomDomainOutputInner call(ServiceResponse<ValidateCustomDomainOutputInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Validates a custom domain mapping to ensure it maps to the correct CNAME in DNS.
     *
     * @param profileName Name of the CDN profile which is unique within the resource group.
     * @param endpointName Name of the endpoint under the profile which is unique globally.
     * @param hostName The host name of the custom domain. Must be a domain name.
     * @return the observable to the ValidateCustomDomainOutputInner object
     */
    public Observable<ServiceResponse<ValidateCustomDomainOutputInner>> validateCustomDomainWithServiceResponseAsync(String profileName, String endpointName, String hostName) {
        if (this.client.resourceGroupName() == null) {
            throw new IllegalArgumentException("Parameter this.client.resourceGroupName() is required and cannot be null.");
        }
        if (profileName == null) {
            throw new IllegalArgumentException("Parameter profileName is required and cannot be null.");
        }
        if (endpointName == null) {
            throw new IllegalArgumentException("Parameter endpointName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        if (hostName == null) {
            throw new IllegalArgumentException("Parameter hostName is required and cannot be null.");
        }
        ValidateCustomDomainInput customDomainProperties = new ValidateCustomDomainInput();
        customDomainProperties.withHostName(hostName);
        return service.validateCustomDomain(this.client.resourceGroupName(), profileName, endpointName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), customDomainProperties, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ValidateCustomDomainOutputInner>>>() {
                @Override
                public Observable<ServiceResponse<ValidateCustomDomainOutputInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ValidateCustomDomainOutputInner> clientResponse = validateCustomDomainDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ValidateCustomDomainOutputInner> validateCustomDomainDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<ValidateCustomDomainOutputInner, ErrorResponseException>(this.client.mapperAdapter())
                .register(200, new TypeToken<ValidateCustomDomainOutputInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Lists existing CDN endpoints.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;EndpointInner&gt; object if successful.
     */
    public PagedList<EndpointInner> listByProfileNext(final String nextPageLink) {
        ServiceResponse<Page<EndpointInner>> response = listByProfileNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<EndpointInner>(response.getBody()) {
            @Override
            public Page<EndpointInner> nextPage(String nextPageLink) {
                return listByProfileNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Lists existing CDN endpoints.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<EndpointInner>> listByProfileNextAsync(final String nextPageLink, final ServiceCall<List<EndpointInner>> serviceCall, final ListOperationCallback<EndpointInner> serviceCallback) {
        return AzureServiceCall.create(
            listByProfileNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<EndpointInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<EndpointInner>>> call(String nextPageLink) {
                    return listByProfileNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists existing CDN endpoints.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;EndpointInner&gt; object
     */
    public Observable<Page<EndpointInner>> listByProfileNextAsync(final String nextPageLink) {
        return listByProfileNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<EndpointInner>>, Page<EndpointInner>>() {
                @Override
                public Page<EndpointInner> call(ServiceResponse<Page<EndpointInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Lists existing CDN endpoints.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;EndpointInner&gt; object
     */
    public Observable<ServiceResponse<Page<EndpointInner>>> listByProfileNextWithServiceResponseAsync(final String nextPageLink) {
        return listByProfileNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<EndpointInner>>, Observable<ServiceResponse<Page<EndpointInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<EndpointInner>>> call(ServiceResponse<Page<EndpointInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByProfileNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists existing CDN endpoints.
     *
    ServiceResponse<PageImpl<EndpointInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;EndpointInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<EndpointInner>>> listByProfileNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.listByProfileNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<EndpointInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<EndpointInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<EndpointInner>> result = listByProfileNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<EndpointInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<EndpointInner>> listByProfileNextDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<EndpointInner>, ErrorResponseException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<EndpointInner>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

}
