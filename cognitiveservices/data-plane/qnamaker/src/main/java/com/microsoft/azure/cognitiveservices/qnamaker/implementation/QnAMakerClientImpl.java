/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.cognitiveservices.qnamaker.implementation;

import com.google.common.base.Joiner;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.AzureClient;
import com.microsoft.azure.AzureServiceClient;
import com.microsoft.azure.cognitiveservices.qnamaker.models.AlterationsDTO;
import com.microsoft.azure.cognitiveservices.qnamaker.models.CreateKbDTO;
import com.microsoft.azure.cognitiveservices.qnamaker.models.EndpointKeysDTO;
import com.microsoft.azure.cognitiveservices.qnamaker.models.ErrorResponseException;
import com.microsoft.azure.cognitiveservices.qnamaker.models.GetOperationDetailsHeaders;
import com.microsoft.azure.cognitiveservices.qnamaker.models.KnowledgebaseDTO;
import com.microsoft.azure.cognitiveservices.qnamaker.models.KnowledgebasesDTO;
import com.microsoft.azure.cognitiveservices.qnamaker.models.Operation;
import com.microsoft.azure.cognitiveservices.qnamaker.models.QnADocumentsDTO;
import com.microsoft.azure.cognitiveservices.qnamaker.models.QnADTO;
import com.microsoft.azure.cognitiveservices.qnamaker.models.ReplaceKbDTO;
import com.microsoft.azure.cognitiveservices.qnamaker.models.UpdateKbOperationDTO;
import com.microsoft.azure.cognitiveservices.qnamaker.models.UpdateKnowledgebaseHeaders;
import com.microsoft.azure.cognitiveservices.qnamaker.models.WordAlterationsDTO;
import com.microsoft.azure.cognitiveservices.qnamaker.QnAMakerClient;
import com.microsoft.rest.credentials.ServiceClientCredentials;
import com.microsoft.rest.RestClient;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.ServiceResponseWithHeaders;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.List;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.PATCH;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * Initializes a new instance of the QnAMakerClientImpl class.
 */
public class QnAMakerClientImpl extends AzureServiceClient implements QnAMakerClient {
    /** The Retrofit service to perform REST calls. */
    private QnAMakerClientService service;
    /** the {@link AzureClient} used for long running operations. */
    private AzureClient azureClient;

    /**
     * Gets the {@link AzureClient} used for long running operations.
     * @return the azure client;
     */
    public AzureClient getAzureClient() {
        return this.azureClient;
    }

    /** Supported Cognitive Services endpoints (protocol and hostname, for example: https://westus.api.cognitive.microsoft.com). */
    private String endpoint;

    /**
     * Gets Supported Cognitive Services endpoints (protocol and hostname, for example: https://westus.api.cognitive.microsoft.com).
     *
     * @return the endpoint value.
     */
    public String endpoint() {
        return this.endpoint;
    }

    /**
     * Sets Supported Cognitive Services endpoints (protocol and hostname, for example: https://westus.api.cognitive.microsoft.com).
     *
     * @param endpoint the endpoint value.
     * @return the service client itself
     */
    public QnAMakerClientImpl withEndpoint(String endpoint) {
        this.endpoint = endpoint;
        return this;
    }

    /** The preferred language for the response. */
    private String acceptLanguage;

    /**
     * Gets The preferred language for the response.
     *
     * @return the acceptLanguage value.
     */
    public String acceptLanguage() {
        return this.acceptLanguage;
    }

    /**
     * Sets The preferred language for the response.
     *
     * @param acceptLanguage the acceptLanguage value.
     * @return the service client itself
     */
    public QnAMakerClientImpl withAcceptLanguage(String acceptLanguage) {
        this.acceptLanguage = acceptLanguage;
        return this;
    }

    /** The retry timeout in seconds for Long Running Operations. Default value is 30. */
    private int longRunningOperationRetryTimeout;

    /**
     * Gets The retry timeout in seconds for Long Running Operations. Default value is 30.
     *
     * @return the longRunningOperationRetryTimeout value.
     */
    public int longRunningOperationRetryTimeout() {
        return this.longRunningOperationRetryTimeout;
    }

    /**
     * Sets The retry timeout in seconds for Long Running Operations. Default value is 30.
     *
     * @param longRunningOperationRetryTimeout the longRunningOperationRetryTimeout value.
     * @return the service client itself
     */
    public QnAMakerClientImpl withLongRunningOperationRetryTimeout(int longRunningOperationRetryTimeout) {
        this.longRunningOperationRetryTimeout = longRunningOperationRetryTimeout;
        return this;
    }

    /** Whether a unique x-ms-client-request-id should be generated. When set to true a unique x-ms-client-request-id value is generated and included in each request. Default is true. */
    private boolean generateClientRequestId;

    /**
     * Gets Whether a unique x-ms-client-request-id should be generated. When set to true a unique x-ms-client-request-id value is generated and included in each request. Default is true.
     *
     * @return the generateClientRequestId value.
     */
    public boolean generateClientRequestId() {
        return this.generateClientRequestId;
    }

    /**
     * Sets Whether a unique x-ms-client-request-id should be generated. When set to true a unique x-ms-client-request-id value is generated and included in each request. Default is true.
     *
     * @param generateClientRequestId the generateClientRequestId value.
     * @return the service client itself
     */
    public QnAMakerClientImpl withGenerateClientRequestId(boolean generateClientRequestId) {
        this.generateClientRequestId = generateClientRequestId;
        return this;
    }

    /**
     * Initializes an instance of QnAMakerClient client.
     *
     * @param credentials the management credentials for Azure
     */
    public QnAMakerClientImpl(ServiceClientCredentials credentials) {
        this("https://{Endpoint}/qnamaker/v4.0", credentials);
    }

    /**
     * Initializes an instance of QnAMakerClient client.
     *
     * @param baseUrl the base URL of the host
     * @param credentials the management credentials for Azure
     */
    private QnAMakerClientImpl(String baseUrl, ServiceClientCredentials credentials) {
        super(baseUrl, credentials);
        initialize();
    }

    /**
     * Initializes an instance of QnAMakerClient client.
     *
     * @param restClient the REST client to connect to Azure.
     */
    public QnAMakerClientImpl(RestClient restClient) {
        super(restClient);
        initialize();
    }

    protected void initialize() {
        this.acceptLanguage = "en-US";
        this.longRunningOperationRetryTimeout = 30;
        this.generateClientRequestId = true;
        this.azureClient = new AzureClient(this);
        initializeService();
    }

    /**
     * Gets the User-Agent header for the client.
     *
     * @return the user agent string.
     */
    @Override
    public String userAgent() {
        return String.format("%s (%s, %s)", super.userAgent(), "QnAMakerClient", "4.0");
    }

    private void initializeService() {
        service = restClient().retrofit().create(QnAMakerClientService.class);
    }

    /**
     * The interface defining all the services for QnAMakerClient to be
     * used by Retrofit to perform actually REST calls.
     */
    interface QnAMakerClientService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.qnamaker.QnAMakerClient getEndpointKeys" })
        @GET("endpointkeys")
        Observable<Response<ResponseBody>> getEndpointKeys(@Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.qnamaker.QnAMakerClient refreshEndpointKeys" })
        @PATCH("endpointkeys/{keyType}")
        Observable<Response<ResponseBody>> refreshEndpointKeys(@Path("keyType") String keyType, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.qnamaker.QnAMakerClient downloadAlterations" })
        @GET("alterations")
        Observable<Response<ResponseBody>> downloadAlterations(@Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.qnamaker.QnAMakerClient replaceAlterations" })
        @PUT("alterations")
        Observable<Response<ResponseBody>> replaceAlterations(@Header("accept-language") String acceptLanguage, @Body WordAlterationsDTO wordAlterations, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.qnamaker.QnAMakerClient getKnowledgebasesForUser" })
        @GET("knowledgebases")
        Observable<Response<ResponseBody>> getKnowledgebasesForUser(@Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.qnamaker.QnAMakerClient getOperationDetails" })
        @GET("operations/{operationId}")
        Observable<Response<ResponseBody>> getOperationDetails(@Path("operationId") String operationId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.qnamaker.QnAMakerClient getKnowledgebaseDetails" })
        @GET("knowledgebases/{kbId}")
        Observable<Response<ResponseBody>> getKnowledgebaseDetails(@Path("kbId") String kbId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.qnamaker.QnAMakerClient deleteKnowledgebase" })
        @HTTP(path = "knowledgebases/{kbId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteKnowledgebase(@Path("kbId") String kbId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.qnamaker.QnAMakerClient publishKnowledgebase" })
        @POST("knowledgebases/{kbId}")
        Observable<Response<ResponseBody>> publishKnowledgebase(@Path("kbId") String kbId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.qnamaker.QnAMakerClient replaceKnowledgebase" })
        @PUT("knowledgebases/{kbId}")
        Observable<Response<ResponseBody>> replaceKnowledgebase(@Path("kbId") String kbId, @Header("accept-language") String acceptLanguage, @Body ReplaceKbDTO replaceKb, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.qnamaker.QnAMakerClient updateKnowledgebase" })
        @PATCH("knowledgebases/{kbId}")
        Observable<Response<ResponseBody>> updateKnowledgebase(@Path("kbId") String kbId, @Body UpdateKbOperationDTO updateKb, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.qnamaker.QnAMakerClient createKnowledgebase" })
        @POST("knowledgebases/create")
        Observable<Response<ResponseBody>> createKnowledgebase(@Body CreateKbDTO createKbPayload, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.qnamaker.QnAMakerClient downloadKnowledgebase" })
        @GET("knowledgebases/{kbId}/{environment}/qna")
        Observable<Response<ResponseBody>> downloadKnowledgebase(@Path("kbId") String kbId, @Path("environment") String environment, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

    }

    /**
     * Gets endpoint keys for an endpoint.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the EndpointKeysDTO object if successful.
     */
    public EndpointKeysDTO getEndpointKeys() {
        return getEndpointKeysWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets endpoint keys for an endpoint.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<EndpointKeysDTO> getEndpointKeysAsync(final ServiceCallback<EndpointKeysDTO> serviceCallback) {
        return ServiceFuture.fromResponse(getEndpointKeysWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets endpoint keys for an endpoint.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EndpointKeysDTO object
     */
    public Observable<EndpointKeysDTO> getEndpointKeysAsync() {
        return getEndpointKeysWithServiceResponseAsync().map(new Func1<ServiceResponse<EndpointKeysDTO>, EndpointKeysDTO>() {
            @Override
            public EndpointKeysDTO call(ServiceResponse<EndpointKeysDTO> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets endpoint keys for an endpoint.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EndpointKeysDTO object
     */
    public Observable<ServiceResponse<EndpointKeysDTO>> getEndpointKeysWithServiceResponseAsync() {
        if (this.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.endpoint() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.endpoint());
        return service.getEndpointKeys(this.acceptLanguage(), parameterizedHost, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<EndpointKeysDTO>>>() {
                @Override
                public Observable<ServiceResponse<EndpointKeysDTO>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<EndpointKeysDTO> clientResponse = getEndpointKeysDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<EndpointKeysDTO> getEndpointKeysDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<EndpointKeysDTO, ErrorResponseException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<EndpointKeysDTO>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Re-generates an endpoint key.
     *
     * @param keyType type of Key
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the EndpointKeysDTO object if successful.
     */
    public EndpointKeysDTO refreshEndpointKeys(String keyType) {
        return refreshEndpointKeysWithServiceResponseAsync(keyType).toBlocking().single().body();
    }

    /**
     * Re-generates an endpoint key.
     *
     * @param keyType type of Key
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<EndpointKeysDTO> refreshEndpointKeysAsync(String keyType, final ServiceCallback<EndpointKeysDTO> serviceCallback) {
        return ServiceFuture.fromResponse(refreshEndpointKeysWithServiceResponseAsync(keyType), serviceCallback);
    }

    /**
     * Re-generates an endpoint key.
     *
     * @param keyType type of Key
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EndpointKeysDTO object
     */
    public Observable<EndpointKeysDTO> refreshEndpointKeysAsync(String keyType) {
        return refreshEndpointKeysWithServiceResponseAsync(keyType).map(new Func1<ServiceResponse<EndpointKeysDTO>, EndpointKeysDTO>() {
            @Override
            public EndpointKeysDTO call(ServiceResponse<EndpointKeysDTO> response) {
                return response.body();
            }
        });
    }

    /**
     * Re-generates an endpoint key.
     *
     * @param keyType type of Key
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EndpointKeysDTO object
     */
    public Observable<ServiceResponse<EndpointKeysDTO>> refreshEndpointKeysWithServiceResponseAsync(String keyType) {
        if (this.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.endpoint() is required and cannot be null.");
        }
        if (keyType == null) {
            throw new IllegalArgumentException("Parameter keyType is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.endpoint());
        return service.refreshEndpointKeys(keyType, this.acceptLanguage(), parameterizedHost, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<EndpointKeysDTO>>>() {
                @Override
                public Observable<ServiceResponse<EndpointKeysDTO>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<EndpointKeysDTO> clientResponse = refreshEndpointKeysDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<EndpointKeysDTO> refreshEndpointKeysDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<EndpointKeysDTO, ErrorResponseException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<EndpointKeysDTO>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Download alterations from runtime.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the WordAlterationsDTO object if successful.
     */
    public WordAlterationsDTO downloadAlterations() {
        return downloadAlterationsWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Download alterations from runtime.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<WordAlterationsDTO> downloadAlterationsAsync(final ServiceCallback<WordAlterationsDTO> serviceCallback) {
        return ServiceFuture.fromResponse(downloadAlterationsWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Download alterations from runtime.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the WordAlterationsDTO object
     */
    public Observable<WordAlterationsDTO> downloadAlterationsAsync() {
        return downloadAlterationsWithServiceResponseAsync().map(new Func1<ServiceResponse<WordAlterationsDTO>, WordAlterationsDTO>() {
            @Override
            public WordAlterationsDTO call(ServiceResponse<WordAlterationsDTO> response) {
                return response.body();
            }
        });
    }

    /**
     * Download alterations from runtime.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the WordAlterationsDTO object
     */
    public Observable<ServiceResponse<WordAlterationsDTO>> downloadAlterationsWithServiceResponseAsync() {
        if (this.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.endpoint() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.endpoint());
        return service.downloadAlterations(this.acceptLanguage(), parameterizedHost, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<WordAlterationsDTO>>>() {
                @Override
                public Observable<ServiceResponse<WordAlterationsDTO>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<WordAlterationsDTO> clientResponse = downloadAlterationsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<WordAlterationsDTO> downloadAlterationsDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<WordAlterationsDTO, ErrorResponseException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<WordAlterationsDTO>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Replace alterations data.
     *
     * @param wordAlterations Collection of word alterations.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void replaceAlterations(List<AlterationsDTO> wordAlterations) {
        replaceAlterationsWithServiceResponseAsync(wordAlterations).toBlocking().single().body();
    }

    /**
     * Replace alterations data.
     *
     * @param wordAlterations Collection of word alterations.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> replaceAlterationsAsync(List<AlterationsDTO> wordAlterations, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(replaceAlterationsWithServiceResponseAsync(wordAlterations), serviceCallback);
    }

    /**
     * Replace alterations data.
     *
     * @param wordAlterations Collection of word alterations.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> replaceAlterationsAsync(List<AlterationsDTO> wordAlterations) {
        return replaceAlterationsWithServiceResponseAsync(wordAlterations).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Replace alterations data.
     *
     * @param wordAlterations Collection of word alterations.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> replaceAlterationsWithServiceResponseAsync(List<AlterationsDTO> wordAlterations) {
        if (this.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.endpoint() is required and cannot be null.");
        }
        if (wordAlterations == null) {
            throw new IllegalArgumentException("Parameter wordAlterations is required and cannot be null.");
        }
        Validator.validate(wordAlterations);
        WordAlterationsDTO wordAlterations1 = new WordAlterationsDTO();
        wordAlterations1.withWordAlterations(wordAlterations);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.endpoint());
        return service.replaceAlterations(this.acceptLanguage(), wordAlterations1, parameterizedHost, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = replaceAlterationsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> replaceAlterationsDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, ErrorResponseException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Gets all knowledgebases for a user.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the KnowledgebasesDTO object if successful.
     */
    public KnowledgebasesDTO getKnowledgebasesForUser() {
        return getKnowledgebasesForUserWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets all knowledgebases for a user.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<KnowledgebasesDTO> getKnowledgebasesForUserAsync(final ServiceCallback<KnowledgebasesDTO> serviceCallback) {
        return ServiceFuture.fromResponse(getKnowledgebasesForUserWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets all knowledgebases for a user.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the KnowledgebasesDTO object
     */
    public Observable<KnowledgebasesDTO> getKnowledgebasesForUserAsync() {
        return getKnowledgebasesForUserWithServiceResponseAsync().map(new Func1<ServiceResponse<KnowledgebasesDTO>, KnowledgebasesDTO>() {
            @Override
            public KnowledgebasesDTO call(ServiceResponse<KnowledgebasesDTO> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets all knowledgebases for a user.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the KnowledgebasesDTO object
     */
    public Observable<ServiceResponse<KnowledgebasesDTO>> getKnowledgebasesForUserWithServiceResponseAsync() {
        if (this.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.endpoint() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.endpoint());
        return service.getKnowledgebasesForUser(this.acceptLanguage(), parameterizedHost, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<KnowledgebasesDTO>>>() {
                @Override
                public Observable<ServiceResponse<KnowledgebasesDTO>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<KnowledgebasesDTO> clientResponse = getKnowledgebasesForUserDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<KnowledgebasesDTO> getKnowledgebasesForUserDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<KnowledgebasesDTO, ErrorResponseException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<KnowledgebasesDTO>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Gets details of a specific long running operation.
     *
     * @param operationId Operation id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Operation object if successful.
     */
    public Operation getOperationDetails(String operationId) {
        return getOperationDetailsWithServiceResponseAsync(operationId).toBlocking().single().body();
    }

    /**
     * Gets details of a specific long running operation.
     *
     * @param operationId Operation id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Operation> getOperationDetailsAsync(String operationId, final ServiceCallback<Operation> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getOperationDetailsWithServiceResponseAsync(operationId), serviceCallback);
    }

    /**
     * Gets details of a specific long running operation.
     *
     * @param operationId Operation id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Operation object
     */
    public Observable<Operation> getOperationDetailsAsync(String operationId) {
        return getOperationDetailsWithServiceResponseAsync(operationId).map(new Func1<ServiceResponseWithHeaders<Operation, GetOperationDetailsHeaders>, Operation>() {
            @Override
            public Operation call(ServiceResponseWithHeaders<Operation, GetOperationDetailsHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets details of a specific long running operation.
     *
     * @param operationId Operation id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Operation object
     */
    public Observable<ServiceResponseWithHeaders<Operation, GetOperationDetailsHeaders>> getOperationDetailsWithServiceResponseAsync(String operationId) {
        if (this.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.endpoint() is required and cannot be null.");
        }
        if (operationId == null) {
            throw new IllegalArgumentException("Parameter operationId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.endpoint());
        return service.getOperationDetails(operationId, this.acceptLanguage(), parameterizedHost, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Operation, GetOperationDetailsHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Operation, GetOperationDetailsHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Operation, GetOperationDetailsHeaders> clientResponse = getOperationDetailsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Operation, GetOperationDetailsHeaders> getOperationDetailsDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Operation, ErrorResponseException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Operation>() { }.getType())
                .registerError(ErrorResponseException.class)
                .buildWithHeaders(response, GetOperationDetailsHeaders.class);
    }

    /**
     * Gets details of a specific knowledgebase.
     *
     * @param kbId Knowledgebase id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the KnowledgebaseDTO object if successful.
     */
    public KnowledgebaseDTO getKnowledgebaseDetails(String kbId) {
        return getKnowledgebaseDetailsWithServiceResponseAsync(kbId).toBlocking().single().body();
    }

    /**
     * Gets details of a specific knowledgebase.
     *
     * @param kbId Knowledgebase id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<KnowledgebaseDTO> getKnowledgebaseDetailsAsync(String kbId, final ServiceCallback<KnowledgebaseDTO> serviceCallback) {
        return ServiceFuture.fromResponse(getKnowledgebaseDetailsWithServiceResponseAsync(kbId), serviceCallback);
    }

    /**
     * Gets details of a specific knowledgebase.
     *
     * @param kbId Knowledgebase id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the KnowledgebaseDTO object
     */
    public Observable<KnowledgebaseDTO> getKnowledgebaseDetailsAsync(String kbId) {
        return getKnowledgebaseDetailsWithServiceResponseAsync(kbId).map(new Func1<ServiceResponse<KnowledgebaseDTO>, KnowledgebaseDTO>() {
            @Override
            public KnowledgebaseDTO call(ServiceResponse<KnowledgebaseDTO> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets details of a specific knowledgebase.
     *
     * @param kbId Knowledgebase id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the KnowledgebaseDTO object
     */
    public Observable<ServiceResponse<KnowledgebaseDTO>> getKnowledgebaseDetailsWithServiceResponseAsync(String kbId) {
        if (this.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.endpoint() is required and cannot be null.");
        }
        if (kbId == null) {
            throw new IllegalArgumentException("Parameter kbId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.endpoint());
        return service.getKnowledgebaseDetails(kbId, this.acceptLanguage(), parameterizedHost, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<KnowledgebaseDTO>>>() {
                @Override
                public Observable<ServiceResponse<KnowledgebaseDTO>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<KnowledgebaseDTO> clientResponse = getKnowledgebaseDetailsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<KnowledgebaseDTO> getKnowledgebaseDetailsDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<KnowledgebaseDTO, ErrorResponseException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<KnowledgebaseDTO>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Deletes the knowledgebase and all its data.
     *
     * @param kbId Knowledgebase id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteKnowledgebase(String kbId) {
        deleteKnowledgebaseWithServiceResponseAsync(kbId).toBlocking().single().body();
    }

    /**
     * Deletes the knowledgebase and all its data.
     *
     * @param kbId Knowledgebase id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteKnowledgebaseAsync(String kbId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteKnowledgebaseWithServiceResponseAsync(kbId), serviceCallback);
    }

    /**
     * Deletes the knowledgebase and all its data.
     *
     * @param kbId Knowledgebase id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteKnowledgebaseAsync(String kbId) {
        return deleteKnowledgebaseWithServiceResponseAsync(kbId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes the knowledgebase and all its data.
     *
     * @param kbId Knowledgebase id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteKnowledgebaseWithServiceResponseAsync(String kbId) {
        if (this.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.endpoint() is required and cannot be null.");
        }
        if (kbId == null) {
            throw new IllegalArgumentException("Parameter kbId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.endpoint());
        return service.deleteKnowledgebase(kbId, this.acceptLanguage(), parameterizedHost, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteKnowledgebaseDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteKnowledgebaseDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, ErrorResponseException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Publishes all changes in test index of a knowledgebase to its prod index.
     *
     * @param kbId Knowledgebase id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void publishKnowledgebase(String kbId) {
        publishKnowledgebaseWithServiceResponseAsync(kbId).toBlocking().single().body();
    }

    /**
     * Publishes all changes in test index of a knowledgebase to its prod index.
     *
     * @param kbId Knowledgebase id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> publishKnowledgebaseAsync(String kbId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(publishKnowledgebaseWithServiceResponseAsync(kbId), serviceCallback);
    }

    /**
     * Publishes all changes in test index of a knowledgebase to its prod index.
     *
     * @param kbId Knowledgebase id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> publishKnowledgebaseAsync(String kbId) {
        return publishKnowledgebaseWithServiceResponseAsync(kbId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Publishes all changes in test index of a knowledgebase to its prod index.
     *
     * @param kbId Knowledgebase id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> publishKnowledgebaseWithServiceResponseAsync(String kbId) {
        if (this.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.endpoint() is required and cannot be null.");
        }
        if (kbId == null) {
            throw new IllegalArgumentException("Parameter kbId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.endpoint());
        return service.publishKnowledgebase(kbId, this.acceptLanguage(), parameterizedHost, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = publishKnowledgebaseDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> publishKnowledgebaseDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, ErrorResponseException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Replace knowledgebase contents.
     *
     * @param kbId Knowledgebase id.
     * @param qnAList List of Q-A (QnADTO) to be added to the knowledgebase. Q-A Ids are assigned by the service and should be omitted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void replaceKnowledgebase(String kbId, List<QnADTO> qnAList) {
        replaceKnowledgebaseWithServiceResponseAsync(kbId, qnAList).toBlocking().single().body();
    }

    /**
     * Replace knowledgebase contents.
     *
     * @param kbId Knowledgebase id.
     * @param qnAList List of Q-A (QnADTO) to be added to the knowledgebase. Q-A Ids are assigned by the service and should be omitted.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> replaceKnowledgebaseAsync(String kbId, List<QnADTO> qnAList, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(replaceKnowledgebaseWithServiceResponseAsync(kbId, qnAList), serviceCallback);
    }

    /**
     * Replace knowledgebase contents.
     *
     * @param kbId Knowledgebase id.
     * @param qnAList List of Q-A (QnADTO) to be added to the knowledgebase. Q-A Ids are assigned by the service and should be omitted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> replaceKnowledgebaseAsync(String kbId, List<QnADTO> qnAList) {
        return replaceKnowledgebaseWithServiceResponseAsync(kbId, qnAList).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Replace knowledgebase contents.
     *
     * @param kbId Knowledgebase id.
     * @param qnAList List of Q-A (QnADTO) to be added to the knowledgebase. Q-A Ids are assigned by the service and should be omitted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> replaceKnowledgebaseWithServiceResponseAsync(String kbId, List<QnADTO> qnAList) {
        if (this.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.endpoint() is required and cannot be null.");
        }
        if (kbId == null) {
            throw new IllegalArgumentException("Parameter kbId is required and cannot be null.");
        }
        if (qnAList == null) {
            throw new IllegalArgumentException("Parameter qnAList is required and cannot be null.");
        }
        Validator.validate(qnAList);
        ReplaceKbDTO replaceKb = new ReplaceKbDTO();
        replaceKb.withQnAList(qnAList);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.endpoint());
        return service.replaceKnowledgebase(kbId, this.acceptLanguage(), replaceKb, parameterizedHost, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = replaceKnowledgebaseDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> replaceKnowledgebaseDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, ErrorResponseException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Asynchronous operation to modify a knowledgebase.
     *
     * @param kbId Knowledgebase id.
     * @param updateKb Post body of the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Operation object if successful.
     */
    public Operation updateKnowledgebase(String kbId, UpdateKbOperationDTO updateKb) {
        return updateKnowledgebaseWithServiceResponseAsync(kbId, updateKb).toBlocking().single().body();
    }

    /**
     * Asynchronous operation to modify a knowledgebase.
     *
     * @param kbId Knowledgebase id.
     * @param updateKb Post body of the request.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Operation> updateKnowledgebaseAsync(String kbId, UpdateKbOperationDTO updateKb, final ServiceCallback<Operation> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateKnowledgebaseWithServiceResponseAsync(kbId, updateKb), serviceCallback);
    }

    /**
     * Asynchronous operation to modify a knowledgebase.
     *
     * @param kbId Knowledgebase id.
     * @param updateKb Post body of the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Operation object
     */
    public Observable<Operation> updateKnowledgebaseAsync(String kbId, UpdateKbOperationDTO updateKb) {
        return updateKnowledgebaseWithServiceResponseAsync(kbId, updateKb).map(new Func1<ServiceResponseWithHeaders<Operation, UpdateKnowledgebaseHeaders>, Operation>() {
            @Override
            public Operation call(ServiceResponseWithHeaders<Operation, UpdateKnowledgebaseHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Asynchronous operation to modify a knowledgebase.
     *
     * @param kbId Knowledgebase id.
     * @param updateKb Post body of the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Operation object
     */
    public Observable<ServiceResponseWithHeaders<Operation, UpdateKnowledgebaseHeaders>> updateKnowledgebaseWithServiceResponseAsync(String kbId, UpdateKbOperationDTO updateKb) {
        if (this.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.endpoint() is required and cannot be null.");
        }
        if (kbId == null) {
            throw new IllegalArgumentException("Parameter kbId is required and cannot be null.");
        }
        if (updateKb == null) {
            throw new IllegalArgumentException("Parameter updateKb is required and cannot be null.");
        }
        Validator.validate(updateKb);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.endpoint());
        return service.updateKnowledgebase(kbId, updateKb, this.acceptLanguage(), parameterizedHost, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Operation, UpdateKnowledgebaseHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Operation, UpdateKnowledgebaseHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Operation, UpdateKnowledgebaseHeaders> clientResponse = updateKnowledgebaseDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Operation, UpdateKnowledgebaseHeaders> updateKnowledgebaseDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Operation, ErrorResponseException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<Operation>() { }.getType())
                .registerError(ErrorResponseException.class)
                .buildWithHeaders(response, UpdateKnowledgebaseHeaders.class);
    }

    /**
     * Asynchronous operation to create a new knowledgebase.
     *
     * @param createKbPayload Post body of the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Operation object if successful.
     */
    public Operation createKnowledgebase(CreateKbDTO createKbPayload) {
        return createKnowledgebaseWithServiceResponseAsync(createKbPayload).toBlocking().single().body();
    }

    /**
     * Asynchronous operation to create a new knowledgebase.
     *
     * @param createKbPayload Post body of the request.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Operation> createKnowledgebaseAsync(CreateKbDTO createKbPayload, final ServiceCallback<Operation> serviceCallback) {
        return ServiceFuture.fromResponse(createKnowledgebaseWithServiceResponseAsync(createKbPayload), serviceCallback);
    }

    /**
     * Asynchronous operation to create a new knowledgebase.
     *
     * @param createKbPayload Post body of the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Operation object
     */
    public Observable<Operation> createKnowledgebaseAsync(CreateKbDTO createKbPayload) {
        return createKnowledgebaseWithServiceResponseAsync(createKbPayload).map(new Func1<ServiceResponse<Operation>, Operation>() {
            @Override
            public Operation call(ServiceResponse<Operation> response) {
                return response.body();
            }
        });
    }

    /**
     * Asynchronous operation to create a new knowledgebase.
     *
     * @param createKbPayload Post body of the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Operation object
     */
    public Observable<ServiceResponse<Operation>> createKnowledgebaseWithServiceResponseAsync(CreateKbDTO createKbPayload) {
        if (this.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.endpoint() is required and cannot be null.");
        }
        if (createKbPayload == null) {
            throw new IllegalArgumentException("Parameter createKbPayload is required and cannot be null.");
        }
        Validator.validate(createKbPayload);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.endpoint());
        return service.createKnowledgebase(createKbPayload, this.acceptLanguage(), parameterizedHost, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Operation>>>() {
                @Override
                public Observable<ServiceResponse<Operation>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Operation> clientResponse = createKnowledgebaseDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Operation> createKnowledgebaseDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Operation, ErrorResponseException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<Operation>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Download the knowledgebase.
     *
     * @param kbId Knowledgebase id.
     * @param environment Specifies whether environment is Test or Prod. Possible values include: 'Prod', 'Test'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the QnADocumentsDTO object if successful.
     */
    public QnADocumentsDTO downloadKnowledgebase(String kbId, String environment) {
        return downloadKnowledgebaseWithServiceResponseAsync(kbId, environment).toBlocking().single().body();
    }

    /**
     * Download the knowledgebase.
     *
     * @param kbId Knowledgebase id.
     * @param environment Specifies whether environment is Test or Prod. Possible values include: 'Prod', 'Test'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<QnADocumentsDTO> downloadKnowledgebaseAsync(String kbId, String environment, final ServiceCallback<QnADocumentsDTO> serviceCallback) {
        return ServiceFuture.fromResponse(downloadKnowledgebaseWithServiceResponseAsync(kbId, environment), serviceCallback);
    }

    /**
     * Download the knowledgebase.
     *
     * @param kbId Knowledgebase id.
     * @param environment Specifies whether environment is Test or Prod. Possible values include: 'Prod', 'Test'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the QnADocumentsDTO object
     */
    public Observable<QnADocumentsDTO> downloadKnowledgebaseAsync(String kbId, String environment) {
        return downloadKnowledgebaseWithServiceResponseAsync(kbId, environment).map(new Func1<ServiceResponse<QnADocumentsDTO>, QnADocumentsDTO>() {
            @Override
            public QnADocumentsDTO call(ServiceResponse<QnADocumentsDTO> response) {
                return response.body();
            }
        });
    }

    /**
     * Download the knowledgebase.
     *
     * @param kbId Knowledgebase id.
     * @param environment Specifies whether environment is Test or Prod. Possible values include: 'Prod', 'Test'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the QnADocumentsDTO object
     */
    public Observable<ServiceResponse<QnADocumentsDTO>> downloadKnowledgebaseWithServiceResponseAsync(String kbId, String environment) {
        if (this.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.endpoint() is required and cannot be null.");
        }
        if (kbId == null) {
            throw new IllegalArgumentException("Parameter kbId is required and cannot be null.");
        }
        if (environment == null) {
            throw new IllegalArgumentException("Parameter environment is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.endpoint());
        return service.downloadKnowledgebase(kbId, environment, this.acceptLanguage(), parameterizedHost, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<QnADocumentsDTO>>>() {
                @Override
                public Observable<ServiceResponse<QnADocumentsDTO>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<QnADocumentsDTO> clientResponse = downloadKnowledgebaseDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<QnADocumentsDTO> downloadKnowledgebaseDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<QnADocumentsDTO, ErrorResponseException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<QnADocumentsDTO>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

}
