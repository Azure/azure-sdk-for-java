/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.cognitiveservices.language.textanalytics.implementation;

import com.google.common.base.Joiner;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.AzureClient;
import com.microsoft.azure.AzureServiceClient;
import com.microsoft.azure.cognitiveservices.language.textanalytics.models.BatchInput;
import com.microsoft.azure.cognitiveservices.language.textanalytics.models.EntitiesBatchResult;
import com.microsoft.azure.cognitiveservices.language.textanalytics.models.ErrorResponseException;
import com.microsoft.azure.cognitiveservices.language.textanalytics.models.Input;
import com.microsoft.azure.cognitiveservices.language.textanalytics.models.KeyPhraseBatchResult;
import com.microsoft.azure.cognitiveservices.language.textanalytics.models.LanguageBatchResult;
import com.microsoft.azure.cognitiveservices.language.textanalytics.models.MultiLanguageBatchInput;
import com.microsoft.azure.cognitiveservices.language.textanalytics.models.MultiLanguageInput;
import com.microsoft.azure.cognitiveservices.language.textanalytics.models.SentimentBatchResult;
import com.microsoft.azure.cognitiveservices.language.textanalytics.TextAnalyticsClient;
import com.microsoft.rest.credentials.ServiceClientCredentials;
import com.microsoft.rest.RestClient;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.List;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.POST;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * Initializes a new instance of the TextAnalyticsClientImpl class.
 */
public class TextAnalyticsClientImpl extends AzureServiceClient implements TextAnalyticsClient {
    /** The Retrofit service to perform REST calls. */
    private TextAnalyticsClientService service;
    /** the {@link AzureClient} used for long running operations. */
    private AzureClient azureClient;

    /**
     * Gets the {@link AzureClient} used for long running operations.
     * @return the azure client;
     */
    public AzureClient getAzureClient() {
        return this.azureClient;
    }

    /** Supported Cognitive Services endpoints (protocol and hostname, for example: https://westus.api.cognitive.microsoft.com). */
    private String endpoint;

    /**
     * Gets Supported Cognitive Services endpoints (protocol and hostname, for example: https://westus.api.cognitive.microsoft.com).
     *
     * @return the endpoint value.
     */
    public String endpoint() {
        return this.endpoint;
    }

    /**
     * Sets Supported Cognitive Services endpoints (protocol and hostname, for example: https://westus.api.cognitive.microsoft.com).
     *
     * @param endpoint the endpoint value.
     * @return the service client itself
     */
    public TextAnalyticsClientImpl withEndpoint(String endpoint) {
        this.endpoint = endpoint;
        return this;
    }

    /** Gets or sets the preferred language for the response. */
    private String acceptLanguage;

    /**
     * Gets Gets or sets the preferred language for the response.
     *
     * @return the acceptLanguage value.
     */
    public String acceptLanguage() {
        return this.acceptLanguage;
    }

    /**
     * Sets Gets or sets the preferred language for the response.
     *
     * @param acceptLanguage the acceptLanguage value.
     * @return the service client itself
     */
    public TextAnalyticsClientImpl withAcceptLanguage(String acceptLanguage) {
        this.acceptLanguage = acceptLanguage;
        return this;
    }

    /** Gets or sets the retry timeout in seconds for Long Running Operations. Default value is 30. */
    private int longRunningOperationRetryTimeout;

    /**
     * Gets Gets or sets the retry timeout in seconds for Long Running Operations. Default value is 30.
     *
     * @return the longRunningOperationRetryTimeout value.
     */
    public int longRunningOperationRetryTimeout() {
        return this.longRunningOperationRetryTimeout;
    }

    /**
     * Sets Gets or sets the retry timeout in seconds for Long Running Operations. Default value is 30.
     *
     * @param longRunningOperationRetryTimeout the longRunningOperationRetryTimeout value.
     * @return the service client itself
     */
    public TextAnalyticsClientImpl withLongRunningOperationRetryTimeout(int longRunningOperationRetryTimeout) {
        this.longRunningOperationRetryTimeout = longRunningOperationRetryTimeout;
        return this;
    }

    /** When set to true a unique x-ms-client-request-id value is generated and included in each request. Default is true. */
    private boolean generateClientRequestId;

    /**
     * Gets When set to true a unique x-ms-client-request-id value is generated and included in each request. Default is true.
     *
     * @return the generateClientRequestId value.
     */
    public boolean generateClientRequestId() {
        return this.generateClientRequestId;
    }

    /**
     * Sets When set to true a unique x-ms-client-request-id value is generated and included in each request. Default is true.
     *
     * @param generateClientRequestId the generateClientRequestId value.
     * @return the service client itself
     */
    public TextAnalyticsClientImpl withGenerateClientRequestId(boolean generateClientRequestId) {
        this.generateClientRequestId = generateClientRequestId;
        return this;
    }

    /**
     * Initializes an instance of TextAnalyticsClient client.
     *
     * @param credentials the management credentials for Azure
     */
    public TextAnalyticsClientImpl(ServiceClientCredentials credentials) {
        this("https://{Endpoint}/text/analytics/v2.1-preview", credentials);
    }

    /**
     * Initializes an instance of TextAnalyticsClient client.
     *
     * @param baseUrl the base URL of the host
     * @param credentials the management credentials for Azure
     */
    private TextAnalyticsClientImpl(String baseUrl, ServiceClientCredentials credentials) {
        super(baseUrl, credentials);
        initialize();
    }

    /**
     * Initializes an instance of TextAnalyticsClient client.
     *
     * @param restClient the REST client to connect to Azure.
     */
    public TextAnalyticsClientImpl(RestClient restClient) {
        super(restClient);
        initialize();
    }

    protected void initialize() {
        this.acceptLanguage = "en-US";
        this.longRunningOperationRetryTimeout = 30;
        this.generateClientRequestId = true;
        this.azureClient = new AzureClient(this);
        initializeService();
    }

    /**
     * Gets the User-Agent header for the client.
     *
     * @return the user agent string.
     */
    @Override
    public String userAgent() {
        return String.format("%s (%s, %s)", super.userAgent(), "TextAnalyticsClient", "v2.1-preview");
    }

    private void initializeService() {
        service = restClient().retrofit().create(TextAnalyticsClientService.class);
    }

    /**
     * The interface defining all the services for TextAnalyticsClient to be
     * used by Retrofit to perform actually REST calls.
     */
    interface TextAnalyticsClientService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.textanalytics.TextAnalyticsClient keyPhrases" })
        @POST("keyPhrases")
        Observable<Response<ResponseBody>> keyPhrases(@Header("accept-language") String acceptLanguage, @Body MultiLanguageBatchInput input, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.textanalytics.TextAnalyticsClient detectLanguage" })
        @POST("languages")
        Observable<Response<ResponseBody>> detectLanguage(@Header("accept-language") String acceptLanguage, @Body BatchInput input, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.textanalytics.TextAnalyticsClient sentiment" })
        @POST("sentiment")
        Observable<Response<ResponseBody>> sentiment(@Header("accept-language") String acceptLanguage, @Body MultiLanguageBatchInput input, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.textanalytics.TextAnalyticsClient entities" })
        @POST("entities")
        Observable<Response<ResponseBody>> entities(@Header("accept-language") String acceptLanguage, @Body MultiLanguageBatchInput input, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

    }

    /**
     * The API returns a list of strings denoting the key talking points in the input text.
     * See the &lt;a href="https://docs.microsoft.com/en-us/azure/cognitive-services/text-analytics/overview#supported-languages"&gt;Text Analytics Documentation&lt;/a&gt; for details about the languages that are supported by key phrase extraction.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the KeyPhraseBatchResult object if successful.
     */
    public KeyPhraseBatchResult keyPhrases() {
        return keyPhrasesWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * The API returns a list of strings denoting the key talking points in the input text.
     * See the &lt;a href="https://docs.microsoft.com/en-us/azure/cognitive-services/text-analytics/overview#supported-languages"&gt;Text Analytics Documentation&lt;/a&gt; for details about the languages that are supported by key phrase extraction.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<KeyPhraseBatchResult> keyPhrasesAsync(final ServiceCallback<KeyPhraseBatchResult> serviceCallback) {
        return ServiceFuture.fromResponse(keyPhrasesWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * The API returns a list of strings denoting the key talking points in the input text.
     * See the &lt;a href="https://docs.microsoft.com/en-us/azure/cognitive-services/text-analytics/overview#supported-languages"&gt;Text Analytics Documentation&lt;/a&gt; for details about the languages that are supported by key phrase extraction.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the KeyPhraseBatchResult object
     */
    public Observable<KeyPhraseBatchResult> keyPhrasesAsync() {
        return keyPhrasesWithServiceResponseAsync().map(new Func1<ServiceResponse<KeyPhraseBatchResult>, KeyPhraseBatchResult>() {
            @Override
            public KeyPhraseBatchResult call(ServiceResponse<KeyPhraseBatchResult> response) {
                return response.body();
            }
        });
    }

    /**
     * The API returns a list of strings denoting the key talking points in the input text.
     * See the &lt;a href="https://docs.microsoft.com/en-us/azure/cognitive-services/text-analytics/overview#supported-languages"&gt;Text Analytics Documentation&lt;/a&gt; for details about the languages that are supported by key phrase extraction.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the KeyPhraseBatchResult object
     */
    public Observable<ServiceResponse<KeyPhraseBatchResult>> keyPhrasesWithServiceResponseAsync() {
        if (this.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.endpoint() is required and cannot be null.");
        }
        final List<MultiLanguageInput> documents = null;
        MultiLanguageBatchInput input = new MultiLanguageBatchInput();
        input.withDocuments(null);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.endpoint());
        return service.keyPhrases(this.acceptLanguage(), input, parameterizedHost, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<KeyPhraseBatchResult>>>() {
                @Override
                public Observable<ServiceResponse<KeyPhraseBatchResult>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<KeyPhraseBatchResult> clientResponse = keyPhrasesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * The API returns a list of strings denoting the key talking points in the input text.
     * See the &lt;a href="https://docs.microsoft.com/en-us/azure/cognitive-services/text-analytics/overview#supported-languages"&gt;Text Analytics Documentation&lt;/a&gt; for details about the languages that are supported by key phrase extraction.
     *
     * @param documents the List&lt;MultiLanguageInput&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the KeyPhraseBatchResult object if successful.
     */
    public KeyPhraseBatchResult keyPhrases(List<MultiLanguageInput> documents) {
        return keyPhrasesWithServiceResponseAsync(documents).toBlocking().single().body();
    }

    /**
     * The API returns a list of strings denoting the key talking points in the input text.
     * See the &lt;a href="https://docs.microsoft.com/en-us/azure/cognitive-services/text-analytics/overview#supported-languages"&gt;Text Analytics Documentation&lt;/a&gt; for details about the languages that are supported by key phrase extraction.
     *
     * @param documents the List&lt;MultiLanguageInput&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<KeyPhraseBatchResult> keyPhrasesAsync(List<MultiLanguageInput> documents, final ServiceCallback<KeyPhraseBatchResult> serviceCallback) {
        return ServiceFuture.fromResponse(keyPhrasesWithServiceResponseAsync(documents), serviceCallback);
    }

    /**
     * The API returns a list of strings denoting the key talking points in the input text.
     * See the &lt;a href="https://docs.microsoft.com/en-us/azure/cognitive-services/text-analytics/overview#supported-languages"&gt;Text Analytics Documentation&lt;/a&gt; for details about the languages that are supported by key phrase extraction.
     *
     * @param documents the List&lt;MultiLanguageInput&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the KeyPhraseBatchResult object
     */
    public Observable<KeyPhraseBatchResult> keyPhrasesAsync(List<MultiLanguageInput> documents) {
        return keyPhrasesWithServiceResponseAsync(documents).map(new Func1<ServiceResponse<KeyPhraseBatchResult>, KeyPhraseBatchResult>() {
            @Override
            public KeyPhraseBatchResult call(ServiceResponse<KeyPhraseBatchResult> response) {
                return response.body();
            }
        });
    }

    /**
     * The API returns a list of strings denoting the key talking points in the input text.
     * See the &lt;a href="https://docs.microsoft.com/en-us/azure/cognitive-services/text-analytics/overview#supported-languages"&gt;Text Analytics Documentation&lt;/a&gt; for details about the languages that are supported by key phrase extraction.
     *
     * @param documents the List&lt;MultiLanguageInput&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the KeyPhraseBatchResult object
     */
    public Observable<ServiceResponse<KeyPhraseBatchResult>> keyPhrasesWithServiceResponseAsync(List<MultiLanguageInput> documents) {
        if (this.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.endpoint() is required and cannot be null.");
        }
        Validator.validate(documents);
        MultiLanguageBatchInput input = new MultiLanguageBatchInput();
        input.withDocuments(documents);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.endpoint());
        return service.keyPhrases(this.acceptLanguage(), input, parameterizedHost, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<KeyPhraseBatchResult>>>() {
                @Override
                public Observable<ServiceResponse<KeyPhraseBatchResult>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<KeyPhraseBatchResult> clientResponse = keyPhrasesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<KeyPhraseBatchResult> keyPhrasesDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<KeyPhraseBatchResult, ErrorResponseException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<KeyPhraseBatchResult>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * The API returns the detected language and a numeric score between 0 and 1.
     * Scores close to 1 indicate 100% certainty that the identified language is true. A total of 120 languages are supported.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the LanguageBatchResult object if successful.
     */
    public LanguageBatchResult detectLanguage() {
        return detectLanguageWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * The API returns the detected language and a numeric score between 0 and 1.
     * Scores close to 1 indicate 100% certainty that the identified language is true. A total of 120 languages are supported.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<LanguageBatchResult> detectLanguageAsync(final ServiceCallback<LanguageBatchResult> serviceCallback) {
        return ServiceFuture.fromResponse(detectLanguageWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * The API returns the detected language and a numeric score between 0 and 1.
     * Scores close to 1 indicate 100% certainty that the identified language is true. A total of 120 languages are supported.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the LanguageBatchResult object
     */
    public Observable<LanguageBatchResult> detectLanguageAsync() {
        return detectLanguageWithServiceResponseAsync().map(new Func1<ServiceResponse<LanguageBatchResult>, LanguageBatchResult>() {
            @Override
            public LanguageBatchResult call(ServiceResponse<LanguageBatchResult> response) {
                return response.body();
            }
        });
    }

    /**
     * The API returns the detected language and a numeric score between 0 and 1.
     * Scores close to 1 indicate 100% certainty that the identified language is true. A total of 120 languages are supported.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the LanguageBatchResult object
     */
    public Observable<ServiceResponse<LanguageBatchResult>> detectLanguageWithServiceResponseAsync() {
        if (this.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.endpoint() is required and cannot be null.");
        }
        final List<Input> documents = null;
        BatchInput input = new BatchInput();
        input.withDocuments(null);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.endpoint());
        return service.detectLanguage(this.acceptLanguage(), input, parameterizedHost, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<LanguageBatchResult>>>() {
                @Override
                public Observable<ServiceResponse<LanguageBatchResult>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<LanguageBatchResult> clientResponse = detectLanguageDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * The API returns the detected language and a numeric score between 0 and 1.
     * Scores close to 1 indicate 100% certainty that the identified language is true. A total of 120 languages are supported.
     *
     * @param documents the List&lt;Input&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the LanguageBatchResult object if successful.
     */
    public LanguageBatchResult detectLanguage(List<Input> documents) {
        return detectLanguageWithServiceResponseAsync(documents).toBlocking().single().body();
    }

    /**
     * The API returns the detected language and a numeric score between 0 and 1.
     * Scores close to 1 indicate 100% certainty that the identified language is true. A total of 120 languages are supported.
     *
     * @param documents the List&lt;Input&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<LanguageBatchResult> detectLanguageAsync(List<Input> documents, final ServiceCallback<LanguageBatchResult> serviceCallback) {
        return ServiceFuture.fromResponse(detectLanguageWithServiceResponseAsync(documents), serviceCallback);
    }

    /**
     * The API returns the detected language and a numeric score between 0 and 1.
     * Scores close to 1 indicate 100% certainty that the identified language is true. A total of 120 languages are supported.
     *
     * @param documents the List&lt;Input&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the LanguageBatchResult object
     */
    public Observable<LanguageBatchResult> detectLanguageAsync(List<Input> documents) {
        return detectLanguageWithServiceResponseAsync(documents).map(new Func1<ServiceResponse<LanguageBatchResult>, LanguageBatchResult>() {
            @Override
            public LanguageBatchResult call(ServiceResponse<LanguageBatchResult> response) {
                return response.body();
            }
        });
    }

    /**
     * The API returns the detected language and a numeric score between 0 and 1.
     * Scores close to 1 indicate 100% certainty that the identified language is true. A total of 120 languages are supported.
     *
     * @param documents the List&lt;Input&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the LanguageBatchResult object
     */
    public Observable<ServiceResponse<LanguageBatchResult>> detectLanguageWithServiceResponseAsync(List<Input> documents) {
        if (this.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.endpoint() is required and cannot be null.");
        }
        Validator.validate(documents);
        BatchInput input = new BatchInput();
        input.withDocuments(documents);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.endpoint());
        return service.detectLanguage(this.acceptLanguage(), input, parameterizedHost, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<LanguageBatchResult>>>() {
                @Override
                public Observable<ServiceResponse<LanguageBatchResult>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<LanguageBatchResult> clientResponse = detectLanguageDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<LanguageBatchResult> detectLanguageDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<LanguageBatchResult, ErrorResponseException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<LanguageBatchResult>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * The API returns a numeric score between 0 and 1.
     * Scores close to 1 indicate positive sentiment, while scores close to 0 indicate negative sentiment. A score of 0.5 indicates the lack of sentiment (e.g. a factoid statement). See the &lt;a href="https://docs.microsoft.com/en-us/azure/cognitive-services/text-analytics/overview#supported-languages"&gt;Text Analytics Documentation&lt;/a&gt; for details about the languages that are supported by sentiment analysis.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SentimentBatchResult object if successful.
     */
    public SentimentBatchResult sentiment() {
        return sentimentWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * The API returns a numeric score between 0 and 1.
     * Scores close to 1 indicate positive sentiment, while scores close to 0 indicate negative sentiment. A score of 0.5 indicates the lack of sentiment (e.g. a factoid statement). See the &lt;a href="https://docs.microsoft.com/en-us/azure/cognitive-services/text-analytics/overview#supported-languages"&gt;Text Analytics Documentation&lt;/a&gt; for details about the languages that are supported by sentiment analysis.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SentimentBatchResult> sentimentAsync(final ServiceCallback<SentimentBatchResult> serviceCallback) {
        return ServiceFuture.fromResponse(sentimentWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * The API returns a numeric score between 0 and 1.
     * Scores close to 1 indicate positive sentiment, while scores close to 0 indicate negative sentiment. A score of 0.5 indicates the lack of sentiment (e.g. a factoid statement). See the &lt;a href="https://docs.microsoft.com/en-us/azure/cognitive-services/text-analytics/overview#supported-languages"&gt;Text Analytics Documentation&lt;/a&gt; for details about the languages that are supported by sentiment analysis.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SentimentBatchResult object
     */
    public Observable<SentimentBatchResult> sentimentAsync() {
        return sentimentWithServiceResponseAsync().map(new Func1<ServiceResponse<SentimentBatchResult>, SentimentBatchResult>() {
            @Override
            public SentimentBatchResult call(ServiceResponse<SentimentBatchResult> response) {
                return response.body();
            }
        });
    }

    /**
     * The API returns a numeric score between 0 and 1.
     * Scores close to 1 indicate positive sentiment, while scores close to 0 indicate negative sentiment. A score of 0.5 indicates the lack of sentiment (e.g. a factoid statement). See the &lt;a href="https://docs.microsoft.com/en-us/azure/cognitive-services/text-analytics/overview#supported-languages"&gt;Text Analytics Documentation&lt;/a&gt; for details about the languages that are supported by sentiment analysis.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SentimentBatchResult object
     */
    public Observable<ServiceResponse<SentimentBatchResult>> sentimentWithServiceResponseAsync() {
        if (this.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.endpoint() is required and cannot be null.");
        }
        final List<MultiLanguageInput> documents = null;
        MultiLanguageBatchInput input = new MultiLanguageBatchInput();
        input.withDocuments(null);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.endpoint());
        return service.sentiment(this.acceptLanguage(), input, parameterizedHost, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SentimentBatchResult>>>() {
                @Override
                public Observable<ServiceResponse<SentimentBatchResult>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SentimentBatchResult> clientResponse = sentimentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * The API returns a numeric score between 0 and 1.
     * Scores close to 1 indicate positive sentiment, while scores close to 0 indicate negative sentiment. A score of 0.5 indicates the lack of sentiment (e.g. a factoid statement). See the &lt;a href="https://docs.microsoft.com/en-us/azure/cognitive-services/text-analytics/overview#supported-languages"&gt;Text Analytics Documentation&lt;/a&gt; for details about the languages that are supported by sentiment analysis.
     *
     * @param documents the List&lt;MultiLanguageInput&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SentimentBatchResult object if successful.
     */
    public SentimentBatchResult sentiment(List<MultiLanguageInput> documents) {
        return sentimentWithServiceResponseAsync(documents).toBlocking().single().body();
    }

    /**
     * The API returns a numeric score between 0 and 1.
     * Scores close to 1 indicate positive sentiment, while scores close to 0 indicate negative sentiment. A score of 0.5 indicates the lack of sentiment (e.g. a factoid statement). See the &lt;a href="https://docs.microsoft.com/en-us/azure/cognitive-services/text-analytics/overview#supported-languages"&gt;Text Analytics Documentation&lt;/a&gt; for details about the languages that are supported by sentiment analysis.
     *
     * @param documents the List&lt;MultiLanguageInput&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SentimentBatchResult> sentimentAsync(List<MultiLanguageInput> documents, final ServiceCallback<SentimentBatchResult> serviceCallback) {
        return ServiceFuture.fromResponse(sentimentWithServiceResponseAsync(documents), serviceCallback);
    }

    /**
     * The API returns a numeric score between 0 and 1.
     * Scores close to 1 indicate positive sentiment, while scores close to 0 indicate negative sentiment. A score of 0.5 indicates the lack of sentiment (e.g. a factoid statement). See the &lt;a href="https://docs.microsoft.com/en-us/azure/cognitive-services/text-analytics/overview#supported-languages"&gt;Text Analytics Documentation&lt;/a&gt; for details about the languages that are supported by sentiment analysis.
     *
     * @param documents the List&lt;MultiLanguageInput&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SentimentBatchResult object
     */
    public Observable<SentimentBatchResult> sentimentAsync(List<MultiLanguageInput> documents) {
        return sentimentWithServiceResponseAsync(documents).map(new Func1<ServiceResponse<SentimentBatchResult>, SentimentBatchResult>() {
            @Override
            public SentimentBatchResult call(ServiceResponse<SentimentBatchResult> response) {
                return response.body();
            }
        });
    }

    /**
     * The API returns a numeric score between 0 and 1.
     * Scores close to 1 indicate positive sentiment, while scores close to 0 indicate negative sentiment. A score of 0.5 indicates the lack of sentiment (e.g. a factoid statement). See the &lt;a href="https://docs.microsoft.com/en-us/azure/cognitive-services/text-analytics/overview#supported-languages"&gt;Text Analytics Documentation&lt;/a&gt; for details about the languages that are supported by sentiment analysis.
     *
     * @param documents the List&lt;MultiLanguageInput&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SentimentBatchResult object
     */
    public Observable<ServiceResponse<SentimentBatchResult>> sentimentWithServiceResponseAsync(List<MultiLanguageInput> documents) {
        if (this.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.endpoint() is required and cannot be null.");
        }
        Validator.validate(documents);
        MultiLanguageBatchInput input = new MultiLanguageBatchInput();
        input.withDocuments(documents);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.endpoint());
        return service.sentiment(this.acceptLanguage(), input, parameterizedHost, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SentimentBatchResult>>>() {
                @Override
                public Observable<ServiceResponse<SentimentBatchResult>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SentimentBatchResult> clientResponse = sentimentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SentimentBatchResult> sentimentDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<SentimentBatchResult, ErrorResponseException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<SentimentBatchResult>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * The API returns a list of recognized entities in a given document.
     * The API returns a list of recognized entities in a given document. To get even more information on each recognized entity we recommend using the Bing Entity Search API by querying for the recognized entities names. See the &lt;a href="https://docs.microsoft.com/en-us/azure/cognitive-services/text-analytics/text-analytics-supported-languages"&gt;Supported languages in Text Analytics API&lt;/a&gt; for the list of enabled languages.The API returns a list of known entities and general named entities ("Person", "Location", "Organization" etc) in a given document. Known entities are returned with Wikipedia Id and Wikipedia link, and also Bing Id which can be used in Bing Entity Search API. General named entities are returned with entity types. If a general named entity is also a known entity, then all information regarding it (Wikipedia Id, Bing Id, entity type etc) will be returned. See the &lt;a href="https://docs.microsoft.com/en-us/azure/cognitive-services/text-analytics/how-tos/text-analytics-how-to-entity-linking#supported-types-for-named-entity-recognition"&gt;Supported Entity Types in Text Analytics API&lt;/a&gt; for the list of supported Entity Types. See the &lt;a href="https://docs.microsoft.com/en-us/azure/cognitive-services/text-analytics/text-analytics-supported-languages"&gt;Supported languages in Text Analytics API&lt;/a&gt; for the list of enabled languages.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the EntitiesBatchResult object if successful.
     */
    public EntitiesBatchResult entities() {
        return entitiesWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * The API returns a list of recognized entities in a given document.
     * The API returns a list of recognized entities in a given document. To get even more information on each recognized entity we recommend using the Bing Entity Search API by querying for the recognized entities names. See the &lt;a href="https://docs.microsoft.com/en-us/azure/cognitive-services/text-analytics/text-analytics-supported-languages"&gt;Supported languages in Text Analytics API&lt;/a&gt; for the list of enabled languages.The API returns a list of known entities and general named entities ("Person", "Location", "Organization" etc) in a given document. Known entities are returned with Wikipedia Id and Wikipedia link, and also Bing Id which can be used in Bing Entity Search API. General named entities are returned with entity types. If a general named entity is also a known entity, then all information regarding it (Wikipedia Id, Bing Id, entity type etc) will be returned. See the &lt;a href="https://docs.microsoft.com/en-us/azure/cognitive-services/text-analytics/how-tos/text-analytics-how-to-entity-linking#supported-types-for-named-entity-recognition"&gt;Supported Entity Types in Text Analytics API&lt;/a&gt; for the list of supported Entity Types. See the &lt;a href="https://docs.microsoft.com/en-us/azure/cognitive-services/text-analytics/text-analytics-supported-languages"&gt;Supported languages in Text Analytics API&lt;/a&gt; for the list of enabled languages.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<EntitiesBatchResult> entitiesAsync(final ServiceCallback<EntitiesBatchResult> serviceCallback) {
        return ServiceFuture.fromResponse(entitiesWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * The API returns a list of recognized entities in a given document.
     * The API returns a list of recognized entities in a given document. To get even more information on each recognized entity we recommend using the Bing Entity Search API by querying for the recognized entities names. See the &lt;a href="https://docs.microsoft.com/en-us/azure/cognitive-services/text-analytics/text-analytics-supported-languages"&gt;Supported languages in Text Analytics API&lt;/a&gt; for the list of enabled languages.The API returns a list of known entities and general named entities ("Person", "Location", "Organization" etc) in a given document. Known entities are returned with Wikipedia Id and Wikipedia link, and also Bing Id which can be used in Bing Entity Search API. General named entities are returned with entity types. If a general named entity is also a known entity, then all information regarding it (Wikipedia Id, Bing Id, entity type etc) will be returned. See the &lt;a href="https://docs.microsoft.com/en-us/azure/cognitive-services/text-analytics/how-tos/text-analytics-how-to-entity-linking#supported-types-for-named-entity-recognition"&gt;Supported Entity Types in Text Analytics API&lt;/a&gt; for the list of supported Entity Types. See the &lt;a href="https://docs.microsoft.com/en-us/azure/cognitive-services/text-analytics/text-analytics-supported-languages"&gt;Supported languages in Text Analytics API&lt;/a&gt; for the list of enabled languages.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EntitiesBatchResult object
     */
    public Observable<EntitiesBatchResult> entitiesAsync() {
        return entitiesWithServiceResponseAsync().map(new Func1<ServiceResponse<EntitiesBatchResult>, EntitiesBatchResult>() {
            @Override
            public EntitiesBatchResult call(ServiceResponse<EntitiesBatchResult> response) {
                return response.body();
            }
        });
    }

    /**
     * The API returns a list of recognized entities in a given document.
     * The API returns a list of recognized entities in a given document. To get even more information on each recognized entity we recommend using the Bing Entity Search API by querying for the recognized entities names. See the &lt;a href="https://docs.microsoft.com/en-us/azure/cognitive-services/text-analytics/text-analytics-supported-languages"&gt;Supported languages in Text Analytics API&lt;/a&gt; for the list of enabled languages.The API returns a list of known entities and general named entities ("Person", "Location", "Organization" etc) in a given document. Known entities are returned with Wikipedia Id and Wikipedia link, and also Bing Id which can be used in Bing Entity Search API. General named entities are returned with entity types. If a general named entity is also a known entity, then all information regarding it (Wikipedia Id, Bing Id, entity type etc) will be returned. See the &lt;a href="https://docs.microsoft.com/en-us/azure/cognitive-services/text-analytics/how-tos/text-analytics-how-to-entity-linking#supported-types-for-named-entity-recognition"&gt;Supported Entity Types in Text Analytics API&lt;/a&gt; for the list of supported Entity Types. See the &lt;a href="https://docs.microsoft.com/en-us/azure/cognitive-services/text-analytics/text-analytics-supported-languages"&gt;Supported languages in Text Analytics API&lt;/a&gt; for the list of enabled languages.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EntitiesBatchResult object
     */
    public Observable<ServiceResponse<EntitiesBatchResult>> entitiesWithServiceResponseAsync() {
        if (this.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.endpoint() is required and cannot be null.");
        }
        final List<MultiLanguageInput> documents = null;
        MultiLanguageBatchInput input = new MultiLanguageBatchInput();
        input.withDocuments(null);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.endpoint());
        return service.entities(this.acceptLanguage(), input, parameterizedHost, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<EntitiesBatchResult>>>() {
                @Override
                public Observable<ServiceResponse<EntitiesBatchResult>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<EntitiesBatchResult> clientResponse = entitiesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * The API returns a list of recognized entities in a given document.
     * The API returns a list of recognized entities in a given document. To get even more information on each recognized entity we recommend using the Bing Entity Search API by querying for the recognized entities names. See the &lt;a href="https://docs.microsoft.com/en-us/azure/cognitive-services/text-analytics/text-analytics-supported-languages"&gt;Supported languages in Text Analytics API&lt;/a&gt; for the list of enabled languages.The API returns a list of known entities and general named entities ("Person", "Location", "Organization" etc) in a given document. Known entities are returned with Wikipedia Id and Wikipedia link, and also Bing Id which can be used in Bing Entity Search API. General named entities are returned with entity types. If a general named entity is also a known entity, then all information regarding it (Wikipedia Id, Bing Id, entity type etc) will be returned. See the &lt;a href="https://docs.microsoft.com/en-us/azure/cognitive-services/text-analytics/how-tos/text-analytics-how-to-entity-linking#supported-types-for-named-entity-recognition"&gt;Supported Entity Types in Text Analytics API&lt;/a&gt; for the list of supported Entity Types. See the &lt;a href="https://docs.microsoft.com/en-us/azure/cognitive-services/text-analytics/text-analytics-supported-languages"&gt;Supported languages in Text Analytics API&lt;/a&gt; for the list of enabled languages.
     *
     * @param documents the List&lt;MultiLanguageInput&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the EntitiesBatchResult object if successful.
     */
    public EntitiesBatchResult entities(List<MultiLanguageInput> documents) {
        return entitiesWithServiceResponseAsync(documents).toBlocking().single().body();
    }

    /**
     * The API returns a list of recognized entities in a given document.
     * The API returns a list of recognized entities in a given document. To get even more information on each recognized entity we recommend using the Bing Entity Search API by querying for the recognized entities names. See the &lt;a href="https://docs.microsoft.com/en-us/azure/cognitive-services/text-analytics/text-analytics-supported-languages"&gt;Supported languages in Text Analytics API&lt;/a&gt; for the list of enabled languages.The API returns a list of known entities and general named entities ("Person", "Location", "Organization" etc) in a given document. Known entities are returned with Wikipedia Id and Wikipedia link, and also Bing Id which can be used in Bing Entity Search API. General named entities are returned with entity types. If a general named entity is also a known entity, then all information regarding it (Wikipedia Id, Bing Id, entity type etc) will be returned. See the &lt;a href="https://docs.microsoft.com/en-us/azure/cognitive-services/text-analytics/how-tos/text-analytics-how-to-entity-linking#supported-types-for-named-entity-recognition"&gt;Supported Entity Types in Text Analytics API&lt;/a&gt; for the list of supported Entity Types. See the &lt;a href="https://docs.microsoft.com/en-us/azure/cognitive-services/text-analytics/text-analytics-supported-languages"&gt;Supported languages in Text Analytics API&lt;/a&gt; for the list of enabled languages.
     *
     * @param documents the List&lt;MultiLanguageInput&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<EntitiesBatchResult> entitiesAsync(List<MultiLanguageInput> documents, final ServiceCallback<EntitiesBatchResult> serviceCallback) {
        return ServiceFuture.fromResponse(entitiesWithServiceResponseAsync(documents), serviceCallback);
    }

    /**
     * The API returns a list of recognized entities in a given document.
     * The API returns a list of recognized entities in a given document. To get even more information on each recognized entity we recommend using the Bing Entity Search API by querying for the recognized entities names. See the &lt;a href="https://docs.microsoft.com/en-us/azure/cognitive-services/text-analytics/text-analytics-supported-languages"&gt;Supported languages in Text Analytics API&lt;/a&gt; for the list of enabled languages.The API returns a list of known entities and general named entities ("Person", "Location", "Organization" etc) in a given document. Known entities are returned with Wikipedia Id and Wikipedia link, and also Bing Id which can be used in Bing Entity Search API. General named entities are returned with entity types. If a general named entity is also a known entity, then all information regarding it (Wikipedia Id, Bing Id, entity type etc) will be returned. See the &lt;a href="https://docs.microsoft.com/en-us/azure/cognitive-services/text-analytics/how-tos/text-analytics-how-to-entity-linking#supported-types-for-named-entity-recognition"&gt;Supported Entity Types in Text Analytics API&lt;/a&gt; for the list of supported Entity Types. See the &lt;a href="https://docs.microsoft.com/en-us/azure/cognitive-services/text-analytics/text-analytics-supported-languages"&gt;Supported languages in Text Analytics API&lt;/a&gt; for the list of enabled languages.
     *
     * @param documents the List&lt;MultiLanguageInput&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EntitiesBatchResult object
     */
    public Observable<EntitiesBatchResult> entitiesAsync(List<MultiLanguageInput> documents) {
        return entitiesWithServiceResponseAsync(documents).map(new Func1<ServiceResponse<EntitiesBatchResult>, EntitiesBatchResult>() {
            @Override
            public EntitiesBatchResult call(ServiceResponse<EntitiesBatchResult> response) {
                return response.body();
            }
        });
    }

    /**
     * The API returns a list of recognized entities in a given document.
     * The API returns a list of recognized entities in a given document. To get even more information on each recognized entity we recommend using the Bing Entity Search API by querying for the recognized entities names. See the &lt;a href="https://docs.microsoft.com/en-us/azure/cognitive-services/text-analytics/text-analytics-supported-languages"&gt;Supported languages in Text Analytics API&lt;/a&gt; for the list of enabled languages.The API returns a list of known entities and general named entities ("Person", "Location", "Organization" etc) in a given document. Known entities are returned with Wikipedia Id and Wikipedia link, and also Bing Id which can be used in Bing Entity Search API. General named entities are returned with entity types. If a general named entity is also a known entity, then all information regarding it (Wikipedia Id, Bing Id, entity type etc) will be returned. See the &lt;a href="https://docs.microsoft.com/en-us/azure/cognitive-services/text-analytics/how-tos/text-analytics-how-to-entity-linking#supported-types-for-named-entity-recognition"&gt;Supported Entity Types in Text Analytics API&lt;/a&gt; for the list of supported Entity Types. See the &lt;a href="https://docs.microsoft.com/en-us/azure/cognitive-services/text-analytics/text-analytics-supported-languages"&gt;Supported languages in Text Analytics API&lt;/a&gt; for the list of enabled languages.
     *
     * @param documents the List&lt;MultiLanguageInput&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EntitiesBatchResult object
     */
    public Observable<ServiceResponse<EntitiesBatchResult>> entitiesWithServiceResponseAsync(List<MultiLanguageInput> documents) {
        if (this.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.endpoint() is required and cannot be null.");
        }
        Validator.validate(documents);
        MultiLanguageBatchInput input = new MultiLanguageBatchInput();
        input.withDocuments(documents);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.endpoint());
        return service.entities(this.acceptLanguage(), input, parameterizedHost, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<EntitiesBatchResult>>>() {
                @Override
                public Observable<ServiceResponse<EntitiesBatchResult>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<EntitiesBatchResult> clientResponse = entitiesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<EntitiesBatchResult> entitiesDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<EntitiesBatchResult, ErrorResponseException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<EntitiesBatchResult>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

}
