/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.cognitiveservices.vision.faceapi.implementation;

import retrofit2.Retrofit;
import com.microsoft.azure.cognitiveservices.vision.faceapi.Snapshots;
import com.google.common.base.Joiner;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.cognitiveservices.vision.faceapi.models.APIErrorException;
import com.microsoft.azure.cognitiveservices.vision.faceapi.models.ApplySnapshotRequest;
import com.microsoft.azure.cognitiveservices.vision.faceapi.models.OperationStatus;
import com.microsoft.azure.cognitiveservices.vision.faceapi.models.Snapshot;
import com.microsoft.azure.cognitiveservices.vision.faceapi.models.SnapshotApplyHeaders;
import com.microsoft.azure.cognitiveservices.vision.faceapi.models.SnapshotApplyMode;
import com.microsoft.azure.cognitiveservices.vision.faceapi.models.SnapshotObjectType;
import com.microsoft.azure.cognitiveservices.vision.faceapi.models.SnapshotTakeHeaders;
import com.microsoft.azure.cognitiveservices.vision.faceapi.models.TakeSnapshotRequest;
import com.microsoft.azure.cognitiveservices.vision.faceapi.models.UpdateSnapshotRequest;
import com.microsoft.rest.CollectionFormat;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.ServiceResponseWithHeaders;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.List;
import java.util.UUID;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.PATCH;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in Snapshots.
 */
public class SnapshotsImpl implements Snapshots {
    /** The Retrofit service to perform REST calls. */
    private SnapshotsService service;
    /** The service client containing this operation class. */
    private FaceClientImpl client;

    /**
     * Initializes an instance of SnapshotsImpl.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public SnapshotsImpl(Retrofit retrofit, FaceClientImpl client) {
        this.service = retrofit.create(SnapshotsService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for Snapshots to be
     * used by Retrofit to perform actually REST calls.
     */
    interface SnapshotsService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.faceapi.Snapshots take" })
        @POST("snapshots")
        Observable<Response<ResponseBody>> take(@Header("accept-language") String acceptLanguage, @Body TakeSnapshotRequest body, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.faceapi.Snapshots list" })
        @GET("snapshots")
        Observable<Response<ResponseBody>> list(@Query("type") SnapshotObjectType type, @Query("applyScope") String applyScope, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.faceapi.Snapshots get" })
        @GET("snapshots/{snapshotId}")
        Observable<Response<ResponseBody>> get(@Path("snapshotId") UUID snapshotId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.faceapi.Snapshots update" })
        @PATCH("snapshots/{snapshotId}")
        Observable<Response<ResponseBody>> update(@Path("snapshotId") UUID snapshotId, @Header("accept-language") String acceptLanguage, @Body UpdateSnapshotRequest body, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.faceapi.Snapshots delete" })
        @HTTP(path = "snapshots/{snapshotId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> delete(@Path("snapshotId") UUID snapshotId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.faceapi.Snapshots apply" })
        @POST("snapshots/{snapshotId}/apply")
        Observable<Response<ResponseBody>> apply(@Path("snapshotId") UUID snapshotId, @Header("accept-language") String acceptLanguage, @Body ApplySnapshotRequest body, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.faceapi.Snapshots getOperationStatus" })
        @GET("operations/{operationId}")
        Observable<Response<ResponseBody>> getOperationStatus(@Path("operationId") UUID operationId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

    }

    /**
     * Submit an operation to take a snapshot of face list, large face list, person group or large person group, with user-specified snapshot type, source object id, apply scope and an optional user data.&lt;br /&gt;
     The snapshot interfaces are for users to backup and restore their face data from one face subscription to another, inside same region or across regions. The workflow contains two phases, user first calls Snapshot - Take to create a copy of the source object and store it as a snapshot, then calls Snapshot - Apply to paste the snapshot to target subscription. The snapshots are stored in a centralized location (per Azure instance), so that they can be applied cross accounts and regions.&lt;br /&gt;
     Taking snapshot is an asynchronous operation. An operation id can be obtained from the "Operation-Location" field in response header, to be used in OperationStatus - Get for tracking the progress of creating the snapshot. The snapshot id will be included in the "resourceLocation" field in OperationStatus - Get response when the operation status is "succeeded".&lt;br /&gt;
     Snapshot taking time depends on the number of person and face entries in the source object. It could be in seconds, or up to several hours for 1,000,000 persons with multiple faces.&lt;br /&gt;
     Snapshots will be automatically expired and cleaned in 48 hours after it is created by Snapshot - Take. User can delete the snapshot using Snapshot - Delete by themselves any time before expiration.&lt;br /&gt;
     Taking snapshot for a certain object will not block any other operations against the object. All read-only operations (Get/List and Identify/FindSimilar/Verify) can be conducted as usual. For all writable operations, including Add/Update/Delete the source object or its persons/faces and Train, they are not blocked but not recommended because writable updates may not be reflected on the snapshot during its taking. After snapshot taking is completed, all readable and writable operations can work as normal. Snapshot will also include the training results of the source object, which means target subscription the snapshot applied to does not need re-train the target object before calling Identify/FindSimilar.&lt;br /&gt;
     * Free-tier subscription quota: 100 take operations per month.
     * S0-tier subscription quota: 100 take operations per day.
     *
     * @param type User specified type for the source object to take snapshot from. Currently FaceList, PersonGroup, LargeFaceList and LargePersonGroup are supported. Possible values include: 'FaceList', 'LargeFaceList', 'LargePersonGroup', 'PersonGroup'
     * @param objectId User specified source object id to take snapshot from.
     * @param applyScope User specified array of target Face subscription ids for the snapshot. For each snapshot, only subscriptions included in the applyScope of Snapshot - Take can apply it.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void take(SnapshotObjectType type, String objectId, List<UUID> applyScope) {
        takeWithServiceResponseAsync(type, objectId, applyScope).toBlocking().single().body();
    }

    /**
     * Submit an operation to take a snapshot of face list, large face list, person group or large person group, with user-specified snapshot type, source object id, apply scope and an optional user data.&lt;br /&gt;
     The snapshot interfaces are for users to backup and restore their face data from one face subscription to another, inside same region or across regions. The workflow contains two phases, user first calls Snapshot - Take to create a copy of the source object and store it as a snapshot, then calls Snapshot - Apply to paste the snapshot to target subscription. The snapshots are stored in a centralized location (per Azure instance), so that they can be applied cross accounts and regions.&lt;br /&gt;
     Taking snapshot is an asynchronous operation. An operation id can be obtained from the "Operation-Location" field in response header, to be used in OperationStatus - Get for tracking the progress of creating the snapshot. The snapshot id will be included in the "resourceLocation" field in OperationStatus - Get response when the operation status is "succeeded".&lt;br /&gt;
     Snapshot taking time depends on the number of person and face entries in the source object. It could be in seconds, or up to several hours for 1,000,000 persons with multiple faces.&lt;br /&gt;
     Snapshots will be automatically expired and cleaned in 48 hours after it is created by Snapshot - Take. User can delete the snapshot using Snapshot - Delete by themselves any time before expiration.&lt;br /&gt;
     Taking snapshot for a certain object will not block any other operations against the object. All read-only operations (Get/List and Identify/FindSimilar/Verify) can be conducted as usual. For all writable operations, including Add/Update/Delete the source object or its persons/faces and Train, they are not blocked but not recommended because writable updates may not be reflected on the snapshot during its taking. After snapshot taking is completed, all readable and writable operations can work as normal. Snapshot will also include the training results of the source object, which means target subscription the snapshot applied to does not need re-train the target object before calling Identify/FindSimilar.&lt;br /&gt;
     * Free-tier subscription quota: 100 take operations per month.
     * S0-tier subscription quota: 100 take operations per day.
     *
     * @param type User specified type for the source object to take snapshot from. Currently FaceList, PersonGroup, LargeFaceList and LargePersonGroup are supported. Possible values include: 'FaceList', 'LargeFaceList', 'LargePersonGroup', 'PersonGroup'
     * @param objectId User specified source object id to take snapshot from.
     * @param applyScope User specified array of target Face subscription ids for the snapshot. For each snapshot, only subscriptions included in the applyScope of Snapshot - Take can apply it.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> takeAsync(SnapshotObjectType type, String objectId, List<UUID> applyScope, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(takeWithServiceResponseAsync(type, objectId, applyScope), serviceCallback);
    }

    /**
     * Submit an operation to take a snapshot of face list, large face list, person group or large person group, with user-specified snapshot type, source object id, apply scope and an optional user data.&lt;br /&gt;
     The snapshot interfaces are for users to backup and restore their face data from one face subscription to another, inside same region or across regions. The workflow contains two phases, user first calls Snapshot - Take to create a copy of the source object and store it as a snapshot, then calls Snapshot - Apply to paste the snapshot to target subscription. The snapshots are stored in a centralized location (per Azure instance), so that they can be applied cross accounts and regions.&lt;br /&gt;
     Taking snapshot is an asynchronous operation. An operation id can be obtained from the "Operation-Location" field in response header, to be used in OperationStatus - Get for tracking the progress of creating the snapshot. The snapshot id will be included in the "resourceLocation" field in OperationStatus - Get response when the operation status is "succeeded".&lt;br /&gt;
     Snapshot taking time depends on the number of person and face entries in the source object. It could be in seconds, or up to several hours for 1,000,000 persons with multiple faces.&lt;br /&gt;
     Snapshots will be automatically expired and cleaned in 48 hours after it is created by Snapshot - Take. User can delete the snapshot using Snapshot - Delete by themselves any time before expiration.&lt;br /&gt;
     Taking snapshot for a certain object will not block any other operations against the object. All read-only operations (Get/List and Identify/FindSimilar/Verify) can be conducted as usual. For all writable operations, including Add/Update/Delete the source object or its persons/faces and Train, they are not blocked but not recommended because writable updates may not be reflected on the snapshot during its taking. After snapshot taking is completed, all readable and writable operations can work as normal. Snapshot will also include the training results of the source object, which means target subscription the snapshot applied to does not need re-train the target object before calling Identify/FindSimilar.&lt;br /&gt;
     * Free-tier subscription quota: 100 take operations per month.
     * S0-tier subscription quota: 100 take operations per day.
     *
     * @param type User specified type for the source object to take snapshot from. Currently FaceList, PersonGroup, LargeFaceList and LargePersonGroup are supported. Possible values include: 'FaceList', 'LargeFaceList', 'LargePersonGroup', 'PersonGroup'
     * @param objectId User specified source object id to take snapshot from.
     * @param applyScope User specified array of target Face subscription ids for the snapshot. For each snapshot, only subscriptions included in the applyScope of Snapshot - Take can apply it.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<Void> takeAsync(SnapshotObjectType type, String objectId, List<UUID> applyScope) {
        return takeWithServiceResponseAsync(type, objectId, applyScope).map(new Func1<ServiceResponseWithHeaders<Void, SnapshotTakeHeaders>, Void>() {
            @Override
            public Void call(ServiceResponseWithHeaders<Void, SnapshotTakeHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Submit an operation to take a snapshot of face list, large face list, person group or large person group, with user-specified snapshot type, source object id, apply scope and an optional user data.&lt;br /&gt;
     The snapshot interfaces are for users to backup and restore their face data from one face subscription to another, inside same region or across regions. The workflow contains two phases, user first calls Snapshot - Take to create a copy of the source object and store it as a snapshot, then calls Snapshot - Apply to paste the snapshot to target subscription. The snapshots are stored in a centralized location (per Azure instance), so that they can be applied cross accounts and regions.&lt;br /&gt;
     Taking snapshot is an asynchronous operation. An operation id can be obtained from the "Operation-Location" field in response header, to be used in OperationStatus - Get for tracking the progress of creating the snapshot. The snapshot id will be included in the "resourceLocation" field in OperationStatus - Get response when the operation status is "succeeded".&lt;br /&gt;
     Snapshot taking time depends on the number of person and face entries in the source object. It could be in seconds, or up to several hours for 1,000,000 persons with multiple faces.&lt;br /&gt;
     Snapshots will be automatically expired and cleaned in 48 hours after it is created by Snapshot - Take. User can delete the snapshot using Snapshot - Delete by themselves any time before expiration.&lt;br /&gt;
     Taking snapshot for a certain object will not block any other operations against the object. All read-only operations (Get/List and Identify/FindSimilar/Verify) can be conducted as usual. For all writable operations, including Add/Update/Delete the source object or its persons/faces and Train, they are not blocked but not recommended because writable updates may not be reflected on the snapshot during its taking. After snapshot taking is completed, all readable and writable operations can work as normal. Snapshot will also include the training results of the source object, which means target subscription the snapshot applied to does not need re-train the target object before calling Identify/FindSimilar.&lt;br /&gt;
     * Free-tier subscription quota: 100 take operations per month.
     * S0-tier subscription quota: 100 take operations per day.
     *
     * @param type User specified type for the source object to take snapshot from. Currently FaceList, PersonGroup, LargeFaceList and LargePersonGroup are supported. Possible values include: 'FaceList', 'LargeFaceList', 'LargePersonGroup', 'PersonGroup'
     * @param objectId User specified source object id to take snapshot from.
     * @param applyScope User specified array of target Face subscription ids for the snapshot. For each snapshot, only subscriptions included in the applyScope of Snapshot - Take can apply it.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<ServiceResponseWithHeaders<Void, SnapshotTakeHeaders>> takeWithServiceResponseAsync(SnapshotObjectType type, String objectId, List<UUID> applyScope) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (type == null) {
            throw new IllegalArgumentException("Parameter type is required and cannot be null.");
        }
        if (objectId == null) {
            throw new IllegalArgumentException("Parameter objectId is required and cannot be null.");
        }
        if (applyScope == null) {
            throw new IllegalArgumentException("Parameter applyScope is required and cannot be null.");
        }
        Validator.validate(applyScope);
        final String userData = null;
        TakeSnapshotRequest body = new TakeSnapshotRequest();
        body.withType(type);
        body.withObjectId(objectId);
        body.withApplyScope(applyScope);
        body.withUserData(null);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.take(this.client.acceptLanguage(), body, parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Void, SnapshotTakeHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Void, SnapshotTakeHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Void, SnapshotTakeHeaders> clientResponse = takeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Submit an operation to take a snapshot of face list, large face list, person group or large person group, with user-specified snapshot type, source object id, apply scope and an optional user data.&lt;br /&gt;
     The snapshot interfaces are for users to backup and restore their face data from one face subscription to another, inside same region or across regions. The workflow contains two phases, user first calls Snapshot - Take to create a copy of the source object and store it as a snapshot, then calls Snapshot - Apply to paste the snapshot to target subscription. The snapshots are stored in a centralized location (per Azure instance), so that they can be applied cross accounts and regions.&lt;br /&gt;
     Taking snapshot is an asynchronous operation. An operation id can be obtained from the "Operation-Location" field in response header, to be used in OperationStatus - Get for tracking the progress of creating the snapshot. The snapshot id will be included in the "resourceLocation" field in OperationStatus - Get response when the operation status is "succeeded".&lt;br /&gt;
     Snapshot taking time depends on the number of person and face entries in the source object. It could be in seconds, or up to several hours for 1,000,000 persons with multiple faces.&lt;br /&gt;
     Snapshots will be automatically expired and cleaned in 48 hours after it is created by Snapshot - Take. User can delete the snapshot using Snapshot - Delete by themselves any time before expiration.&lt;br /&gt;
     Taking snapshot for a certain object will not block any other operations against the object. All read-only operations (Get/List and Identify/FindSimilar/Verify) can be conducted as usual. For all writable operations, including Add/Update/Delete the source object or its persons/faces and Train, they are not blocked but not recommended because writable updates may not be reflected on the snapshot during its taking. After snapshot taking is completed, all readable and writable operations can work as normal. Snapshot will also include the training results of the source object, which means target subscription the snapshot applied to does not need re-train the target object before calling Identify/FindSimilar.&lt;br /&gt;
     * Free-tier subscription quota: 100 take operations per month.
     * S0-tier subscription quota: 100 take operations per day.
     *
     * @param type User specified type for the source object to take snapshot from. Currently FaceList, PersonGroup, LargeFaceList and LargePersonGroup are supported. Possible values include: 'FaceList', 'LargeFaceList', 'LargePersonGroup', 'PersonGroup'
     * @param objectId User specified source object id to take snapshot from.
     * @param applyScope User specified array of target Face subscription ids for the snapshot. For each snapshot, only subscriptions included in the applyScope of Snapshot - Take can apply it.
     * @param userData User specified data about the snapshot for any purpose. Length should not exceed 16KB.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void take(SnapshotObjectType type, String objectId, List<UUID> applyScope, String userData) {
        takeWithServiceResponseAsync(type, objectId, applyScope, userData).toBlocking().single().body();
    }

    /**
     * Submit an operation to take a snapshot of face list, large face list, person group or large person group, with user-specified snapshot type, source object id, apply scope and an optional user data.&lt;br /&gt;
     The snapshot interfaces are for users to backup and restore their face data from one face subscription to another, inside same region or across regions. The workflow contains two phases, user first calls Snapshot - Take to create a copy of the source object and store it as a snapshot, then calls Snapshot - Apply to paste the snapshot to target subscription. The snapshots are stored in a centralized location (per Azure instance), so that they can be applied cross accounts and regions.&lt;br /&gt;
     Taking snapshot is an asynchronous operation. An operation id can be obtained from the "Operation-Location" field in response header, to be used in OperationStatus - Get for tracking the progress of creating the snapshot. The snapshot id will be included in the "resourceLocation" field in OperationStatus - Get response when the operation status is "succeeded".&lt;br /&gt;
     Snapshot taking time depends on the number of person and face entries in the source object. It could be in seconds, or up to several hours for 1,000,000 persons with multiple faces.&lt;br /&gt;
     Snapshots will be automatically expired and cleaned in 48 hours after it is created by Snapshot - Take. User can delete the snapshot using Snapshot - Delete by themselves any time before expiration.&lt;br /&gt;
     Taking snapshot for a certain object will not block any other operations against the object. All read-only operations (Get/List and Identify/FindSimilar/Verify) can be conducted as usual. For all writable operations, including Add/Update/Delete the source object or its persons/faces and Train, they are not blocked but not recommended because writable updates may not be reflected on the snapshot during its taking. After snapshot taking is completed, all readable and writable operations can work as normal. Snapshot will also include the training results of the source object, which means target subscription the snapshot applied to does not need re-train the target object before calling Identify/FindSimilar.&lt;br /&gt;
     * Free-tier subscription quota: 100 take operations per month.
     * S0-tier subscription quota: 100 take operations per day.
     *
     * @param type User specified type for the source object to take snapshot from. Currently FaceList, PersonGroup, LargeFaceList and LargePersonGroup are supported. Possible values include: 'FaceList', 'LargeFaceList', 'LargePersonGroup', 'PersonGroup'
     * @param objectId User specified source object id to take snapshot from.
     * @param applyScope User specified array of target Face subscription ids for the snapshot. For each snapshot, only subscriptions included in the applyScope of Snapshot - Take can apply it.
     * @param userData User specified data about the snapshot for any purpose. Length should not exceed 16KB.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> takeAsync(SnapshotObjectType type, String objectId, List<UUID> applyScope, String userData, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(takeWithServiceResponseAsync(type, objectId, applyScope, userData), serviceCallback);
    }

    /**
     * Submit an operation to take a snapshot of face list, large face list, person group or large person group, with user-specified snapshot type, source object id, apply scope and an optional user data.&lt;br /&gt;
     The snapshot interfaces are for users to backup and restore their face data from one face subscription to another, inside same region or across regions. The workflow contains two phases, user first calls Snapshot - Take to create a copy of the source object and store it as a snapshot, then calls Snapshot - Apply to paste the snapshot to target subscription. The snapshots are stored in a centralized location (per Azure instance), so that they can be applied cross accounts and regions.&lt;br /&gt;
     Taking snapshot is an asynchronous operation. An operation id can be obtained from the "Operation-Location" field in response header, to be used in OperationStatus - Get for tracking the progress of creating the snapshot. The snapshot id will be included in the "resourceLocation" field in OperationStatus - Get response when the operation status is "succeeded".&lt;br /&gt;
     Snapshot taking time depends on the number of person and face entries in the source object. It could be in seconds, or up to several hours for 1,000,000 persons with multiple faces.&lt;br /&gt;
     Snapshots will be automatically expired and cleaned in 48 hours after it is created by Snapshot - Take. User can delete the snapshot using Snapshot - Delete by themselves any time before expiration.&lt;br /&gt;
     Taking snapshot for a certain object will not block any other operations against the object. All read-only operations (Get/List and Identify/FindSimilar/Verify) can be conducted as usual. For all writable operations, including Add/Update/Delete the source object or its persons/faces and Train, they are not blocked but not recommended because writable updates may not be reflected on the snapshot during its taking. After snapshot taking is completed, all readable and writable operations can work as normal. Snapshot will also include the training results of the source object, which means target subscription the snapshot applied to does not need re-train the target object before calling Identify/FindSimilar.&lt;br /&gt;
     * Free-tier subscription quota: 100 take operations per month.
     * S0-tier subscription quota: 100 take operations per day.
     *
     * @param type User specified type for the source object to take snapshot from. Currently FaceList, PersonGroup, LargeFaceList and LargePersonGroup are supported. Possible values include: 'FaceList', 'LargeFaceList', 'LargePersonGroup', 'PersonGroup'
     * @param objectId User specified source object id to take snapshot from.
     * @param applyScope User specified array of target Face subscription ids for the snapshot. For each snapshot, only subscriptions included in the applyScope of Snapshot - Take can apply it.
     * @param userData User specified data about the snapshot for any purpose. Length should not exceed 16KB.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<Void> takeAsync(SnapshotObjectType type, String objectId, List<UUID> applyScope, String userData) {
        return takeWithServiceResponseAsync(type, objectId, applyScope, userData).map(new Func1<ServiceResponseWithHeaders<Void, SnapshotTakeHeaders>, Void>() {
            @Override
            public Void call(ServiceResponseWithHeaders<Void, SnapshotTakeHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Submit an operation to take a snapshot of face list, large face list, person group or large person group, with user-specified snapshot type, source object id, apply scope and an optional user data.&lt;br /&gt;
     The snapshot interfaces are for users to backup and restore their face data from one face subscription to another, inside same region or across regions. The workflow contains two phases, user first calls Snapshot - Take to create a copy of the source object and store it as a snapshot, then calls Snapshot - Apply to paste the snapshot to target subscription. The snapshots are stored in a centralized location (per Azure instance), so that they can be applied cross accounts and regions.&lt;br /&gt;
     Taking snapshot is an asynchronous operation. An operation id can be obtained from the "Operation-Location" field in response header, to be used in OperationStatus - Get for tracking the progress of creating the snapshot. The snapshot id will be included in the "resourceLocation" field in OperationStatus - Get response when the operation status is "succeeded".&lt;br /&gt;
     Snapshot taking time depends on the number of person and face entries in the source object. It could be in seconds, or up to several hours for 1,000,000 persons with multiple faces.&lt;br /&gt;
     Snapshots will be automatically expired and cleaned in 48 hours after it is created by Snapshot - Take. User can delete the snapshot using Snapshot - Delete by themselves any time before expiration.&lt;br /&gt;
     Taking snapshot for a certain object will not block any other operations against the object. All read-only operations (Get/List and Identify/FindSimilar/Verify) can be conducted as usual. For all writable operations, including Add/Update/Delete the source object or its persons/faces and Train, they are not blocked but not recommended because writable updates may not be reflected on the snapshot during its taking. After snapshot taking is completed, all readable and writable operations can work as normal. Snapshot will also include the training results of the source object, which means target subscription the snapshot applied to does not need re-train the target object before calling Identify/FindSimilar.&lt;br /&gt;
     * Free-tier subscription quota: 100 take operations per month.
     * S0-tier subscription quota: 100 take operations per day.
     *
     * @param type User specified type for the source object to take snapshot from. Currently FaceList, PersonGroup, LargeFaceList and LargePersonGroup are supported. Possible values include: 'FaceList', 'LargeFaceList', 'LargePersonGroup', 'PersonGroup'
     * @param objectId User specified source object id to take snapshot from.
     * @param applyScope User specified array of target Face subscription ids for the snapshot. For each snapshot, only subscriptions included in the applyScope of Snapshot - Take can apply it.
     * @param userData User specified data about the snapshot for any purpose. Length should not exceed 16KB.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<ServiceResponseWithHeaders<Void, SnapshotTakeHeaders>> takeWithServiceResponseAsync(SnapshotObjectType type, String objectId, List<UUID> applyScope, String userData) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (type == null) {
            throw new IllegalArgumentException("Parameter type is required and cannot be null.");
        }
        if (objectId == null) {
            throw new IllegalArgumentException("Parameter objectId is required and cannot be null.");
        }
        if (applyScope == null) {
            throw new IllegalArgumentException("Parameter applyScope is required and cannot be null.");
        }
        Validator.validate(applyScope);
        TakeSnapshotRequest body = new TakeSnapshotRequest();
        body.withType(type);
        body.withObjectId(objectId);
        body.withApplyScope(applyScope);
        body.withUserData(userData);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.take(this.client.acceptLanguage(), body, parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Void, SnapshotTakeHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Void, SnapshotTakeHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Void, SnapshotTakeHeaders> clientResponse = takeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Void, SnapshotTakeHeaders> takeDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(APIErrorException.class)
                .buildWithHeaders(response, SnapshotTakeHeaders.class);
    }

    /**
     * List all accessible snapshots with related information, including snapshots that were taken by the user, or snapshots to be applied to the user (subscription id was included in the applyScope in Snapshot - Take).
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Snapshot&gt; object if successful.
     */
    public List<Snapshot> list() {
        return listWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * List all accessible snapshots with related information, including snapshots that were taken by the user, or snapshots to be applied to the user (subscription id was included in the applyScope in Snapshot - Take).
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Snapshot>> listAsync(final ServiceCallback<List<Snapshot>> serviceCallback) {
        return ServiceFuture.fromResponse(listWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * List all accessible snapshots with related information, including snapshots that were taken by the user, or snapshots to be applied to the user (subscription id was included in the applyScope in Snapshot - Take).
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Snapshot&gt; object
     */
    public Observable<List<Snapshot>> listAsync() {
        return listWithServiceResponseAsync().map(new Func1<ServiceResponse<List<Snapshot>>, List<Snapshot>>() {
            @Override
            public List<Snapshot> call(ServiceResponse<List<Snapshot>> response) {
                return response.body();
            }
        });
    }

    /**
     * List all accessible snapshots with related information, including snapshots that were taken by the user, or snapshots to be applied to the user (subscription id was included in the applyScope in Snapshot - Take).
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Snapshot&gt; object
     */
    public Observable<ServiceResponse<List<Snapshot>>> listWithServiceResponseAsync() {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        final SnapshotObjectType type = null;
        final List<UUID> applyScope = null;
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        String applyScopeConverted = this.client.serializerAdapter().serializeList(applyScope, CollectionFormat.CSV);
        return service.list(type, applyScopeConverted, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Snapshot>>>>() {
                @Override
                public Observable<ServiceResponse<List<Snapshot>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Snapshot>> clientResponse = listDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * List all accessible snapshots with related information, including snapshots that were taken by the user, or snapshots to be applied to the user (subscription id was included in the applyScope in Snapshot - Take).
     *
     * @param type User specified object type as a search filter. Possible values include: 'FaceList', 'LargeFaceList', 'LargePersonGroup', 'PersonGroup'
     * @param applyScope User specified snapshot apply scopes as a search filter. ApplyScope is an array of the target Azure subscription ids for the snapshot, specified by the user who created the snapshot by Snapshot - Take.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Snapshot&gt; object if successful.
     */
    public List<Snapshot> list(SnapshotObjectType type, List<UUID> applyScope) {
        return listWithServiceResponseAsync(type, applyScope).toBlocking().single().body();
    }

    /**
     * List all accessible snapshots with related information, including snapshots that were taken by the user, or snapshots to be applied to the user (subscription id was included in the applyScope in Snapshot - Take).
     *
     * @param type User specified object type as a search filter. Possible values include: 'FaceList', 'LargeFaceList', 'LargePersonGroup', 'PersonGroup'
     * @param applyScope User specified snapshot apply scopes as a search filter. ApplyScope is an array of the target Azure subscription ids for the snapshot, specified by the user who created the snapshot by Snapshot - Take.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Snapshot>> listAsync(SnapshotObjectType type, List<UUID> applyScope, final ServiceCallback<List<Snapshot>> serviceCallback) {
        return ServiceFuture.fromResponse(listWithServiceResponseAsync(type, applyScope), serviceCallback);
    }

    /**
     * List all accessible snapshots with related information, including snapshots that were taken by the user, or snapshots to be applied to the user (subscription id was included in the applyScope in Snapshot - Take).
     *
     * @param type User specified object type as a search filter. Possible values include: 'FaceList', 'LargeFaceList', 'LargePersonGroup', 'PersonGroup'
     * @param applyScope User specified snapshot apply scopes as a search filter. ApplyScope is an array of the target Azure subscription ids for the snapshot, specified by the user who created the snapshot by Snapshot - Take.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Snapshot&gt; object
     */
    public Observable<List<Snapshot>> listAsync(SnapshotObjectType type, List<UUID> applyScope) {
        return listWithServiceResponseAsync(type, applyScope).map(new Func1<ServiceResponse<List<Snapshot>>, List<Snapshot>>() {
            @Override
            public List<Snapshot> call(ServiceResponse<List<Snapshot>> response) {
                return response.body();
            }
        });
    }

    /**
     * List all accessible snapshots with related information, including snapshots that were taken by the user, or snapshots to be applied to the user (subscription id was included in the applyScope in Snapshot - Take).
     *
     * @param type User specified object type as a search filter. Possible values include: 'FaceList', 'LargeFaceList', 'LargePersonGroup', 'PersonGroup'
     * @param applyScope User specified snapshot apply scopes as a search filter. ApplyScope is an array of the target Azure subscription ids for the snapshot, specified by the user who created the snapshot by Snapshot - Take.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Snapshot&gt; object
     */
    public Observable<ServiceResponse<List<Snapshot>>> listWithServiceResponseAsync(SnapshotObjectType type, List<UUID> applyScope) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        Validator.validate(applyScope);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        String applyScopeConverted = this.client.serializerAdapter().serializeList(applyScope, CollectionFormat.CSV);
        return service.list(type, applyScopeConverted, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Snapshot>>>>() {
                @Override
                public Observable<ServiceResponse<List<Snapshot>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Snapshot>> clientResponse = listDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Snapshot>> listDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<Snapshot>, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<Snapshot>>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }

    /**
     * Retrieve information about a snapshot. Snapshot is only accessible to the source subscription who took it, and target subscriptions included in the applyScope in Snapshot - Take.
     *
     * @param snapshotId Id referencing a particular snapshot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Snapshot object if successful.
     */
    public Snapshot get(UUID snapshotId) {
        return getWithServiceResponseAsync(snapshotId).toBlocking().single().body();
    }

    /**
     * Retrieve information about a snapshot. Snapshot is only accessible to the source subscription who took it, and target subscriptions included in the applyScope in Snapshot - Take.
     *
     * @param snapshotId Id referencing a particular snapshot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Snapshot> getAsync(UUID snapshotId, final ServiceCallback<Snapshot> serviceCallback) {
        return ServiceFuture.fromResponse(getWithServiceResponseAsync(snapshotId), serviceCallback);
    }

    /**
     * Retrieve information about a snapshot. Snapshot is only accessible to the source subscription who took it, and target subscriptions included in the applyScope in Snapshot - Take.
     *
     * @param snapshotId Id referencing a particular snapshot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Snapshot object
     */
    public Observable<Snapshot> getAsync(UUID snapshotId) {
        return getWithServiceResponseAsync(snapshotId).map(new Func1<ServiceResponse<Snapshot>, Snapshot>() {
            @Override
            public Snapshot call(ServiceResponse<Snapshot> response) {
                return response.body();
            }
        });
    }

    /**
     * Retrieve information about a snapshot. Snapshot is only accessible to the source subscription who took it, and target subscriptions included in the applyScope in Snapshot - Take.
     *
     * @param snapshotId Id referencing a particular snapshot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Snapshot object
     */
    public Observable<ServiceResponse<Snapshot>> getWithServiceResponseAsync(UUID snapshotId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (snapshotId == null) {
            throw new IllegalArgumentException("Parameter snapshotId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.get(snapshotId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Snapshot>>>() {
                @Override
                public Observable<ServiceResponse<Snapshot>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Snapshot> clientResponse = getDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Snapshot> getDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Snapshot, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Snapshot>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }

    /**
     * Update the information of a snapshot. Only the source subscription who took the snapshot can update the snapshot.
     *
     * @param snapshotId Id referencing a particular snapshot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void update(UUID snapshotId) {
        updateWithServiceResponseAsync(snapshotId).toBlocking().single().body();
    }

    /**
     * Update the information of a snapshot. Only the source subscription who took the snapshot can update the snapshot.
     *
     * @param snapshotId Id referencing a particular snapshot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> updateAsync(UUID snapshotId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(updateWithServiceResponseAsync(snapshotId), serviceCallback);
    }

    /**
     * Update the information of a snapshot. Only the source subscription who took the snapshot can update the snapshot.
     *
     * @param snapshotId Id referencing a particular snapshot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> updateAsync(UUID snapshotId) {
        return updateWithServiceResponseAsync(snapshotId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Update the information of a snapshot. Only the source subscription who took the snapshot can update the snapshot.
     *
     * @param snapshotId Id referencing a particular snapshot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> updateWithServiceResponseAsync(UUID snapshotId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (snapshotId == null) {
            throw new IllegalArgumentException("Parameter snapshotId is required and cannot be null.");
        }
        final List<UUID> applyScope = null;
        final String userData = null;
        UpdateSnapshotRequest body = new UpdateSnapshotRequest();
        body.withApplyScope(null);
        body.withUserData(null);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.update(snapshotId, this.client.acceptLanguage(), body, parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = updateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Update the information of a snapshot. Only the source subscription who took the snapshot can update the snapshot.
     *
     * @param snapshotId Id referencing a particular snapshot.
     * @param applyScope Array of the target Face subscription ids for the snapshot, specified by the user who created the snapshot when calling Snapshot - Take. For each snapshot, only subscriptions included in the applyScope of Snapshot - Take can apply it.
     * @param userData User specified data about the snapshot for any purpose. Length should not exceed 16KB.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void update(UUID snapshotId, List<UUID> applyScope, String userData) {
        updateWithServiceResponseAsync(snapshotId, applyScope, userData).toBlocking().single().body();
    }

    /**
     * Update the information of a snapshot. Only the source subscription who took the snapshot can update the snapshot.
     *
     * @param snapshotId Id referencing a particular snapshot.
     * @param applyScope Array of the target Face subscription ids for the snapshot, specified by the user who created the snapshot when calling Snapshot - Take. For each snapshot, only subscriptions included in the applyScope of Snapshot - Take can apply it.
     * @param userData User specified data about the snapshot for any purpose. Length should not exceed 16KB.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> updateAsync(UUID snapshotId, List<UUID> applyScope, String userData, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(updateWithServiceResponseAsync(snapshotId, applyScope, userData), serviceCallback);
    }

    /**
     * Update the information of a snapshot. Only the source subscription who took the snapshot can update the snapshot.
     *
     * @param snapshotId Id referencing a particular snapshot.
     * @param applyScope Array of the target Face subscription ids for the snapshot, specified by the user who created the snapshot when calling Snapshot - Take. For each snapshot, only subscriptions included in the applyScope of Snapshot - Take can apply it.
     * @param userData User specified data about the snapshot for any purpose. Length should not exceed 16KB.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> updateAsync(UUID snapshotId, List<UUID> applyScope, String userData) {
        return updateWithServiceResponseAsync(snapshotId, applyScope, userData).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Update the information of a snapshot. Only the source subscription who took the snapshot can update the snapshot.
     *
     * @param snapshotId Id referencing a particular snapshot.
     * @param applyScope Array of the target Face subscription ids for the snapshot, specified by the user who created the snapshot when calling Snapshot - Take. For each snapshot, only subscriptions included in the applyScope of Snapshot - Take can apply it.
     * @param userData User specified data about the snapshot for any purpose. Length should not exceed 16KB.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> updateWithServiceResponseAsync(UUID snapshotId, List<UUID> applyScope, String userData) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (snapshotId == null) {
            throw new IllegalArgumentException("Parameter snapshotId is required and cannot be null.");
        }
        Validator.validate(applyScope);
        UpdateSnapshotRequest body = new UpdateSnapshotRequest();
        body.withApplyScope(applyScope);
        body.withUserData(userData);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.update(snapshotId, this.client.acceptLanguage(), body, parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = updateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> updateDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }

    /**
     * Delete an existing snapshot according to the snapshotId. All object data and information in the snapshot will also be deleted. Only the source subscription who took the snapshot can delete the snapshot. If the user does not delete a snapshot with this API, the snapshot will still be automatically deleted in 48 hours after creation.
     *
     * @param snapshotId Id referencing a particular snapshot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void delete(UUID snapshotId) {
        deleteWithServiceResponseAsync(snapshotId).toBlocking().single().body();
    }

    /**
     * Delete an existing snapshot according to the snapshotId. All object data and information in the snapshot will also be deleted. Only the source subscription who took the snapshot can delete the snapshot. If the user does not delete a snapshot with this API, the snapshot will still be automatically deleted in 48 hours after creation.
     *
     * @param snapshotId Id referencing a particular snapshot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteAsync(UUID snapshotId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteWithServiceResponseAsync(snapshotId), serviceCallback);
    }

    /**
     * Delete an existing snapshot according to the snapshotId. All object data and information in the snapshot will also be deleted. Only the source subscription who took the snapshot can delete the snapshot. If the user does not delete a snapshot with this API, the snapshot will still be automatically deleted in 48 hours after creation.
     *
     * @param snapshotId Id referencing a particular snapshot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteAsync(UUID snapshotId) {
        return deleteWithServiceResponseAsync(snapshotId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete an existing snapshot according to the snapshotId. All object data and information in the snapshot will also be deleted. Only the source subscription who took the snapshot can delete the snapshot. If the user does not delete a snapshot with this API, the snapshot will still be automatically deleted in 48 hours after creation.
     *
     * @param snapshotId Id referencing a particular snapshot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteWithServiceResponseAsync(UUID snapshotId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (snapshotId == null) {
            throw new IllegalArgumentException("Parameter snapshotId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.delete(snapshotId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }

    /**
     * Submit an operation to apply a snapshot to current subscription. For each snapshot, only subscriptions included in the applyScope of Snapshot - Take can apply it.&lt;br /&gt;
     The snapshot interfaces are for users to backup and restore their face data from one face subscription to another, inside same region or across regions. The workflow contains two phases, user first calls Snapshot - Take to create a copy of the source object and store it as a snapshot, then calls Snapshot - Apply to paste the snapshot to target subscription. The snapshots are stored in a centralized location (per Azure instance), so that they can be applied cross accounts and regions.&lt;br /&gt;
     Applying snapshot is an asynchronous operation. An operation id can be obtained from the "Operation-Location" field in response header, to be used in OperationStatus - Get for tracking the progress of applying the snapshot. The target object id will be included in the "resourceLocation" field in OperationStatus - Get response when the operation status is "succeeded".&lt;br /&gt;
     Snapshot applying time depends on the number of person and face entries in the snapshot object. It could be in seconds, or up to 1 hour for 1,000,000 persons with multiple faces.&lt;br /&gt;
     Snapshots will be automatically expired and cleaned in 48 hours after it is created by Snapshot - Take. So the target subscription is required to apply the snapshot in 48 hours since its creation.&lt;br /&gt;
     Applying a snapshot will not block any other operations against the target object, however it is not recommended because the correctness cannot be guaranteed during snapshot applying. After snapshot applying is completed, all operations towards the target object can work as normal. Snapshot also includes the training results of the source object, which means target subscription the snapshot applied to does not need re-train the target object before calling Identify/FindSimilar.&lt;br /&gt;
     One snapshot can be applied multiple times in parallel, while currently only CreateNew apply mode is supported, which means the apply operation will fail if target subscription already contains an object of same type and using the same objectId. Users can specify the "objectId" in request body to avoid such conflicts.&lt;br /&gt;
     * Free-tier subscription quota: 100 apply operations per month.
     * S0-tier subscription quota: 100 apply operations per day.
     *
     * @param snapshotId Id referencing a particular snapshot.
     * @param objectId User specified target object id to be created from the snapshot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void apply(UUID snapshotId, String objectId) {
        applyWithServiceResponseAsync(snapshotId, objectId).toBlocking().single().body();
    }

    /**
     * Submit an operation to apply a snapshot to current subscription. For each snapshot, only subscriptions included in the applyScope of Snapshot - Take can apply it.&lt;br /&gt;
     The snapshot interfaces are for users to backup and restore their face data from one face subscription to another, inside same region or across regions. The workflow contains two phases, user first calls Snapshot - Take to create a copy of the source object and store it as a snapshot, then calls Snapshot - Apply to paste the snapshot to target subscription. The snapshots are stored in a centralized location (per Azure instance), so that they can be applied cross accounts and regions.&lt;br /&gt;
     Applying snapshot is an asynchronous operation. An operation id can be obtained from the "Operation-Location" field in response header, to be used in OperationStatus - Get for tracking the progress of applying the snapshot. The target object id will be included in the "resourceLocation" field in OperationStatus - Get response when the operation status is "succeeded".&lt;br /&gt;
     Snapshot applying time depends on the number of person and face entries in the snapshot object. It could be in seconds, or up to 1 hour for 1,000,000 persons with multiple faces.&lt;br /&gt;
     Snapshots will be automatically expired and cleaned in 48 hours after it is created by Snapshot - Take. So the target subscription is required to apply the snapshot in 48 hours since its creation.&lt;br /&gt;
     Applying a snapshot will not block any other operations against the target object, however it is not recommended because the correctness cannot be guaranteed during snapshot applying. After snapshot applying is completed, all operations towards the target object can work as normal. Snapshot also includes the training results of the source object, which means target subscription the snapshot applied to does not need re-train the target object before calling Identify/FindSimilar.&lt;br /&gt;
     One snapshot can be applied multiple times in parallel, while currently only CreateNew apply mode is supported, which means the apply operation will fail if target subscription already contains an object of same type and using the same objectId. Users can specify the "objectId" in request body to avoid such conflicts.&lt;br /&gt;
     * Free-tier subscription quota: 100 apply operations per month.
     * S0-tier subscription quota: 100 apply operations per day.
     *
     * @param snapshotId Id referencing a particular snapshot.
     * @param objectId User specified target object id to be created from the snapshot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> applyAsync(UUID snapshotId, String objectId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(applyWithServiceResponseAsync(snapshotId, objectId), serviceCallback);
    }

    /**
     * Submit an operation to apply a snapshot to current subscription. For each snapshot, only subscriptions included in the applyScope of Snapshot - Take can apply it.&lt;br /&gt;
     The snapshot interfaces are for users to backup and restore their face data from one face subscription to another, inside same region or across regions. The workflow contains two phases, user first calls Snapshot - Take to create a copy of the source object and store it as a snapshot, then calls Snapshot - Apply to paste the snapshot to target subscription. The snapshots are stored in a centralized location (per Azure instance), so that they can be applied cross accounts and regions.&lt;br /&gt;
     Applying snapshot is an asynchronous operation. An operation id can be obtained from the "Operation-Location" field in response header, to be used in OperationStatus - Get for tracking the progress of applying the snapshot. The target object id will be included in the "resourceLocation" field in OperationStatus - Get response when the operation status is "succeeded".&lt;br /&gt;
     Snapshot applying time depends on the number of person and face entries in the snapshot object. It could be in seconds, or up to 1 hour for 1,000,000 persons with multiple faces.&lt;br /&gt;
     Snapshots will be automatically expired and cleaned in 48 hours after it is created by Snapshot - Take. So the target subscription is required to apply the snapshot in 48 hours since its creation.&lt;br /&gt;
     Applying a snapshot will not block any other operations against the target object, however it is not recommended because the correctness cannot be guaranteed during snapshot applying. After snapshot applying is completed, all operations towards the target object can work as normal. Snapshot also includes the training results of the source object, which means target subscription the snapshot applied to does not need re-train the target object before calling Identify/FindSimilar.&lt;br /&gt;
     One snapshot can be applied multiple times in parallel, while currently only CreateNew apply mode is supported, which means the apply operation will fail if target subscription already contains an object of same type and using the same objectId. Users can specify the "objectId" in request body to avoid such conflicts.&lt;br /&gt;
     * Free-tier subscription quota: 100 apply operations per month.
     * S0-tier subscription quota: 100 apply operations per day.
     *
     * @param snapshotId Id referencing a particular snapshot.
     * @param objectId User specified target object id to be created from the snapshot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<Void> applyAsync(UUID snapshotId, String objectId) {
        return applyWithServiceResponseAsync(snapshotId, objectId).map(new Func1<ServiceResponseWithHeaders<Void, SnapshotApplyHeaders>, Void>() {
            @Override
            public Void call(ServiceResponseWithHeaders<Void, SnapshotApplyHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Submit an operation to apply a snapshot to current subscription. For each snapshot, only subscriptions included in the applyScope of Snapshot - Take can apply it.&lt;br /&gt;
     The snapshot interfaces are for users to backup and restore their face data from one face subscription to another, inside same region or across regions. The workflow contains two phases, user first calls Snapshot - Take to create a copy of the source object and store it as a snapshot, then calls Snapshot - Apply to paste the snapshot to target subscription. The snapshots are stored in a centralized location (per Azure instance), so that they can be applied cross accounts and regions.&lt;br /&gt;
     Applying snapshot is an asynchronous operation. An operation id can be obtained from the "Operation-Location" field in response header, to be used in OperationStatus - Get for tracking the progress of applying the snapshot. The target object id will be included in the "resourceLocation" field in OperationStatus - Get response when the operation status is "succeeded".&lt;br /&gt;
     Snapshot applying time depends on the number of person and face entries in the snapshot object. It could be in seconds, or up to 1 hour for 1,000,000 persons with multiple faces.&lt;br /&gt;
     Snapshots will be automatically expired and cleaned in 48 hours after it is created by Snapshot - Take. So the target subscription is required to apply the snapshot in 48 hours since its creation.&lt;br /&gt;
     Applying a snapshot will not block any other operations against the target object, however it is not recommended because the correctness cannot be guaranteed during snapshot applying. After snapshot applying is completed, all operations towards the target object can work as normal. Snapshot also includes the training results of the source object, which means target subscription the snapshot applied to does not need re-train the target object before calling Identify/FindSimilar.&lt;br /&gt;
     One snapshot can be applied multiple times in parallel, while currently only CreateNew apply mode is supported, which means the apply operation will fail if target subscription already contains an object of same type and using the same objectId. Users can specify the "objectId" in request body to avoid such conflicts.&lt;br /&gt;
     * Free-tier subscription quota: 100 apply operations per month.
     * S0-tier subscription quota: 100 apply operations per day.
     *
     * @param snapshotId Id referencing a particular snapshot.
     * @param objectId User specified target object id to be created from the snapshot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<ServiceResponseWithHeaders<Void, SnapshotApplyHeaders>> applyWithServiceResponseAsync(UUID snapshotId, String objectId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (snapshotId == null) {
            throw new IllegalArgumentException("Parameter snapshotId is required and cannot be null.");
        }
        if (objectId == null) {
            throw new IllegalArgumentException("Parameter objectId is required and cannot be null.");
        }
        final SnapshotApplyMode mode = null;
        ApplySnapshotRequest body = new ApplySnapshotRequest();
        body.withObjectId(objectId);
        body.withMode(null);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.apply(snapshotId, this.client.acceptLanguage(), body, parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Void, SnapshotApplyHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Void, SnapshotApplyHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Void, SnapshotApplyHeaders> clientResponse = applyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Submit an operation to apply a snapshot to current subscription. For each snapshot, only subscriptions included in the applyScope of Snapshot - Take can apply it.&lt;br /&gt;
     The snapshot interfaces are for users to backup and restore their face data from one face subscription to another, inside same region or across regions. The workflow contains two phases, user first calls Snapshot - Take to create a copy of the source object and store it as a snapshot, then calls Snapshot - Apply to paste the snapshot to target subscription. The snapshots are stored in a centralized location (per Azure instance), so that they can be applied cross accounts and regions.&lt;br /&gt;
     Applying snapshot is an asynchronous operation. An operation id can be obtained from the "Operation-Location" field in response header, to be used in OperationStatus - Get for tracking the progress of applying the snapshot. The target object id will be included in the "resourceLocation" field in OperationStatus - Get response when the operation status is "succeeded".&lt;br /&gt;
     Snapshot applying time depends on the number of person and face entries in the snapshot object. It could be in seconds, or up to 1 hour for 1,000,000 persons with multiple faces.&lt;br /&gt;
     Snapshots will be automatically expired and cleaned in 48 hours after it is created by Snapshot - Take. So the target subscription is required to apply the snapshot in 48 hours since its creation.&lt;br /&gt;
     Applying a snapshot will not block any other operations against the target object, however it is not recommended because the correctness cannot be guaranteed during snapshot applying. After snapshot applying is completed, all operations towards the target object can work as normal. Snapshot also includes the training results of the source object, which means target subscription the snapshot applied to does not need re-train the target object before calling Identify/FindSimilar.&lt;br /&gt;
     One snapshot can be applied multiple times in parallel, while currently only CreateNew apply mode is supported, which means the apply operation will fail if target subscription already contains an object of same type and using the same objectId. Users can specify the "objectId" in request body to avoid such conflicts.&lt;br /&gt;
     * Free-tier subscription quota: 100 apply operations per month.
     * S0-tier subscription quota: 100 apply operations per day.
     *
     * @param snapshotId Id referencing a particular snapshot.
     * @param objectId User specified target object id to be created from the snapshot.
     * @param mode Snapshot applying mode. Currently only CreateNew is supported, which means the apply operation will fail if target subscription already contains an object of same type and using the same objectId. Users can specify the "objectId" in request body to avoid such conflicts. Possible values include: 'CreateNew'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void apply(UUID snapshotId, String objectId, SnapshotApplyMode mode) {
        applyWithServiceResponseAsync(snapshotId, objectId, mode).toBlocking().single().body();
    }

    /**
     * Submit an operation to apply a snapshot to current subscription. For each snapshot, only subscriptions included in the applyScope of Snapshot - Take can apply it.&lt;br /&gt;
     The snapshot interfaces are for users to backup and restore their face data from one face subscription to another, inside same region or across regions. The workflow contains two phases, user first calls Snapshot - Take to create a copy of the source object and store it as a snapshot, then calls Snapshot - Apply to paste the snapshot to target subscription. The snapshots are stored in a centralized location (per Azure instance), so that they can be applied cross accounts and regions.&lt;br /&gt;
     Applying snapshot is an asynchronous operation. An operation id can be obtained from the "Operation-Location" field in response header, to be used in OperationStatus - Get for tracking the progress of applying the snapshot. The target object id will be included in the "resourceLocation" field in OperationStatus - Get response when the operation status is "succeeded".&lt;br /&gt;
     Snapshot applying time depends on the number of person and face entries in the snapshot object. It could be in seconds, or up to 1 hour for 1,000,000 persons with multiple faces.&lt;br /&gt;
     Snapshots will be automatically expired and cleaned in 48 hours after it is created by Snapshot - Take. So the target subscription is required to apply the snapshot in 48 hours since its creation.&lt;br /&gt;
     Applying a snapshot will not block any other operations against the target object, however it is not recommended because the correctness cannot be guaranteed during snapshot applying. After snapshot applying is completed, all operations towards the target object can work as normal. Snapshot also includes the training results of the source object, which means target subscription the snapshot applied to does not need re-train the target object before calling Identify/FindSimilar.&lt;br /&gt;
     One snapshot can be applied multiple times in parallel, while currently only CreateNew apply mode is supported, which means the apply operation will fail if target subscription already contains an object of same type and using the same objectId. Users can specify the "objectId" in request body to avoid such conflicts.&lt;br /&gt;
     * Free-tier subscription quota: 100 apply operations per month.
     * S0-tier subscription quota: 100 apply operations per day.
     *
     * @param snapshotId Id referencing a particular snapshot.
     * @param objectId User specified target object id to be created from the snapshot.
     * @param mode Snapshot applying mode. Currently only CreateNew is supported, which means the apply operation will fail if target subscription already contains an object of same type and using the same objectId. Users can specify the "objectId" in request body to avoid such conflicts. Possible values include: 'CreateNew'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> applyAsync(UUID snapshotId, String objectId, SnapshotApplyMode mode, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(applyWithServiceResponseAsync(snapshotId, objectId, mode), serviceCallback);
    }

    /**
     * Submit an operation to apply a snapshot to current subscription. For each snapshot, only subscriptions included in the applyScope of Snapshot - Take can apply it.&lt;br /&gt;
     The snapshot interfaces are for users to backup and restore their face data from one face subscription to another, inside same region or across regions. The workflow contains two phases, user first calls Snapshot - Take to create a copy of the source object and store it as a snapshot, then calls Snapshot - Apply to paste the snapshot to target subscription. The snapshots are stored in a centralized location (per Azure instance), so that they can be applied cross accounts and regions.&lt;br /&gt;
     Applying snapshot is an asynchronous operation. An operation id can be obtained from the "Operation-Location" field in response header, to be used in OperationStatus - Get for tracking the progress of applying the snapshot. The target object id will be included in the "resourceLocation" field in OperationStatus - Get response when the operation status is "succeeded".&lt;br /&gt;
     Snapshot applying time depends on the number of person and face entries in the snapshot object. It could be in seconds, or up to 1 hour for 1,000,000 persons with multiple faces.&lt;br /&gt;
     Snapshots will be automatically expired and cleaned in 48 hours after it is created by Snapshot - Take. So the target subscription is required to apply the snapshot in 48 hours since its creation.&lt;br /&gt;
     Applying a snapshot will not block any other operations against the target object, however it is not recommended because the correctness cannot be guaranteed during snapshot applying. After snapshot applying is completed, all operations towards the target object can work as normal. Snapshot also includes the training results of the source object, which means target subscription the snapshot applied to does not need re-train the target object before calling Identify/FindSimilar.&lt;br /&gt;
     One snapshot can be applied multiple times in parallel, while currently only CreateNew apply mode is supported, which means the apply operation will fail if target subscription already contains an object of same type and using the same objectId. Users can specify the "objectId" in request body to avoid such conflicts.&lt;br /&gt;
     * Free-tier subscription quota: 100 apply operations per month.
     * S0-tier subscription quota: 100 apply operations per day.
     *
     * @param snapshotId Id referencing a particular snapshot.
     * @param objectId User specified target object id to be created from the snapshot.
     * @param mode Snapshot applying mode. Currently only CreateNew is supported, which means the apply operation will fail if target subscription already contains an object of same type and using the same objectId. Users can specify the "objectId" in request body to avoid such conflicts. Possible values include: 'CreateNew'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<Void> applyAsync(UUID snapshotId, String objectId, SnapshotApplyMode mode) {
        return applyWithServiceResponseAsync(snapshotId, objectId, mode).map(new Func1<ServiceResponseWithHeaders<Void, SnapshotApplyHeaders>, Void>() {
            @Override
            public Void call(ServiceResponseWithHeaders<Void, SnapshotApplyHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Submit an operation to apply a snapshot to current subscription. For each snapshot, only subscriptions included in the applyScope of Snapshot - Take can apply it.&lt;br /&gt;
     The snapshot interfaces are for users to backup and restore their face data from one face subscription to another, inside same region or across regions. The workflow contains two phases, user first calls Snapshot - Take to create a copy of the source object and store it as a snapshot, then calls Snapshot - Apply to paste the snapshot to target subscription. The snapshots are stored in a centralized location (per Azure instance), so that they can be applied cross accounts and regions.&lt;br /&gt;
     Applying snapshot is an asynchronous operation. An operation id can be obtained from the "Operation-Location" field in response header, to be used in OperationStatus - Get for tracking the progress of applying the snapshot. The target object id will be included in the "resourceLocation" field in OperationStatus - Get response when the operation status is "succeeded".&lt;br /&gt;
     Snapshot applying time depends on the number of person and face entries in the snapshot object. It could be in seconds, or up to 1 hour for 1,000,000 persons with multiple faces.&lt;br /&gt;
     Snapshots will be automatically expired and cleaned in 48 hours after it is created by Snapshot - Take. So the target subscription is required to apply the snapshot in 48 hours since its creation.&lt;br /&gt;
     Applying a snapshot will not block any other operations against the target object, however it is not recommended because the correctness cannot be guaranteed during snapshot applying. After snapshot applying is completed, all operations towards the target object can work as normal. Snapshot also includes the training results of the source object, which means target subscription the snapshot applied to does not need re-train the target object before calling Identify/FindSimilar.&lt;br /&gt;
     One snapshot can be applied multiple times in parallel, while currently only CreateNew apply mode is supported, which means the apply operation will fail if target subscription already contains an object of same type and using the same objectId. Users can specify the "objectId" in request body to avoid such conflicts.&lt;br /&gt;
     * Free-tier subscription quota: 100 apply operations per month.
     * S0-tier subscription quota: 100 apply operations per day.
     *
     * @param snapshotId Id referencing a particular snapshot.
     * @param objectId User specified target object id to be created from the snapshot.
     * @param mode Snapshot applying mode. Currently only CreateNew is supported, which means the apply operation will fail if target subscription already contains an object of same type and using the same objectId. Users can specify the "objectId" in request body to avoid such conflicts. Possible values include: 'CreateNew'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<ServiceResponseWithHeaders<Void, SnapshotApplyHeaders>> applyWithServiceResponseAsync(UUID snapshotId, String objectId, SnapshotApplyMode mode) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (snapshotId == null) {
            throw new IllegalArgumentException("Parameter snapshotId is required and cannot be null.");
        }
        if (objectId == null) {
            throw new IllegalArgumentException("Parameter objectId is required and cannot be null.");
        }
        ApplySnapshotRequest body = new ApplySnapshotRequest();
        body.withObjectId(objectId);
        body.withMode(mode);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.apply(snapshotId, this.client.acceptLanguage(), body, parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Void, SnapshotApplyHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Void, SnapshotApplyHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Void, SnapshotApplyHeaders> clientResponse = applyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Void, SnapshotApplyHeaders> applyDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(APIErrorException.class)
                .buildWithHeaders(response, SnapshotApplyHeaders.class);
    }

    /**
     * Retrieve the status of a take/apply snapshot operation.
     *
     * @param operationId Id referencing a particular take/apply snapshot operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatus object if successful.
     */
    public OperationStatus getOperationStatus(UUID operationId) {
        return getOperationStatusWithServiceResponseAsync(operationId).toBlocking().single().body();
    }

    /**
     * Retrieve the status of a take/apply snapshot operation.
     *
     * @param operationId Id referencing a particular take/apply snapshot operation.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatus> getOperationStatusAsync(UUID operationId, final ServiceCallback<OperationStatus> serviceCallback) {
        return ServiceFuture.fromResponse(getOperationStatusWithServiceResponseAsync(operationId), serviceCallback);
    }

    /**
     * Retrieve the status of a take/apply snapshot operation.
     *
     * @param operationId Id referencing a particular take/apply snapshot operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<OperationStatus> getOperationStatusAsync(UUID operationId) {
        return getOperationStatusWithServiceResponseAsync(operationId).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
            @Override
            public OperationStatus call(ServiceResponse<OperationStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Retrieve the status of a take/apply snapshot operation.
     *
     * @param operationId Id referencing a particular take/apply snapshot operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> getOperationStatusWithServiceResponseAsync(UUID operationId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (operationId == null) {
            throw new IllegalArgumentException("Parameter operationId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.getOperationStatus(operationId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatus>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatus> clientResponse = getOperationStatusDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatus> getOperationStatusDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatus, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatus>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }

}
