/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.cognitiveservices.vision.faceapi.implementation;

import retrofit2.Retrofit;
import com.microsoft.azure.cognitiveservices.vision.faceapi.PersonGroups;
import com.google.common.base.Joiner;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.cognitiveservices.vision.faceapi.models.APIErrorException;
import com.microsoft.azure.cognitiveservices.vision.faceapi.models.MetaDataContract;
import com.microsoft.azure.cognitiveservices.vision.faceapi.models.NameAndUserDataContract;
import com.microsoft.azure.cognitiveservices.vision.faceapi.models.PersonGroup;
import com.microsoft.azure.cognitiveservices.vision.faceapi.models.RecognitionModel;
import com.microsoft.azure.cognitiveservices.vision.faceapi.models.TrainingStatus;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import java.io.IOException;
import java.util.List;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.PATCH;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in PersonGroups.
 */
public class PersonGroupsImpl implements PersonGroups {
    /** The Retrofit service to perform REST calls. */
    private PersonGroupsService service;
    /** The service client containing this operation class. */
    private FaceClientImpl client;

    /**
     * Initializes an instance of PersonGroupsImpl.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public PersonGroupsImpl(Retrofit retrofit, FaceClientImpl client) {
        this.service = retrofit.create(PersonGroupsService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for PersonGroups to be
     * used by Retrofit to perform actually REST calls.
     */
    interface PersonGroupsService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.faceapi.PersonGroups create" })
        @PUT("persongroups/{personGroupId}")
        Observable<Response<ResponseBody>> create(@Path("personGroupId") String personGroupId, @Header("accept-language") String acceptLanguage, @Body MetaDataContract body, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.faceapi.PersonGroups delete" })
        @HTTP(path = "persongroups/{personGroupId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> delete(@Path("personGroupId") String personGroupId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.faceapi.PersonGroups get" })
        @GET("persongroups/{personGroupId}")
        Observable<Response<ResponseBody>> get(@Path("personGroupId") String personGroupId, @Query("returnRecognitionModel") Boolean returnRecognitionModel, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.faceapi.PersonGroups update" })
        @PATCH("persongroups/{personGroupId}")
        Observable<Response<ResponseBody>> update(@Path("personGroupId") String personGroupId, @Header("accept-language") String acceptLanguage, @Body NameAndUserDataContract body, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.faceapi.PersonGroups getTrainingStatus" })
        @GET("persongroups/{personGroupId}/training")
        Observable<Response<ResponseBody>> getTrainingStatus(@Path("personGroupId") String personGroupId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.faceapi.PersonGroups list" })
        @GET("persongroups")
        Observable<Response<ResponseBody>> list(@Query("start") String start, @Query("top") Integer top, @Query("returnRecognitionModel") Boolean returnRecognitionModel, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.faceapi.PersonGroups train" })
        @POST("persongroups/{personGroupId}/train")
        Observable<Response<ResponseBody>> train(@Path("personGroupId") String personGroupId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

    }

    /**
     * Create a new person group with specified personGroupId, name, user-provided userData and recognitionModel.
     &lt;br /&gt; A person group is the container of the uploaded person data, including face images and face recognition features.
     &lt;br /&gt; After creation, use [PersonGroup Person - Create](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523c) to add persons into the group, and then call [PersonGroup - Train](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395249) to get this group ready for [Face - Identify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239).
     &lt;br /&gt; The person's face, image, and userData will be stored on server until [PersonGroup Person - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523d) or [PersonGroup - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395245) is called.
     &lt;br /&gt;
     * Free-tier subscription quota: 1,000 person groups. Each holds up to 1,000 persons.
     * S0-tier subscription quota: 1,000,000 person groups. Each holds up to 10,000 persons.
     * to handle larger scale face identification problem, please consider using [LargePersonGroup](/docs/services/563879b61984550e40cbbe8d/operations/599acdee6ac60f11b48b5a9d).
     &lt;br /&gt;
     'recognitionModel' should be specified to associate with this person group. The default value for 'recognitionModel' is 'recognition_01', if the latest model needed, please explicitly specify the model you need in this parameter. New faces that are added to an existing person group will use the recognition model that's already associated with the collection. Existing face features in a person group can't be updated to features extracted by another version of recognition model.
     *
     * @param personGroupId Id referencing a particular person group.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void create(String personGroupId) {
        createWithServiceResponseAsync(personGroupId).toBlocking().single().body();
    }

    /**
     * Create a new person group with specified personGroupId, name, user-provided userData and recognitionModel.
     &lt;br /&gt; A person group is the container of the uploaded person data, including face images and face recognition features.
     &lt;br /&gt; After creation, use [PersonGroup Person - Create](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523c) to add persons into the group, and then call [PersonGroup - Train](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395249) to get this group ready for [Face - Identify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239).
     &lt;br /&gt; The person's face, image, and userData will be stored on server until [PersonGroup Person - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523d) or [PersonGroup - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395245) is called.
     &lt;br /&gt;
     * Free-tier subscription quota: 1,000 person groups. Each holds up to 1,000 persons.
     * S0-tier subscription quota: 1,000,000 person groups. Each holds up to 10,000 persons.
     * to handle larger scale face identification problem, please consider using [LargePersonGroup](/docs/services/563879b61984550e40cbbe8d/operations/599acdee6ac60f11b48b5a9d).
     &lt;br /&gt;
     'recognitionModel' should be specified to associate with this person group. The default value for 'recognitionModel' is 'recognition_01', if the latest model needed, please explicitly specify the model you need in this parameter. New faces that are added to an existing person group will use the recognition model that's already associated with the collection. Existing face features in a person group can't be updated to features extracted by another version of recognition model.
     *
     * @param personGroupId Id referencing a particular person group.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> createAsync(String personGroupId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(createWithServiceResponseAsync(personGroupId), serviceCallback);
    }

    /**
     * Create a new person group with specified personGroupId, name, user-provided userData and recognitionModel.
     &lt;br /&gt; A person group is the container of the uploaded person data, including face images and face recognition features.
     &lt;br /&gt; After creation, use [PersonGroup Person - Create](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523c) to add persons into the group, and then call [PersonGroup - Train](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395249) to get this group ready for [Face - Identify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239).
     &lt;br /&gt; The person's face, image, and userData will be stored on server until [PersonGroup Person - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523d) or [PersonGroup - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395245) is called.
     &lt;br /&gt;
     * Free-tier subscription quota: 1,000 person groups. Each holds up to 1,000 persons.
     * S0-tier subscription quota: 1,000,000 person groups. Each holds up to 10,000 persons.
     * to handle larger scale face identification problem, please consider using [LargePersonGroup](/docs/services/563879b61984550e40cbbe8d/operations/599acdee6ac60f11b48b5a9d).
     &lt;br /&gt;
     'recognitionModel' should be specified to associate with this person group. The default value for 'recognitionModel' is 'recognition_01', if the latest model needed, please explicitly specify the model you need in this parameter. New faces that are added to an existing person group will use the recognition model that's already associated with the collection. Existing face features in a person group can't be updated to features extracted by another version of recognition model.
     *
     * @param personGroupId Id referencing a particular person group.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> createAsync(String personGroupId) {
        return createWithServiceResponseAsync(personGroupId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Create a new person group with specified personGroupId, name, user-provided userData and recognitionModel.
     &lt;br /&gt; A person group is the container of the uploaded person data, including face images and face recognition features.
     &lt;br /&gt; After creation, use [PersonGroup Person - Create](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523c) to add persons into the group, and then call [PersonGroup - Train](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395249) to get this group ready for [Face - Identify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239).
     &lt;br /&gt; The person's face, image, and userData will be stored on server until [PersonGroup Person - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523d) or [PersonGroup - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395245) is called.
     &lt;br /&gt;
     * Free-tier subscription quota: 1,000 person groups. Each holds up to 1,000 persons.
     * S0-tier subscription quota: 1,000,000 person groups. Each holds up to 10,000 persons.
     * to handle larger scale face identification problem, please consider using [LargePersonGroup](/docs/services/563879b61984550e40cbbe8d/operations/599acdee6ac60f11b48b5a9d).
     &lt;br /&gt;
     'recognitionModel' should be specified to associate with this person group. The default value for 'recognitionModel' is 'recognition_01', if the latest model needed, please explicitly specify the model you need in this parameter. New faces that are added to an existing person group will use the recognition model that's already associated with the collection. Existing face features in a person group can't be updated to features extracted by another version of recognition model.
     *
     * @param personGroupId Id referencing a particular person group.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> createWithServiceResponseAsync(String personGroupId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (personGroupId == null) {
            throw new IllegalArgumentException("Parameter personGroupId is required and cannot be null.");
        }
        final String name = null;
        final String userData = null;
        final RecognitionModel recognitionModel = null;
        MetaDataContract body = new MetaDataContract();
        body.withName(null);
        body.withUserData(null);
        body.withRecognitionModel(null);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.create(personGroupId, this.client.acceptLanguage(), body, parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = createDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Create a new person group with specified personGroupId, name, user-provided userData and recognitionModel.
     &lt;br /&gt; A person group is the container of the uploaded person data, including face images and face recognition features.
     &lt;br /&gt; After creation, use [PersonGroup Person - Create](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523c) to add persons into the group, and then call [PersonGroup - Train](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395249) to get this group ready for [Face - Identify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239).
     &lt;br /&gt; The person's face, image, and userData will be stored on server until [PersonGroup Person - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523d) or [PersonGroup - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395245) is called.
     &lt;br /&gt;
     * Free-tier subscription quota: 1,000 person groups. Each holds up to 1,000 persons.
     * S0-tier subscription quota: 1,000,000 person groups. Each holds up to 10,000 persons.
     * to handle larger scale face identification problem, please consider using [LargePersonGroup](/docs/services/563879b61984550e40cbbe8d/operations/599acdee6ac60f11b48b5a9d).
     &lt;br /&gt;
     'recognitionModel' should be specified to associate with this person group. The default value for 'recognitionModel' is 'recognition_01', if the latest model needed, please explicitly specify the model you need in this parameter. New faces that are added to an existing person group will use the recognition model that's already associated with the collection. Existing face features in a person group can't be updated to features extracted by another version of recognition model.
     *
     * @param personGroupId Id referencing a particular person group.
     * @param name User defined name, maximum length is 128.
     * @param userData User specified data. Length should not exceed 16KB.
     * @param recognitionModel Possible values include: 'recognition_01', 'recognition_02'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void create(String personGroupId, String name, String userData, RecognitionModel recognitionModel) {
        createWithServiceResponseAsync(personGroupId, name, userData, recognitionModel).toBlocking().single().body();
    }

    /**
     * Create a new person group with specified personGroupId, name, user-provided userData and recognitionModel.
     &lt;br /&gt; A person group is the container of the uploaded person data, including face images and face recognition features.
     &lt;br /&gt; After creation, use [PersonGroup Person - Create](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523c) to add persons into the group, and then call [PersonGroup - Train](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395249) to get this group ready for [Face - Identify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239).
     &lt;br /&gt; The person's face, image, and userData will be stored on server until [PersonGroup Person - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523d) or [PersonGroup - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395245) is called.
     &lt;br /&gt;
     * Free-tier subscription quota: 1,000 person groups. Each holds up to 1,000 persons.
     * S0-tier subscription quota: 1,000,000 person groups. Each holds up to 10,000 persons.
     * to handle larger scale face identification problem, please consider using [LargePersonGroup](/docs/services/563879b61984550e40cbbe8d/operations/599acdee6ac60f11b48b5a9d).
     &lt;br /&gt;
     'recognitionModel' should be specified to associate with this person group. The default value for 'recognitionModel' is 'recognition_01', if the latest model needed, please explicitly specify the model you need in this parameter. New faces that are added to an existing person group will use the recognition model that's already associated with the collection. Existing face features in a person group can't be updated to features extracted by another version of recognition model.
     *
     * @param personGroupId Id referencing a particular person group.
     * @param name User defined name, maximum length is 128.
     * @param userData User specified data. Length should not exceed 16KB.
     * @param recognitionModel Possible values include: 'recognition_01', 'recognition_02'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> createAsync(String personGroupId, String name, String userData, RecognitionModel recognitionModel, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(createWithServiceResponseAsync(personGroupId, name, userData, recognitionModel), serviceCallback);
    }

    /**
     * Create a new person group with specified personGroupId, name, user-provided userData and recognitionModel.
     &lt;br /&gt; A person group is the container of the uploaded person data, including face images and face recognition features.
     &lt;br /&gt; After creation, use [PersonGroup Person - Create](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523c) to add persons into the group, and then call [PersonGroup - Train](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395249) to get this group ready for [Face - Identify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239).
     &lt;br /&gt; The person's face, image, and userData will be stored on server until [PersonGroup Person - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523d) or [PersonGroup - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395245) is called.
     &lt;br /&gt;
     * Free-tier subscription quota: 1,000 person groups. Each holds up to 1,000 persons.
     * S0-tier subscription quota: 1,000,000 person groups. Each holds up to 10,000 persons.
     * to handle larger scale face identification problem, please consider using [LargePersonGroup](/docs/services/563879b61984550e40cbbe8d/operations/599acdee6ac60f11b48b5a9d).
     &lt;br /&gt;
     'recognitionModel' should be specified to associate with this person group. The default value for 'recognitionModel' is 'recognition_01', if the latest model needed, please explicitly specify the model you need in this parameter. New faces that are added to an existing person group will use the recognition model that's already associated with the collection. Existing face features in a person group can't be updated to features extracted by another version of recognition model.
     *
     * @param personGroupId Id referencing a particular person group.
     * @param name User defined name, maximum length is 128.
     * @param userData User specified data. Length should not exceed 16KB.
     * @param recognitionModel Possible values include: 'recognition_01', 'recognition_02'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> createAsync(String personGroupId, String name, String userData, RecognitionModel recognitionModel) {
        return createWithServiceResponseAsync(personGroupId, name, userData, recognitionModel).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Create a new person group with specified personGroupId, name, user-provided userData and recognitionModel.
     &lt;br /&gt; A person group is the container of the uploaded person data, including face images and face recognition features.
     &lt;br /&gt; After creation, use [PersonGroup Person - Create](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523c) to add persons into the group, and then call [PersonGroup - Train](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395249) to get this group ready for [Face - Identify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239).
     &lt;br /&gt; The person's face, image, and userData will be stored on server until [PersonGroup Person - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523d) or [PersonGroup - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395245) is called.
     &lt;br /&gt;
     * Free-tier subscription quota: 1,000 person groups. Each holds up to 1,000 persons.
     * S0-tier subscription quota: 1,000,000 person groups. Each holds up to 10,000 persons.
     * to handle larger scale face identification problem, please consider using [LargePersonGroup](/docs/services/563879b61984550e40cbbe8d/operations/599acdee6ac60f11b48b5a9d).
     &lt;br /&gt;
     'recognitionModel' should be specified to associate with this person group. The default value for 'recognitionModel' is 'recognition_01', if the latest model needed, please explicitly specify the model you need in this parameter. New faces that are added to an existing person group will use the recognition model that's already associated with the collection. Existing face features in a person group can't be updated to features extracted by another version of recognition model.
     *
     * @param personGroupId Id referencing a particular person group.
     * @param name User defined name, maximum length is 128.
     * @param userData User specified data. Length should not exceed 16KB.
     * @param recognitionModel Possible values include: 'recognition_01', 'recognition_02'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> createWithServiceResponseAsync(String personGroupId, String name, String userData, RecognitionModel recognitionModel) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (personGroupId == null) {
            throw new IllegalArgumentException("Parameter personGroupId is required and cannot be null.");
        }
        MetaDataContract body = new MetaDataContract();
        body.withName(name);
        body.withUserData(userData);
        body.withRecognitionModel(recognitionModel);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.create(personGroupId, this.client.acceptLanguage(), body, parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = createDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> createDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }

    /**
     * Delete an existing person group. Persisted face features of all people in the person group will also be deleted.
     *
     * @param personGroupId Id referencing a particular person group.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void delete(String personGroupId) {
        deleteWithServiceResponseAsync(personGroupId).toBlocking().single().body();
    }

    /**
     * Delete an existing person group. Persisted face features of all people in the person group will also be deleted.
     *
     * @param personGroupId Id referencing a particular person group.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteAsync(String personGroupId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteWithServiceResponseAsync(personGroupId), serviceCallback);
    }

    /**
     * Delete an existing person group. Persisted face features of all people in the person group will also be deleted.
     *
     * @param personGroupId Id referencing a particular person group.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteAsync(String personGroupId) {
        return deleteWithServiceResponseAsync(personGroupId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete an existing person group. Persisted face features of all people in the person group will also be deleted.
     *
     * @param personGroupId Id referencing a particular person group.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteWithServiceResponseAsync(String personGroupId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (personGroupId == null) {
            throw new IllegalArgumentException("Parameter personGroupId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.delete(personGroupId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }

    /**
     * Retrieve person group name, userData and recognitionModel. To get person information under this personGroup, use [PersonGroup Person - List](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395241).
     *
     * @param personGroupId Id referencing a particular person group.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PersonGroup object if successful.
     */
    public PersonGroup get(String personGroupId) {
        return getWithServiceResponseAsync(personGroupId).toBlocking().single().body();
    }

    /**
     * Retrieve person group name, userData and recognitionModel. To get person information under this personGroup, use [PersonGroup Person - List](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395241).
     *
     * @param personGroupId Id referencing a particular person group.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PersonGroup> getAsync(String personGroupId, final ServiceCallback<PersonGroup> serviceCallback) {
        return ServiceFuture.fromResponse(getWithServiceResponseAsync(personGroupId), serviceCallback);
    }

    /**
     * Retrieve person group name, userData and recognitionModel. To get person information under this personGroup, use [PersonGroup Person - List](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395241).
     *
     * @param personGroupId Id referencing a particular person group.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PersonGroup object
     */
    public Observable<PersonGroup> getAsync(String personGroupId) {
        return getWithServiceResponseAsync(personGroupId).map(new Func1<ServiceResponse<PersonGroup>, PersonGroup>() {
            @Override
            public PersonGroup call(ServiceResponse<PersonGroup> response) {
                return response.body();
            }
        });
    }

    /**
     * Retrieve person group name, userData and recognitionModel. To get person information under this personGroup, use [PersonGroup Person - List](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395241).
     *
     * @param personGroupId Id referencing a particular person group.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PersonGroup object
     */
    public Observable<ServiceResponse<PersonGroup>> getWithServiceResponseAsync(String personGroupId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (personGroupId == null) {
            throw new IllegalArgumentException("Parameter personGroupId is required and cannot be null.");
        }
        final Boolean returnRecognitionModel = null;
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.get(personGroupId, returnRecognitionModel, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PersonGroup>>>() {
                @Override
                public Observable<ServiceResponse<PersonGroup>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PersonGroup> clientResponse = getDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Retrieve person group name, userData and recognitionModel. To get person information under this personGroup, use [PersonGroup Person - List](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395241).
     *
     * @param personGroupId Id referencing a particular person group.
     * @param returnRecognitionModel A value indicating whether the operation should return 'recognitionModel' in response.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PersonGroup object if successful.
     */
    public PersonGroup get(String personGroupId, Boolean returnRecognitionModel) {
        return getWithServiceResponseAsync(personGroupId, returnRecognitionModel).toBlocking().single().body();
    }

    /**
     * Retrieve person group name, userData and recognitionModel. To get person information under this personGroup, use [PersonGroup Person - List](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395241).
     *
     * @param personGroupId Id referencing a particular person group.
     * @param returnRecognitionModel A value indicating whether the operation should return 'recognitionModel' in response.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PersonGroup> getAsync(String personGroupId, Boolean returnRecognitionModel, final ServiceCallback<PersonGroup> serviceCallback) {
        return ServiceFuture.fromResponse(getWithServiceResponseAsync(personGroupId, returnRecognitionModel), serviceCallback);
    }

    /**
     * Retrieve person group name, userData and recognitionModel. To get person information under this personGroup, use [PersonGroup Person - List](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395241).
     *
     * @param personGroupId Id referencing a particular person group.
     * @param returnRecognitionModel A value indicating whether the operation should return 'recognitionModel' in response.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PersonGroup object
     */
    public Observable<PersonGroup> getAsync(String personGroupId, Boolean returnRecognitionModel) {
        return getWithServiceResponseAsync(personGroupId, returnRecognitionModel).map(new Func1<ServiceResponse<PersonGroup>, PersonGroup>() {
            @Override
            public PersonGroup call(ServiceResponse<PersonGroup> response) {
                return response.body();
            }
        });
    }

    /**
     * Retrieve person group name, userData and recognitionModel. To get person information under this personGroup, use [PersonGroup Person - List](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395241).
     *
     * @param personGroupId Id referencing a particular person group.
     * @param returnRecognitionModel A value indicating whether the operation should return 'recognitionModel' in response.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PersonGroup object
     */
    public Observable<ServiceResponse<PersonGroup>> getWithServiceResponseAsync(String personGroupId, Boolean returnRecognitionModel) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (personGroupId == null) {
            throw new IllegalArgumentException("Parameter personGroupId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.get(personGroupId, returnRecognitionModel, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PersonGroup>>>() {
                @Override
                public Observable<ServiceResponse<PersonGroup>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PersonGroup> clientResponse = getDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PersonGroup> getDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PersonGroup, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PersonGroup>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }

    /**
     * Update an existing person group's display name and userData. The properties which does not appear in request body will not be updated.
     *
     * @param personGroupId Id referencing a particular person group.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void update(String personGroupId) {
        updateWithServiceResponseAsync(personGroupId).toBlocking().single().body();
    }

    /**
     * Update an existing person group's display name and userData. The properties which does not appear in request body will not be updated.
     *
     * @param personGroupId Id referencing a particular person group.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> updateAsync(String personGroupId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(updateWithServiceResponseAsync(personGroupId), serviceCallback);
    }

    /**
     * Update an existing person group's display name and userData. The properties which does not appear in request body will not be updated.
     *
     * @param personGroupId Id referencing a particular person group.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> updateAsync(String personGroupId) {
        return updateWithServiceResponseAsync(personGroupId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Update an existing person group's display name and userData. The properties which does not appear in request body will not be updated.
     *
     * @param personGroupId Id referencing a particular person group.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> updateWithServiceResponseAsync(String personGroupId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (personGroupId == null) {
            throw new IllegalArgumentException("Parameter personGroupId is required and cannot be null.");
        }
        final String name = null;
        final String userData = null;
        NameAndUserDataContract body = new NameAndUserDataContract();
        body.withName(null);
        body.withUserData(null);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.update(personGroupId, this.client.acceptLanguage(), body, parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = updateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Update an existing person group's display name and userData. The properties which does not appear in request body will not be updated.
     *
     * @param personGroupId Id referencing a particular person group.
     * @param name User defined name, maximum length is 128.
     * @param userData User specified data. Length should not exceed 16KB.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void update(String personGroupId, String name, String userData) {
        updateWithServiceResponseAsync(personGroupId, name, userData).toBlocking().single().body();
    }

    /**
     * Update an existing person group's display name and userData. The properties which does not appear in request body will not be updated.
     *
     * @param personGroupId Id referencing a particular person group.
     * @param name User defined name, maximum length is 128.
     * @param userData User specified data. Length should not exceed 16KB.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> updateAsync(String personGroupId, String name, String userData, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(updateWithServiceResponseAsync(personGroupId, name, userData), serviceCallback);
    }

    /**
     * Update an existing person group's display name and userData. The properties which does not appear in request body will not be updated.
     *
     * @param personGroupId Id referencing a particular person group.
     * @param name User defined name, maximum length is 128.
     * @param userData User specified data. Length should not exceed 16KB.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> updateAsync(String personGroupId, String name, String userData) {
        return updateWithServiceResponseAsync(personGroupId, name, userData).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Update an existing person group's display name and userData. The properties which does not appear in request body will not be updated.
     *
     * @param personGroupId Id referencing a particular person group.
     * @param name User defined name, maximum length is 128.
     * @param userData User specified data. Length should not exceed 16KB.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> updateWithServiceResponseAsync(String personGroupId, String name, String userData) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (personGroupId == null) {
            throw new IllegalArgumentException("Parameter personGroupId is required and cannot be null.");
        }
        NameAndUserDataContract body = new NameAndUserDataContract();
        body.withName(name);
        body.withUserData(userData);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.update(personGroupId, this.client.acceptLanguage(), body, parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = updateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> updateDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }

    /**
     * Retrieve the training status of a person group (completed or ongoing).
     *
     * @param personGroupId Id referencing a particular person group.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TrainingStatus object if successful.
     */
    public TrainingStatus getTrainingStatus(String personGroupId) {
        return getTrainingStatusWithServiceResponseAsync(personGroupId).toBlocking().single().body();
    }

    /**
     * Retrieve the training status of a person group (completed or ongoing).
     *
     * @param personGroupId Id referencing a particular person group.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TrainingStatus> getTrainingStatusAsync(String personGroupId, final ServiceCallback<TrainingStatus> serviceCallback) {
        return ServiceFuture.fromResponse(getTrainingStatusWithServiceResponseAsync(personGroupId), serviceCallback);
    }

    /**
     * Retrieve the training status of a person group (completed or ongoing).
     *
     * @param personGroupId Id referencing a particular person group.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TrainingStatus object
     */
    public Observable<TrainingStatus> getTrainingStatusAsync(String personGroupId) {
        return getTrainingStatusWithServiceResponseAsync(personGroupId).map(new Func1<ServiceResponse<TrainingStatus>, TrainingStatus>() {
            @Override
            public TrainingStatus call(ServiceResponse<TrainingStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Retrieve the training status of a person group (completed or ongoing).
     *
     * @param personGroupId Id referencing a particular person group.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TrainingStatus object
     */
    public Observable<ServiceResponse<TrainingStatus>> getTrainingStatusWithServiceResponseAsync(String personGroupId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (personGroupId == null) {
            throw new IllegalArgumentException("Parameter personGroupId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.getTrainingStatus(personGroupId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<TrainingStatus>>>() {
                @Override
                public Observable<ServiceResponse<TrainingStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<TrainingStatus> clientResponse = getTrainingStatusDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<TrainingStatus> getTrainingStatusDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<TrainingStatus, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<TrainingStatus>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }

    /**
     * List person groups personGroupId, name, userData and recognitionModel.&lt;br /&gt;
     * Person groups are stored in alphabetical order of personGroupId.
     * "start" parameter (string, optional) is a user-provided personGroupId value that returned entries have larger ids by string comparison. "start" set to empty to indicate return from the first item.
     * "top" parameter (int, optional) specifies the number of entries to return. A maximal of 1000 entries can be returned in one call. To fetch more, you can specify "start" with the last returned entrys Id of the current call.
     &lt;br /&gt;
     For example, total 5 person groups: "group1", ..., "group5".
     &lt;br /&gt; "start=&amp;top=" will return all 5 groups.
     &lt;br /&gt; "start=&amp;top=2" will return "group1", "group2".
     &lt;br /&gt; "start=group2&amp;top=3" will return "group3", "group4", "group5".
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;PersonGroup&gt; object if successful.
     */
    public List<PersonGroup> list() {
        return listWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * List person groups personGroupId, name, userData and recognitionModel.&lt;br /&gt;
     * Person groups are stored in alphabetical order of personGroupId.
     * "start" parameter (string, optional) is a user-provided personGroupId value that returned entries have larger ids by string comparison. "start" set to empty to indicate return from the first item.
     * "top" parameter (int, optional) specifies the number of entries to return. A maximal of 1000 entries can be returned in one call. To fetch more, you can specify "start" with the last returned entrys Id of the current call.
     &lt;br /&gt;
     For example, total 5 person groups: "group1", ..., "group5".
     &lt;br /&gt; "start=&amp;top=" will return all 5 groups.
     &lt;br /&gt; "start=&amp;top=2" will return "group1", "group2".
     &lt;br /&gt; "start=group2&amp;top=3" will return "group3", "group4", "group5".
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<PersonGroup>> listAsync(final ServiceCallback<List<PersonGroup>> serviceCallback) {
        return ServiceFuture.fromResponse(listWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * List person groups personGroupId, name, userData and recognitionModel.&lt;br /&gt;
     * Person groups are stored in alphabetical order of personGroupId.
     * "start" parameter (string, optional) is a user-provided personGroupId value that returned entries have larger ids by string comparison. "start" set to empty to indicate return from the first item.
     * "top" parameter (int, optional) specifies the number of entries to return. A maximal of 1000 entries can be returned in one call. To fetch more, you can specify "start" with the last returned entrys Id of the current call.
     &lt;br /&gt;
     For example, total 5 person groups: "group1", ..., "group5".
     &lt;br /&gt; "start=&amp;top=" will return all 5 groups.
     &lt;br /&gt; "start=&amp;top=2" will return "group1", "group2".
     &lt;br /&gt; "start=group2&amp;top=3" will return "group3", "group4", "group5".
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PersonGroup&gt; object
     */
    public Observable<List<PersonGroup>> listAsync() {
        return listWithServiceResponseAsync().map(new Func1<ServiceResponse<List<PersonGroup>>, List<PersonGroup>>() {
            @Override
            public List<PersonGroup> call(ServiceResponse<List<PersonGroup>> response) {
                return response.body();
            }
        });
    }

    /**
     * List person groups personGroupId, name, userData and recognitionModel.&lt;br /&gt;
     * Person groups are stored in alphabetical order of personGroupId.
     * "start" parameter (string, optional) is a user-provided personGroupId value that returned entries have larger ids by string comparison. "start" set to empty to indicate return from the first item.
     * "top" parameter (int, optional) specifies the number of entries to return. A maximal of 1000 entries can be returned in one call. To fetch more, you can specify "start" with the last returned entrys Id of the current call.
     &lt;br /&gt;
     For example, total 5 person groups: "group1", ..., "group5".
     &lt;br /&gt; "start=&amp;top=" will return all 5 groups.
     &lt;br /&gt; "start=&amp;top=2" will return "group1", "group2".
     &lt;br /&gt; "start=group2&amp;top=3" will return "group3", "group4", "group5".
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PersonGroup&gt; object
     */
    public Observable<ServiceResponse<List<PersonGroup>>> listWithServiceResponseAsync() {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        final String start = null;
        final Integer top = null;
        final Boolean returnRecognitionModel = null;
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.list(start, top, returnRecognitionModel, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<PersonGroup>>>>() {
                @Override
                public Observable<ServiceResponse<List<PersonGroup>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<PersonGroup>> clientResponse = listDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * List person groups personGroupId, name, userData and recognitionModel.&lt;br /&gt;
     * Person groups are stored in alphabetical order of personGroupId.
     * "start" parameter (string, optional) is a user-provided personGroupId value that returned entries have larger ids by string comparison. "start" set to empty to indicate return from the first item.
     * "top" parameter (int, optional) specifies the number of entries to return. A maximal of 1000 entries can be returned in one call. To fetch more, you can specify "start" with the last returned entrys Id of the current call.
     &lt;br /&gt;
     For example, total 5 person groups: "group1", ..., "group5".
     &lt;br /&gt; "start=&amp;top=" will return all 5 groups.
     &lt;br /&gt; "start=&amp;top=2" will return "group1", "group2".
     &lt;br /&gt; "start=group2&amp;top=3" will return "group3", "group4", "group5".
     *
     * @param start List person groups from the least personGroupId greater than the "start".
     * @param top The number of person groups to list.
     * @param returnRecognitionModel A value indicating whether the operation should return 'recognitionModel' in response.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;PersonGroup&gt; object if successful.
     */
    public List<PersonGroup> list(String start, Integer top, Boolean returnRecognitionModel) {
        return listWithServiceResponseAsync(start, top, returnRecognitionModel).toBlocking().single().body();
    }

    /**
     * List person groups personGroupId, name, userData and recognitionModel.&lt;br /&gt;
     * Person groups are stored in alphabetical order of personGroupId.
     * "start" parameter (string, optional) is a user-provided personGroupId value that returned entries have larger ids by string comparison. "start" set to empty to indicate return from the first item.
     * "top" parameter (int, optional) specifies the number of entries to return. A maximal of 1000 entries can be returned in one call. To fetch more, you can specify "start" with the last returned entrys Id of the current call.
     &lt;br /&gt;
     For example, total 5 person groups: "group1", ..., "group5".
     &lt;br /&gt; "start=&amp;top=" will return all 5 groups.
     &lt;br /&gt; "start=&amp;top=2" will return "group1", "group2".
     &lt;br /&gt; "start=group2&amp;top=3" will return "group3", "group4", "group5".
     *
     * @param start List person groups from the least personGroupId greater than the "start".
     * @param top The number of person groups to list.
     * @param returnRecognitionModel A value indicating whether the operation should return 'recognitionModel' in response.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<PersonGroup>> listAsync(String start, Integer top, Boolean returnRecognitionModel, final ServiceCallback<List<PersonGroup>> serviceCallback) {
        return ServiceFuture.fromResponse(listWithServiceResponseAsync(start, top, returnRecognitionModel), serviceCallback);
    }

    /**
     * List person groups personGroupId, name, userData and recognitionModel.&lt;br /&gt;
     * Person groups are stored in alphabetical order of personGroupId.
     * "start" parameter (string, optional) is a user-provided personGroupId value that returned entries have larger ids by string comparison. "start" set to empty to indicate return from the first item.
     * "top" parameter (int, optional) specifies the number of entries to return. A maximal of 1000 entries can be returned in one call. To fetch more, you can specify "start" with the last returned entrys Id of the current call.
     &lt;br /&gt;
     For example, total 5 person groups: "group1", ..., "group5".
     &lt;br /&gt; "start=&amp;top=" will return all 5 groups.
     &lt;br /&gt; "start=&amp;top=2" will return "group1", "group2".
     &lt;br /&gt; "start=group2&amp;top=3" will return "group3", "group4", "group5".
     *
     * @param start List person groups from the least personGroupId greater than the "start".
     * @param top The number of person groups to list.
     * @param returnRecognitionModel A value indicating whether the operation should return 'recognitionModel' in response.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PersonGroup&gt; object
     */
    public Observable<List<PersonGroup>> listAsync(String start, Integer top, Boolean returnRecognitionModel) {
        return listWithServiceResponseAsync(start, top, returnRecognitionModel).map(new Func1<ServiceResponse<List<PersonGroup>>, List<PersonGroup>>() {
            @Override
            public List<PersonGroup> call(ServiceResponse<List<PersonGroup>> response) {
                return response.body();
            }
        });
    }

    /**
     * List person groups personGroupId, name, userData and recognitionModel.&lt;br /&gt;
     * Person groups are stored in alphabetical order of personGroupId.
     * "start" parameter (string, optional) is a user-provided personGroupId value that returned entries have larger ids by string comparison. "start" set to empty to indicate return from the first item.
     * "top" parameter (int, optional) specifies the number of entries to return. A maximal of 1000 entries can be returned in one call. To fetch more, you can specify "start" with the last returned entrys Id of the current call.
     &lt;br /&gt;
     For example, total 5 person groups: "group1", ..., "group5".
     &lt;br /&gt; "start=&amp;top=" will return all 5 groups.
     &lt;br /&gt; "start=&amp;top=2" will return "group1", "group2".
     &lt;br /&gt; "start=group2&amp;top=3" will return "group3", "group4", "group5".
     *
     * @param start List person groups from the least personGroupId greater than the "start".
     * @param top The number of person groups to list.
     * @param returnRecognitionModel A value indicating whether the operation should return 'recognitionModel' in response.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PersonGroup&gt; object
     */
    public Observable<ServiceResponse<List<PersonGroup>>> listWithServiceResponseAsync(String start, Integer top, Boolean returnRecognitionModel) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.list(start, top, returnRecognitionModel, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<PersonGroup>>>>() {
                @Override
                public Observable<ServiceResponse<List<PersonGroup>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<PersonGroup>> clientResponse = listDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<PersonGroup>> listDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<PersonGroup>, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<PersonGroup>>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }

    /**
     * Queue a person group training task, the training task may not be started immediately.
     *
     * @param personGroupId Id referencing a particular person group.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void train(String personGroupId) {
        trainWithServiceResponseAsync(personGroupId).toBlocking().single().body();
    }

    /**
     * Queue a person group training task, the training task may not be started immediately.
     *
     * @param personGroupId Id referencing a particular person group.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> trainAsync(String personGroupId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(trainWithServiceResponseAsync(personGroupId), serviceCallback);
    }

    /**
     * Queue a person group training task, the training task may not be started immediately.
     *
     * @param personGroupId Id referencing a particular person group.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> trainAsync(String personGroupId) {
        return trainWithServiceResponseAsync(personGroupId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Queue a person group training task, the training task may not be started immediately.
     *
     * @param personGroupId Id referencing a particular person group.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> trainWithServiceResponseAsync(String personGroupId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (personGroupId == null) {
            throw new IllegalArgumentException("Parameter personGroupId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.train(personGroupId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = trainDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> trainDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }

}
