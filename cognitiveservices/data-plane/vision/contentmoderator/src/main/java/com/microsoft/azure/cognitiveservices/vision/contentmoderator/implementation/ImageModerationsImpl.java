/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.cognitiveservices.vision.contentmoderator.implementation;

import retrofit2.Retrofit;
import com.microsoft.azure.cognitiveservices.vision.contentmoderator.ImageModerations;
import com.google.common.base.Joiner;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.cognitiveservices.vision.contentmoderator.models.APIErrorException;
import com.microsoft.azure.cognitiveservices.vision.contentmoderator.models.Evaluate;
import com.microsoft.azure.cognitiveservices.vision.contentmoderator.models.FoundFaces;
import com.microsoft.azure.cognitiveservices.vision.contentmoderator.models.ImageUrl;
import com.microsoft.azure.cognitiveservices.vision.contentmoderator.models.MatchResponse;
import com.microsoft.azure.cognitiveservices.vision.contentmoderator.models.OCR;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.InputStream;
import java.io.IOException;
import okhttp3.MediaType;
import okhttp3.RequestBody;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.POST;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in ImageModerations.
 */
public class ImageModerationsImpl implements ImageModerations {
    /** The Retrofit service to perform REST calls. */
    private ImageModerationsService service;
    /** The service client containing this operation class. */
    private ContentModeratorClientImpl client;

    /**
     * Initializes an instance of ImageModerationsImpl.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public ImageModerationsImpl(Retrofit retrofit, ContentModeratorClientImpl client) {
        this.service = retrofit.create(ImageModerationsService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for ImageModerations to be
     * used by Retrofit to perform actually REST calls.
     */
    interface ImageModerationsService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.contentmoderator.ImageModerations findFaces" })
        @POST("contentmoderator/moderate/v1.0/ProcessImage/FindFaces")
        Observable<Response<ResponseBody>> findFaces(@Query("CacheImage") Boolean cacheImage, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.contentmoderator.ImageModerations oCRMethod" })
        @POST("contentmoderator/moderate/v1.0/ProcessImage/OCR")
        Observable<Response<ResponseBody>> oCRMethod(@Query("language") String language, @Query("CacheImage") Boolean cacheImage, @Query("enhanced") Boolean enhanced, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.contentmoderator.ImageModerations evaluateMethod" })
        @POST("contentmoderator/moderate/v1.0/ProcessImage/Evaluate")
        Observable<Response<ResponseBody>> evaluateMethod(@Query("CacheImage") Boolean cacheImage, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.contentmoderator.ImageModerations matchMethod" })
        @POST("contentmoderator/moderate/v1.0/ProcessImage/Match")
        Observable<Response<ResponseBody>> matchMethod(@Query("listId") String listId, @Query("CacheImage") Boolean cacheImage, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: image/gif", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.contentmoderator.ImageModerations findFacesFileInput" })
        @POST("contentmoderator/moderate/v1.0/ProcessImage/FindFaces")
        Observable<Response<ResponseBody>> findFacesFileInput(@Query("CacheImage") Boolean cacheImage, @Body RequestBody imageStream, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.contentmoderator.ImageModerations findFacesUrlInput" })
        @POST("contentmoderator/moderate/v1.0/ProcessImage/FindFaces")
        Observable<Response<ResponseBody>> findFacesUrlInput(@Query("CacheImage") Boolean cacheImage, @Header("Content-Type") String contentType, @Body ImageUrl imageUrl, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.contentmoderator.ImageModerations oCRUrlInput" })
        @POST("contentmoderator/moderate/v1.0/ProcessImage/OCR")
        Observable<Response<ResponseBody>> oCRUrlInput(@Query("language") String language, @Query("CacheImage") Boolean cacheImage, @Query("enhanced") Boolean enhanced, @Header("Content-Type") String contentType, @Body ImageUrl imageUrl, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: image/gif", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.contentmoderator.ImageModerations oCRFileInput" })
        @POST("contentmoderator/moderate/v1.0/ProcessImage/OCR")
        Observable<Response<ResponseBody>> oCRFileInput(@Query("language") String language, @Query("CacheImage") Boolean cacheImage, @Query("enhanced") Boolean enhanced, @Body RequestBody imageStream, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: image/gif", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.contentmoderator.ImageModerations evaluateFileInput" })
        @POST("contentmoderator/moderate/v1.0/ProcessImage/Evaluate")
        Observable<Response<ResponseBody>> evaluateFileInput(@Query("CacheImage") Boolean cacheImage, @Body RequestBody imageStream, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.contentmoderator.ImageModerations evaluateUrlInput" })
        @POST("contentmoderator/moderate/v1.0/ProcessImage/Evaluate")
        Observable<Response<ResponseBody>> evaluateUrlInput(@Query("CacheImage") Boolean cacheImage, @Header("Content-Type") String contentType, @Body ImageUrl imageUrl, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.contentmoderator.ImageModerations matchUrlInput" })
        @POST("contentmoderator/moderate/v1.0/ProcessImage/Match")
        Observable<Response<ResponseBody>> matchUrlInput(@Query("listId") String listId, @Query("CacheImage") Boolean cacheImage, @Header("Content-Type") String contentType, @Body ImageUrl imageUrl, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: image/gif", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.contentmoderator.ImageModerations matchFileInput" })
        @POST("contentmoderator/moderate/v1.0/ProcessImage/Match")
        Observable<Response<ResponseBody>> matchFileInput(@Query("listId") String listId, @Query("CacheImage") Boolean cacheImage, @Body RequestBody imageStream, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

    }

    /**
     * Returns the list of faces found.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the FoundFaces object if successful.
     */
    public FoundFaces findFaces() {
        return findFacesWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Returns the list of faces found.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<FoundFaces> findFacesAsync(final ServiceCallback<FoundFaces> serviceCallback) {
        return ServiceFuture.fromResponse(findFacesWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Returns the list of faces found.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FoundFaces object
     */
    public Observable<FoundFaces> findFacesAsync() {
        return findFacesWithServiceResponseAsync().map(new Func1<ServiceResponse<FoundFaces>, FoundFaces>() {
            @Override
            public FoundFaces call(ServiceResponse<FoundFaces> response) {
                return response.body();
            }
        });
    }

    /**
     * Returns the list of faces found.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FoundFaces object
     */
    public Observable<ServiceResponse<FoundFaces>> findFacesWithServiceResponseAsync() {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        final Boolean cacheImage = null;
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.findFaces(cacheImage, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<FoundFaces>>>() {
                @Override
                public Observable<ServiceResponse<FoundFaces>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<FoundFaces> clientResponse = findFacesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Returns the list of faces found.
     *
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the FoundFaces object if successful.
     */
    public FoundFaces findFaces(Boolean cacheImage) {
        return findFacesWithServiceResponseAsync(cacheImage).toBlocking().single().body();
    }

    /**
     * Returns the list of faces found.
     *
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<FoundFaces> findFacesAsync(Boolean cacheImage, final ServiceCallback<FoundFaces> serviceCallback) {
        return ServiceFuture.fromResponse(findFacesWithServiceResponseAsync(cacheImage), serviceCallback);
    }

    /**
     * Returns the list of faces found.
     *
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FoundFaces object
     */
    public Observable<FoundFaces> findFacesAsync(Boolean cacheImage) {
        return findFacesWithServiceResponseAsync(cacheImage).map(new Func1<ServiceResponse<FoundFaces>, FoundFaces>() {
            @Override
            public FoundFaces call(ServiceResponse<FoundFaces> response) {
                return response.body();
            }
        });
    }

    /**
     * Returns the list of faces found.
     *
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FoundFaces object
     */
    public Observable<ServiceResponse<FoundFaces>> findFacesWithServiceResponseAsync(Boolean cacheImage) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.findFaces(cacheImage, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<FoundFaces>>>() {
                @Override
                public Observable<ServiceResponse<FoundFaces>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<FoundFaces> clientResponse = findFacesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<FoundFaces> findFacesDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<FoundFaces, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<FoundFaces>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }

    /**
     * Returns any text found in the image for the language specified. If no language is specified in input then the detection defaults to English.
     *
     * @param language Language of the terms.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OCR object if successful.
     */
    public OCR oCRMethod(String language) {
        return oCRMethodWithServiceResponseAsync(language).toBlocking().single().body();
    }

    /**
     * Returns any text found in the image for the language specified. If no language is specified in input then the detection defaults to English.
     *
     * @param language Language of the terms.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OCR> oCRMethodAsync(String language, final ServiceCallback<OCR> serviceCallback) {
        return ServiceFuture.fromResponse(oCRMethodWithServiceResponseAsync(language), serviceCallback);
    }

    /**
     * Returns any text found in the image for the language specified. If no language is specified in input then the detection defaults to English.
     *
     * @param language Language of the terms.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OCR object
     */
    public Observable<OCR> oCRMethodAsync(String language) {
        return oCRMethodWithServiceResponseAsync(language).map(new Func1<ServiceResponse<OCR>, OCR>() {
            @Override
            public OCR call(ServiceResponse<OCR> response) {
                return response.body();
            }
        });
    }

    /**
     * Returns any text found in the image for the language specified. If no language is specified in input then the detection defaults to English.
     *
     * @param language Language of the terms.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OCR object
     */
    public Observable<ServiceResponse<OCR>> oCRMethodWithServiceResponseAsync(String language) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (language == null) {
            throw new IllegalArgumentException("Parameter language is required and cannot be null.");
        }
        final Boolean cacheImage = null;
        final Boolean enhanced = null;
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.oCRMethod(language, cacheImage, enhanced, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OCR>>>() {
                @Override
                public Observable<ServiceResponse<OCR>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OCR> clientResponse = oCRMethodDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Returns any text found in the image for the language specified. If no language is specified in input then the detection defaults to English.
     *
     * @param language Language of the terms.
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @param enhanced When set to True, the image goes through additional processing to come with additional candidates.
     image/tiff is not supported when enhanced is set to true
     Note: This impacts the response time.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OCR object if successful.
     */
    public OCR oCRMethod(String language, Boolean cacheImage, Boolean enhanced) {
        return oCRMethodWithServiceResponseAsync(language, cacheImage, enhanced).toBlocking().single().body();
    }

    /**
     * Returns any text found in the image for the language specified. If no language is specified in input then the detection defaults to English.
     *
     * @param language Language of the terms.
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @param enhanced When set to True, the image goes through additional processing to come with additional candidates.
     image/tiff is not supported when enhanced is set to true
     Note: This impacts the response time.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OCR> oCRMethodAsync(String language, Boolean cacheImage, Boolean enhanced, final ServiceCallback<OCR> serviceCallback) {
        return ServiceFuture.fromResponse(oCRMethodWithServiceResponseAsync(language, cacheImage, enhanced), serviceCallback);
    }

    /**
     * Returns any text found in the image for the language specified. If no language is specified in input then the detection defaults to English.
     *
     * @param language Language of the terms.
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @param enhanced When set to True, the image goes through additional processing to come with additional candidates.
     image/tiff is not supported when enhanced is set to true
     Note: This impacts the response time.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OCR object
     */
    public Observable<OCR> oCRMethodAsync(String language, Boolean cacheImage, Boolean enhanced) {
        return oCRMethodWithServiceResponseAsync(language, cacheImage, enhanced).map(new Func1<ServiceResponse<OCR>, OCR>() {
            @Override
            public OCR call(ServiceResponse<OCR> response) {
                return response.body();
            }
        });
    }

    /**
     * Returns any text found in the image for the language specified. If no language is specified in input then the detection defaults to English.
     *
     * @param language Language of the terms.
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @param enhanced When set to True, the image goes through additional processing to come with additional candidates.
     image/tiff is not supported when enhanced is set to true
     Note: This impacts the response time.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OCR object
     */
    public Observable<ServiceResponse<OCR>> oCRMethodWithServiceResponseAsync(String language, Boolean cacheImage, Boolean enhanced) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (language == null) {
            throw new IllegalArgumentException("Parameter language is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.oCRMethod(language, cacheImage, enhanced, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OCR>>>() {
                @Override
                public Observable<ServiceResponse<OCR>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OCR> clientResponse = oCRMethodDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OCR> oCRMethodDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OCR, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OCR>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }

    /**
     * Returns probabilities of the image containing racy or adult content.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Evaluate object if successful.
     */
    public Evaluate evaluateMethod() {
        return evaluateMethodWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Returns probabilities of the image containing racy or adult content.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Evaluate> evaluateMethodAsync(final ServiceCallback<Evaluate> serviceCallback) {
        return ServiceFuture.fromResponse(evaluateMethodWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Returns probabilities of the image containing racy or adult content.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Evaluate object
     */
    public Observable<Evaluate> evaluateMethodAsync() {
        return evaluateMethodWithServiceResponseAsync().map(new Func1<ServiceResponse<Evaluate>, Evaluate>() {
            @Override
            public Evaluate call(ServiceResponse<Evaluate> response) {
                return response.body();
            }
        });
    }

    /**
     * Returns probabilities of the image containing racy or adult content.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Evaluate object
     */
    public Observable<ServiceResponse<Evaluate>> evaluateMethodWithServiceResponseAsync() {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        final Boolean cacheImage = null;
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.evaluateMethod(cacheImage, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Evaluate>>>() {
                @Override
                public Observable<ServiceResponse<Evaluate>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Evaluate> clientResponse = evaluateMethodDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Returns probabilities of the image containing racy or adult content.
     *
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Evaluate object if successful.
     */
    public Evaluate evaluateMethod(Boolean cacheImage) {
        return evaluateMethodWithServiceResponseAsync(cacheImage).toBlocking().single().body();
    }

    /**
     * Returns probabilities of the image containing racy or adult content.
     *
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Evaluate> evaluateMethodAsync(Boolean cacheImage, final ServiceCallback<Evaluate> serviceCallback) {
        return ServiceFuture.fromResponse(evaluateMethodWithServiceResponseAsync(cacheImage), serviceCallback);
    }

    /**
     * Returns probabilities of the image containing racy or adult content.
     *
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Evaluate object
     */
    public Observable<Evaluate> evaluateMethodAsync(Boolean cacheImage) {
        return evaluateMethodWithServiceResponseAsync(cacheImage).map(new Func1<ServiceResponse<Evaluate>, Evaluate>() {
            @Override
            public Evaluate call(ServiceResponse<Evaluate> response) {
                return response.body();
            }
        });
    }

    /**
     * Returns probabilities of the image containing racy or adult content.
     *
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Evaluate object
     */
    public Observable<ServiceResponse<Evaluate>> evaluateMethodWithServiceResponseAsync(Boolean cacheImage) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.evaluateMethod(cacheImage, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Evaluate>>>() {
                @Override
                public Observable<ServiceResponse<Evaluate>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Evaluate> clientResponse = evaluateMethodDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Evaluate> evaluateMethodDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Evaluate, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Evaluate>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }

    /**
     * Fuzzily match an image against one of your custom Image Lists. You can create and manage your custom image lists using &lt;a href="/docs/services/578ff44d2703741568569ab9/operations/578ff7b12703741568569abe"&gt;this&lt;/a&gt; API.
     Returns ID and tags of matching image.&lt;br/&gt;
     &lt;br/&gt;
     Note: Refresh Index must be run on the corresponding Image List before additions and removals are reflected in the response.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MatchResponse object if successful.
     */
    public MatchResponse matchMethod() {
        return matchMethodWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Fuzzily match an image against one of your custom Image Lists. You can create and manage your custom image lists using &lt;a href="/docs/services/578ff44d2703741568569ab9/operations/578ff7b12703741568569abe"&gt;this&lt;/a&gt; API.
     Returns ID and tags of matching image.&lt;br/&gt;
     &lt;br/&gt;
     Note: Refresh Index must be run on the corresponding Image List before additions and removals are reflected in the response.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MatchResponse> matchMethodAsync(final ServiceCallback<MatchResponse> serviceCallback) {
        return ServiceFuture.fromResponse(matchMethodWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Fuzzily match an image against one of your custom Image Lists. You can create and manage your custom image lists using &lt;a href="/docs/services/578ff44d2703741568569ab9/operations/578ff7b12703741568569abe"&gt;this&lt;/a&gt; API.
     Returns ID and tags of matching image.&lt;br/&gt;
     &lt;br/&gt;
     Note: Refresh Index must be run on the corresponding Image List before additions and removals are reflected in the response.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MatchResponse object
     */
    public Observable<MatchResponse> matchMethodAsync() {
        return matchMethodWithServiceResponseAsync().map(new Func1<ServiceResponse<MatchResponse>, MatchResponse>() {
            @Override
            public MatchResponse call(ServiceResponse<MatchResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * Fuzzily match an image against one of your custom Image Lists. You can create and manage your custom image lists using &lt;a href="/docs/services/578ff44d2703741568569ab9/operations/578ff7b12703741568569abe"&gt;this&lt;/a&gt; API.
     Returns ID and tags of matching image.&lt;br/&gt;
     &lt;br/&gt;
     Note: Refresh Index must be run on the corresponding Image List before additions and removals are reflected in the response.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MatchResponse object
     */
    public Observable<ServiceResponse<MatchResponse>> matchMethodWithServiceResponseAsync() {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        final String listId = null;
        final Boolean cacheImage = null;
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.matchMethod(listId, cacheImage, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<MatchResponse>>>() {
                @Override
                public Observable<ServiceResponse<MatchResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<MatchResponse> clientResponse = matchMethodDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Fuzzily match an image against one of your custom Image Lists. You can create and manage your custom image lists using &lt;a href="/docs/services/578ff44d2703741568569ab9/operations/578ff7b12703741568569abe"&gt;this&lt;/a&gt; API.
     Returns ID and tags of matching image.&lt;br/&gt;
     &lt;br/&gt;
     Note: Refresh Index must be run on the corresponding Image List before additions and removals are reflected in the response.
     *
     * @param listId The list Id.
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MatchResponse object if successful.
     */
    public MatchResponse matchMethod(String listId, Boolean cacheImage) {
        return matchMethodWithServiceResponseAsync(listId, cacheImage).toBlocking().single().body();
    }

    /**
     * Fuzzily match an image against one of your custom Image Lists. You can create and manage your custom image lists using &lt;a href="/docs/services/578ff44d2703741568569ab9/operations/578ff7b12703741568569abe"&gt;this&lt;/a&gt; API.
     Returns ID and tags of matching image.&lt;br/&gt;
     &lt;br/&gt;
     Note: Refresh Index must be run on the corresponding Image List before additions and removals are reflected in the response.
     *
     * @param listId The list Id.
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MatchResponse> matchMethodAsync(String listId, Boolean cacheImage, final ServiceCallback<MatchResponse> serviceCallback) {
        return ServiceFuture.fromResponse(matchMethodWithServiceResponseAsync(listId, cacheImage), serviceCallback);
    }

    /**
     * Fuzzily match an image against one of your custom Image Lists. You can create and manage your custom image lists using &lt;a href="/docs/services/578ff44d2703741568569ab9/operations/578ff7b12703741568569abe"&gt;this&lt;/a&gt; API.
     Returns ID and tags of matching image.&lt;br/&gt;
     &lt;br/&gt;
     Note: Refresh Index must be run on the corresponding Image List before additions and removals are reflected in the response.
     *
     * @param listId The list Id.
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MatchResponse object
     */
    public Observable<MatchResponse> matchMethodAsync(String listId, Boolean cacheImage) {
        return matchMethodWithServiceResponseAsync(listId, cacheImage).map(new Func1<ServiceResponse<MatchResponse>, MatchResponse>() {
            @Override
            public MatchResponse call(ServiceResponse<MatchResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * Fuzzily match an image against one of your custom Image Lists. You can create and manage your custom image lists using &lt;a href="/docs/services/578ff44d2703741568569ab9/operations/578ff7b12703741568569abe"&gt;this&lt;/a&gt; API.
     Returns ID and tags of matching image.&lt;br/&gt;
     &lt;br/&gt;
     Note: Refresh Index must be run on the corresponding Image List before additions and removals are reflected in the response.
     *
     * @param listId The list Id.
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MatchResponse object
     */
    public Observable<ServiceResponse<MatchResponse>> matchMethodWithServiceResponseAsync(String listId, Boolean cacheImage) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.matchMethod(listId, cacheImage, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<MatchResponse>>>() {
                @Override
                public Observable<ServiceResponse<MatchResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<MatchResponse> clientResponse = matchMethodDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<MatchResponse> matchMethodDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<MatchResponse, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<MatchResponse>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }

    /**
     * Returns the list of faces found.
     *
     * @param imageStream The image file.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the FoundFaces object if successful.
     */
    public FoundFaces findFacesFileInput(byte[] imageStream) {
        return findFacesFileInputWithServiceResponseAsync(imageStream).toBlocking().single().body();
    }

    /**
     * Returns the list of faces found.
     *
     * @param imageStream The image file.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<FoundFaces> findFacesFileInputAsync(byte[] imageStream, final ServiceCallback<FoundFaces> serviceCallback) {
        return ServiceFuture.fromResponse(findFacesFileInputWithServiceResponseAsync(imageStream), serviceCallback);
    }

    /**
     * Returns the list of faces found.
     *
     * @param imageStream The image file.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FoundFaces object
     */
    public Observable<FoundFaces> findFacesFileInputAsync(byte[] imageStream) {
        return findFacesFileInputWithServiceResponseAsync(imageStream).map(new Func1<ServiceResponse<FoundFaces>, FoundFaces>() {
            @Override
            public FoundFaces call(ServiceResponse<FoundFaces> response) {
                return response.body();
            }
        });
    }

    /**
     * Returns the list of faces found.
     *
     * @param imageStream The image file.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FoundFaces object
     */
    public Observable<ServiceResponse<FoundFaces>> findFacesFileInputWithServiceResponseAsync(byte[] imageStream) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (imageStream == null) {
            throw new IllegalArgumentException("Parameter imageStream is required and cannot be null.");
        }
        final Boolean cacheImage = null;
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        RequestBody imageStreamConverted = RequestBody.create(MediaType.parse("image/gif"), imageStream);
        return service.findFacesFileInput(cacheImage, imageStreamConverted, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<FoundFaces>>>() {
                @Override
                public Observable<ServiceResponse<FoundFaces>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<FoundFaces> clientResponse = findFacesFileInputDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Returns the list of faces found.
     *
     * @param imageStream The image file.
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the FoundFaces object if successful.
     */
    public FoundFaces findFacesFileInput(byte[] imageStream, Boolean cacheImage) {
        return findFacesFileInputWithServiceResponseAsync(imageStream, cacheImage).toBlocking().single().body();
    }

    /**
     * Returns the list of faces found.
     *
     * @param imageStream The image file.
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<FoundFaces> findFacesFileInputAsync(byte[] imageStream, Boolean cacheImage, final ServiceCallback<FoundFaces> serviceCallback) {
        return ServiceFuture.fromResponse(findFacesFileInputWithServiceResponseAsync(imageStream, cacheImage), serviceCallback);
    }

    /**
     * Returns the list of faces found.
     *
     * @param imageStream The image file.
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FoundFaces object
     */
    public Observable<FoundFaces> findFacesFileInputAsync(byte[] imageStream, Boolean cacheImage) {
        return findFacesFileInputWithServiceResponseAsync(imageStream, cacheImage).map(new Func1<ServiceResponse<FoundFaces>, FoundFaces>() {
            @Override
            public FoundFaces call(ServiceResponse<FoundFaces> response) {
                return response.body();
            }
        });
    }

    /**
     * Returns the list of faces found.
     *
     * @param imageStream The image file.
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FoundFaces object
     */
    public Observable<ServiceResponse<FoundFaces>> findFacesFileInputWithServiceResponseAsync(byte[] imageStream, Boolean cacheImage) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (imageStream == null) {
            throw new IllegalArgumentException("Parameter imageStream is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        RequestBody imageStreamConverted = RequestBody.create(MediaType.parse("image/gif"), imageStream);
        return service.findFacesFileInput(cacheImage, imageStreamConverted, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<FoundFaces>>>() {
                @Override
                public Observable<ServiceResponse<FoundFaces>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<FoundFaces> clientResponse = findFacesFileInputDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<FoundFaces> findFacesFileInputDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<FoundFaces, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<FoundFaces>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }

    /**
     * Returns the list of faces found.
     *
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the FoundFaces object if successful.
     */
    public FoundFaces findFacesUrlInput(String contentType, ImageUrl imageUrl) {
        return findFacesUrlInputWithServiceResponseAsync(contentType, imageUrl).toBlocking().single().body();
    }

    /**
     * Returns the list of faces found.
     *
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<FoundFaces> findFacesUrlInputAsync(String contentType, ImageUrl imageUrl, final ServiceCallback<FoundFaces> serviceCallback) {
        return ServiceFuture.fromResponse(findFacesUrlInputWithServiceResponseAsync(contentType, imageUrl), serviceCallback);
    }

    /**
     * Returns the list of faces found.
     *
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FoundFaces object
     */
    public Observable<FoundFaces> findFacesUrlInputAsync(String contentType, ImageUrl imageUrl) {
        return findFacesUrlInputWithServiceResponseAsync(contentType, imageUrl).map(new Func1<ServiceResponse<FoundFaces>, FoundFaces>() {
            @Override
            public FoundFaces call(ServiceResponse<FoundFaces> response) {
                return response.body();
            }
        });
    }

    /**
     * Returns the list of faces found.
     *
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FoundFaces object
     */
    public Observable<ServiceResponse<FoundFaces>> findFacesUrlInputWithServiceResponseAsync(String contentType, ImageUrl imageUrl) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (contentType == null) {
            throw new IllegalArgumentException("Parameter contentType is required and cannot be null.");
        }
        if (imageUrl == null) {
            throw new IllegalArgumentException("Parameter imageUrl is required and cannot be null.");
        }
        Validator.validate(imageUrl);
        final Boolean cacheImage = null;
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.findFacesUrlInput(cacheImage, contentType, imageUrl, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<FoundFaces>>>() {
                @Override
                public Observable<ServiceResponse<FoundFaces>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<FoundFaces> clientResponse = findFacesUrlInputDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Returns the list of faces found.
     *
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the FoundFaces object if successful.
     */
    public FoundFaces findFacesUrlInput(String contentType, ImageUrl imageUrl, Boolean cacheImage) {
        return findFacesUrlInputWithServiceResponseAsync(contentType, imageUrl, cacheImage).toBlocking().single().body();
    }

    /**
     * Returns the list of faces found.
     *
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<FoundFaces> findFacesUrlInputAsync(String contentType, ImageUrl imageUrl, Boolean cacheImage, final ServiceCallback<FoundFaces> serviceCallback) {
        return ServiceFuture.fromResponse(findFacesUrlInputWithServiceResponseAsync(contentType, imageUrl, cacheImage), serviceCallback);
    }

    /**
     * Returns the list of faces found.
     *
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FoundFaces object
     */
    public Observable<FoundFaces> findFacesUrlInputAsync(String contentType, ImageUrl imageUrl, Boolean cacheImage) {
        return findFacesUrlInputWithServiceResponseAsync(contentType, imageUrl, cacheImage).map(new Func1<ServiceResponse<FoundFaces>, FoundFaces>() {
            @Override
            public FoundFaces call(ServiceResponse<FoundFaces> response) {
                return response.body();
            }
        });
    }

    /**
     * Returns the list of faces found.
     *
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FoundFaces object
     */
    public Observable<ServiceResponse<FoundFaces>> findFacesUrlInputWithServiceResponseAsync(String contentType, ImageUrl imageUrl, Boolean cacheImage) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (contentType == null) {
            throw new IllegalArgumentException("Parameter contentType is required and cannot be null.");
        }
        if (imageUrl == null) {
            throw new IllegalArgumentException("Parameter imageUrl is required and cannot be null.");
        }
        Validator.validate(imageUrl);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.findFacesUrlInput(cacheImage, contentType, imageUrl, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<FoundFaces>>>() {
                @Override
                public Observable<ServiceResponse<FoundFaces>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<FoundFaces> clientResponse = findFacesUrlInputDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<FoundFaces> findFacesUrlInputDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<FoundFaces, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<FoundFaces>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }

    /**
     * Returns any text found in the image for the language specified. If no language is specified in input then the detection defaults to English.
     *
     * @param language Language of the terms.
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OCR object if successful.
     */
    public OCR oCRUrlInput(String language, String contentType, ImageUrl imageUrl) {
        return oCRUrlInputWithServiceResponseAsync(language, contentType, imageUrl).toBlocking().single().body();
    }

    /**
     * Returns any text found in the image for the language specified. If no language is specified in input then the detection defaults to English.
     *
     * @param language Language of the terms.
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OCR> oCRUrlInputAsync(String language, String contentType, ImageUrl imageUrl, final ServiceCallback<OCR> serviceCallback) {
        return ServiceFuture.fromResponse(oCRUrlInputWithServiceResponseAsync(language, contentType, imageUrl), serviceCallback);
    }

    /**
     * Returns any text found in the image for the language specified. If no language is specified in input then the detection defaults to English.
     *
     * @param language Language of the terms.
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OCR object
     */
    public Observable<OCR> oCRUrlInputAsync(String language, String contentType, ImageUrl imageUrl) {
        return oCRUrlInputWithServiceResponseAsync(language, contentType, imageUrl).map(new Func1<ServiceResponse<OCR>, OCR>() {
            @Override
            public OCR call(ServiceResponse<OCR> response) {
                return response.body();
            }
        });
    }

    /**
     * Returns any text found in the image for the language specified. If no language is specified in input then the detection defaults to English.
     *
     * @param language Language of the terms.
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OCR object
     */
    public Observable<ServiceResponse<OCR>> oCRUrlInputWithServiceResponseAsync(String language, String contentType, ImageUrl imageUrl) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (language == null) {
            throw new IllegalArgumentException("Parameter language is required and cannot be null.");
        }
        if (contentType == null) {
            throw new IllegalArgumentException("Parameter contentType is required and cannot be null.");
        }
        if (imageUrl == null) {
            throw new IllegalArgumentException("Parameter imageUrl is required and cannot be null.");
        }
        Validator.validate(imageUrl);
        final Boolean cacheImage = null;
        final Boolean enhanced = null;
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.oCRUrlInput(language, cacheImage, enhanced, contentType, imageUrl, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OCR>>>() {
                @Override
                public Observable<ServiceResponse<OCR>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OCR> clientResponse = oCRUrlInputDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Returns any text found in the image for the language specified. If no language is specified in input then the detection defaults to English.
     *
     * @param language Language of the terms.
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @param enhanced When set to True, the image goes through additional processing to come with additional candidates.
     image/tiff is not supported when enhanced is set to true
     Note: This impacts the response time.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OCR object if successful.
     */
    public OCR oCRUrlInput(String language, String contentType, ImageUrl imageUrl, Boolean cacheImage, Boolean enhanced) {
        return oCRUrlInputWithServiceResponseAsync(language, contentType, imageUrl, cacheImage, enhanced).toBlocking().single().body();
    }

    /**
     * Returns any text found in the image for the language specified. If no language is specified in input then the detection defaults to English.
     *
     * @param language Language of the terms.
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @param enhanced When set to True, the image goes through additional processing to come with additional candidates.
     image/tiff is not supported when enhanced is set to true
     Note: This impacts the response time.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OCR> oCRUrlInputAsync(String language, String contentType, ImageUrl imageUrl, Boolean cacheImage, Boolean enhanced, final ServiceCallback<OCR> serviceCallback) {
        return ServiceFuture.fromResponse(oCRUrlInputWithServiceResponseAsync(language, contentType, imageUrl, cacheImage, enhanced), serviceCallback);
    }

    /**
     * Returns any text found in the image for the language specified. If no language is specified in input then the detection defaults to English.
     *
     * @param language Language of the terms.
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @param enhanced When set to True, the image goes through additional processing to come with additional candidates.
     image/tiff is not supported when enhanced is set to true
     Note: This impacts the response time.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OCR object
     */
    public Observable<OCR> oCRUrlInputAsync(String language, String contentType, ImageUrl imageUrl, Boolean cacheImage, Boolean enhanced) {
        return oCRUrlInputWithServiceResponseAsync(language, contentType, imageUrl, cacheImage, enhanced).map(new Func1<ServiceResponse<OCR>, OCR>() {
            @Override
            public OCR call(ServiceResponse<OCR> response) {
                return response.body();
            }
        });
    }

    /**
     * Returns any text found in the image for the language specified. If no language is specified in input then the detection defaults to English.
     *
     * @param language Language of the terms.
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @param enhanced When set to True, the image goes through additional processing to come with additional candidates.
     image/tiff is not supported when enhanced is set to true
     Note: This impacts the response time.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OCR object
     */
    public Observable<ServiceResponse<OCR>> oCRUrlInputWithServiceResponseAsync(String language, String contentType, ImageUrl imageUrl, Boolean cacheImage, Boolean enhanced) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (language == null) {
            throw new IllegalArgumentException("Parameter language is required and cannot be null.");
        }
        if (contentType == null) {
            throw new IllegalArgumentException("Parameter contentType is required and cannot be null.");
        }
        if (imageUrl == null) {
            throw new IllegalArgumentException("Parameter imageUrl is required and cannot be null.");
        }
        Validator.validate(imageUrl);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.oCRUrlInput(language, cacheImage, enhanced, contentType, imageUrl, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OCR>>>() {
                @Override
                public Observable<ServiceResponse<OCR>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OCR> clientResponse = oCRUrlInputDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OCR> oCRUrlInputDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OCR, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OCR>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }

    /**
     * Returns any text found in the image for the language specified. If no language is specified in input then the detection defaults to English.
     *
     * @param language Language of the terms.
     * @param imageStream The image file.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OCR object if successful.
     */
    public OCR oCRFileInput(String language, byte[] imageStream) {
        return oCRFileInputWithServiceResponseAsync(language, imageStream).toBlocking().single().body();
    }

    /**
     * Returns any text found in the image for the language specified. If no language is specified in input then the detection defaults to English.
     *
     * @param language Language of the terms.
     * @param imageStream The image file.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OCR> oCRFileInputAsync(String language, byte[] imageStream, final ServiceCallback<OCR> serviceCallback) {
        return ServiceFuture.fromResponse(oCRFileInputWithServiceResponseAsync(language, imageStream), serviceCallback);
    }

    /**
     * Returns any text found in the image for the language specified. If no language is specified in input then the detection defaults to English.
     *
     * @param language Language of the terms.
     * @param imageStream The image file.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OCR object
     */
    public Observable<OCR> oCRFileInputAsync(String language, byte[] imageStream) {
        return oCRFileInputWithServiceResponseAsync(language, imageStream).map(new Func1<ServiceResponse<OCR>, OCR>() {
            @Override
            public OCR call(ServiceResponse<OCR> response) {
                return response.body();
            }
        });
    }

    /**
     * Returns any text found in the image for the language specified. If no language is specified in input then the detection defaults to English.
     *
     * @param language Language of the terms.
     * @param imageStream The image file.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OCR object
     */
    public Observable<ServiceResponse<OCR>> oCRFileInputWithServiceResponseAsync(String language, byte[] imageStream) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (language == null) {
            throw new IllegalArgumentException("Parameter language is required and cannot be null.");
        }
        if (imageStream == null) {
            throw new IllegalArgumentException("Parameter imageStream is required and cannot be null.");
        }
        final Boolean cacheImage = null;
        final Boolean enhanced = null;
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        RequestBody imageStreamConverted = RequestBody.create(MediaType.parse("image/gif"), imageStream);
        return service.oCRFileInput(language, cacheImage, enhanced, imageStreamConverted, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OCR>>>() {
                @Override
                public Observable<ServiceResponse<OCR>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OCR> clientResponse = oCRFileInputDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Returns any text found in the image for the language specified. If no language is specified in input then the detection defaults to English.
     *
     * @param language Language of the terms.
     * @param imageStream The image file.
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @param enhanced When set to True, the image goes through additional processing to come with additional candidates.
     image/tiff is not supported when enhanced is set to true
     Note: This impacts the response time.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OCR object if successful.
     */
    public OCR oCRFileInput(String language, byte[] imageStream, Boolean cacheImage, Boolean enhanced) {
        return oCRFileInputWithServiceResponseAsync(language, imageStream, cacheImage, enhanced).toBlocking().single().body();
    }

    /**
     * Returns any text found in the image for the language specified. If no language is specified in input then the detection defaults to English.
     *
     * @param language Language of the terms.
     * @param imageStream The image file.
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @param enhanced When set to True, the image goes through additional processing to come with additional candidates.
     image/tiff is not supported when enhanced is set to true
     Note: This impacts the response time.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OCR> oCRFileInputAsync(String language, byte[] imageStream, Boolean cacheImage, Boolean enhanced, final ServiceCallback<OCR> serviceCallback) {
        return ServiceFuture.fromResponse(oCRFileInputWithServiceResponseAsync(language, imageStream, cacheImage, enhanced), serviceCallback);
    }

    /**
     * Returns any text found in the image for the language specified. If no language is specified in input then the detection defaults to English.
     *
     * @param language Language of the terms.
     * @param imageStream The image file.
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @param enhanced When set to True, the image goes through additional processing to come with additional candidates.
     image/tiff is not supported when enhanced is set to true
     Note: This impacts the response time.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OCR object
     */
    public Observable<OCR> oCRFileInputAsync(String language, byte[] imageStream, Boolean cacheImage, Boolean enhanced) {
        return oCRFileInputWithServiceResponseAsync(language, imageStream, cacheImage, enhanced).map(new Func1<ServiceResponse<OCR>, OCR>() {
            @Override
            public OCR call(ServiceResponse<OCR> response) {
                return response.body();
            }
        });
    }

    /**
     * Returns any text found in the image for the language specified. If no language is specified in input then the detection defaults to English.
     *
     * @param language Language of the terms.
     * @param imageStream The image file.
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @param enhanced When set to True, the image goes through additional processing to come with additional candidates.
     image/tiff is not supported when enhanced is set to true
     Note: This impacts the response time.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OCR object
     */
    public Observable<ServiceResponse<OCR>> oCRFileInputWithServiceResponseAsync(String language, byte[] imageStream, Boolean cacheImage, Boolean enhanced) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (language == null) {
            throw new IllegalArgumentException("Parameter language is required and cannot be null.");
        }
        if (imageStream == null) {
            throw new IllegalArgumentException("Parameter imageStream is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        RequestBody imageStreamConverted = RequestBody.create(MediaType.parse("image/gif"), imageStream);
        return service.oCRFileInput(language, cacheImage, enhanced, imageStreamConverted, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OCR>>>() {
                @Override
                public Observable<ServiceResponse<OCR>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OCR> clientResponse = oCRFileInputDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OCR> oCRFileInputDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OCR, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OCR>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }

    /**
     * Returns probabilities of the image containing racy or adult content.
     *
     * @param imageStream The image file.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Evaluate object if successful.
     */
    public Evaluate evaluateFileInput(byte[] imageStream) {
        return evaluateFileInputWithServiceResponseAsync(imageStream).toBlocking().single().body();
    }

    /**
     * Returns probabilities of the image containing racy or adult content.
     *
     * @param imageStream The image file.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Evaluate> evaluateFileInputAsync(byte[] imageStream, final ServiceCallback<Evaluate> serviceCallback) {
        return ServiceFuture.fromResponse(evaluateFileInputWithServiceResponseAsync(imageStream), serviceCallback);
    }

    /**
     * Returns probabilities of the image containing racy or adult content.
     *
     * @param imageStream The image file.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Evaluate object
     */
    public Observable<Evaluate> evaluateFileInputAsync(byte[] imageStream) {
        return evaluateFileInputWithServiceResponseAsync(imageStream).map(new Func1<ServiceResponse<Evaluate>, Evaluate>() {
            @Override
            public Evaluate call(ServiceResponse<Evaluate> response) {
                return response.body();
            }
        });
    }

    /**
     * Returns probabilities of the image containing racy or adult content.
     *
     * @param imageStream The image file.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Evaluate object
     */
    public Observable<ServiceResponse<Evaluate>> evaluateFileInputWithServiceResponseAsync(byte[] imageStream) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (imageStream == null) {
            throw new IllegalArgumentException("Parameter imageStream is required and cannot be null.");
        }
        final Boolean cacheImage = null;
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        RequestBody imageStreamConverted = RequestBody.create(MediaType.parse("image/gif"), imageStream);
        return service.evaluateFileInput(cacheImage, imageStreamConverted, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Evaluate>>>() {
                @Override
                public Observable<ServiceResponse<Evaluate>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Evaluate> clientResponse = evaluateFileInputDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Returns probabilities of the image containing racy or adult content.
     *
     * @param imageStream The image file.
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Evaluate object if successful.
     */
    public Evaluate evaluateFileInput(byte[] imageStream, Boolean cacheImage) {
        return evaluateFileInputWithServiceResponseAsync(imageStream, cacheImage).toBlocking().single().body();
    }

    /**
     * Returns probabilities of the image containing racy or adult content.
     *
     * @param imageStream The image file.
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Evaluate> evaluateFileInputAsync(byte[] imageStream, Boolean cacheImage, final ServiceCallback<Evaluate> serviceCallback) {
        return ServiceFuture.fromResponse(evaluateFileInputWithServiceResponseAsync(imageStream, cacheImage), serviceCallback);
    }

    /**
     * Returns probabilities of the image containing racy or adult content.
     *
     * @param imageStream The image file.
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Evaluate object
     */
    public Observable<Evaluate> evaluateFileInputAsync(byte[] imageStream, Boolean cacheImage) {
        return evaluateFileInputWithServiceResponseAsync(imageStream, cacheImage).map(new Func1<ServiceResponse<Evaluate>, Evaluate>() {
            @Override
            public Evaluate call(ServiceResponse<Evaluate> response) {
                return response.body();
            }
        });
    }

    /**
     * Returns probabilities of the image containing racy or adult content.
     *
     * @param imageStream The image file.
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Evaluate object
     */
    public Observable<ServiceResponse<Evaluate>> evaluateFileInputWithServiceResponseAsync(byte[] imageStream, Boolean cacheImage) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (imageStream == null) {
            throw new IllegalArgumentException("Parameter imageStream is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        RequestBody imageStreamConverted = RequestBody.create(MediaType.parse("image/gif"), imageStream);
        return service.evaluateFileInput(cacheImage, imageStreamConverted, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Evaluate>>>() {
                @Override
                public Observable<ServiceResponse<Evaluate>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Evaluate> clientResponse = evaluateFileInputDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Evaluate> evaluateFileInputDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Evaluate, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Evaluate>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }

    /**
     * Returns probabilities of the image containing racy or adult content.
     *
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Evaluate object if successful.
     */
    public Evaluate evaluateUrlInput(String contentType, ImageUrl imageUrl) {
        return evaluateUrlInputWithServiceResponseAsync(contentType, imageUrl).toBlocking().single().body();
    }

    /**
     * Returns probabilities of the image containing racy or adult content.
     *
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Evaluate> evaluateUrlInputAsync(String contentType, ImageUrl imageUrl, final ServiceCallback<Evaluate> serviceCallback) {
        return ServiceFuture.fromResponse(evaluateUrlInputWithServiceResponseAsync(contentType, imageUrl), serviceCallback);
    }

    /**
     * Returns probabilities of the image containing racy or adult content.
     *
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Evaluate object
     */
    public Observable<Evaluate> evaluateUrlInputAsync(String contentType, ImageUrl imageUrl) {
        return evaluateUrlInputWithServiceResponseAsync(contentType, imageUrl).map(new Func1<ServiceResponse<Evaluate>, Evaluate>() {
            @Override
            public Evaluate call(ServiceResponse<Evaluate> response) {
                return response.body();
            }
        });
    }

    /**
     * Returns probabilities of the image containing racy or adult content.
     *
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Evaluate object
     */
    public Observable<ServiceResponse<Evaluate>> evaluateUrlInputWithServiceResponseAsync(String contentType, ImageUrl imageUrl) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (contentType == null) {
            throw new IllegalArgumentException("Parameter contentType is required and cannot be null.");
        }
        if (imageUrl == null) {
            throw new IllegalArgumentException("Parameter imageUrl is required and cannot be null.");
        }
        Validator.validate(imageUrl);
        final Boolean cacheImage = null;
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.evaluateUrlInput(cacheImage, contentType, imageUrl, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Evaluate>>>() {
                @Override
                public Observable<ServiceResponse<Evaluate>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Evaluate> clientResponse = evaluateUrlInputDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Returns probabilities of the image containing racy or adult content.
     *
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Evaluate object if successful.
     */
    public Evaluate evaluateUrlInput(String contentType, ImageUrl imageUrl, Boolean cacheImage) {
        return evaluateUrlInputWithServiceResponseAsync(contentType, imageUrl, cacheImage).toBlocking().single().body();
    }

    /**
     * Returns probabilities of the image containing racy or adult content.
     *
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Evaluate> evaluateUrlInputAsync(String contentType, ImageUrl imageUrl, Boolean cacheImage, final ServiceCallback<Evaluate> serviceCallback) {
        return ServiceFuture.fromResponse(evaluateUrlInputWithServiceResponseAsync(contentType, imageUrl, cacheImage), serviceCallback);
    }

    /**
     * Returns probabilities of the image containing racy or adult content.
     *
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Evaluate object
     */
    public Observable<Evaluate> evaluateUrlInputAsync(String contentType, ImageUrl imageUrl, Boolean cacheImage) {
        return evaluateUrlInputWithServiceResponseAsync(contentType, imageUrl, cacheImage).map(new Func1<ServiceResponse<Evaluate>, Evaluate>() {
            @Override
            public Evaluate call(ServiceResponse<Evaluate> response) {
                return response.body();
            }
        });
    }

    /**
     * Returns probabilities of the image containing racy or adult content.
     *
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Evaluate object
     */
    public Observable<ServiceResponse<Evaluate>> evaluateUrlInputWithServiceResponseAsync(String contentType, ImageUrl imageUrl, Boolean cacheImage) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (contentType == null) {
            throw new IllegalArgumentException("Parameter contentType is required and cannot be null.");
        }
        if (imageUrl == null) {
            throw new IllegalArgumentException("Parameter imageUrl is required and cannot be null.");
        }
        Validator.validate(imageUrl);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.evaluateUrlInput(cacheImage, contentType, imageUrl, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Evaluate>>>() {
                @Override
                public Observable<ServiceResponse<Evaluate>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Evaluate> clientResponse = evaluateUrlInputDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Evaluate> evaluateUrlInputDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Evaluate, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Evaluate>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }

    /**
     * Fuzzily match an image against one of your custom Image Lists. You can create and manage your custom image lists using &lt;a href="/docs/services/578ff44d2703741568569ab9/operations/578ff7b12703741568569abe"&gt;this&lt;/a&gt; API.
     Returns ID and tags of matching image.&lt;br/&gt;
     &lt;br/&gt;
     Note: Refresh Index must be run on the corresponding Image List before additions and removals are reflected in the response.
     *
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MatchResponse object if successful.
     */
    public MatchResponse matchUrlInput(String contentType, ImageUrl imageUrl) {
        return matchUrlInputWithServiceResponseAsync(contentType, imageUrl).toBlocking().single().body();
    }

    /**
     * Fuzzily match an image against one of your custom Image Lists. You can create and manage your custom image lists using &lt;a href="/docs/services/578ff44d2703741568569ab9/operations/578ff7b12703741568569abe"&gt;this&lt;/a&gt; API.
     Returns ID and tags of matching image.&lt;br/&gt;
     &lt;br/&gt;
     Note: Refresh Index must be run on the corresponding Image List before additions and removals are reflected in the response.
     *
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MatchResponse> matchUrlInputAsync(String contentType, ImageUrl imageUrl, final ServiceCallback<MatchResponse> serviceCallback) {
        return ServiceFuture.fromResponse(matchUrlInputWithServiceResponseAsync(contentType, imageUrl), serviceCallback);
    }

    /**
     * Fuzzily match an image against one of your custom Image Lists. You can create and manage your custom image lists using &lt;a href="/docs/services/578ff44d2703741568569ab9/operations/578ff7b12703741568569abe"&gt;this&lt;/a&gt; API.
     Returns ID and tags of matching image.&lt;br/&gt;
     &lt;br/&gt;
     Note: Refresh Index must be run on the corresponding Image List before additions and removals are reflected in the response.
     *
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MatchResponse object
     */
    public Observable<MatchResponse> matchUrlInputAsync(String contentType, ImageUrl imageUrl) {
        return matchUrlInputWithServiceResponseAsync(contentType, imageUrl).map(new Func1<ServiceResponse<MatchResponse>, MatchResponse>() {
            @Override
            public MatchResponse call(ServiceResponse<MatchResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * Fuzzily match an image against one of your custom Image Lists. You can create and manage your custom image lists using &lt;a href="/docs/services/578ff44d2703741568569ab9/operations/578ff7b12703741568569abe"&gt;this&lt;/a&gt; API.
     Returns ID and tags of matching image.&lt;br/&gt;
     &lt;br/&gt;
     Note: Refresh Index must be run on the corresponding Image List before additions and removals are reflected in the response.
     *
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MatchResponse object
     */
    public Observable<ServiceResponse<MatchResponse>> matchUrlInputWithServiceResponseAsync(String contentType, ImageUrl imageUrl) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (contentType == null) {
            throw new IllegalArgumentException("Parameter contentType is required and cannot be null.");
        }
        if (imageUrl == null) {
            throw new IllegalArgumentException("Parameter imageUrl is required and cannot be null.");
        }
        Validator.validate(imageUrl);
        final String listId = null;
        final Boolean cacheImage = null;
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.matchUrlInput(listId, cacheImage, contentType, imageUrl, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<MatchResponse>>>() {
                @Override
                public Observable<ServiceResponse<MatchResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<MatchResponse> clientResponse = matchUrlInputDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Fuzzily match an image against one of your custom Image Lists. You can create and manage your custom image lists using &lt;a href="/docs/services/578ff44d2703741568569ab9/operations/578ff7b12703741568569abe"&gt;this&lt;/a&gt; API.
     Returns ID and tags of matching image.&lt;br/&gt;
     &lt;br/&gt;
     Note: Refresh Index must be run on the corresponding Image List before additions and removals are reflected in the response.
     *
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @param listId The list Id.
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MatchResponse object if successful.
     */
    public MatchResponse matchUrlInput(String contentType, ImageUrl imageUrl, String listId, Boolean cacheImage) {
        return matchUrlInputWithServiceResponseAsync(contentType, imageUrl, listId, cacheImage).toBlocking().single().body();
    }

    /**
     * Fuzzily match an image against one of your custom Image Lists. You can create and manage your custom image lists using &lt;a href="/docs/services/578ff44d2703741568569ab9/operations/578ff7b12703741568569abe"&gt;this&lt;/a&gt; API.
     Returns ID and tags of matching image.&lt;br/&gt;
     &lt;br/&gt;
     Note: Refresh Index must be run on the corresponding Image List before additions and removals are reflected in the response.
     *
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @param listId The list Id.
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MatchResponse> matchUrlInputAsync(String contentType, ImageUrl imageUrl, String listId, Boolean cacheImage, final ServiceCallback<MatchResponse> serviceCallback) {
        return ServiceFuture.fromResponse(matchUrlInputWithServiceResponseAsync(contentType, imageUrl, listId, cacheImage), serviceCallback);
    }

    /**
     * Fuzzily match an image against one of your custom Image Lists. You can create and manage your custom image lists using &lt;a href="/docs/services/578ff44d2703741568569ab9/operations/578ff7b12703741568569abe"&gt;this&lt;/a&gt; API.
     Returns ID and tags of matching image.&lt;br/&gt;
     &lt;br/&gt;
     Note: Refresh Index must be run on the corresponding Image List before additions and removals are reflected in the response.
     *
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @param listId The list Id.
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MatchResponse object
     */
    public Observable<MatchResponse> matchUrlInputAsync(String contentType, ImageUrl imageUrl, String listId, Boolean cacheImage) {
        return matchUrlInputWithServiceResponseAsync(contentType, imageUrl, listId, cacheImage).map(new Func1<ServiceResponse<MatchResponse>, MatchResponse>() {
            @Override
            public MatchResponse call(ServiceResponse<MatchResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * Fuzzily match an image against one of your custom Image Lists. You can create and manage your custom image lists using &lt;a href="/docs/services/578ff44d2703741568569ab9/operations/578ff7b12703741568569abe"&gt;this&lt;/a&gt; API.
     Returns ID and tags of matching image.&lt;br/&gt;
     &lt;br/&gt;
     Note: Refresh Index must be run on the corresponding Image List before additions and removals are reflected in the response.
     *
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @param listId The list Id.
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MatchResponse object
     */
    public Observable<ServiceResponse<MatchResponse>> matchUrlInputWithServiceResponseAsync(String contentType, ImageUrl imageUrl, String listId, Boolean cacheImage) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (contentType == null) {
            throw new IllegalArgumentException("Parameter contentType is required and cannot be null.");
        }
        if (imageUrl == null) {
            throw new IllegalArgumentException("Parameter imageUrl is required and cannot be null.");
        }
        Validator.validate(imageUrl);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.matchUrlInput(listId, cacheImage, contentType, imageUrl, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<MatchResponse>>>() {
                @Override
                public Observable<ServiceResponse<MatchResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<MatchResponse> clientResponse = matchUrlInputDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<MatchResponse> matchUrlInputDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<MatchResponse, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<MatchResponse>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }

    /**
     * Fuzzily match an image against one of your custom Image Lists. You can create and manage your custom image lists using &lt;a href="/docs/services/578ff44d2703741568569ab9/operations/578ff7b12703741568569abe"&gt;this&lt;/a&gt; API.
     Returns ID and tags of matching image.&lt;br/&gt;
     &lt;br/&gt;
     Note: Refresh Index must be run on the corresponding Image List before additions and removals are reflected in the response.
     *
     * @param imageStream The image file.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MatchResponse object if successful.
     */
    public MatchResponse matchFileInput(byte[] imageStream) {
        return matchFileInputWithServiceResponseAsync(imageStream).toBlocking().single().body();
    }

    /**
     * Fuzzily match an image against one of your custom Image Lists. You can create and manage your custom image lists using &lt;a href="/docs/services/578ff44d2703741568569ab9/operations/578ff7b12703741568569abe"&gt;this&lt;/a&gt; API.
     Returns ID and tags of matching image.&lt;br/&gt;
     &lt;br/&gt;
     Note: Refresh Index must be run on the corresponding Image List before additions and removals are reflected in the response.
     *
     * @param imageStream The image file.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MatchResponse> matchFileInputAsync(byte[] imageStream, final ServiceCallback<MatchResponse> serviceCallback) {
        return ServiceFuture.fromResponse(matchFileInputWithServiceResponseAsync(imageStream), serviceCallback);
    }

    /**
     * Fuzzily match an image against one of your custom Image Lists. You can create and manage your custom image lists using &lt;a href="/docs/services/578ff44d2703741568569ab9/operations/578ff7b12703741568569abe"&gt;this&lt;/a&gt; API.
     Returns ID and tags of matching image.&lt;br/&gt;
     &lt;br/&gt;
     Note: Refresh Index must be run on the corresponding Image List before additions and removals are reflected in the response.
     *
     * @param imageStream The image file.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MatchResponse object
     */
    public Observable<MatchResponse> matchFileInputAsync(byte[] imageStream) {
        return matchFileInputWithServiceResponseAsync(imageStream).map(new Func1<ServiceResponse<MatchResponse>, MatchResponse>() {
            @Override
            public MatchResponse call(ServiceResponse<MatchResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * Fuzzily match an image against one of your custom Image Lists. You can create and manage your custom image lists using &lt;a href="/docs/services/578ff44d2703741568569ab9/operations/578ff7b12703741568569abe"&gt;this&lt;/a&gt; API.
     Returns ID and tags of matching image.&lt;br/&gt;
     &lt;br/&gt;
     Note: Refresh Index must be run on the corresponding Image List before additions and removals are reflected in the response.
     *
     * @param imageStream The image file.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MatchResponse object
     */
    public Observable<ServiceResponse<MatchResponse>> matchFileInputWithServiceResponseAsync(byte[] imageStream) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (imageStream == null) {
            throw new IllegalArgumentException("Parameter imageStream is required and cannot be null.");
        }
        final String listId = null;
        final Boolean cacheImage = null;
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        RequestBody imageStreamConverted = RequestBody.create(MediaType.parse("image/gif"), imageStream);
        return service.matchFileInput(listId, cacheImage, imageStreamConverted, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<MatchResponse>>>() {
                @Override
                public Observable<ServiceResponse<MatchResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<MatchResponse> clientResponse = matchFileInputDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Fuzzily match an image against one of your custom Image Lists. You can create and manage your custom image lists using &lt;a href="/docs/services/578ff44d2703741568569ab9/operations/578ff7b12703741568569abe"&gt;this&lt;/a&gt; API.
     Returns ID and tags of matching image.&lt;br/&gt;
     &lt;br/&gt;
     Note: Refresh Index must be run on the corresponding Image List before additions and removals are reflected in the response.
     *
     * @param imageStream The image file.
     * @param listId The list Id.
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MatchResponse object if successful.
     */
    public MatchResponse matchFileInput(byte[] imageStream, String listId, Boolean cacheImage) {
        return matchFileInputWithServiceResponseAsync(imageStream, listId, cacheImage).toBlocking().single().body();
    }

    /**
     * Fuzzily match an image against one of your custom Image Lists. You can create and manage your custom image lists using &lt;a href="/docs/services/578ff44d2703741568569ab9/operations/578ff7b12703741568569abe"&gt;this&lt;/a&gt; API.
     Returns ID and tags of matching image.&lt;br/&gt;
     &lt;br/&gt;
     Note: Refresh Index must be run on the corresponding Image List before additions and removals are reflected in the response.
     *
     * @param imageStream The image file.
     * @param listId The list Id.
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MatchResponse> matchFileInputAsync(byte[] imageStream, String listId, Boolean cacheImage, final ServiceCallback<MatchResponse> serviceCallback) {
        return ServiceFuture.fromResponse(matchFileInputWithServiceResponseAsync(imageStream, listId, cacheImage), serviceCallback);
    }

    /**
     * Fuzzily match an image against one of your custom Image Lists. You can create and manage your custom image lists using &lt;a href="/docs/services/578ff44d2703741568569ab9/operations/578ff7b12703741568569abe"&gt;this&lt;/a&gt; API.
     Returns ID and tags of matching image.&lt;br/&gt;
     &lt;br/&gt;
     Note: Refresh Index must be run on the corresponding Image List before additions and removals are reflected in the response.
     *
     * @param imageStream The image file.
     * @param listId The list Id.
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MatchResponse object
     */
    public Observable<MatchResponse> matchFileInputAsync(byte[] imageStream, String listId, Boolean cacheImage) {
        return matchFileInputWithServiceResponseAsync(imageStream, listId, cacheImage).map(new Func1<ServiceResponse<MatchResponse>, MatchResponse>() {
            @Override
            public MatchResponse call(ServiceResponse<MatchResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * Fuzzily match an image against one of your custom Image Lists. You can create and manage your custom image lists using &lt;a href="/docs/services/578ff44d2703741568569ab9/operations/578ff7b12703741568569abe"&gt;this&lt;/a&gt; API.
     Returns ID and tags of matching image.&lt;br/&gt;
     &lt;br/&gt;
     Note: Refresh Index must be run on the corresponding Image List before additions and removals are reflected in the response.
     *
     * @param imageStream The image file.
     * @param listId The list Id.
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MatchResponse object
     */
    public Observable<ServiceResponse<MatchResponse>> matchFileInputWithServiceResponseAsync(byte[] imageStream, String listId, Boolean cacheImage) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (imageStream == null) {
            throw new IllegalArgumentException("Parameter imageStream is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        RequestBody imageStreamConverted = RequestBody.create(MediaType.parse("image/gif"), imageStream);
        return service.matchFileInput(listId, cacheImage, imageStreamConverted, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<MatchResponse>>>() {
                @Override
                public Observable<ServiceResponse<MatchResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<MatchResponse> clientResponse = matchFileInputDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<MatchResponse> matchFileInputDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<MatchResponse, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<MatchResponse>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }

}
