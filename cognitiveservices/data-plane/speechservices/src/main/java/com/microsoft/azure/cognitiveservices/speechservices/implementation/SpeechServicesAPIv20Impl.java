/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.cognitiveservices.speechservices.implementation;

import com.google.common.reflect.TypeToken;
import com.microsoft.azure.AzureClient;
import com.microsoft.azure.AzureServiceClient;
import com.microsoft.azure.CloudException;
import com.microsoft.azure.cognitiveservices.speechservices.models.CreateAccuracyTestHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.CreateEndpointDataExportHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.CreateEndpointHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.CreateLanguageGenerationEndpointHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.CreateLanguageGenerationModelHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.CreateModelHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.CreateTranscriptionHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.CreateVoiceDeploymentHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.CreateVoiceModelHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.CreateVoiceTestHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.Dataset;
import com.microsoft.azure.cognitiveservices.speechservices.models.DatasetUpdate;
import com.microsoft.azure.cognitiveservices.speechservices.models.DeleteAccuracyTestHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.DeleteDatasetHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.DeleteDeploymentHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.DeleteEndpointDataExportHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.DeleteEndpointDataHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.DeleteEndpointHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.DeleteLanguageGenerationEndpointHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.DeleteLanguageGenerationModelHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.DeleteModelHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.DeleteTranscriptionHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.DeleteVoiceDatasetHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.DeleteVoiceModelHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.DeleteVoiceTestHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.Endpoint;
import com.microsoft.azure.cognitiveservices.speechservices.models.EndpointData;
import com.microsoft.azure.cognitiveservices.speechservices.models.EndpointDataDefinition;
import com.microsoft.azure.cognitiveservices.speechservices.models.EndpointDefinition;
import com.microsoft.azure.cognitiveservices.speechservices.models.EndpointUpdate;
import com.microsoft.azure.cognitiveservices.speechservices.models.ErrorContent;
import com.microsoft.azure.cognitiveservices.speechservices.models.GetAccuracyTestHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.GetAccuracyTestsHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.GetDatasetHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.GetDatasetsHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.GetEndpointDataExportHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.GetEndpointDataExportsHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.GetEndpointHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.GetEndpointsHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.GetHealthStatusHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.GetLanguageGenerationEndpointHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.GetLanguageGenerationEndpointsHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.GetLanguageGenerationModelHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.GetLanguageGenerationModelsHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.GetModelHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.GetModelsHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.GetSupportedLocalesForDatasetsHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.GetSupportedLocalesForDatasetsOKResponse;
import com.microsoft.azure.cognitiveservices.speechservices.models.GetSupportedLocalesForEndpointsHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.GetSupportedLocalesForLanguageGenerationEndpointsHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.GetSupportedLocalesForLanguageGenerationModelsHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.GetSupportedLocalesForModelsHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.GetSupportedLocalesForModelsOKResponse;
import com.microsoft.azure.cognitiveservices.speechservices.models.GetSupportedLocalesForTranscriptionsHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.GetSupportedLocalesForVoiceDatasetsHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.GetSupportedLocalesForVoiceEndpointsHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.GetSupportedLocalesForVoiceModelsHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.GetTranscriptionHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.GetTranscriptionsHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.GetVoiceDatasetsHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.GetVoiceDeploymentHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.GetVoiceDeploymentsHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.GetVoiceModelHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.GetVoiceModelsHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.GetVoiceTestHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.HealthStatusResponse;
import com.microsoft.azure.cognitiveservices.speechservices.models.Model;
import com.microsoft.azure.cognitiveservices.speechservices.models.ModelDefinition;
import com.microsoft.azure.cognitiveservices.speechservices.models.ModelUpdate;
import com.microsoft.azure.cognitiveservices.speechservices.models.SpeechEndpointDefinition;
import com.microsoft.azure.cognitiveservices.speechservices.models.SpeechModelDefinition;
import com.microsoft.azure.cognitiveservices.speechservices.models.Test;
import com.microsoft.azure.cognitiveservices.speechservices.models.TestDefinition;
import com.microsoft.azure.cognitiveservices.speechservices.models.TestUpdate;
import com.microsoft.azure.cognitiveservices.speechservices.models.Transcription;
import com.microsoft.azure.cognitiveservices.speechservices.models.TranscriptionDefinition;
import com.microsoft.azure.cognitiveservices.speechservices.models.TranscriptionUpdate;
import com.microsoft.azure.cognitiveservices.speechservices.models.UpdateAccuracyTestHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.UpdateDatasetHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.UpdateEndpointHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.UpdateLanguageGenerationEndpointHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.UpdateLanguageGenerationModelHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.UpdateModelHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.UpdateTranscriptionHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.UpdateVoiceDatasetHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.UpdateVoiceEndpointHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.UpdateVoiceModelHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.UploadDatasetHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.UploadVoiceDatasetHeaders;
import com.microsoft.azure.cognitiveservices.speechservices.models.VoiceTest;
import com.microsoft.azure.cognitiveservices.speechservices.models.VoiceTestDefinition;
import com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20;
import com.microsoft.rest.credentials.ServiceClientCredentials;
import com.microsoft.rest.RestClient;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponseWithHeaders;
import com.microsoft.rest.Validator;
import java.io.InputStream;
import java.io.IOException;
import java.util.List;
import java.util.UUID;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.Multipart;
import retrofit2.http.Part;
import retrofit2.http.PATCH;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * Initializes a new instance of the SpeechServicesAPIv20Impl class.
 */
public class SpeechServicesAPIv20Impl extends AzureServiceClient implements SpeechServicesAPIv20 {
    /** The Retrofit service to perform REST calls. */
    private SpeechServicesAPIv20Service service;
    /** the {@link AzureClient} used for long running operations. */
    private AzureClient azureClient;

    /**
     * Gets the {@link AzureClient} used for long running operations.
     * @return the azure client;
     */
    public AzureClient getAzureClient() {
        return this.azureClient;
    }

    /** The preferred language for the response. */
    private String acceptLanguage;

    /**
     * Gets The preferred language for the response.
     *
     * @return the acceptLanguage value.
     */
    public String acceptLanguage() {
        return this.acceptLanguage;
    }

    /**
     * Sets The preferred language for the response.
     *
     * @param acceptLanguage the acceptLanguage value.
     * @return the service client itself
     */
    public SpeechServicesAPIv20Impl withAcceptLanguage(String acceptLanguage) {
        this.acceptLanguage = acceptLanguage;
        return this;
    }

    /** The retry timeout in seconds for Long Running Operations. Default value is 30. */
    private int longRunningOperationRetryTimeout;

    /**
     * Gets The retry timeout in seconds for Long Running Operations. Default value is 30.
     *
     * @return the longRunningOperationRetryTimeout value.
     */
    public int longRunningOperationRetryTimeout() {
        return this.longRunningOperationRetryTimeout;
    }

    /**
     * Sets The retry timeout in seconds for Long Running Operations. Default value is 30.
     *
     * @param longRunningOperationRetryTimeout the longRunningOperationRetryTimeout value.
     * @return the service client itself
     */
    public SpeechServicesAPIv20Impl withLongRunningOperationRetryTimeout(int longRunningOperationRetryTimeout) {
        this.longRunningOperationRetryTimeout = longRunningOperationRetryTimeout;
        return this;
    }

    /** Whether a unique x-ms-client-request-id should be generated. When set to true a unique x-ms-client-request-id value is generated and included in each request. Default is true. */
    private boolean generateClientRequestId;

    /**
     * Gets Whether a unique x-ms-client-request-id should be generated. When set to true a unique x-ms-client-request-id value is generated and included in each request. Default is true.
     *
     * @return the generateClientRequestId value.
     */
    public boolean generateClientRequestId() {
        return this.generateClientRequestId;
    }

    /**
     * Sets Whether a unique x-ms-client-request-id should be generated. When set to true a unique x-ms-client-request-id value is generated and included in each request. Default is true.
     *
     * @param generateClientRequestId the generateClientRequestId value.
     * @return the service client itself
     */
    public SpeechServicesAPIv20Impl withGenerateClientRequestId(boolean generateClientRequestId) {
        this.generateClientRequestId = generateClientRequestId;
        return this;
    }

    /**
     * Initializes an instance of SpeechServicesAPIv20 client.
     *
     * @param credentials the management credentials for Azure
     */
    public SpeechServicesAPIv20Impl(ServiceClientCredentials credentials) {
        this("https://westus.cris.ai", credentials);
    }

    /**
     * Initializes an instance of SpeechServicesAPIv20 client.
     *
     * @param baseUrl the base URL of the host
     * @param credentials the management credentials for Azure
     */
    public SpeechServicesAPIv20Impl(String baseUrl, ServiceClientCredentials credentials) {
        super(baseUrl, credentials);
        initialize();
    }

    /**
     * Initializes an instance of SpeechServicesAPIv20 client.
     *
     * @param restClient the REST client to connect to Azure.
     */
    public SpeechServicesAPIv20Impl(RestClient restClient) {
        super(restClient);
        initialize();
    }

    protected void initialize() {
        this.acceptLanguage = "en-US";
        this.longRunningOperationRetryTimeout = 30;
        this.generateClientRequestId = true;
        this.azureClient = new AzureClient(this);
        initializeService();
    }

    /**
     * Gets the User-Agent header for the client.
     *
     * @return the user agent string.
     */
    @Override
    public String userAgent() {
        return String.format("%s (%s, %s)", super.userAgent(), "SpeechServicesAPIv20", "v2.0");
    }

    private void initializeService() {
        service = restClient().retrofit().create(SpeechServicesAPIv20Service.class);
    }

    /**
     * The interface defining all the services for SpeechServicesAPIv20 to be
     * used by Retrofit to perform actually REST calls.
     */
    interface SpeechServicesAPIv20Service {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 getAccuracyTests" })
        @GET("api/speechtotext/v2.0/accuracytests")
        Observable<Response<ResponseBody>> getAccuracyTests(@Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 createAccuracyTest" })
        @POST("api/speechtotext/v2.0/accuracytests")
        Observable<Response<ResponseBody>> createAccuracyTest(@Body TestDefinition testDefinition, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 getAccuracyTest" })
        @GET("api/speechtotext/v2.0/accuracytests/{id}")
        Observable<Response<ResponseBody>> getAccuracyTest(@Path("id") UUID id, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 deleteAccuracyTest" })
        @HTTP(path = "api/speechtotext/v2.0/accuracytests/{id}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteAccuracyTest(@Path("id") UUID id, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 updateAccuracyTest" })
        @PATCH("api/speechtotext/v2.0/accuracytests/{id}")
        Observable<Response<ResponseBody>> updateAccuracyTest(@Path("id") UUID id, @Body TestUpdate testUpdate, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 getDatasets" })
        @GET("api/speechtotext/v2.0/datasets")
        Observable<Response<ResponseBody>> getDatasets(@Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 getDataset" })
        @GET("api/speechtotext/v2.0/datasets/{id}")
        Observable<Response<ResponseBody>> getDataset(@Path("id") UUID id, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 deleteDataset" })
        @HTTP(path = "api/speechtotext/v2.0/datasets/{id}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteDataset(@Path("id") UUID id, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 updateDataset" })
        @PATCH("api/speechtotext/v2.0/datasets/{id}")
        Observable<Response<ResponseBody>> updateDataset(@Path("id") UUID id, @Body DatasetUpdate datasetUpdate, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 getSupportedLocalesForDatasets" })
        @GET("api/speechtotext/v2.0/datasets/locales")
        Observable<Response<ResponseBody>> getSupportedLocalesForDatasets(@Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Multipart
        @POST("api/speechtotext/v2.0/datasets/upload")
        Observable<Response<ResponseBody>> uploadDataset(@Part("name") String name, @Part("description") String description, @Part("locale") String locale, @Part("dataImportKind") String dataImportKind, @Part("properties") String properties, @Part("audiodata") RequestBody audiodata, @Part("transcriptions") RequestBody transcriptions, @Part("languagedata") RequestBody languagedata, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 getEndpoints" })
        @GET("api/speechtotext/v2.0/endpoints")
        Observable<Response<ResponseBody>> getEndpoints(@Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 createEndpoint" })
        @POST("api/speechtotext/v2.0/endpoints")
        Observable<Response<ResponseBody>> createEndpoint(@Body SpeechEndpointDefinition endpointDefinition, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 getEndpoint" })
        @GET("api/speechtotext/v2.0/endpoints/{id}")
        Observable<Response<ResponseBody>> getEndpoint(@Path("id") UUID id, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 deleteEndpoint" })
        @HTTP(path = "api/speechtotext/v2.0/endpoints/{id}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteEndpoint(@Path("id") UUID id, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 updateEndpoint" })
        @PATCH("api/speechtotext/v2.0/endpoints/{id}")
        Observable<Response<ResponseBody>> updateEndpoint(@Path("id") UUID id, @Body EndpointUpdate endpointUpdate, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 getSupportedLocalesForEndpoints" })
        @GET("api/speechtotext/v2.0/endpoints/locales")
        Observable<Response<ResponseBody>> getSupportedLocalesForEndpoints(@Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 getEndpointDataExports" })
        @GET("api/speechtotext/v2.0/endpoints/{endpointId}/data")
        Observable<Response<ResponseBody>> getEndpointDataExports(@Path("endpointId") UUID endpointId, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 createEndpointDataExport" })
        @POST("api/speechtotext/v2.0/endpoints/{endpointId}/data")
        Observable<Response<ResponseBody>> createEndpointDataExport(@Path("endpointId") UUID endpointId, @Body EndpointDataDefinition endpointDataDefinition, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 deleteEndpointData" })
        @HTTP(path = "api/speechtotext/v2.0/endpoints/{endpointId}/data", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteEndpointData(@Path("endpointId") UUID endpointId, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 getEndpointDataExport" })
        @GET("api/speechtotext/v2.0/endpoints/{endpointId}/data/{id}")
        Observable<Response<ResponseBody>> getEndpointDataExport(@Path("endpointId") UUID endpointId, @Path("id") UUID id, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 deleteEndpointDataExport" })
        @HTTP(path = "api/speechtotext/v2.0/endpoints/{endpointId}/data/{id}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteEndpointDataExport(@Path("endpointId") UUID endpointId, @Path("id") UUID id, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 getModels" })
        @GET("api/speechtotext/v2.0/models")
        Observable<Response<ResponseBody>> getModels(@Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 createModel" })
        @POST("api/speechtotext/v2.0/models")
        Observable<Response<ResponseBody>> createModel(@Body SpeechModelDefinition modelDefinition, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 getModel" })
        @GET("api/speechtotext/v2.0/models/{id}")
        Observable<Response<ResponseBody>> getModel(@Path("id") UUID id, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 deleteModel" })
        @HTTP(path = "api/speechtotext/v2.0/models/{id}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteModel(@Path("id") UUID id, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 updateModel" })
        @PATCH("api/speechtotext/v2.0/models/{id}")
        Observable<Response<ResponseBody>> updateModel(@Path("id") UUID id, @Body ModelUpdate modelUpdate, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 getSupportedLocalesForModels" })
        @GET("api/speechtotext/v2.0/models/locales")
        Observable<Response<ResponseBody>> getSupportedLocalesForModels(@Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 getTranscriptions" })
        @GET("api/speechtotext/v2.0/transcriptions")
        Observable<Response<ResponseBody>> getTranscriptions(@Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 createTranscription" })
        @POST("api/speechtotext/v2.0/transcriptions")
        Observable<Response<ResponseBody>> createTranscription(@Body TranscriptionDefinition transcription, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 getTranscription" })
        @GET("api/speechtotext/v2.0/transcriptions/{id}")
        Observable<Response<ResponseBody>> getTranscription(@Path("id") UUID id, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 deleteTranscription" })
        @HTTP(path = "api/speechtotext/v2.0/transcriptions/{id}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteTranscription(@Path("id") UUID id, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 updateTranscription" })
        @PATCH("api/speechtotext/v2.0/transcriptions/{id}")
        Observable<Response<ResponseBody>> updateTranscription(@Path("id") UUID id, @Body TranscriptionUpdate transcriptionUpdate, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 getSupportedLocalesForTranscriptions" })
        @GET("api/speechtotext/v2.0/transcriptions/locales")
        Observable<Response<ResponseBody>> getSupportedLocalesForTranscriptions(@Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 getLanguageGenerationEndpoints" })
        @GET("api/languagegeneration/v2.0/Endpoints")
        Observable<Response<ResponseBody>> getLanguageGenerationEndpoints(@Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 createLanguageGenerationEndpoint" })
        @POST("api/languagegeneration/v2.0/Endpoints")
        Observable<Response<ResponseBody>> createLanguageGenerationEndpoint(@Body EndpointDefinition endpointDefinition, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 getLanguageGenerationEndpoint" })
        @GET("api/languagegeneration/v2.0/Endpoints/{id}")
        Observable<Response<ResponseBody>> getLanguageGenerationEndpoint(@Path("id") UUID id, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 deleteLanguageGenerationEndpoint" })
        @HTTP(path = "api/languagegeneration/v2.0/Endpoints/{id}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteLanguageGenerationEndpoint(@Path("id") UUID id, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 updateLanguageGenerationEndpoint" })
        @PATCH("api/languagegeneration/v2.0/Endpoints/{id}")
        Observable<Response<ResponseBody>> updateLanguageGenerationEndpoint(@Path("id") UUID id, @Body EndpointUpdate endpointUpdate, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 getSupportedLocalesForLanguageGenerationEndpoints" })
        @GET("api/languagegeneration/v2.0/Endpoints/locales")
        Observable<Response<ResponseBody>> getSupportedLocalesForLanguageGenerationEndpoints(@Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 getLanguageGenerationModels" })
        @GET("api/languagegeneration/v2.0/Models")
        Observable<Response<ResponseBody>> getLanguageGenerationModels(@Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 createLanguageGenerationModel" })
        @POST("api/languagegeneration/v2.0/Models")
        Observable<Response<ResponseBody>> createLanguageGenerationModel(@Body ModelDefinition modelDefinition, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 getLanguageGenerationModel" })
        @GET("api/languagegeneration/v2.0/Models/{id}")
        Observable<Response<ResponseBody>> getLanguageGenerationModel(@Path("id") UUID id, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 deleteLanguageGenerationModel" })
        @HTTP(path = "api/languagegeneration/v2.0/Models/{id}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteLanguageGenerationModel(@Path("id") UUID id, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 updateLanguageGenerationModel" })
        @PATCH("api/languagegeneration/v2.0/Models/{id}")
        Observable<Response<ResponseBody>> updateLanguageGenerationModel(@Path("id") UUID id, @Body ModelUpdate modelUpdate, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 getSupportedLocalesForLanguageGenerationModels" })
        @GET("api/languagegeneration/v2.0/Models/locales")
        Observable<Response<ResponseBody>> getSupportedLocalesForLanguageGenerationModels(@Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 getHealthStatus" })
        @GET("api/common/v2.0/healthstatus")
        Observable<Response<ResponseBody>> getHealthStatus(@Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 getVoiceDatasets" })
        @GET("api/texttospeech/v2.0/datasets")
        Observable<Response<ResponseBody>> getVoiceDatasets(@Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 getSupportedLocalesForVoiceDatasets" })
        @GET("api/texttospeech/v2.0/datasets/locales")
        Observable<Response<ResponseBody>> getSupportedLocalesForVoiceDatasets(@Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Multipart
        @POST("api/texttospeech/v2.0/datasets/upload")
        Observable<Response<ResponseBody>> uploadVoiceDataset(@Part("name") String name, @Part("description") String description, @Part("locale") String locale, @Part("dataImportKind") String dataImportKind, @Part("properties") String properties, @Part("audiodata") RequestBody audiodata, @Part("transcriptions") RequestBody transcriptions, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 deleteVoiceDataset" })
        @HTTP(path = "api/texttospeech/v2.0/datasets/{id}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteVoiceDataset(@Path("id") UUID id, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 updateVoiceDataset" })
        @PATCH("api/texttospeech/v2.0/datasets/{id}")
        Observable<Response<ResponseBody>> updateVoiceDataset(@Path("id") UUID id, @Body DatasetUpdate datasetUpdate, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 getVoiceDeployments" })
        @GET("api/texttospeech/v2.0/endpoints")
        Observable<Response<ResponseBody>> getVoiceDeployments(@Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 createVoiceDeployment" })
        @POST("api/texttospeech/v2.0/endpoints")
        Observable<Response<ResponseBody>> createVoiceDeployment(@Body EndpointDefinition endpoint, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 getVoiceDeployment" })
        @GET("api/texttospeech/v2.0/endpoints/{id}")
        Observable<Response<ResponseBody>> getVoiceDeployment(@Path("id") UUID id, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 deleteDeployment" })
        @HTTP(path = "api/texttospeech/v2.0/endpoints/{id}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteDeployment(@Path("id") UUID id, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 updateVoiceEndpoint" })
        @PATCH("api/texttospeech/v2.0/endpoints/{id}")
        Observable<Response<ResponseBody>> updateVoiceEndpoint(@Path("id") UUID id, @Body EndpointUpdate endpointUpdate, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 getSupportedLocalesForVoiceEndpoints" })
        @GET("api/texttospeech/v2.0/endpoints/locales")
        Observable<Response<ResponseBody>> getSupportedLocalesForVoiceEndpoints(@Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 getVoiceModels" })
        @GET("api/texttospeech/v2.0/models")
        Observable<Response<ResponseBody>> getVoiceModels(@Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 createVoiceModel" })
        @POST("api/texttospeech/v2.0/models")
        Observable<Response<ResponseBody>> createVoiceModel(@Body ModelDefinition modelDefinition, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 getVoiceModel" })
        @GET("api/texttospeech/v2.0/models/{id}")
        Observable<Response<ResponseBody>> getVoiceModel(@Path("id") UUID id, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 deleteVoiceModel" })
        @HTTP(path = "api/texttospeech/v2.0/models/{id}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteVoiceModel(@Path("id") UUID id, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 updateVoiceModel" })
        @PATCH("api/texttospeech/v2.0/models/{id}")
        Observable<Response<ResponseBody>> updateVoiceModel(@Path("id") UUID id, @Body ModelUpdate modelUpdate, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 getSupportedLocalesForVoiceModels" })
        @GET("api/texttospeech/v2.0/models/locales")
        Observable<Response<ResponseBody>> getSupportedLocalesForVoiceModels(@Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 getVoiceTest" })
        @GET("api/texttospeech/v2.0/tests/{id}")
        Observable<Response<ResponseBody>> getVoiceTest(@Path("id") UUID id, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 deleteVoiceTest" })
        @HTTP(path = "api/texttospeech/v2.0/tests/{id}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteVoiceTest(@Path("id") UUID id, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.speechservices.SpeechServicesAPIv20 createVoiceTest" })
        @POST("api/texttospeech/v2.0/tests")
        Observable<Response<ResponseBody>> createVoiceTest(@Body VoiceTestDefinition voiceTestDefinition, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

    }

    /**
     * Gets the list of accuracy tests for the authenticated subscription.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getAccuracyTests() {
        return getAccuracyTestsWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets the list of accuracy tests for the authenticated subscription.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getAccuracyTestsAsync(final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getAccuracyTestsWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets the list of accuracy tests for the authenticated subscription.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getAccuracyTestsAsync() {
        return getAccuracyTestsWithServiceResponseAsync().map(new Func1<ServiceResponseWithHeaders<Object, GetAccuracyTestsHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetAccuracyTestsHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the list of accuracy tests for the authenticated subscription.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetAccuracyTestsHeaders>> getAccuracyTestsWithServiceResponseAsync() {
        return service.getAccuracyTests(this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetAccuracyTestsHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetAccuracyTestsHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetAccuracyTestsHeaders> clientResponse = getAccuracyTestsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetAccuracyTestsHeaders> getAccuracyTestsDelegate(Response<ResponseBody> response) throws CloudException, IOException {
        return this.restClient().responseBuilderFactory().<Object, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<Test>>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, GetAccuracyTestsHeaders.class);
    }

    /**
     * Creates a new accuracy test.
     *
     * @param testDefinition The details of the new accuracy test.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ErrorContent object if successful.
     */
    public ErrorContent createAccuracyTest(TestDefinition testDefinition) {
        return createAccuracyTestWithServiceResponseAsync(testDefinition).toBlocking().single().body();
    }

    /**
     * Creates a new accuracy test.
     *
     * @param testDefinition The details of the new accuracy test.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ErrorContent> createAccuracyTestAsync(TestDefinition testDefinition, final ServiceCallback<ErrorContent> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createAccuracyTestWithServiceResponseAsync(testDefinition), serviceCallback);
    }

    /**
     * Creates a new accuracy test.
     *
     * @param testDefinition The details of the new accuracy test.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ErrorContent> createAccuracyTestAsync(TestDefinition testDefinition) {
        return createAccuracyTestWithServiceResponseAsync(testDefinition).map(new Func1<ServiceResponseWithHeaders<ErrorContent, CreateAccuracyTestHeaders>, ErrorContent>() {
            @Override
            public ErrorContent call(ServiceResponseWithHeaders<ErrorContent, CreateAccuracyTestHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new accuracy test.
     *
     * @param testDefinition The details of the new accuracy test.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ServiceResponseWithHeaders<ErrorContent, CreateAccuracyTestHeaders>> createAccuracyTestWithServiceResponseAsync(TestDefinition testDefinition) {
        if (testDefinition == null) {
            throw new IllegalArgumentException("Parameter testDefinition is required and cannot be null.");
        }
        Validator.validate(testDefinition);
        return service.createAccuracyTest(testDefinition, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<ErrorContent, CreateAccuracyTestHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<ErrorContent, CreateAccuracyTestHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<ErrorContent, CreateAccuracyTestHeaders> clientResponse = createAccuracyTestDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<ErrorContent, CreateAccuracyTestHeaders> createAccuracyTestDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ErrorContent, CloudException>newInstance(this.serializerAdapter())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(415, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, CreateAccuracyTestHeaders.class);
    }

    /**
     * Gets the accuracy test identified by the given ID.
     *
     * @param id The identifier of the accuracy test.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getAccuracyTest(UUID id) {
        return getAccuracyTestWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Gets the accuracy test identified by the given ID.
     *
     * @param id The identifier of the accuracy test.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getAccuracyTestAsync(UUID id, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getAccuracyTestWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Gets the accuracy test identified by the given ID.
     *
     * @param id The identifier of the accuracy test.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getAccuracyTestAsync(UUID id) {
        return getAccuracyTestWithServiceResponseAsync(id).map(new Func1<ServiceResponseWithHeaders<Object, GetAccuracyTestHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetAccuracyTestHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the accuracy test identified by the given ID.
     *
     * @param id The identifier of the accuracy test.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetAccuracyTestHeaders>> getAccuracyTestWithServiceResponseAsync(UUID id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.getAccuracyTest(id, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetAccuracyTestHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetAccuracyTestHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetAccuracyTestHeaders> clientResponse = getAccuracyTestDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetAccuracyTestHeaders> getAccuracyTestDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Test>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(404, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, GetAccuracyTestHeaders.class);
    }

    /**
     * Deletes the accuracy test identified by the given ID.
     *
     * @param id The identifier of the accuracy test.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ErrorContent object if successful.
     */
    public ErrorContent deleteAccuracyTest(UUID id) {
        return deleteAccuracyTestWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Deletes the accuracy test identified by the given ID.
     *
     * @param id The identifier of the accuracy test.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ErrorContent> deleteAccuracyTestAsync(UUID id, final ServiceCallback<ErrorContent> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(deleteAccuracyTestWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Deletes the accuracy test identified by the given ID.
     *
     * @param id The identifier of the accuracy test.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ErrorContent> deleteAccuracyTestAsync(UUID id) {
        return deleteAccuracyTestWithServiceResponseAsync(id).map(new Func1<ServiceResponseWithHeaders<ErrorContent, DeleteAccuracyTestHeaders>, ErrorContent>() {
            @Override
            public ErrorContent call(ServiceResponseWithHeaders<ErrorContent, DeleteAccuracyTestHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes the accuracy test identified by the given ID.
     *
     * @param id The identifier of the accuracy test.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ServiceResponseWithHeaders<ErrorContent, DeleteAccuracyTestHeaders>> deleteAccuracyTestWithServiceResponseAsync(UUID id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.deleteAccuracyTest(id, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<ErrorContent, DeleteAccuracyTestHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<ErrorContent, DeleteAccuracyTestHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<ErrorContent, DeleteAccuracyTestHeaders> clientResponse = deleteAccuracyTestDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<ErrorContent, DeleteAccuracyTestHeaders> deleteAccuracyTestDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ErrorContent, CloudException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, DeleteAccuracyTestHeaders.class);
    }

    /**
     * Updates the mutable details of the test identified by its id.
     *
     * @param id The identifier of the accuracy test.
     * @param testUpdate The object containing the updated fields of the test.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateAccuracyTest(UUID id, TestUpdate testUpdate) {
        return updateAccuracyTestWithServiceResponseAsync(id, testUpdate).toBlocking().single().body();
    }

    /**
     * Updates the mutable details of the test identified by its id.
     *
     * @param id The identifier of the accuracy test.
     * @param testUpdate The object containing the updated fields of the test.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateAccuracyTestAsync(UUID id, TestUpdate testUpdate, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateAccuracyTestWithServiceResponseAsync(id, testUpdate), serviceCallback);
    }

    /**
     * Updates the mutable details of the test identified by its id.
     *
     * @param id The identifier of the accuracy test.
     * @param testUpdate The object containing the updated fields of the test.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateAccuracyTestAsync(UUID id, TestUpdate testUpdate) {
        return updateAccuracyTestWithServiceResponseAsync(id, testUpdate).map(new Func1<ServiceResponseWithHeaders<Object, UpdateAccuracyTestHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, UpdateAccuracyTestHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the mutable details of the test identified by its id.
     *
     * @param id The identifier of the accuracy test.
     * @param testUpdate The object containing the updated fields of the test.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, UpdateAccuracyTestHeaders>> updateAccuracyTestWithServiceResponseAsync(UUID id, TestUpdate testUpdate) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (testUpdate == null) {
            throw new IllegalArgumentException("Parameter testUpdate is required and cannot be null.");
        }
        Validator.validate(testUpdate);
        return service.updateAccuracyTest(id, testUpdate, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, UpdateAccuracyTestHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, UpdateAccuracyTestHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, UpdateAccuracyTestHeaders> clientResponse = updateAccuracyTestDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, UpdateAccuracyTestHeaders> updateAccuracyTestDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Test>() { }.getType())
                .register(400, new TypeToken<ErrorContent>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(409, new TypeToken<ErrorContent>() { }.getType())
                .register(415, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, UpdateAccuracyTestHeaders.class);
    }

    /**
     * Gets a list of datasets for the authenticated subscription.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getDatasets() {
        return getDatasetsWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets a list of datasets for the authenticated subscription.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getDatasetsAsync(final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getDatasetsWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets a list of datasets for the authenticated subscription.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getDatasetsAsync() {
        return getDatasetsWithServiceResponseAsync().map(new Func1<ServiceResponseWithHeaders<Object, GetDatasetsHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetDatasetsHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of datasets for the authenticated subscription.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetDatasetsHeaders>> getDatasetsWithServiceResponseAsync() {
        return service.getDatasets(this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetDatasetsHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetDatasetsHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetDatasetsHeaders> clientResponse = getDatasetsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetDatasetsHeaders> getDatasetsDelegate(Response<ResponseBody> response) throws CloudException, IOException {
        return this.restClient().responseBuilderFactory().<Object, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<Dataset>>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, GetDatasetsHeaders.class);
    }

    /**
     * Gets the dataset identified by the given ID.
     *
     * @param id The identifier of the dataset.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getDataset(UUID id) {
        return getDatasetWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Gets the dataset identified by the given ID.
     *
     * @param id The identifier of the dataset.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getDatasetAsync(UUID id, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getDatasetWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Gets the dataset identified by the given ID.
     *
     * @param id The identifier of the dataset.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getDatasetAsync(UUID id) {
        return getDatasetWithServiceResponseAsync(id).map(new Func1<ServiceResponseWithHeaders<Object, GetDatasetHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetDatasetHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the dataset identified by the given ID.
     *
     * @param id The identifier of the dataset.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetDatasetHeaders>> getDatasetWithServiceResponseAsync(UUID id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.getDataset(id, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetDatasetHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetDatasetHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetDatasetHeaders> clientResponse = getDatasetDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetDatasetHeaders> getDatasetDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Dataset>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(404, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, GetDatasetHeaders.class);
    }

    /**
     * Deletes the specified dataset.
     *
     * @param id The identifier of the dataset.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ErrorContent object if successful.
     */
    public ErrorContent deleteDataset(UUID id) {
        return deleteDatasetWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Deletes the specified dataset.
     *
     * @param id The identifier of the dataset.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ErrorContent> deleteDatasetAsync(UUID id, final ServiceCallback<ErrorContent> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(deleteDatasetWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Deletes the specified dataset.
     *
     * @param id The identifier of the dataset.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ErrorContent> deleteDatasetAsync(UUID id) {
        return deleteDatasetWithServiceResponseAsync(id).map(new Func1<ServiceResponseWithHeaders<ErrorContent, DeleteDatasetHeaders>, ErrorContent>() {
            @Override
            public ErrorContent call(ServiceResponseWithHeaders<ErrorContent, DeleteDatasetHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes the specified dataset.
     *
     * @param id The identifier of the dataset.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ServiceResponseWithHeaders<ErrorContent, DeleteDatasetHeaders>> deleteDatasetWithServiceResponseAsync(UUID id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.deleteDataset(id, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<ErrorContent, DeleteDatasetHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<ErrorContent, DeleteDatasetHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<ErrorContent, DeleteDatasetHeaders> clientResponse = deleteDatasetDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<ErrorContent, DeleteDatasetHeaders> deleteDatasetDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ErrorContent, CloudException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(405, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, DeleteDatasetHeaders.class);
    }

    /**
     * Updates the mutable details of the dataset identified by its ID.
     *
     * @param id The identifier of the dataset.
     * @param datasetUpdate The updated values for the dataset.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateDataset(UUID id, DatasetUpdate datasetUpdate) {
        return updateDatasetWithServiceResponseAsync(id, datasetUpdate).toBlocking().single().body();
    }

    /**
     * Updates the mutable details of the dataset identified by its ID.
     *
     * @param id The identifier of the dataset.
     * @param datasetUpdate The updated values for the dataset.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateDatasetAsync(UUID id, DatasetUpdate datasetUpdate, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateDatasetWithServiceResponseAsync(id, datasetUpdate), serviceCallback);
    }

    /**
     * Updates the mutable details of the dataset identified by its ID.
     *
     * @param id The identifier of the dataset.
     * @param datasetUpdate The updated values for the dataset.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateDatasetAsync(UUID id, DatasetUpdate datasetUpdate) {
        return updateDatasetWithServiceResponseAsync(id, datasetUpdate).map(new Func1<ServiceResponseWithHeaders<Object, UpdateDatasetHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, UpdateDatasetHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the mutable details of the dataset identified by its ID.
     *
     * @param id The identifier of the dataset.
     * @param datasetUpdate The updated values for the dataset.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, UpdateDatasetHeaders>> updateDatasetWithServiceResponseAsync(UUID id, DatasetUpdate datasetUpdate) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (datasetUpdate == null) {
            throw new IllegalArgumentException("Parameter datasetUpdate is required and cannot be null.");
        }
        Validator.validate(datasetUpdate);
        return service.updateDataset(id, datasetUpdate, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, UpdateDatasetHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, UpdateDatasetHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, UpdateDatasetHeaders> clientResponse = updateDatasetDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, UpdateDatasetHeaders> updateDatasetDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Dataset>() { }.getType())
                .register(400, new TypeToken<ErrorContent>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(409, new TypeToken<ErrorContent>() { }.getType())
                .register(415, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, UpdateDatasetHeaders.class);
    }

    /**
     * Gets a list of supported locales for data imports.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getSupportedLocalesForDatasets() {
        return getSupportedLocalesForDatasetsWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets a list of supported locales for data imports.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getSupportedLocalesForDatasetsAsync(final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getSupportedLocalesForDatasetsWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets a list of supported locales for data imports.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getSupportedLocalesForDatasetsAsync() {
        return getSupportedLocalesForDatasetsWithServiceResponseAsync().map(new Func1<ServiceResponseWithHeaders<Object, GetSupportedLocalesForDatasetsHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetSupportedLocalesForDatasetsHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of supported locales for data imports.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetSupportedLocalesForDatasetsHeaders>> getSupportedLocalesForDatasetsWithServiceResponseAsync() {
        return service.getSupportedLocalesForDatasets(this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetSupportedLocalesForDatasetsHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetSupportedLocalesForDatasetsHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetSupportedLocalesForDatasetsHeaders> clientResponse = getSupportedLocalesForDatasetsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetSupportedLocalesForDatasetsHeaders> getSupportedLocalesForDatasetsDelegate(Response<ResponseBody> response) throws CloudException, IOException {
        return this.restClient().responseBuilderFactory().<Object, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<GetSupportedLocalesForDatasetsOKResponse>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, GetSupportedLocalesForDatasetsHeaders.class);
    }

    /**
     * Uploads data and creates a new dataset.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ErrorContent object if successful.
     */
    public ErrorContent uploadDataset() {
        return uploadDatasetWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Uploads data and creates a new dataset.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ErrorContent> uploadDatasetAsync(final ServiceCallback<ErrorContent> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(uploadDatasetWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Uploads data and creates a new dataset.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ErrorContent> uploadDatasetAsync() {
        return uploadDatasetWithServiceResponseAsync().map(new Func1<ServiceResponseWithHeaders<ErrorContent, UploadDatasetHeaders>, ErrorContent>() {
            @Override
            public ErrorContent call(ServiceResponseWithHeaders<ErrorContent, UploadDatasetHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Uploads data and creates a new dataset.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ServiceResponseWithHeaders<ErrorContent, UploadDatasetHeaders>> uploadDatasetWithServiceResponseAsync() {
        final String name = null;
        final String description = null;
        final String locale = null;
        final String dataImportKind = null;
        final String properties = null;
        final byte[] audiodata = new byte[0];
        final byte[] transcriptions = new byte[0];
        final byte[] languagedata = new byte[0];
        RequestBody audiodataConverted = RequestBody.create(MediaType.parse("multipart/form-data"), new byte[0]);
        if (audiodata != null) {
            audiodataConverted = RequestBody.create(MediaType.parse("multipart/form-data"), audiodata);
        }
        RequestBody transcriptionsConverted = RequestBody.create(MediaType.parse("multipart/form-data"), new byte[0]);
        if (transcriptions != null) {
            transcriptionsConverted = RequestBody.create(MediaType.parse("multipart/form-data"), transcriptions);
        }
        RequestBody languagedataConverted = RequestBody.create(MediaType.parse("multipart/form-data"), new byte[0]);
        if (languagedata != null) {
            languagedataConverted = RequestBody.create(MediaType.parse("multipart/form-data"), languagedata);
        }
        return service.uploadDataset(name, description, locale, dataImportKind, properties, audiodataConverted, transcriptionsConverted, languagedataConverted, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<ErrorContent, UploadDatasetHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<ErrorContent, UploadDatasetHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<ErrorContent, UploadDatasetHeaders> clientResponse = uploadDatasetDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Uploads data and creates a new dataset.
     *
     * @param name The name of this data import (always add this string for any import).
     * @param description Optional description of this data import.
     * @param locale The locale of this data import (always add this string for any import).
     * @param dataImportKind The kind of the data import (always add this string for any import). Possible values include: 'None', 'Language', 'Acoustic', 'Pronunciation', 'CustomVoice', 'LanguageGeneration'
     * @param properties Optional properties of this data import (json serialized object with key/values, where all values must be strings)
     * @param audiodata A zip file containing the audio data (this and the audio archive file for acoustic data imports).
     * @param transcriptions A text file containing the transcriptions for the audio data (this and the transcriptions file for acoustic data imports).
     * @param languagedata A text file containing the language or pronunciation data (only this file for language data imports).
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ErrorContent object if successful.
     */
    public ErrorContent uploadDataset(String name, String description, String locale, String dataImportKind, String properties, byte[] audiodata, byte[] transcriptions, byte[] languagedata) {
        return uploadDatasetWithServiceResponseAsync(name, description, locale, dataImportKind, properties, audiodata, transcriptions, languagedata).toBlocking().single().body();
    }

    /**
     * Uploads data and creates a new dataset.
     *
     * @param name The name of this data import (always add this string for any import).
     * @param description Optional description of this data import.
     * @param locale The locale of this data import (always add this string for any import).
     * @param dataImportKind The kind of the data import (always add this string for any import). Possible values include: 'None', 'Language', 'Acoustic', 'Pronunciation', 'CustomVoice', 'LanguageGeneration'
     * @param properties Optional properties of this data import (json serialized object with key/values, where all values must be strings)
     * @param audiodata A zip file containing the audio data (this and the audio archive file for acoustic data imports).
     * @param transcriptions A text file containing the transcriptions for the audio data (this and the transcriptions file for acoustic data imports).
     * @param languagedata A text file containing the language or pronunciation data (only this file for language data imports).
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ErrorContent> uploadDatasetAsync(String name, String description, String locale, String dataImportKind, String properties, byte[] audiodata, byte[] transcriptions, byte[] languagedata, final ServiceCallback<ErrorContent> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(uploadDatasetWithServiceResponseAsync(name, description, locale, dataImportKind, properties, audiodata, transcriptions, languagedata), serviceCallback);
    }

    /**
     * Uploads data and creates a new dataset.
     *
     * @param name The name of this data import (always add this string for any import).
     * @param description Optional description of this data import.
     * @param locale The locale of this data import (always add this string for any import).
     * @param dataImportKind The kind of the data import (always add this string for any import). Possible values include: 'None', 'Language', 'Acoustic', 'Pronunciation', 'CustomVoice', 'LanguageGeneration'
     * @param properties Optional properties of this data import (json serialized object with key/values, where all values must be strings)
     * @param audiodata A zip file containing the audio data (this and the audio archive file for acoustic data imports).
     * @param transcriptions A text file containing the transcriptions for the audio data (this and the transcriptions file for acoustic data imports).
     * @param languagedata A text file containing the language or pronunciation data (only this file for language data imports).
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ErrorContent> uploadDatasetAsync(String name, String description, String locale, String dataImportKind, String properties, byte[] audiodata, byte[] transcriptions, byte[] languagedata) {
        return uploadDatasetWithServiceResponseAsync(name, description, locale, dataImportKind, properties, audiodata, transcriptions, languagedata).map(new Func1<ServiceResponseWithHeaders<ErrorContent, UploadDatasetHeaders>, ErrorContent>() {
            @Override
            public ErrorContent call(ServiceResponseWithHeaders<ErrorContent, UploadDatasetHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Uploads data and creates a new dataset.
     *
     * @param name The name of this data import (always add this string for any import).
     * @param description Optional description of this data import.
     * @param locale The locale of this data import (always add this string for any import).
     * @param dataImportKind The kind of the data import (always add this string for any import). Possible values include: 'None', 'Language', 'Acoustic', 'Pronunciation', 'CustomVoice', 'LanguageGeneration'
     * @param properties Optional properties of this data import (json serialized object with key/values, where all values must be strings)
     * @param audiodata A zip file containing the audio data (this and the audio archive file for acoustic data imports).
     * @param transcriptions A text file containing the transcriptions for the audio data (this and the transcriptions file for acoustic data imports).
     * @param languagedata A text file containing the language or pronunciation data (only this file for language data imports).
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ServiceResponseWithHeaders<ErrorContent, UploadDatasetHeaders>> uploadDatasetWithServiceResponseAsync(String name, String description, String locale, String dataImportKind, String properties, byte[] audiodata, byte[] transcriptions, byte[] languagedata) {
        RequestBody audiodataConverted = RequestBody.create(MediaType.parse("multipart/form-data"), new byte[0]);
        if (audiodata != null) {
            audiodataConverted = RequestBody.create(MediaType.parse("multipart/form-data"), audiodata);
        }
        RequestBody transcriptionsConverted = RequestBody.create(MediaType.parse("multipart/form-data"), new byte[0]);
        if (transcriptions != null) {
            transcriptionsConverted = RequestBody.create(MediaType.parse("multipart/form-data"), transcriptions);
        }
        RequestBody languagedataConverted = RequestBody.create(MediaType.parse("multipart/form-data"), new byte[0]);
        if (languagedata != null) {
            languagedataConverted = RequestBody.create(MediaType.parse("multipart/form-data"), languagedata);
        }
        return service.uploadDataset(name, description, locale, dataImportKind, properties, audiodataConverted, transcriptionsConverted, languagedataConverted, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<ErrorContent, UploadDatasetHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<ErrorContent, UploadDatasetHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<ErrorContent, UploadDatasetHeaders> clientResponse = uploadDatasetDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<ErrorContent, UploadDatasetHeaders> uploadDatasetDelegate(Response<ResponseBody> response) throws CloudException, IOException {
        return this.restClient().responseBuilderFactory().<ErrorContent, CloudException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .register(400, new TypeToken<ErrorContent>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(415, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, UploadDatasetHeaders.class);
    }

    /**
     * Gets the list of endpoints for the authenticated subscription.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getEndpoints() {
        return getEndpointsWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets the list of endpoints for the authenticated subscription.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getEndpointsAsync(final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getEndpointsWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets the list of endpoints for the authenticated subscription.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getEndpointsAsync() {
        return getEndpointsWithServiceResponseAsync().map(new Func1<ServiceResponseWithHeaders<Object, GetEndpointsHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetEndpointsHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the list of endpoints for the authenticated subscription.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetEndpointsHeaders>> getEndpointsWithServiceResponseAsync() {
        return service.getEndpoints(this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetEndpointsHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetEndpointsHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetEndpointsHeaders> clientResponse = getEndpointsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetEndpointsHeaders> getEndpointsDelegate(Response<ResponseBody> response) throws CloudException, IOException {
        return this.restClient().responseBuilderFactory().<Object, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<Endpoint>>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, GetEndpointsHeaders.class);
    }

    /**
     * Creates a new endpoint.
     *
     * @param endpointDefinition The details of the endpoint.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ErrorContent object if successful.
     */
    public ErrorContent createEndpoint(SpeechEndpointDefinition endpointDefinition) {
        return createEndpointWithServiceResponseAsync(endpointDefinition).toBlocking().single().body();
    }

    /**
     * Creates a new endpoint.
     *
     * @param endpointDefinition The details of the endpoint.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ErrorContent> createEndpointAsync(SpeechEndpointDefinition endpointDefinition, final ServiceCallback<ErrorContent> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createEndpointWithServiceResponseAsync(endpointDefinition), serviceCallback);
    }

    /**
     * Creates a new endpoint.
     *
     * @param endpointDefinition The details of the endpoint.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ErrorContent> createEndpointAsync(SpeechEndpointDefinition endpointDefinition) {
        return createEndpointWithServiceResponseAsync(endpointDefinition).map(new Func1<ServiceResponseWithHeaders<ErrorContent, CreateEndpointHeaders>, ErrorContent>() {
            @Override
            public ErrorContent call(ServiceResponseWithHeaders<ErrorContent, CreateEndpointHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new endpoint.
     *
     * @param endpointDefinition The details of the endpoint.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ServiceResponseWithHeaders<ErrorContent, CreateEndpointHeaders>> createEndpointWithServiceResponseAsync(SpeechEndpointDefinition endpointDefinition) {
        if (endpointDefinition == null) {
            throw new IllegalArgumentException("Parameter endpointDefinition is required and cannot be null.");
        }
        Validator.validate(endpointDefinition);
        return service.createEndpoint(endpointDefinition, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<ErrorContent, CreateEndpointHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<ErrorContent, CreateEndpointHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<ErrorContent, CreateEndpointHeaders> clientResponse = createEndpointDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<ErrorContent, CreateEndpointHeaders> createEndpointDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ErrorContent, CloudException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .register(400, new TypeToken<ErrorContent>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(415, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .register(503, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, CreateEndpointHeaders.class);
    }

    /**
     * Gets the endpoint identified by the given ID.
     *
     * @param id The identifier of the endpoint.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getEndpoint(UUID id) {
        return getEndpointWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Gets the endpoint identified by the given ID.
     *
     * @param id The identifier of the endpoint.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getEndpointAsync(UUID id, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getEndpointWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Gets the endpoint identified by the given ID.
     *
     * @param id The identifier of the endpoint.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getEndpointAsync(UUID id) {
        return getEndpointWithServiceResponseAsync(id).map(new Func1<ServiceResponseWithHeaders<Object, GetEndpointHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetEndpointHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the endpoint identified by the given ID.
     *
     * @param id The identifier of the endpoint.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetEndpointHeaders>> getEndpointWithServiceResponseAsync(UUID id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.getEndpoint(id, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetEndpointHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetEndpointHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetEndpointHeaders> clientResponse = getEndpointDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetEndpointHeaders> getEndpointDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Endpoint>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(404, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, GetEndpointHeaders.class);
    }

    /**
     * Deletes the endpoint identified by the given ID.
     *
     * @param id The identifier of the endpoint.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ErrorContent object if successful.
     */
    public ErrorContent deleteEndpoint(UUID id) {
        return deleteEndpointWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Deletes the endpoint identified by the given ID.
     *
     * @param id The identifier of the endpoint.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ErrorContent> deleteEndpointAsync(UUID id, final ServiceCallback<ErrorContent> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(deleteEndpointWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Deletes the endpoint identified by the given ID.
     *
     * @param id The identifier of the endpoint.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ErrorContent> deleteEndpointAsync(UUID id) {
        return deleteEndpointWithServiceResponseAsync(id).map(new Func1<ServiceResponseWithHeaders<ErrorContent, DeleteEndpointHeaders>, ErrorContent>() {
            @Override
            public ErrorContent call(ServiceResponseWithHeaders<ErrorContent, DeleteEndpointHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes the endpoint identified by the given ID.
     *
     * @param id The identifier of the endpoint.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ServiceResponseWithHeaders<ErrorContent, DeleteEndpointHeaders>> deleteEndpointWithServiceResponseAsync(UUID id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.deleteEndpoint(id, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<ErrorContent, DeleteEndpointHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<ErrorContent, DeleteEndpointHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<ErrorContent, DeleteEndpointHeaders> clientResponse = deleteEndpointDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<ErrorContent, DeleteEndpointHeaders> deleteEndpointDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ErrorContent, CloudException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, DeleteEndpointHeaders.class);
    }

    /**
     * Updates the metadata of the endpoint identified by the given ID.
     *
     * @param id The identifier of the endpoint.
     * @param endpointUpdate The updated values for the endpoint.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateEndpoint(UUID id, EndpointUpdate endpointUpdate) {
        return updateEndpointWithServiceResponseAsync(id, endpointUpdate).toBlocking().single().body();
    }

    /**
     * Updates the metadata of the endpoint identified by the given ID.
     *
     * @param id The identifier of the endpoint.
     * @param endpointUpdate The updated values for the endpoint.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateEndpointAsync(UUID id, EndpointUpdate endpointUpdate, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateEndpointWithServiceResponseAsync(id, endpointUpdate), serviceCallback);
    }

    /**
     * Updates the metadata of the endpoint identified by the given ID.
     *
     * @param id The identifier of the endpoint.
     * @param endpointUpdate The updated values for the endpoint.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateEndpointAsync(UUID id, EndpointUpdate endpointUpdate) {
        return updateEndpointWithServiceResponseAsync(id, endpointUpdate).map(new Func1<ServiceResponseWithHeaders<Object, UpdateEndpointHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, UpdateEndpointHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the metadata of the endpoint identified by the given ID.
     *
     * @param id The identifier of the endpoint.
     * @param endpointUpdate The updated values for the endpoint.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, UpdateEndpointHeaders>> updateEndpointWithServiceResponseAsync(UUID id, EndpointUpdate endpointUpdate) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (endpointUpdate == null) {
            throw new IllegalArgumentException("Parameter endpointUpdate is required and cannot be null.");
        }
        Validator.validate(endpointUpdate);
        return service.updateEndpoint(id, endpointUpdate, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, UpdateEndpointHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, UpdateEndpointHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, UpdateEndpointHeaders> clientResponse = updateEndpointDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, UpdateEndpointHeaders> updateEndpointDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Endpoint>() { }.getType())
                .register(400, new TypeToken<ErrorContent>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(409, new TypeToken<ErrorContent>() { }.getType())
                .register(415, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, UpdateEndpointHeaders.class);
    }

    /**
     * Gets a list of supported locales for endpoint creations.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getSupportedLocalesForEndpoints() {
        return getSupportedLocalesForEndpointsWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets a list of supported locales for endpoint creations.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getSupportedLocalesForEndpointsAsync(final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getSupportedLocalesForEndpointsWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets a list of supported locales for endpoint creations.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getSupportedLocalesForEndpointsAsync() {
        return getSupportedLocalesForEndpointsWithServiceResponseAsync().map(new Func1<ServiceResponseWithHeaders<Object, GetSupportedLocalesForEndpointsHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetSupportedLocalesForEndpointsHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of supported locales for endpoint creations.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetSupportedLocalesForEndpointsHeaders>> getSupportedLocalesForEndpointsWithServiceResponseAsync() {
        return service.getSupportedLocalesForEndpoints(this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetSupportedLocalesForEndpointsHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetSupportedLocalesForEndpointsHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetSupportedLocalesForEndpointsHeaders> clientResponse = getSupportedLocalesForEndpointsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetSupportedLocalesForEndpointsHeaders> getSupportedLocalesForEndpointsDelegate(Response<ResponseBody> response) throws CloudException, IOException {
        return this.restClient().responseBuilderFactory().<Object, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<String>>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, GetSupportedLocalesForEndpointsHeaders.class);
    }

    /**
     * Gets the list of endpoint data export tasks for the authenticated user.
     *
     * @param endpointId The identifier of the endpoint.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getEndpointDataExports(UUID endpointId) {
        return getEndpointDataExportsWithServiceResponseAsync(endpointId).toBlocking().single().body();
    }

    /**
     * Gets the list of endpoint data export tasks for the authenticated user.
     *
     * @param endpointId The identifier of the endpoint.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getEndpointDataExportsAsync(UUID endpointId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getEndpointDataExportsWithServiceResponseAsync(endpointId), serviceCallback);
    }

    /**
     * Gets the list of endpoint data export tasks for the authenticated user.
     *
     * @param endpointId The identifier of the endpoint.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getEndpointDataExportsAsync(UUID endpointId) {
        return getEndpointDataExportsWithServiceResponseAsync(endpointId).map(new Func1<ServiceResponseWithHeaders<Object, GetEndpointDataExportsHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetEndpointDataExportsHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the list of endpoint data export tasks for the authenticated user.
     *
     * @param endpointId The identifier of the endpoint.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetEndpointDataExportsHeaders>> getEndpointDataExportsWithServiceResponseAsync(UUID endpointId) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        return service.getEndpointDataExports(endpointId, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetEndpointDataExportsHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetEndpointDataExportsHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetEndpointDataExportsHeaders> clientResponse = getEndpointDataExportsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetEndpointDataExportsHeaders> getEndpointDataExportsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<EndpointData>>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(404, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, GetEndpointDataExportsHeaders.class);
    }

    /**
     * Create a new endpoint data export task.
     *
     * @param endpointId The identifier of the endpoint.
     * @param endpointDataDefinition The details of the new endpoint data export.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ErrorContent object if successful.
     */
    public ErrorContent createEndpointDataExport(UUID endpointId, EndpointDataDefinition endpointDataDefinition) {
        return createEndpointDataExportWithServiceResponseAsync(endpointId, endpointDataDefinition).toBlocking().single().body();
    }

    /**
     * Create a new endpoint data export task.
     *
     * @param endpointId The identifier of the endpoint.
     * @param endpointDataDefinition The details of the new endpoint data export.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ErrorContent> createEndpointDataExportAsync(UUID endpointId, EndpointDataDefinition endpointDataDefinition, final ServiceCallback<ErrorContent> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createEndpointDataExportWithServiceResponseAsync(endpointId, endpointDataDefinition), serviceCallback);
    }

    /**
     * Create a new endpoint data export task.
     *
     * @param endpointId The identifier of the endpoint.
     * @param endpointDataDefinition The details of the new endpoint data export.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ErrorContent> createEndpointDataExportAsync(UUID endpointId, EndpointDataDefinition endpointDataDefinition) {
        return createEndpointDataExportWithServiceResponseAsync(endpointId, endpointDataDefinition).map(new Func1<ServiceResponseWithHeaders<ErrorContent, CreateEndpointDataExportHeaders>, ErrorContent>() {
            @Override
            public ErrorContent call(ServiceResponseWithHeaders<ErrorContent, CreateEndpointDataExportHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Create a new endpoint data export task.
     *
     * @param endpointId The identifier of the endpoint.
     * @param endpointDataDefinition The details of the new endpoint data export.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ServiceResponseWithHeaders<ErrorContent, CreateEndpointDataExportHeaders>> createEndpointDataExportWithServiceResponseAsync(UUID endpointId, EndpointDataDefinition endpointDataDefinition) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (endpointDataDefinition == null) {
            throw new IllegalArgumentException("Parameter endpointDataDefinition is required and cannot be null.");
        }
        Validator.validate(endpointDataDefinition);
        return service.createEndpointDataExport(endpointId, endpointDataDefinition, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<ErrorContent, CreateEndpointDataExportHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<ErrorContent, CreateEndpointDataExportHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<ErrorContent, CreateEndpointDataExportHeaders> clientResponse = createEndpointDataExportDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<ErrorContent, CreateEndpointDataExportHeaders> createEndpointDataExportDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ErrorContent, CloudException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<ErrorContent>() { }.getType())
                .register(400, new TypeToken<ErrorContent>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(404, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, CreateEndpointDataExportHeaders.class);
    }

    /**
     * Deletes the transcriptions and captured audio files associated with the endpoint identified by the given ID.
     * Deletion will happen in the background and can take up to a day.
     *
     * @param endpointId The identifier of the endpoint.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ErrorContent object if successful.
     */
    public ErrorContent deleteEndpointData(UUID endpointId) {
        return deleteEndpointDataWithServiceResponseAsync(endpointId).toBlocking().single().body();
    }

    /**
     * Deletes the transcriptions and captured audio files associated with the endpoint identified by the given ID.
     * Deletion will happen in the background and can take up to a day.
     *
     * @param endpointId The identifier of the endpoint.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ErrorContent> deleteEndpointDataAsync(UUID endpointId, final ServiceCallback<ErrorContent> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(deleteEndpointDataWithServiceResponseAsync(endpointId), serviceCallback);
    }

    /**
     * Deletes the transcriptions and captured audio files associated with the endpoint identified by the given ID.
     * Deletion will happen in the background and can take up to a day.
     *
     * @param endpointId The identifier of the endpoint.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ErrorContent> deleteEndpointDataAsync(UUID endpointId) {
        return deleteEndpointDataWithServiceResponseAsync(endpointId).map(new Func1<ServiceResponseWithHeaders<ErrorContent, DeleteEndpointDataHeaders>, ErrorContent>() {
            @Override
            public ErrorContent call(ServiceResponseWithHeaders<ErrorContent, DeleteEndpointDataHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes the transcriptions and captured audio files associated with the endpoint identified by the given ID.
     * Deletion will happen in the background and can take up to a day.
     *
     * @param endpointId The identifier of the endpoint.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ServiceResponseWithHeaders<ErrorContent, DeleteEndpointDataHeaders>> deleteEndpointDataWithServiceResponseAsync(UUID endpointId) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        return service.deleteEndpointData(endpointId, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<ErrorContent, DeleteEndpointDataHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<ErrorContent, DeleteEndpointDataHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<ErrorContent, DeleteEndpointDataHeaders> clientResponse = deleteEndpointDataDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<ErrorContent, DeleteEndpointDataHeaders> deleteEndpointDataDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ErrorContent, CloudException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, DeleteEndpointDataHeaders.class);
    }

    /**
     * Gets the specified endpoint data export task for the authenticated user.
     *
     * @param endpointId The identifier of the endpoint.
     * @param id The identifier of the data export.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getEndpointDataExport(UUID endpointId, UUID id) {
        return getEndpointDataExportWithServiceResponseAsync(endpointId, id).toBlocking().single().body();
    }

    /**
     * Gets the specified endpoint data export task for the authenticated user.
     *
     * @param endpointId The identifier of the endpoint.
     * @param id The identifier of the data export.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getEndpointDataExportAsync(UUID endpointId, UUID id, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getEndpointDataExportWithServiceResponseAsync(endpointId, id), serviceCallback);
    }

    /**
     * Gets the specified endpoint data export task for the authenticated user.
     *
     * @param endpointId The identifier of the endpoint.
     * @param id The identifier of the data export.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getEndpointDataExportAsync(UUID endpointId, UUID id) {
        return getEndpointDataExportWithServiceResponseAsync(endpointId, id).map(new Func1<ServiceResponseWithHeaders<Object, GetEndpointDataExportHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetEndpointDataExportHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the specified endpoint data export task for the authenticated user.
     *
     * @param endpointId The identifier of the endpoint.
     * @param id The identifier of the data export.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetEndpointDataExportHeaders>> getEndpointDataExportWithServiceResponseAsync(UUID endpointId, UUID id) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.getEndpointDataExport(endpointId, id, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetEndpointDataExportHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetEndpointDataExportHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetEndpointDataExportHeaders> clientResponse = getEndpointDataExportDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetEndpointDataExportHeaders> getEndpointDataExportDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<EndpointData>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(404, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, GetEndpointDataExportHeaders.class);
    }

    /**
     * Deletes the endpoint data export task identified by the given ID.
     *
     * @param endpointId The identifier of the endpoint.
     * @param id The identifier of the endpoint data export.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ErrorContent object if successful.
     */
    public ErrorContent deleteEndpointDataExport(UUID endpointId, UUID id) {
        return deleteEndpointDataExportWithServiceResponseAsync(endpointId, id).toBlocking().single().body();
    }

    /**
     * Deletes the endpoint data export task identified by the given ID.
     *
     * @param endpointId The identifier of the endpoint.
     * @param id The identifier of the endpoint data export.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ErrorContent> deleteEndpointDataExportAsync(UUID endpointId, UUID id, final ServiceCallback<ErrorContent> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(deleteEndpointDataExportWithServiceResponseAsync(endpointId, id), serviceCallback);
    }

    /**
     * Deletes the endpoint data export task identified by the given ID.
     *
     * @param endpointId The identifier of the endpoint.
     * @param id The identifier of the endpoint data export.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ErrorContent> deleteEndpointDataExportAsync(UUID endpointId, UUID id) {
        return deleteEndpointDataExportWithServiceResponseAsync(endpointId, id).map(new Func1<ServiceResponseWithHeaders<ErrorContent, DeleteEndpointDataExportHeaders>, ErrorContent>() {
            @Override
            public ErrorContent call(ServiceResponseWithHeaders<ErrorContent, DeleteEndpointDataExportHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes the endpoint data export task identified by the given ID.
     *
     * @param endpointId The identifier of the endpoint.
     * @param id The identifier of the endpoint data export.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ServiceResponseWithHeaders<ErrorContent, DeleteEndpointDataExportHeaders>> deleteEndpointDataExportWithServiceResponseAsync(UUID endpointId, UUID id) {
        if (endpointId == null) {
            throw new IllegalArgumentException("Parameter endpointId is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.deleteEndpointDataExport(endpointId, id, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<ErrorContent, DeleteEndpointDataExportHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<ErrorContent, DeleteEndpointDataExportHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<ErrorContent, DeleteEndpointDataExportHeaders> clientResponse = deleteEndpointDataExportDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<ErrorContent, DeleteEndpointDataExportHeaders> deleteEndpointDataExportDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ErrorContent, CloudException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(405, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, DeleteEndpointDataExportHeaders.class);
    }

    /**
     * Gets the list of models for the authenticated subscription.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getModels() {
        return getModelsWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets the list of models for the authenticated subscription.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getModelsAsync(final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getModelsWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets the list of models for the authenticated subscription.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getModelsAsync() {
        return getModelsWithServiceResponseAsync().map(new Func1<ServiceResponseWithHeaders<Object, GetModelsHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetModelsHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the list of models for the authenticated subscription.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetModelsHeaders>> getModelsWithServiceResponseAsync() {
        return service.getModels(this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetModelsHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetModelsHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetModelsHeaders> clientResponse = getModelsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetModelsHeaders> getModelsDelegate(Response<ResponseBody> response) throws CloudException, IOException {
        return this.restClient().responseBuilderFactory().<Object, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<Model>>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, GetModelsHeaders.class);
    }

    /**
     * Creates a new model.
     *
     * @param modelDefinition The details of the new model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ErrorContent object if successful.
     */
    public ErrorContent createModel(SpeechModelDefinition modelDefinition) {
        return createModelWithServiceResponseAsync(modelDefinition).toBlocking().single().body();
    }

    /**
     * Creates a new model.
     *
     * @param modelDefinition The details of the new model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ErrorContent> createModelAsync(SpeechModelDefinition modelDefinition, final ServiceCallback<ErrorContent> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createModelWithServiceResponseAsync(modelDefinition), serviceCallback);
    }

    /**
     * Creates a new model.
     *
     * @param modelDefinition The details of the new model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ErrorContent> createModelAsync(SpeechModelDefinition modelDefinition) {
        return createModelWithServiceResponseAsync(modelDefinition).map(new Func1<ServiceResponseWithHeaders<ErrorContent, CreateModelHeaders>, ErrorContent>() {
            @Override
            public ErrorContent call(ServiceResponseWithHeaders<ErrorContent, CreateModelHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new model.
     *
     * @param modelDefinition The details of the new model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ServiceResponseWithHeaders<ErrorContent, CreateModelHeaders>> createModelWithServiceResponseAsync(SpeechModelDefinition modelDefinition) {
        if (modelDefinition == null) {
            throw new IllegalArgumentException("Parameter modelDefinition is required and cannot be null.");
        }
        Validator.validate(modelDefinition);
        return service.createModel(modelDefinition, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<ErrorContent, CreateModelHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<ErrorContent, CreateModelHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<ErrorContent, CreateModelHeaders> clientResponse = createModelDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<ErrorContent, CreateModelHeaders> createModelDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ErrorContent, CloudException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .register(400, new TypeToken<ErrorContent>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(415, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, CreateModelHeaders.class);
    }

    /**
     * Gets the model identified by the given ID.
     *
     * @param id The identifier of the model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getModel(UUID id) {
        return getModelWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Gets the model identified by the given ID.
     *
     * @param id The identifier of the model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getModelAsync(UUID id, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getModelWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Gets the model identified by the given ID.
     *
     * @param id The identifier of the model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getModelAsync(UUID id) {
        return getModelWithServiceResponseAsync(id).map(new Func1<ServiceResponseWithHeaders<Object, GetModelHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetModelHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the model identified by the given ID.
     *
     * @param id The identifier of the model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetModelHeaders>> getModelWithServiceResponseAsync(UUID id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.getModel(id, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetModelHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetModelHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetModelHeaders> clientResponse = getModelDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetModelHeaders> getModelDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Model>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(404, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, GetModelHeaders.class);
    }

    /**
     * Deletes the model identified by the given ID.
     *
     * @param id The identifier of the model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ErrorContent object if successful.
     */
    public ErrorContent deleteModel(UUID id) {
        return deleteModelWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Deletes the model identified by the given ID.
     *
     * @param id The identifier of the model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ErrorContent> deleteModelAsync(UUID id, final ServiceCallback<ErrorContent> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(deleteModelWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Deletes the model identified by the given ID.
     *
     * @param id The identifier of the model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ErrorContent> deleteModelAsync(UUID id) {
        return deleteModelWithServiceResponseAsync(id).map(new Func1<ServiceResponseWithHeaders<ErrorContent, DeleteModelHeaders>, ErrorContent>() {
            @Override
            public ErrorContent call(ServiceResponseWithHeaders<ErrorContent, DeleteModelHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes the model identified by the given ID.
     *
     * @param id The identifier of the model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ServiceResponseWithHeaders<ErrorContent, DeleteModelHeaders>> deleteModelWithServiceResponseAsync(UUID id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.deleteModel(id, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<ErrorContent, DeleteModelHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<ErrorContent, DeleteModelHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<ErrorContent, DeleteModelHeaders> clientResponse = deleteModelDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<ErrorContent, DeleteModelHeaders> deleteModelDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ErrorContent, CloudException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(405, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, DeleteModelHeaders.class);
    }

    /**
     * Updates the metadata of the model identified by the given ID.
     *
     * @param id The identifier of the model.
     * @param modelUpdate The updated values for the model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateModel(UUID id, ModelUpdate modelUpdate) {
        return updateModelWithServiceResponseAsync(id, modelUpdate).toBlocking().single().body();
    }

    /**
     * Updates the metadata of the model identified by the given ID.
     *
     * @param id The identifier of the model.
     * @param modelUpdate The updated values for the model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateModelAsync(UUID id, ModelUpdate modelUpdate, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateModelWithServiceResponseAsync(id, modelUpdate), serviceCallback);
    }

    /**
     * Updates the metadata of the model identified by the given ID.
     *
     * @param id The identifier of the model.
     * @param modelUpdate The updated values for the model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateModelAsync(UUID id, ModelUpdate modelUpdate) {
        return updateModelWithServiceResponseAsync(id, modelUpdate).map(new Func1<ServiceResponseWithHeaders<Object, UpdateModelHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, UpdateModelHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the metadata of the model identified by the given ID.
     *
     * @param id The identifier of the model.
     * @param modelUpdate The updated values for the model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, UpdateModelHeaders>> updateModelWithServiceResponseAsync(UUID id, ModelUpdate modelUpdate) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (modelUpdate == null) {
            throw new IllegalArgumentException("Parameter modelUpdate is required and cannot be null.");
        }
        Validator.validate(modelUpdate);
        return service.updateModel(id, modelUpdate, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, UpdateModelHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, UpdateModelHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, UpdateModelHeaders> clientResponse = updateModelDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, UpdateModelHeaders> updateModelDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Model>() { }.getType())
                .register(400, new TypeToken<ErrorContent>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(409, new TypeToken<ErrorContent>() { }.getType())
                .register(415, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, UpdateModelHeaders.class);
    }

    /**
     * Gets a list of supported locales for model adaptation.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getSupportedLocalesForModels() {
        return getSupportedLocalesForModelsWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets a list of supported locales for model adaptation.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getSupportedLocalesForModelsAsync(final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getSupportedLocalesForModelsWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets a list of supported locales for model adaptation.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getSupportedLocalesForModelsAsync() {
        return getSupportedLocalesForModelsWithServiceResponseAsync().map(new Func1<ServiceResponseWithHeaders<Object, GetSupportedLocalesForModelsHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetSupportedLocalesForModelsHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of supported locales for model adaptation.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetSupportedLocalesForModelsHeaders>> getSupportedLocalesForModelsWithServiceResponseAsync() {
        return service.getSupportedLocalesForModels(this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetSupportedLocalesForModelsHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetSupportedLocalesForModelsHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetSupportedLocalesForModelsHeaders> clientResponse = getSupportedLocalesForModelsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetSupportedLocalesForModelsHeaders> getSupportedLocalesForModelsDelegate(Response<ResponseBody> response) throws CloudException, IOException {
        return this.restClient().responseBuilderFactory().<Object, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<GetSupportedLocalesForModelsOKResponse>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, GetSupportedLocalesForModelsHeaders.class);
    }

    /**
     * Gets a list of transcriptions for the authenticated subscription.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getTranscriptions() {
        return getTranscriptionsWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets a list of transcriptions for the authenticated subscription.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getTranscriptionsAsync(final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getTranscriptionsWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets a list of transcriptions for the authenticated subscription.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getTranscriptionsAsync() {
        return getTranscriptionsWithServiceResponseAsync().map(new Func1<ServiceResponseWithHeaders<Object, GetTranscriptionsHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetTranscriptionsHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of transcriptions for the authenticated subscription.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetTranscriptionsHeaders>> getTranscriptionsWithServiceResponseAsync() {
        return service.getTranscriptions(this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetTranscriptionsHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetTranscriptionsHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetTranscriptionsHeaders> clientResponse = getTranscriptionsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetTranscriptionsHeaders> getTranscriptionsDelegate(Response<ResponseBody> response) throws CloudException, IOException {
        return this.restClient().responseBuilderFactory().<Object, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<Transcription>>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, GetTranscriptionsHeaders.class);
    }

    /**
     * Creates a new transcription.
     *
     * @param transcription The details of the new transcription.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ErrorContent object if successful.
     */
    public ErrorContent createTranscription(TranscriptionDefinition transcription) {
        return createTranscriptionWithServiceResponseAsync(transcription).toBlocking().single().body();
    }

    /**
     * Creates a new transcription.
     *
     * @param transcription The details of the new transcription.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ErrorContent> createTranscriptionAsync(TranscriptionDefinition transcription, final ServiceCallback<ErrorContent> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createTranscriptionWithServiceResponseAsync(transcription), serviceCallback);
    }

    /**
     * Creates a new transcription.
     *
     * @param transcription The details of the new transcription.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ErrorContent> createTranscriptionAsync(TranscriptionDefinition transcription) {
        return createTranscriptionWithServiceResponseAsync(transcription).map(new Func1<ServiceResponseWithHeaders<ErrorContent, CreateTranscriptionHeaders>, ErrorContent>() {
            @Override
            public ErrorContent call(ServiceResponseWithHeaders<ErrorContent, CreateTranscriptionHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new transcription.
     *
     * @param transcription The details of the new transcription.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ServiceResponseWithHeaders<ErrorContent, CreateTranscriptionHeaders>> createTranscriptionWithServiceResponseAsync(TranscriptionDefinition transcription) {
        if (transcription == null) {
            throw new IllegalArgumentException("Parameter transcription is required and cannot be null.");
        }
        Validator.validate(transcription);
        return service.createTranscription(transcription, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<ErrorContent, CreateTranscriptionHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<ErrorContent, CreateTranscriptionHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<ErrorContent, CreateTranscriptionHeaders> clientResponse = createTranscriptionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<ErrorContent, CreateTranscriptionHeaders> createTranscriptionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ErrorContent, CloudException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .register(400, new TypeToken<ErrorContent>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(415, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .register(503, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, CreateTranscriptionHeaders.class);
    }

    /**
     * Gets the transcription identified by the given ID.
     *
     * @param id The identifier of the transcription.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getTranscription(UUID id) {
        return getTranscriptionWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Gets the transcription identified by the given ID.
     *
     * @param id The identifier of the transcription.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getTranscriptionAsync(UUID id, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getTranscriptionWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Gets the transcription identified by the given ID.
     *
     * @param id The identifier of the transcription.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getTranscriptionAsync(UUID id) {
        return getTranscriptionWithServiceResponseAsync(id).map(new Func1<ServiceResponseWithHeaders<Object, GetTranscriptionHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetTranscriptionHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the transcription identified by the given ID.
     *
     * @param id The identifier of the transcription.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetTranscriptionHeaders>> getTranscriptionWithServiceResponseAsync(UUID id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.getTranscription(id, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetTranscriptionHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetTranscriptionHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetTranscriptionHeaders> clientResponse = getTranscriptionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetTranscriptionHeaders> getTranscriptionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Transcription>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(404, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, GetTranscriptionHeaders.class);
    }

    /**
     * Deletes the specified transcription task.
     *
     * @param id The identifier of the transcription.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ErrorContent object if successful.
     */
    public ErrorContent deleteTranscription(UUID id) {
        return deleteTranscriptionWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Deletes the specified transcription task.
     *
     * @param id The identifier of the transcription.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ErrorContent> deleteTranscriptionAsync(UUID id, final ServiceCallback<ErrorContent> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(deleteTranscriptionWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Deletes the specified transcription task.
     *
     * @param id The identifier of the transcription.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ErrorContent> deleteTranscriptionAsync(UUID id) {
        return deleteTranscriptionWithServiceResponseAsync(id).map(new Func1<ServiceResponseWithHeaders<ErrorContent, DeleteTranscriptionHeaders>, ErrorContent>() {
            @Override
            public ErrorContent call(ServiceResponseWithHeaders<ErrorContent, DeleteTranscriptionHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes the specified transcription task.
     *
     * @param id The identifier of the transcription.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ServiceResponseWithHeaders<ErrorContent, DeleteTranscriptionHeaders>> deleteTranscriptionWithServiceResponseAsync(UUID id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.deleteTranscription(id, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<ErrorContent, DeleteTranscriptionHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<ErrorContent, DeleteTranscriptionHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<ErrorContent, DeleteTranscriptionHeaders> clientResponse = deleteTranscriptionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<ErrorContent, DeleteTranscriptionHeaders> deleteTranscriptionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ErrorContent, CloudException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<ErrorContent>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(405, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, DeleteTranscriptionHeaders.class);
    }

    /**
     * Updates the mutable details of the transcription identified by its ID.
     *
     * @param id The identifier of the transcription.
     * @param transcriptionUpdate The updated values for the transcription.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateTranscription(UUID id, TranscriptionUpdate transcriptionUpdate) {
        return updateTranscriptionWithServiceResponseAsync(id, transcriptionUpdate).toBlocking().single().body();
    }

    /**
     * Updates the mutable details of the transcription identified by its ID.
     *
     * @param id The identifier of the transcription.
     * @param transcriptionUpdate The updated values for the transcription.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateTranscriptionAsync(UUID id, TranscriptionUpdate transcriptionUpdate, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateTranscriptionWithServiceResponseAsync(id, transcriptionUpdate), serviceCallback);
    }

    /**
     * Updates the mutable details of the transcription identified by its ID.
     *
     * @param id The identifier of the transcription.
     * @param transcriptionUpdate The updated values for the transcription.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateTranscriptionAsync(UUID id, TranscriptionUpdate transcriptionUpdate) {
        return updateTranscriptionWithServiceResponseAsync(id, transcriptionUpdate).map(new Func1<ServiceResponseWithHeaders<Object, UpdateTranscriptionHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, UpdateTranscriptionHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the mutable details of the transcription identified by its ID.
     *
     * @param id The identifier of the transcription.
     * @param transcriptionUpdate The updated values for the transcription.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, UpdateTranscriptionHeaders>> updateTranscriptionWithServiceResponseAsync(UUID id, TranscriptionUpdate transcriptionUpdate) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (transcriptionUpdate == null) {
            throw new IllegalArgumentException("Parameter transcriptionUpdate is required and cannot be null.");
        }
        Validator.validate(transcriptionUpdate);
        return service.updateTranscription(id, transcriptionUpdate, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, UpdateTranscriptionHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, UpdateTranscriptionHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, UpdateTranscriptionHeaders> clientResponse = updateTranscriptionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, UpdateTranscriptionHeaders> updateTranscriptionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Transcription>() { }.getType())
                .register(400, new TypeToken<ErrorContent>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(409, new TypeToken<ErrorContent>() { }.getType())
                .register(415, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, UpdateTranscriptionHeaders.class);
    }

    /**
     * Gets a list of supported locales for offline transcriptions.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getSupportedLocalesForTranscriptions() {
        return getSupportedLocalesForTranscriptionsWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets a list of supported locales for offline transcriptions.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getSupportedLocalesForTranscriptionsAsync(final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getSupportedLocalesForTranscriptionsWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets a list of supported locales for offline transcriptions.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getSupportedLocalesForTranscriptionsAsync() {
        return getSupportedLocalesForTranscriptionsWithServiceResponseAsync().map(new Func1<ServiceResponseWithHeaders<Object, GetSupportedLocalesForTranscriptionsHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetSupportedLocalesForTranscriptionsHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of supported locales for offline transcriptions.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetSupportedLocalesForTranscriptionsHeaders>> getSupportedLocalesForTranscriptionsWithServiceResponseAsync() {
        return service.getSupportedLocalesForTranscriptions(this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetSupportedLocalesForTranscriptionsHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetSupportedLocalesForTranscriptionsHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetSupportedLocalesForTranscriptionsHeaders> clientResponse = getSupportedLocalesForTranscriptionsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetSupportedLocalesForTranscriptionsHeaders> getSupportedLocalesForTranscriptionsDelegate(Response<ResponseBody> response) throws CloudException, IOException {
        return this.restClient().responseBuilderFactory().<Object, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<String>>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, GetSupportedLocalesForTranscriptionsHeaders.class);
    }

    /**
     * Gets all language generation endpoint of a subscription.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getLanguageGenerationEndpoints() {
        return getLanguageGenerationEndpointsWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets all language generation endpoint of a subscription.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getLanguageGenerationEndpointsAsync(final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getLanguageGenerationEndpointsWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets all language generation endpoint of a subscription.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getLanguageGenerationEndpointsAsync() {
        return getLanguageGenerationEndpointsWithServiceResponseAsync().map(new Func1<ServiceResponseWithHeaders<Object, GetLanguageGenerationEndpointsHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetLanguageGenerationEndpointsHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets all language generation endpoint of a subscription.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetLanguageGenerationEndpointsHeaders>> getLanguageGenerationEndpointsWithServiceResponseAsync() {
        return service.getLanguageGenerationEndpoints(this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetLanguageGenerationEndpointsHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetLanguageGenerationEndpointsHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetLanguageGenerationEndpointsHeaders> clientResponse = getLanguageGenerationEndpointsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetLanguageGenerationEndpointsHeaders> getLanguageGenerationEndpointsDelegate(Response<ResponseBody> response) throws CloudException, IOException {
        return this.restClient().responseBuilderFactory().<Object, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<Endpoint>>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, GetLanguageGenerationEndpointsHeaders.class);
    }

    /**
     * Creates a new language generation endpoint.
     *
     * @param endpointDefinition the EndpointDefinition value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ErrorContent object if successful.
     */
    public ErrorContent createLanguageGenerationEndpoint(EndpointDefinition endpointDefinition) {
        return createLanguageGenerationEndpointWithServiceResponseAsync(endpointDefinition).toBlocking().single().body();
    }

    /**
     * Creates a new language generation endpoint.
     *
     * @param endpointDefinition the EndpointDefinition value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ErrorContent> createLanguageGenerationEndpointAsync(EndpointDefinition endpointDefinition, final ServiceCallback<ErrorContent> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createLanguageGenerationEndpointWithServiceResponseAsync(endpointDefinition), serviceCallback);
    }

    /**
     * Creates a new language generation endpoint.
     *
     * @param endpointDefinition the EndpointDefinition value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ErrorContent> createLanguageGenerationEndpointAsync(EndpointDefinition endpointDefinition) {
        return createLanguageGenerationEndpointWithServiceResponseAsync(endpointDefinition).map(new Func1<ServiceResponseWithHeaders<ErrorContent, CreateLanguageGenerationEndpointHeaders>, ErrorContent>() {
            @Override
            public ErrorContent call(ServiceResponseWithHeaders<ErrorContent, CreateLanguageGenerationEndpointHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new language generation endpoint.
     *
     * @param endpointDefinition the EndpointDefinition value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ServiceResponseWithHeaders<ErrorContent, CreateLanguageGenerationEndpointHeaders>> createLanguageGenerationEndpointWithServiceResponseAsync(EndpointDefinition endpointDefinition) {
        if (endpointDefinition == null) {
            throw new IllegalArgumentException("Parameter endpointDefinition is required and cannot be null.");
        }
        Validator.validate(endpointDefinition);
        return service.createLanguageGenerationEndpoint(endpointDefinition, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<ErrorContent, CreateLanguageGenerationEndpointHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<ErrorContent, CreateLanguageGenerationEndpointHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<ErrorContent, CreateLanguageGenerationEndpointHeaders> clientResponse = createLanguageGenerationEndpointDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<ErrorContent, CreateLanguageGenerationEndpointHeaders> createLanguageGenerationEndpointDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ErrorContent, CloudException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .register(400, new TypeToken<ErrorContent>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, CreateLanguageGenerationEndpointHeaders.class);
    }

    /**
     * Gets the specified deployed language generation endpoint.
     *
     * @param id the UUID value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getLanguageGenerationEndpoint(UUID id) {
        return getLanguageGenerationEndpointWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Gets the specified deployed language generation endpoint.
     *
     * @param id the UUID value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getLanguageGenerationEndpointAsync(UUID id, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getLanguageGenerationEndpointWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Gets the specified deployed language generation endpoint.
     *
     * @param id the UUID value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getLanguageGenerationEndpointAsync(UUID id) {
        return getLanguageGenerationEndpointWithServiceResponseAsync(id).map(new Func1<ServiceResponseWithHeaders<Object, GetLanguageGenerationEndpointHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetLanguageGenerationEndpointHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the specified deployed language generation endpoint.
     *
     * @param id the UUID value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetLanguageGenerationEndpointHeaders>> getLanguageGenerationEndpointWithServiceResponseAsync(UUID id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.getLanguageGenerationEndpoint(id, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetLanguageGenerationEndpointHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetLanguageGenerationEndpointHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetLanguageGenerationEndpointHeaders> clientResponse = getLanguageGenerationEndpointDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetLanguageGenerationEndpointHeaders> getLanguageGenerationEndpointDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Endpoint>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, GetLanguageGenerationEndpointHeaders.class);
    }

    /**
     * Deletes the language generation model endpoint with the given id.
     *
     * @param id The identifier of the language generation model endpoint.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ErrorContent object if successful.
     */
    public ErrorContent deleteLanguageGenerationEndpoint(UUID id) {
        return deleteLanguageGenerationEndpointWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Deletes the language generation model endpoint with the given id.
     *
     * @param id The identifier of the language generation model endpoint.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ErrorContent> deleteLanguageGenerationEndpointAsync(UUID id, final ServiceCallback<ErrorContent> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(deleteLanguageGenerationEndpointWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Deletes the language generation model endpoint with the given id.
     *
     * @param id The identifier of the language generation model endpoint.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ErrorContent> deleteLanguageGenerationEndpointAsync(UUID id) {
        return deleteLanguageGenerationEndpointWithServiceResponseAsync(id).map(new Func1<ServiceResponseWithHeaders<ErrorContent, DeleteLanguageGenerationEndpointHeaders>, ErrorContent>() {
            @Override
            public ErrorContent call(ServiceResponseWithHeaders<ErrorContent, DeleteLanguageGenerationEndpointHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes the language generation model endpoint with the given id.
     *
     * @param id The identifier of the language generation model endpoint.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ServiceResponseWithHeaders<ErrorContent, DeleteLanguageGenerationEndpointHeaders>> deleteLanguageGenerationEndpointWithServiceResponseAsync(UUID id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.deleteLanguageGenerationEndpoint(id, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<ErrorContent, DeleteLanguageGenerationEndpointHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<ErrorContent, DeleteLanguageGenerationEndpointHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<ErrorContent, DeleteLanguageGenerationEndpointHeaders> clientResponse = deleteLanguageGenerationEndpointDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<ErrorContent, DeleteLanguageGenerationEndpointHeaders> deleteLanguageGenerationEndpointDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ErrorContent, CloudException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(405, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, DeleteLanguageGenerationEndpointHeaders.class);
    }

    /**
     * Updates the mutable details of the language generation endpoint identified by its id.
     *
     * @param id The identifier of the language generation model endpoint.
     * @param endpointUpdate The object contains the updated fields of the endpoint.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateLanguageGenerationEndpoint(UUID id, EndpointUpdate endpointUpdate) {
        return updateLanguageGenerationEndpointWithServiceResponseAsync(id, endpointUpdate).toBlocking().single().body();
    }

    /**
     * Updates the mutable details of the language generation endpoint identified by its id.
     *
     * @param id The identifier of the language generation model endpoint.
     * @param endpointUpdate The object contains the updated fields of the endpoint.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateLanguageGenerationEndpointAsync(UUID id, EndpointUpdate endpointUpdate, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateLanguageGenerationEndpointWithServiceResponseAsync(id, endpointUpdate), serviceCallback);
    }

    /**
     * Updates the mutable details of the language generation endpoint identified by its id.
     *
     * @param id The identifier of the language generation model endpoint.
     * @param endpointUpdate The object contains the updated fields of the endpoint.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateLanguageGenerationEndpointAsync(UUID id, EndpointUpdate endpointUpdate) {
        return updateLanguageGenerationEndpointWithServiceResponseAsync(id, endpointUpdate).map(new Func1<ServiceResponseWithHeaders<Object, UpdateLanguageGenerationEndpointHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, UpdateLanguageGenerationEndpointHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the mutable details of the language generation endpoint identified by its id.
     *
     * @param id The identifier of the language generation model endpoint.
     * @param endpointUpdate The object contains the updated fields of the endpoint.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, UpdateLanguageGenerationEndpointHeaders>> updateLanguageGenerationEndpointWithServiceResponseAsync(UUID id, EndpointUpdate endpointUpdate) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (endpointUpdate == null) {
            throw new IllegalArgumentException("Parameter endpointUpdate is required and cannot be null.");
        }
        Validator.validate(endpointUpdate);
        return service.updateLanguageGenerationEndpoint(id, endpointUpdate, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, UpdateLanguageGenerationEndpointHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, UpdateLanguageGenerationEndpointHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, UpdateLanguageGenerationEndpointHeaders> clientResponse = updateLanguageGenerationEndpointDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, UpdateLanguageGenerationEndpointHeaders> updateLanguageGenerationEndpointDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Endpoint>() { }.getType())
                .register(400, new TypeToken<ErrorContent>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(409, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, UpdateLanguageGenerationEndpointHeaders.class);
    }

    /**
     * Gets a list of supported locales for language generation endpoint creation.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getSupportedLocalesForLanguageGenerationEndpoints() {
        return getSupportedLocalesForLanguageGenerationEndpointsWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets a list of supported locales for language generation endpoint creation.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getSupportedLocalesForLanguageGenerationEndpointsAsync(final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getSupportedLocalesForLanguageGenerationEndpointsWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets a list of supported locales for language generation endpoint creation.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getSupportedLocalesForLanguageGenerationEndpointsAsync() {
        return getSupportedLocalesForLanguageGenerationEndpointsWithServiceResponseAsync().map(new Func1<ServiceResponseWithHeaders<Object, GetSupportedLocalesForLanguageGenerationEndpointsHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetSupportedLocalesForLanguageGenerationEndpointsHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of supported locales for language generation endpoint creation.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetSupportedLocalesForLanguageGenerationEndpointsHeaders>> getSupportedLocalesForLanguageGenerationEndpointsWithServiceResponseAsync() {
        return service.getSupportedLocalesForLanguageGenerationEndpoints(this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetSupportedLocalesForLanguageGenerationEndpointsHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetSupportedLocalesForLanguageGenerationEndpointsHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetSupportedLocalesForLanguageGenerationEndpointsHeaders> clientResponse = getSupportedLocalesForLanguageGenerationEndpointsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetSupportedLocalesForLanguageGenerationEndpointsHeaders> getSupportedLocalesForLanguageGenerationEndpointsDelegate(Response<ResponseBody> response) throws CloudException, IOException {
        return this.restClient().responseBuilderFactory().<Object, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<String>>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, GetSupportedLocalesForLanguageGenerationEndpointsHeaders.class);
    }

    /**
     * Gets all language generation model of a subscription.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getLanguageGenerationModels() {
        return getLanguageGenerationModelsWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets all language generation model of a subscription.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getLanguageGenerationModelsAsync(final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getLanguageGenerationModelsWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets all language generation model of a subscription.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getLanguageGenerationModelsAsync() {
        return getLanguageGenerationModelsWithServiceResponseAsync().map(new Func1<ServiceResponseWithHeaders<Object, GetLanguageGenerationModelsHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetLanguageGenerationModelsHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets all language generation model of a subscription.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetLanguageGenerationModelsHeaders>> getLanguageGenerationModelsWithServiceResponseAsync() {
        return service.getLanguageGenerationModels(this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetLanguageGenerationModelsHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetLanguageGenerationModelsHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetLanguageGenerationModelsHeaders> clientResponse = getLanguageGenerationModelsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetLanguageGenerationModelsHeaders> getLanguageGenerationModelsDelegate(Response<ResponseBody> response) throws CloudException, IOException {
        return this.restClient().responseBuilderFactory().<Object, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<Model>>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, GetLanguageGenerationModelsHeaders.class);
    }

    /**
     * Creates a new language generation model.
     *
     * @param modelDefinition the ModelDefinition value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ErrorContent object if successful.
     */
    public ErrorContent createLanguageGenerationModel(ModelDefinition modelDefinition) {
        return createLanguageGenerationModelWithServiceResponseAsync(modelDefinition).toBlocking().single().body();
    }

    /**
     * Creates a new language generation model.
     *
     * @param modelDefinition the ModelDefinition value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ErrorContent> createLanguageGenerationModelAsync(ModelDefinition modelDefinition, final ServiceCallback<ErrorContent> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createLanguageGenerationModelWithServiceResponseAsync(modelDefinition), serviceCallback);
    }

    /**
     * Creates a new language generation model.
     *
     * @param modelDefinition the ModelDefinition value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ErrorContent> createLanguageGenerationModelAsync(ModelDefinition modelDefinition) {
        return createLanguageGenerationModelWithServiceResponseAsync(modelDefinition).map(new Func1<ServiceResponseWithHeaders<ErrorContent, CreateLanguageGenerationModelHeaders>, ErrorContent>() {
            @Override
            public ErrorContent call(ServiceResponseWithHeaders<ErrorContent, CreateLanguageGenerationModelHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new language generation model.
     *
     * @param modelDefinition the ModelDefinition value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ServiceResponseWithHeaders<ErrorContent, CreateLanguageGenerationModelHeaders>> createLanguageGenerationModelWithServiceResponseAsync(ModelDefinition modelDefinition) {
        if (modelDefinition == null) {
            throw new IllegalArgumentException("Parameter modelDefinition is required and cannot be null.");
        }
        Validator.validate(modelDefinition);
        return service.createLanguageGenerationModel(modelDefinition, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<ErrorContent, CreateLanguageGenerationModelHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<ErrorContent, CreateLanguageGenerationModelHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<ErrorContent, CreateLanguageGenerationModelHeaders> clientResponse = createLanguageGenerationModelDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<ErrorContent, CreateLanguageGenerationModelHeaders> createLanguageGenerationModelDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ErrorContent, CloudException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .register(400, new TypeToken<ErrorContent>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, CreateLanguageGenerationModelHeaders.class);
    }

    /**
     * Gets the specified language generation model.
     *
     * @param id the UUID value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getLanguageGenerationModel(UUID id) {
        return getLanguageGenerationModelWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Gets the specified language generation model.
     *
     * @param id the UUID value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getLanguageGenerationModelAsync(UUID id, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getLanguageGenerationModelWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Gets the specified language generation model.
     *
     * @param id the UUID value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getLanguageGenerationModelAsync(UUID id) {
        return getLanguageGenerationModelWithServiceResponseAsync(id).map(new Func1<ServiceResponseWithHeaders<Object, GetLanguageGenerationModelHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetLanguageGenerationModelHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the specified language generation model.
     *
     * @param id the UUID value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetLanguageGenerationModelHeaders>> getLanguageGenerationModelWithServiceResponseAsync(UUID id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.getLanguageGenerationModel(id, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetLanguageGenerationModelHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetLanguageGenerationModelHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetLanguageGenerationModelHeaders> clientResponse = getLanguageGenerationModelDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetLanguageGenerationModelHeaders> getLanguageGenerationModelDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Model>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, GetLanguageGenerationModelHeaders.class);
    }

    /**
     * Deletes the language generation model with the given id.
     *
     * @param id The identifier of the language generation model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ErrorContent object if successful.
     */
    public ErrorContent deleteLanguageGenerationModel(UUID id) {
        return deleteLanguageGenerationModelWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Deletes the language generation model with the given id.
     *
     * @param id The identifier of the language generation model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ErrorContent> deleteLanguageGenerationModelAsync(UUID id, final ServiceCallback<ErrorContent> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(deleteLanguageGenerationModelWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Deletes the language generation model with the given id.
     *
     * @param id The identifier of the language generation model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ErrorContent> deleteLanguageGenerationModelAsync(UUID id) {
        return deleteLanguageGenerationModelWithServiceResponseAsync(id).map(new Func1<ServiceResponseWithHeaders<ErrorContent, DeleteLanguageGenerationModelHeaders>, ErrorContent>() {
            @Override
            public ErrorContent call(ServiceResponseWithHeaders<ErrorContent, DeleteLanguageGenerationModelHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes the language generation model with the given id.
     *
     * @param id The identifier of the language generation model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ServiceResponseWithHeaders<ErrorContent, DeleteLanguageGenerationModelHeaders>> deleteLanguageGenerationModelWithServiceResponseAsync(UUID id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.deleteLanguageGenerationModel(id, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<ErrorContent, DeleteLanguageGenerationModelHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<ErrorContent, DeleteLanguageGenerationModelHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<ErrorContent, DeleteLanguageGenerationModelHeaders> clientResponse = deleteLanguageGenerationModelDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<ErrorContent, DeleteLanguageGenerationModelHeaders> deleteLanguageGenerationModelDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ErrorContent, CloudException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(405, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, DeleteLanguageGenerationModelHeaders.class);
    }

    /**
     * Updates the mutable details of the language generation model identified by its id.
     *
     * @param id The route parameter identifies the language generation model to change.
     * @param modelUpdate The object contains the updated fields of the model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateLanguageGenerationModel(UUID id, ModelUpdate modelUpdate) {
        return updateLanguageGenerationModelWithServiceResponseAsync(id, modelUpdate).toBlocking().single().body();
    }

    /**
     * Updates the mutable details of the language generation model identified by its id.
     *
     * @param id The route parameter identifies the language generation model to change.
     * @param modelUpdate The object contains the updated fields of the model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateLanguageGenerationModelAsync(UUID id, ModelUpdate modelUpdate, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateLanguageGenerationModelWithServiceResponseAsync(id, modelUpdate), serviceCallback);
    }

    /**
     * Updates the mutable details of the language generation model identified by its id.
     *
     * @param id The route parameter identifies the language generation model to change.
     * @param modelUpdate The object contains the updated fields of the model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateLanguageGenerationModelAsync(UUID id, ModelUpdate modelUpdate) {
        return updateLanguageGenerationModelWithServiceResponseAsync(id, modelUpdate).map(new Func1<ServiceResponseWithHeaders<Object, UpdateLanguageGenerationModelHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, UpdateLanguageGenerationModelHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the mutable details of the language generation model identified by its id.
     *
     * @param id The route parameter identifies the language generation model to change.
     * @param modelUpdate The object contains the updated fields of the model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, UpdateLanguageGenerationModelHeaders>> updateLanguageGenerationModelWithServiceResponseAsync(UUID id, ModelUpdate modelUpdate) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (modelUpdate == null) {
            throw new IllegalArgumentException("Parameter modelUpdate is required and cannot be null.");
        }
        Validator.validate(modelUpdate);
        return service.updateLanguageGenerationModel(id, modelUpdate, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, UpdateLanguageGenerationModelHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, UpdateLanguageGenerationModelHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, UpdateLanguageGenerationModelHeaders> clientResponse = updateLanguageGenerationModelDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, UpdateLanguageGenerationModelHeaders> updateLanguageGenerationModelDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Model>() { }.getType())
                .register(400, new TypeToken<ErrorContent>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(409, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, UpdateLanguageGenerationModelHeaders.class);
    }

    /**
     * Gets a list of supported locales for language generation model creation.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getSupportedLocalesForLanguageGenerationModels() {
        return getSupportedLocalesForLanguageGenerationModelsWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets a list of supported locales for language generation model creation.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getSupportedLocalesForLanguageGenerationModelsAsync(final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getSupportedLocalesForLanguageGenerationModelsWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets a list of supported locales for language generation model creation.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getSupportedLocalesForLanguageGenerationModelsAsync() {
        return getSupportedLocalesForLanguageGenerationModelsWithServiceResponseAsync().map(new Func1<ServiceResponseWithHeaders<Object, GetSupportedLocalesForLanguageGenerationModelsHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetSupportedLocalesForLanguageGenerationModelsHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of supported locales for language generation model creation.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetSupportedLocalesForLanguageGenerationModelsHeaders>> getSupportedLocalesForLanguageGenerationModelsWithServiceResponseAsync() {
        return service.getSupportedLocalesForLanguageGenerationModels(this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetSupportedLocalesForLanguageGenerationModelsHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetSupportedLocalesForLanguageGenerationModelsHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetSupportedLocalesForLanguageGenerationModelsHeaders> clientResponse = getSupportedLocalesForLanguageGenerationModelsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetSupportedLocalesForLanguageGenerationModelsHeaders> getSupportedLocalesForLanguageGenerationModelsDelegate(Response<ResponseBody> response) throws CloudException, IOException {
        return this.restClient().responseBuilderFactory().<Object, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<String>>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, GetSupportedLocalesForLanguageGenerationModelsHeaders.class);
    }

    /**
     * The action returns the health of the different components of the serivce.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HealthStatusResponse object if successful.
     */
    public HealthStatusResponse getHealthStatus() {
        return getHealthStatusWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * The action returns the health of the different components of the serivce.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HealthStatusResponse> getHealthStatusAsync(final ServiceCallback<HealthStatusResponse> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getHealthStatusWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * The action returns the health of the different components of the serivce.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HealthStatusResponse object
     */
    public Observable<HealthStatusResponse> getHealthStatusAsync() {
        return getHealthStatusWithServiceResponseAsync().map(new Func1<ServiceResponseWithHeaders<HealthStatusResponse, GetHealthStatusHeaders>, HealthStatusResponse>() {
            @Override
            public HealthStatusResponse call(ServiceResponseWithHeaders<HealthStatusResponse, GetHealthStatusHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * The action returns the health of the different components of the serivce.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HealthStatusResponse object
     */
    public Observable<ServiceResponseWithHeaders<HealthStatusResponse, GetHealthStatusHeaders>> getHealthStatusWithServiceResponseAsync() {
        return service.getHealthStatus(this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<HealthStatusResponse, GetHealthStatusHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<HealthStatusResponse, GetHealthStatusHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<HealthStatusResponse, GetHealthStatusHeaders> clientResponse = getHealthStatusDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<HealthStatusResponse, GetHealthStatusHeaders> getHealthStatusDelegate(Response<ResponseBody> response) throws CloudException, IOException {
        return this.restClient().responseBuilderFactory().<HealthStatusResponse, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<HealthStatusResponse>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, GetHealthStatusHeaders.class);
    }

    /**
     * Gets all voice datasets of a user.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getVoiceDatasets() {
        return getVoiceDatasetsWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets all voice datasets of a user.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getVoiceDatasetsAsync(final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getVoiceDatasetsWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets all voice datasets of a user.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getVoiceDatasetsAsync() {
        return getVoiceDatasetsWithServiceResponseAsync().map(new Func1<ServiceResponseWithHeaders<Object, GetVoiceDatasetsHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetVoiceDatasetsHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets all voice datasets of a user.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetVoiceDatasetsHeaders>> getVoiceDatasetsWithServiceResponseAsync() {
        return service.getVoiceDatasets(this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetVoiceDatasetsHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetVoiceDatasetsHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetVoiceDatasetsHeaders> clientResponse = getVoiceDatasetsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetVoiceDatasetsHeaders> getVoiceDatasetsDelegate(Response<ResponseBody> response) throws CloudException, IOException {
        return this.restClient().responseBuilderFactory().<Object, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<Dataset>>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, GetVoiceDatasetsHeaders.class);
    }

    /**
     * Gets a list of supported locales for custom voice data imports.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getSupportedLocalesForVoiceDatasets() {
        return getSupportedLocalesForVoiceDatasetsWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets a list of supported locales for custom voice data imports.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getSupportedLocalesForVoiceDatasetsAsync(final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getSupportedLocalesForVoiceDatasetsWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets a list of supported locales for custom voice data imports.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getSupportedLocalesForVoiceDatasetsAsync() {
        return getSupportedLocalesForVoiceDatasetsWithServiceResponseAsync().map(new Func1<ServiceResponseWithHeaders<Object, GetSupportedLocalesForVoiceDatasetsHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetSupportedLocalesForVoiceDatasetsHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of supported locales for custom voice data imports.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetSupportedLocalesForVoiceDatasetsHeaders>> getSupportedLocalesForVoiceDatasetsWithServiceResponseAsync() {
        return service.getSupportedLocalesForVoiceDatasets(this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetSupportedLocalesForVoiceDatasetsHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetSupportedLocalesForVoiceDatasetsHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetSupportedLocalesForVoiceDatasetsHeaders> clientResponse = getSupportedLocalesForVoiceDatasetsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetSupportedLocalesForVoiceDatasetsHeaders> getSupportedLocalesForVoiceDatasetsDelegate(Response<ResponseBody> response) throws CloudException, IOException {
        return this.restClient().responseBuilderFactory().<Object, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<String>>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, GetSupportedLocalesForVoiceDatasetsHeaders.class);
    }

    /**
     * Uploads data and creates a new voice data object.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ErrorContent object if successful.
     */
    public ErrorContent uploadVoiceDataset() {
        return uploadVoiceDatasetWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Uploads data and creates a new voice data object.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ErrorContent> uploadVoiceDatasetAsync(final ServiceCallback<ErrorContent> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(uploadVoiceDatasetWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Uploads data and creates a new voice data object.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ErrorContent> uploadVoiceDatasetAsync() {
        return uploadVoiceDatasetWithServiceResponseAsync().map(new Func1<ServiceResponseWithHeaders<ErrorContent, UploadVoiceDatasetHeaders>, ErrorContent>() {
            @Override
            public ErrorContent call(ServiceResponseWithHeaders<ErrorContent, UploadVoiceDatasetHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Uploads data and creates a new voice data object.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ServiceResponseWithHeaders<ErrorContent, UploadVoiceDatasetHeaders>> uploadVoiceDatasetWithServiceResponseAsync() {
        final String name = null;
        final String description = null;
        final String locale = null;
        final String dataImportKind = null;
        final String properties = null;
        final byte[] audiodata = new byte[0];
        final byte[] transcriptions = new byte[0];
        RequestBody audiodataConverted = RequestBody.create(MediaType.parse("multipart/form-data"), new byte[0]);
        if (audiodata != null) {
            audiodataConverted = RequestBody.create(MediaType.parse("multipart/form-data"), audiodata);
        }
        RequestBody transcriptionsConverted = RequestBody.create(MediaType.parse("multipart/form-data"), new byte[0]);
        if (transcriptions != null) {
            transcriptionsConverted = RequestBody.create(MediaType.parse("multipart/form-data"), transcriptions);
        }
        return service.uploadVoiceDataset(name, description, locale, dataImportKind, properties, audiodataConverted, transcriptionsConverted, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<ErrorContent, UploadVoiceDatasetHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<ErrorContent, UploadVoiceDatasetHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<ErrorContent, UploadVoiceDatasetHeaders> clientResponse = uploadVoiceDatasetDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Uploads data and creates a new voice data object.
     *
     * @param name The name of this data import (always add this string for any import).
     * @param description Optional description of this data import.
     * @param locale The locale of this data import (always add this string for any import).
     * @param dataImportKind The kind of the data import (always add this string for any import). Possible values include: 'None', 'Language', 'Acoustic', 'Pronunciation', 'CustomVoice', 'LanguageGeneration'
     * @param properties Optional properties of this data import (json serialized object with key/values, where all values must be strings)
     * @param audiodata A zip file containing the audio data.
     * @param transcriptions The transcriptions text file of the audio data.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ErrorContent object if successful.
     */
    public ErrorContent uploadVoiceDataset(String name, String description, String locale, String dataImportKind, String properties, byte[] audiodata, byte[] transcriptions) {
        return uploadVoiceDatasetWithServiceResponseAsync(name, description, locale, dataImportKind, properties, audiodata, transcriptions).toBlocking().single().body();
    }

    /**
     * Uploads data and creates a new voice data object.
     *
     * @param name The name of this data import (always add this string for any import).
     * @param description Optional description of this data import.
     * @param locale The locale of this data import (always add this string for any import).
     * @param dataImportKind The kind of the data import (always add this string for any import). Possible values include: 'None', 'Language', 'Acoustic', 'Pronunciation', 'CustomVoice', 'LanguageGeneration'
     * @param properties Optional properties of this data import (json serialized object with key/values, where all values must be strings)
     * @param audiodata A zip file containing the audio data.
     * @param transcriptions The transcriptions text file of the audio data.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ErrorContent> uploadVoiceDatasetAsync(String name, String description, String locale, String dataImportKind, String properties, byte[] audiodata, byte[] transcriptions, final ServiceCallback<ErrorContent> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(uploadVoiceDatasetWithServiceResponseAsync(name, description, locale, dataImportKind, properties, audiodata, transcriptions), serviceCallback);
    }

    /**
     * Uploads data and creates a new voice data object.
     *
     * @param name The name of this data import (always add this string for any import).
     * @param description Optional description of this data import.
     * @param locale The locale of this data import (always add this string for any import).
     * @param dataImportKind The kind of the data import (always add this string for any import). Possible values include: 'None', 'Language', 'Acoustic', 'Pronunciation', 'CustomVoice', 'LanguageGeneration'
     * @param properties Optional properties of this data import (json serialized object with key/values, where all values must be strings)
     * @param audiodata A zip file containing the audio data.
     * @param transcriptions The transcriptions text file of the audio data.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ErrorContent> uploadVoiceDatasetAsync(String name, String description, String locale, String dataImportKind, String properties, byte[] audiodata, byte[] transcriptions) {
        return uploadVoiceDatasetWithServiceResponseAsync(name, description, locale, dataImportKind, properties, audiodata, transcriptions).map(new Func1<ServiceResponseWithHeaders<ErrorContent, UploadVoiceDatasetHeaders>, ErrorContent>() {
            @Override
            public ErrorContent call(ServiceResponseWithHeaders<ErrorContent, UploadVoiceDatasetHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Uploads data and creates a new voice data object.
     *
     * @param name The name of this data import (always add this string for any import).
     * @param description Optional description of this data import.
     * @param locale The locale of this data import (always add this string for any import).
     * @param dataImportKind The kind of the data import (always add this string for any import). Possible values include: 'None', 'Language', 'Acoustic', 'Pronunciation', 'CustomVoice', 'LanguageGeneration'
     * @param properties Optional properties of this data import (json serialized object with key/values, where all values must be strings)
     * @param audiodata A zip file containing the audio data.
     * @param transcriptions The transcriptions text file of the audio data.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ServiceResponseWithHeaders<ErrorContent, UploadVoiceDatasetHeaders>> uploadVoiceDatasetWithServiceResponseAsync(String name, String description, String locale, String dataImportKind, String properties, byte[] audiodata, byte[] transcriptions) {
        RequestBody audiodataConverted = RequestBody.create(MediaType.parse("multipart/form-data"), new byte[0]);
        if (audiodata != null) {
            audiodataConverted = RequestBody.create(MediaType.parse("multipart/form-data"), audiodata);
        }
        RequestBody transcriptionsConverted = RequestBody.create(MediaType.parse("multipart/form-data"), new byte[0]);
        if (transcriptions != null) {
            transcriptionsConverted = RequestBody.create(MediaType.parse("multipart/form-data"), transcriptions);
        }
        return service.uploadVoiceDataset(name, description, locale, dataImportKind, properties, audiodataConverted, transcriptionsConverted, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<ErrorContent, UploadVoiceDatasetHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<ErrorContent, UploadVoiceDatasetHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<ErrorContent, UploadVoiceDatasetHeaders> clientResponse = uploadVoiceDatasetDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<ErrorContent, UploadVoiceDatasetHeaders> uploadVoiceDatasetDelegate(Response<ResponseBody> response) throws CloudException, IOException {
        return this.restClient().responseBuilderFactory().<ErrorContent, CloudException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .register(400, new TypeToken<ErrorContent>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(415, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, UploadVoiceDatasetHeaders.class);
    }

    /**
     * Deletes the voice dataset with the given id.
     *
     * @param id The identifier of the voice dataset
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ErrorContent object if successful.
     */
    public ErrorContent deleteVoiceDataset(UUID id) {
        return deleteVoiceDatasetWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Deletes the voice dataset with the given id.
     *
     * @param id The identifier of the voice dataset
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ErrorContent> deleteVoiceDatasetAsync(UUID id, final ServiceCallback<ErrorContent> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(deleteVoiceDatasetWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Deletes the voice dataset with the given id.
     *
     * @param id The identifier of the voice dataset
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ErrorContent> deleteVoiceDatasetAsync(UUID id) {
        return deleteVoiceDatasetWithServiceResponseAsync(id).map(new Func1<ServiceResponseWithHeaders<ErrorContent, DeleteVoiceDatasetHeaders>, ErrorContent>() {
            @Override
            public ErrorContent call(ServiceResponseWithHeaders<ErrorContent, DeleteVoiceDatasetHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes the voice dataset with the given id.
     *
     * @param id The identifier of the voice dataset
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ServiceResponseWithHeaders<ErrorContent, DeleteVoiceDatasetHeaders>> deleteVoiceDatasetWithServiceResponseAsync(UUID id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.deleteVoiceDataset(id, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<ErrorContent, DeleteVoiceDatasetHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<ErrorContent, DeleteVoiceDatasetHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<ErrorContent, DeleteVoiceDatasetHeaders> clientResponse = deleteVoiceDatasetDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<ErrorContent, DeleteVoiceDatasetHeaders> deleteVoiceDatasetDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ErrorContent, CloudException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(405, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, DeleteVoiceDatasetHeaders.class);
    }

    /**
     * Updates the mutable details of the voice dataset identified by its ID.
     *
     * @param id The identifier of the voice dataset.
     * @param datasetUpdate The updated values for the voice dataset.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateVoiceDataset(UUID id, DatasetUpdate datasetUpdate) {
        return updateVoiceDatasetWithServiceResponseAsync(id, datasetUpdate).toBlocking().single().body();
    }

    /**
     * Updates the mutable details of the voice dataset identified by its ID.
     *
     * @param id The identifier of the voice dataset.
     * @param datasetUpdate The updated values for the voice dataset.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateVoiceDatasetAsync(UUID id, DatasetUpdate datasetUpdate, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateVoiceDatasetWithServiceResponseAsync(id, datasetUpdate), serviceCallback);
    }

    /**
     * Updates the mutable details of the voice dataset identified by its ID.
     *
     * @param id The identifier of the voice dataset.
     * @param datasetUpdate The updated values for the voice dataset.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateVoiceDatasetAsync(UUID id, DatasetUpdate datasetUpdate) {
        return updateVoiceDatasetWithServiceResponseAsync(id, datasetUpdate).map(new Func1<ServiceResponseWithHeaders<Object, UpdateVoiceDatasetHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, UpdateVoiceDatasetHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the mutable details of the voice dataset identified by its ID.
     *
     * @param id The identifier of the voice dataset.
     * @param datasetUpdate The updated values for the voice dataset.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, UpdateVoiceDatasetHeaders>> updateVoiceDatasetWithServiceResponseAsync(UUID id, DatasetUpdate datasetUpdate) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (datasetUpdate == null) {
            throw new IllegalArgumentException("Parameter datasetUpdate is required and cannot be null.");
        }
        Validator.validate(datasetUpdate);
        return service.updateVoiceDataset(id, datasetUpdate, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, UpdateVoiceDatasetHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, UpdateVoiceDatasetHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, UpdateVoiceDatasetHeaders> clientResponse = updateVoiceDatasetDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, UpdateVoiceDatasetHeaders> updateVoiceDatasetDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Dataset>() { }.getType())
                .register(400, new TypeToken<ErrorContent>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(409, new TypeToken<ErrorContent>() { }.getType())
                .register(415, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, UpdateVoiceDatasetHeaders.class);
    }

    /**
     * Gets a list of voice endpoint details.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getVoiceDeployments() {
        return getVoiceDeploymentsWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets a list of voice endpoint details.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getVoiceDeploymentsAsync(final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getVoiceDeploymentsWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets a list of voice endpoint details.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getVoiceDeploymentsAsync() {
        return getVoiceDeploymentsWithServiceResponseAsync().map(new Func1<ServiceResponseWithHeaders<Object, GetVoiceDeploymentsHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetVoiceDeploymentsHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of voice endpoint details.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetVoiceDeploymentsHeaders>> getVoiceDeploymentsWithServiceResponseAsync() {
        return service.getVoiceDeployments(this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetVoiceDeploymentsHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetVoiceDeploymentsHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetVoiceDeploymentsHeaders> clientResponse = getVoiceDeploymentsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetVoiceDeploymentsHeaders> getVoiceDeploymentsDelegate(Response<ResponseBody> response) throws CloudException, IOException {
        return this.restClient().responseBuilderFactory().<Object, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<Endpoint>>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, GetVoiceDeploymentsHeaders.class);
    }

    /**
     * Creates a new voice endpoint object.
     *
     * @param endpoint the EndpointDefinition value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ErrorContent object if successful.
     */
    public ErrorContent createVoiceDeployment(EndpointDefinition endpoint) {
        return createVoiceDeploymentWithServiceResponseAsync(endpoint).toBlocking().single().body();
    }

    /**
     * Creates a new voice endpoint object.
     *
     * @param endpoint the EndpointDefinition value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ErrorContent> createVoiceDeploymentAsync(EndpointDefinition endpoint, final ServiceCallback<ErrorContent> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createVoiceDeploymentWithServiceResponseAsync(endpoint), serviceCallback);
    }

    /**
     * Creates a new voice endpoint object.
     *
     * @param endpoint the EndpointDefinition value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ErrorContent> createVoiceDeploymentAsync(EndpointDefinition endpoint) {
        return createVoiceDeploymentWithServiceResponseAsync(endpoint).map(new Func1<ServiceResponseWithHeaders<ErrorContent, CreateVoiceDeploymentHeaders>, ErrorContent>() {
            @Override
            public ErrorContent call(ServiceResponseWithHeaders<ErrorContent, CreateVoiceDeploymentHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new voice endpoint object.
     *
     * @param endpoint the EndpointDefinition value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ServiceResponseWithHeaders<ErrorContent, CreateVoiceDeploymentHeaders>> createVoiceDeploymentWithServiceResponseAsync(EndpointDefinition endpoint) {
        if (endpoint == null) {
            throw new IllegalArgumentException("Parameter endpoint is required and cannot be null.");
        }
        Validator.validate(endpoint);
        return service.createVoiceDeployment(endpoint, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<ErrorContent, CreateVoiceDeploymentHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<ErrorContent, CreateVoiceDeploymentHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<ErrorContent, CreateVoiceDeploymentHeaders> clientResponse = createVoiceDeploymentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<ErrorContent, CreateVoiceDeploymentHeaders> createVoiceDeploymentDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ErrorContent, CloudException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .register(400, new TypeToken<ErrorContent>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, CreateVoiceDeploymentHeaders.class);
    }

    /**
     * Gets the details of a Custom Voice endpoint.
     *
     * @param id the UUID value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getVoiceDeployment(UUID id) {
        return getVoiceDeploymentWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Gets the details of a Custom Voice endpoint.
     *
     * @param id the UUID value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getVoiceDeploymentAsync(UUID id, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getVoiceDeploymentWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Gets the details of a Custom Voice endpoint.
     *
     * @param id the UUID value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getVoiceDeploymentAsync(UUID id) {
        return getVoiceDeploymentWithServiceResponseAsync(id).map(new Func1<ServiceResponseWithHeaders<Object, GetVoiceDeploymentHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetVoiceDeploymentHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the details of a Custom Voice endpoint.
     *
     * @param id the UUID value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetVoiceDeploymentHeaders>> getVoiceDeploymentWithServiceResponseAsync(UUID id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.getVoiceDeployment(id, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetVoiceDeploymentHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetVoiceDeploymentHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetVoiceDeploymentHeaders> clientResponse = getVoiceDeploymentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetVoiceDeploymentHeaders> getVoiceDeploymentDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Endpoint>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, GetVoiceDeploymentHeaders.class);
    }

    /**
     * Delete the specified voice endpoint.
     *
     * @param id The id of voice endpoint.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ErrorContent object if successful.
     */
    public ErrorContent deleteDeployment(UUID id) {
        return deleteDeploymentWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Delete the specified voice endpoint.
     *
     * @param id The id of voice endpoint.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ErrorContent> deleteDeploymentAsync(UUID id, final ServiceCallback<ErrorContent> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(deleteDeploymentWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Delete the specified voice endpoint.
     *
     * @param id The id of voice endpoint.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ErrorContent> deleteDeploymentAsync(UUID id) {
        return deleteDeploymentWithServiceResponseAsync(id).map(new Func1<ServiceResponseWithHeaders<ErrorContent, DeleteDeploymentHeaders>, ErrorContent>() {
            @Override
            public ErrorContent call(ServiceResponseWithHeaders<ErrorContent, DeleteDeploymentHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete the specified voice endpoint.
     *
     * @param id The id of voice endpoint.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ServiceResponseWithHeaders<ErrorContent, DeleteDeploymentHeaders>> deleteDeploymentWithServiceResponseAsync(UUID id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.deleteDeployment(id, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<ErrorContent, DeleteDeploymentHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<ErrorContent, DeleteDeploymentHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<ErrorContent, DeleteDeploymentHeaders> clientResponse = deleteDeploymentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<ErrorContent, DeleteDeploymentHeaders> deleteDeploymentDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ErrorContent, CloudException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(405, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, DeleteDeploymentHeaders.class);
    }

    /**
     * Updates the name and description of the endpoint identified by the given ID.
     *
     * @param id The identifier of the endpoint.
     * @param endpointUpdate The updated values for the endpoint.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateVoiceEndpoint(UUID id, EndpointUpdate endpointUpdate) {
        return updateVoiceEndpointWithServiceResponseAsync(id, endpointUpdate).toBlocking().single().body();
    }

    /**
     * Updates the name and description of the endpoint identified by the given ID.
     *
     * @param id The identifier of the endpoint.
     * @param endpointUpdate The updated values for the endpoint.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateVoiceEndpointAsync(UUID id, EndpointUpdate endpointUpdate, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateVoiceEndpointWithServiceResponseAsync(id, endpointUpdate), serviceCallback);
    }

    /**
     * Updates the name and description of the endpoint identified by the given ID.
     *
     * @param id The identifier of the endpoint.
     * @param endpointUpdate The updated values for the endpoint.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateVoiceEndpointAsync(UUID id, EndpointUpdate endpointUpdate) {
        return updateVoiceEndpointWithServiceResponseAsync(id, endpointUpdate).map(new Func1<ServiceResponseWithHeaders<Object, UpdateVoiceEndpointHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, UpdateVoiceEndpointHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the name and description of the endpoint identified by the given ID.
     *
     * @param id The identifier of the endpoint.
     * @param endpointUpdate The updated values for the endpoint.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, UpdateVoiceEndpointHeaders>> updateVoiceEndpointWithServiceResponseAsync(UUID id, EndpointUpdate endpointUpdate) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (endpointUpdate == null) {
            throw new IllegalArgumentException("Parameter endpointUpdate is required and cannot be null.");
        }
        Validator.validate(endpointUpdate);
        return service.updateVoiceEndpoint(id, endpointUpdate, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, UpdateVoiceEndpointHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, UpdateVoiceEndpointHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, UpdateVoiceEndpointHeaders> clientResponse = updateVoiceEndpointDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, UpdateVoiceEndpointHeaders> updateVoiceEndpointDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Endpoint>() { }.getType())
                .register(400, new TypeToken<ErrorContent>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(409, new TypeToken<ErrorContent>() { }.getType())
                .register(415, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, UpdateVoiceEndpointHeaders.class);
    }

    /**
     * Gets a list of supported locales for custom voice Endpoints.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getSupportedLocalesForVoiceEndpoints() {
        return getSupportedLocalesForVoiceEndpointsWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets a list of supported locales for custom voice Endpoints.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getSupportedLocalesForVoiceEndpointsAsync(final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getSupportedLocalesForVoiceEndpointsWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets a list of supported locales for custom voice Endpoints.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getSupportedLocalesForVoiceEndpointsAsync() {
        return getSupportedLocalesForVoiceEndpointsWithServiceResponseAsync().map(new Func1<ServiceResponseWithHeaders<Object, GetSupportedLocalesForVoiceEndpointsHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetSupportedLocalesForVoiceEndpointsHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of supported locales for custom voice Endpoints.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetSupportedLocalesForVoiceEndpointsHeaders>> getSupportedLocalesForVoiceEndpointsWithServiceResponseAsync() {
        return service.getSupportedLocalesForVoiceEndpoints(this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetSupportedLocalesForVoiceEndpointsHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetSupportedLocalesForVoiceEndpointsHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetSupportedLocalesForVoiceEndpointsHeaders> clientResponse = getSupportedLocalesForVoiceEndpointsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetSupportedLocalesForVoiceEndpointsHeaders> getSupportedLocalesForVoiceEndpointsDelegate(Response<ResponseBody> response) throws CloudException, IOException {
        return this.restClient().responseBuilderFactory().<Object, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<String>>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, GetSupportedLocalesForVoiceEndpointsHeaders.class);
    }

    /**
     * Gets a list of voice model details.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getVoiceModels() {
        return getVoiceModelsWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets a list of voice model details.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getVoiceModelsAsync(final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getVoiceModelsWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets a list of voice model details.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getVoiceModelsAsync() {
        return getVoiceModelsWithServiceResponseAsync().map(new Func1<ServiceResponseWithHeaders<Object, GetVoiceModelsHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetVoiceModelsHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of voice model details.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetVoiceModelsHeaders>> getVoiceModelsWithServiceResponseAsync() {
        return service.getVoiceModels(this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetVoiceModelsHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetVoiceModelsHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetVoiceModelsHeaders> clientResponse = getVoiceModelsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetVoiceModelsHeaders> getVoiceModelsDelegate(Response<ResponseBody> response) throws CloudException, IOException {
        return this.restClient().responseBuilderFactory().<Object, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<Model>>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, GetVoiceModelsHeaders.class);
    }

    /**
     * Creates a new voice model object.
     *
     * @param modelDefinition the ModelDefinition value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ErrorContent object if successful.
     */
    public ErrorContent createVoiceModel(ModelDefinition modelDefinition) {
        return createVoiceModelWithServiceResponseAsync(modelDefinition).toBlocking().single().body();
    }

    /**
     * Creates a new voice model object.
     *
     * @param modelDefinition the ModelDefinition value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ErrorContent> createVoiceModelAsync(ModelDefinition modelDefinition, final ServiceCallback<ErrorContent> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createVoiceModelWithServiceResponseAsync(modelDefinition), serviceCallback);
    }

    /**
     * Creates a new voice model object.
     *
     * @param modelDefinition the ModelDefinition value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ErrorContent> createVoiceModelAsync(ModelDefinition modelDefinition) {
        return createVoiceModelWithServiceResponseAsync(modelDefinition).map(new Func1<ServiceResponseWithHeaders<ErrorContent, CreateVoiceModelHeaders>, ErrorContent>() {
            @Override
            public ErrorContent call(ServiceResponseWithHeaders<ErrorContent, CreateVoiceModelHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new voice model object.
     *
     * @param modelDefinition the ModelDefinition value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ServiceResponseWithHeaders<ErrorContent, CreateVoiceModelHeaders>> createVoiceModelWithServiceResponseAsync(ModelDefinition modelDefinition) {
        if (modelDefinition == null) {
            throw new IllegalArgumentException("Parameter modelDefinition is required and cannot be null.");
        }
        Validator.validate(modelDefinition);
        return service.createVoiceModel(modelDefinition, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<ErrorContent, CreateVoiceModelHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<ErrorContent, CreateVoiceModelHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<ErrorContent, CreateVoiceModelHeaders> clientResponse = createVoiceModelDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<ErrorContent, CreateVoiceModelHeaders> createVoiceModelDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ErrorContent, CloudException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .register(400, new TypeToken<ErrorContent>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, CreateVoiceModelHeaders.class);
    }

    /**
     * Gets specified voice model details.
     *
     * @param id the UUID value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getVoiceModel(UUID id) {
        return getVoiceModelWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Gets specified voice model details.
     *
     * @param id the UUID value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getVoiceModelAsync(UUID id, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getVoiceModelWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Gets specified voice model details.
     *
     * @param id the UUID value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getVoiceModelAsync(UUID id) {
        return getVoiceModelWithServiceResponseAsync(id).map(new Func1<ServiceResponseWithHeaders<Object, GetVoiceModelHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetVoiceModelHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets specified voice model details.
     *
     * @param id the UUID value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetVoiceModelHeaders>> getVoiceModelWithServiceResponseAsync(UUID id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.getVoiceModel(id, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetVoiceModelHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetVoiceModelHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetVoiceModelHeaders> clientResponse = getVoiceModelDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetVoiceModelHeaders> getVoiceModelDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Model>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, GetVoiceModelHeaders.class);
    }

    /**
     * Deletes the voice model with the given id.
     *
     * @param id The identifier of the voice model
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ErrorContent object if successful.
     */
    public ErrorContent deleteVoiceModel(UUID id) {
        return deleteVoiceModelWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Deletes the voice model with the given id.
     *
     * @param id The identifier of the voice model
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ErrorContent> deleteVoiceModelAsync(UUID id, final ServiceCallback<ErrorContent> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(deleteVoiceModelWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Deletes the voice model with the given id.
     *
     * @param id The identifier of the voice model
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ErrorContent> deleteVoiceModelAsync(UUID id) {
        return deleteVoiceModelWithServiceResponseAsync(id).map(new Func1<ServiceResponseWithHeaders<ErrorContent, DeleteVoiceModelHeaders>, ErrorContent>() {
            @Override
            public ErrorContent call(ServiceResponseWithHeaders<ErrorContent, DeleteVoiceModelHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes the voice model with the given id.
     *
     * @param id The identifier of the voice model
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ServiceResponseWithHeaders<ErrorContent, DeleteVoiceModelHeaders>> deleteVoiceModelWithServiceResponseAsync(UUID id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.deleteVoiceModel(id, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<ErrorContent, DeleteVoiceModelHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<ErrorContent, DeleteVoiceModelHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<ErrorContent, DeleteVoiceModelHeaders> clientResponse = deleteVoiceModelDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<ErrorContent, DeleteVoiceModelHeaders> deleteVoiceModelDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ErrorContent, CloudException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(405, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, DeleteVoiceModelHeaders.class);
    }

    /**
     * Updates the metadata of the voice model identified by the given ID.
     *
     * @param id The identifier of the voice model.
     * @param modelUpdate The updated values for the voice model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateVoiceModel(UUID id, ModelUpdate modelUpdate) {
        return updateVoiceModelWithServiceResponseAsync(id, modelUpdate).toBlocking().single().body();
    }

    /**
     * Updates the metadata of the voice model identified by the given ID.
     *
     * @param id The identifier of the voice model.
     * @param modelUpdate The updated values for the voice model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateVoiceModelAsync(UUID id, ModelUpdate modelUpdate, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateVoiceModelWithServiceResponseAsync(id, modelUpdate), serviceCallback);
    }

    /**
     * Updates the metadata of the voice model identified by the given ID.
     *
     * @param id The identifier of the voice model.
     * @param modelUpdate The updated values for the voice model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateVoiceModelAsync(UUID id, ModelUpdate modelUpdate) {
        return updateVoiceModelWithServiceResponseAsync(id, modelUpdate).map(new Func1<ServiceResponseWithHeaders<Object, UpdateVoiceModelHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, UpdateVoiceModelHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the metadata of the voice model identified by the given ID.
     *
     * @param id The identifier of the voice model.
     * @param modelUpdate The updated values for the voice model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, UpdateVoiceModelHeaders>> updateVoiceModelWithServiceResponseAsync(UUID id, ModelUpdate modelUpdate) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (modelUpdate == null) {
            throw new IllegalArgumentException("Parameter modelUpdate is required and cannot be null.");
        }
        Validator.validate(modelUpdate);
        return service.updateVoiceModel(id, modelUpdate, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, UpdateVoiceModelHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, UpdateVoiceModelHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, UpdateVoiceModelHeaders> clientResponse = updateVoiceModelDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, UpdateVoiceModelHeaders> updateVoiceModelDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Model>() { }.getType())
                .register(400, new TypeToken<ErrorContent>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(409, new TypeToken<ErrorContent>() { }.getType())
                .register(415, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, UpdateVoiceModelHeaders.class);
    }

    /**
     * Gets a list of supported locales for custom voice Models.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getSupportedLocalesForVoiceModels() {
        return getSupportedLocalesForVoiceModelsWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets a list of supported locales for custom voice Models.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getSupportedLocalesForVoiceModelsAsync(final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getSupportedLocalesForVoiceModelsWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets a list of supported locales for custom voice Models.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getSupportedLocalesForVoiceModelsAsync() {
        return getSupportedLocalesForVoiceModelsWithServiceResponseAsync().map(new Func1<ServiceResponseWithHeaders<Object, GetSupportedLocalesForVoiceModelsHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetSupportedLocalesForVoiceModelsHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of supported locales for custom voice Models.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetSupportedLocalesForVoiceModelsHeaders>> getSupportedLocalesForVoiceModelsWithServiceResponseAsync() {
        return service.getSupportedLocalesForVoiceModels(this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetSupportedLocalesForVoiceModelsHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetSupportedLocalesForVoiceModelsHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetSupportedLocalesForVoiceModelsHeaders> clientResponse = getSupportedLocalesForVoiceModelsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetSupportedLocalesForVoiceModelsHeaders> getSupportedLocalesForVoiceModelsDelegate(Response<ResponseBody> response) throws CloudException, IOException {
        return this.restClient().responseBuilderFactory().<Object, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<String>>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, GetSupportedLocalesForVoiceModelsHeaders.class);
    }

    /**
     * Gets detail of the specified voice test.
     *
     * @param id The identifier of the voice test.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getVoiceTest(UUID id) {
        return getVoiceTestWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Gets detail of the specified voice test.
     *
     * @param id The identifier of the voice test.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getVoiceTestAsync(UUID id, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getVoiceTestWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Gets detail of the specified voice test.
     *
     * @param id The identifier of the voice test.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getVoiceTestAsync(UUID id) {
        return getVoiceTestWithServiceResponseAsync(id).map(new Func1<ServiceResponseWithHeaders<Object, GetVoiceTestHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetVoiceTestHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets detail of the specified voice test.
     *
     * @param id The identifier of the voice test.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetVoiceTestHeaders>> getVoiceTestWithServiceResponseAsync(UUID id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.getVoiceTest(id, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetVoiceTestHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetVoiceTestHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetVoiceTestHeaders> clientResponse = getVoiceTestDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetVoiceTestHeaders> getVoiceTestDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<VoiceTest>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, GetVoiceTestHeaders.class);
    }

    /**
     * Deletes the specified voice test.
     *
     * @param id The identifier of the voice test.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ErrorContent object if successful.
     */
    public ErrorContent deleteVoiceTest(UUID id) {
        return deleteVoiceTestWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Deletes the specified voice test.
     *
     * @param id The identifier of the voice test.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ErrorContent> deleteVoiceTestAsync(UUID id, final ServiceCallback<ErrorContent> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(deleteVoiceTestWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Deletes the specified voice test.
     *
     * @param id The identifier of the voice test.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ErrorContent> deleteVoiceTestAsync(UUID id) {
        return deleteVoiceTestWithServiceResponseAsync(id).map(new Func1<ServiceResponseWithHeaders<ErrorContent, DeleteVoiceTestHeaders>, ErrorContent>() {
            @Override
            public ErrorContent call(ServiceResponseWithHeaders<ErrorContent, DeleteVoiceTestHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes the specified voice test.
     *
     * @param id The identifier of the voice test.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ServiceResponseWithHeaders<ErrorContent, DeleteVoiceTestHeaders>> deleteVoiceTestWithServiceResponseAsync(UUID id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.deleteVoiceTest(id, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<ErrorContent, DeleteVoiceTestHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<ErrorContent, DeleteVoiceTestHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<ErrorContent, DeleteVoiceTestHeaders> clientResponse = deleteVoiceTestDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<ErrorContent, DeleteVoiceTestHeaders> deleteVoiceTestDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ErrorContent, CloudException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .register(400, new TypeToken<ErrorContent>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(405, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, DeleteVoiceTestHeaders.class);
    }

    /**
     * Creates a new voice test.
     *
     * @param voiceTestDefinition the VoiceTestDefinition value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ErrorContent object if successful.
     */
    public ErrorContent createVoiceTest(VoiceTestDefinition voiceTestDefinition) {
        return createVoiceTestWithServiceResponseAsync(voiceTestDefinition).toBlocking().single().body();
    }

    /**
     * Creates a new voice test.
     *
     * @param voiceTestDefinition the VoiceTestDefinition value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ErrorContent> createVoiceTestAsync(VoiceTestDefinition voiceTestDefinition, final ServiceCallback<ErrorContent> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createVoiceTestWithServiceResponseAsync(voiceTestDefinition), serviceCallback);
    }

    /**
     * Creates a new voice test.
     *
     * @param voiceTestDefinition the VoiceTestDefinition value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ErrorContent> createVoiceTestAsync(VoiceTestDefinition voiceTestDefinition) {
        return createVoiceTestWithServiceResponseAsync(voiceTestDefinition).map(new Func1<ServiceResponseWithHeaders<ErrorContent, CreateVoiceTestHeaders>, ErrorContent>() {
            @Override
            public ErrorContent call(ServiceResponseWithHeaders<ErrorContent, CreateVoiceTestHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new voice test.
     *
     * @param voiceTestDefinition the VoiceTestDefinition value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErrorContent object
     */
    public Observable<ServiceResponseWithHeaders<ErrorContent, CreateVoiceTestHeaders>> createVoiceTestWithServiceResponseAsync(VoiceTestDefinition voiceTestDefinition) {
        if (voiceTestDefinition == null) {
            throw new IllegalArgumentException("Parameter voiceTestDefinition is required and cannot be null.");
        }
        Validator.validate(voiceTestDefinition);
        return service.createVoiceTest(voiceTestDefinition, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<ErrorContent, CreateVoiceTestHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<ErrorContent, CreateVoiceTestHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<ErrorContent, CreateVoiceTestHeaders> clientResponse = createVoiceTestDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<ErrorContent, CreateVoiceTestHeaders> createVoiceTestDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ErrorContent, CloudException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .register(400, new TypeToken<ErrorContent>() { }.getType())
                .register(401, new TypeToken<ErrorContent>() { }.getType())
                .register(403, new TypeToken<ErrorContent>() { }.getType())
                .register(429, new TypeToken<ErrorContent>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, CreateVoiceTestHeaders.class);
    }

}
