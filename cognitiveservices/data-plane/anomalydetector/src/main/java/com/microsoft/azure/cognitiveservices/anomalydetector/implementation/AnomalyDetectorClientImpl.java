/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.cognitiveservices.anomalydetector.implementation;

import com.google.common.base.Joiner;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.AzureClient;
import com.microsoft.azure.AzureServiceClient;
import com.microsoft.azure.cognitiveservices.anomalydetector.AnomalyDetectorClient;
import com.microsoft.azure.cognitiveservices.anomalydetector.models.APIErrorException;
import com.microsoft.azure.cognitiveservices.anomalydetector.models.EntireDetectResponse;
import com.microsoft.azure.cognitiveservices.anomalydetector.models.LastDetectResponse;
import com.microsoft.azure.cognitiveservices.anomalydetector.models.Request;
import com.microsoft.rest.credentials.ServiceClientCredentials;
import com.microsoft.rest.RestClient;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.IOException;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.POST;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * Initializes a new instance of the AnomalyDetectorClientImpl class.
 */
public class AnomalyDetectorClientImpl extends AzureServiceClient implements AnomalyDetectorClient {
    /** The Retrofit service to perform REST calls. */
    private AnomalyDetectorClientService service;
    /** the {@link AzureClient} used for long running operations. */
    private AzureClient azureClient;

    /**
     * Gets the {@link AzureClient} used for long running operations.
     * @return the azure client;
     */
    public AzureClient getAzureClient() {
        return this.azureClient;
    }

    /** Supported Cognitive Services endpoints (protocol and hostname, for example: https://westus2.api.cognitive.microsoft.com). */
    private String endpoint;

    /**
     * Gets Supported Cognitive Services endpoints (protocol and hostname, for example: https://westus2.api.cognitive.microsoft.com).
     *
     * @return the endpoint value.
     */
    public String endpoint() {
        return this.endpoint;
    }

    /**
     * Sets Supported Cognitive Services endpoints (protocol and hostname, for example: https://westus2.api.cognitive.microsoft.com).
     *
     * @param endpoint the endpoint value.
     * @return the service client itself
     */
    public AnomalyDetectorClientImpl withEndpoint(String endpoint) {
        this.endpoint = endpoint;
        return this;
    }

    /** The preferred language for the response. */
    private String acceptLanguage;

    /**
     * Gets The preferred language for the response.
     *
     * @return the acceptLanguage value.
     */
    public String acceptLanguage() {
        return this.acceptLanguage;
    }

    /**
     * Sets The preferred language for the response.
     *
     * @param acceptLanguage the acceptLanguage value.
     * @return the service client itself
     */
    public AnomalyDetectorClientImpl withAcceptLanguage(String acceptLanguage) {
        this.acceptLanguage = acceptLanguage;
        return this;
    }

    /** The retry timeout in seconds for Long Running Operations. Default value is 30. */
    private int longRunningOperationRetryTimeout;

    /**
     * Gets The retry timeout in seconds for Long Running Operations. Default value is 30.
     *
     * @return the longRunningOperationRetryTimeout value.
     */
    public int longRunningOperationRetryTimeout() {
        return this.longRunningOperationRetryTimeout;
    }

    /**
     * Sets The retry timeout in seconds for Long Running Operations. Default value is 30.
     *
     * @param longRunningOperationRetryTimeout the longRunningOperationRetryTimeout value.
     * @return the service client itself
     */
    public AnomalyDetectorClientImpl withLongRunningOperationRetryTimeout(int longRunningOperationRetryTimeout) {
        this.longRunningOperationRetryTimeout = longRunningOperationRetryTimeout;
        return this;
    }

    /** Whether a unique x-ms-client-request-id should be generated. When set to true a unique x-ms-client-request-id value is generated and included in each request. Default is true. */
    private boolean generateClientRequestId;

    /**
     * Gets Whether a unique x-ms-client-request-id should be generated. When set to true a unique x-ms-client-request-id value is generated and included in each request. Default is true.
     *
     * @return the generateClientRequestId value.
     */
    public boolean generateClientRequestId() {
        return this.generateClientRequestId;
    }

    /**
     * Sets Whether a unique x-ms-client-request-id should be generated. When set to true a unique x-ms-client-request-id value is generated and included in each request. Default is true.
     *
     * @param generateClientRequestId the generateClientRequestId value.
     * @return the service client itself
     */
    public AnomalyDetectorClientImpl withGenerateClientRequestId(boolean generateClientRequestId) {
        this.generateClientRequestId = generateClientRequestId;
        return this;
    }

    /**
     * Initializes an instance of AnomalyDetectorClient client.
     *
     * @param credentials the management credentials for Azure
     */
    public AnomalyDetectorClientImpl(ServiceClientCredentials credentials) {
        this("https://{Endpoint}/anomalydetector/v1.0", credentials);
    }

    /**
     * Initializes an instance of AnomalyDetectorClient client.
     *
     * @param baseUrl the base URL of the host
     * @param credentials the management credentials for Azure
     */
    private AnomalyDetectorClientImpl(String baseUrl, ServiceClientCredentials credentials) {
        super(baseUrl, credentials);
        initialize();
    }

    /**
     * Initializes an instance of AnomalyDetectorClient client.
     *
     * @param restClient the REST client to connect to Azure.
     */
    public AnomalyDetectorClientImpl(RestClient restClient) {
        super(restClient);
        initialize();
    }

    protected void initialize() {
        this.acceptLanguage = "en-US";
        this.longRunningOperationRetryTimeout = 30;
        this.generateClientRequestId = true;
        this.azureClient = new AzureClient(this);
        initializeService();
    }

    /**
     * Gets the User-Agent header for the client.
     *
     * @return the user agent string.
     */
    @Override
    public String userAgent() {
        return String.format("%s (%s, %s)", super.userAgent(), "AnomalyDetectorClient", "1.0");
    }

    private void initializeService() {
        service = restClient().retrofit().create(AnomalyDetectorClientService.class);
    }

    /**
     * The interface defining all the services for AnomalyDetectorClient to be
     * used by Retrofit to perform actually REST calls.
     */
    interface AnomalyDetectorClientService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.anomalydetector.AnomalyDetectorClient entireDetect" })
        @POST("timeseries/entire/detect")
        Observable<Response<ResponseBody>> entireDetect(@Body Request body, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.anomalydetector.AnomalyDetectorClient lastDetect" })
        @POST("timeseries/last/detect")
        Observable<Response<ResponseBody>> lastDetect(@Body Request body, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

    }

    /**
     * Detect anomalies for the entire series in batch.
     * This operation generates a model using an entire series, each point is detected with the same model. With this method, points before and after a certain point are used to determine whether it is an anomaly. The entire detection can give user an overall status of the time series.
     *
     * @param body Time series points and period if needed. Advanced model parameters can also be set in the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the EntireDetectResponse object if successful.
     */
    public EntireDetectResponse entireDetect(Request body) {
        return entireDetectWithServiceResponseAsync(body).toBlocking().single().body();
    }

    /**
     * Detect anomalies for the entire series in batch.
     * This operation generates a model using an entire series, each point is detected with the same model. With this method, points before and after a certain point are used to determine whether it is an anomaly. The entire detection can give user an overall status of the time series.
     *
     * @param body Time series points and period if needed. Advanced model parameters can also be set in the request.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<EntireDetectResponse> entireDetectAsync(Request body, final ServiceCallback<EntireDetectResponse> serviceCallback) {
        return ServiceFuture.fromResponse(entireDetectWithServiceResponseAsync(body), serviceCallback);
    }

    /**
     * Detect anomalies for the entire series in batch.
     * This operation generates a model using an entire series, each point is detected with the same model. With this method, points before and after a certain point are used to determine whether it is an anomaly. The entire detection can give user an overall status of the time series.
     *
     * @param body Time series points and period if needed. Advanced model parameters can also be set in the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EntireDetectResponse object
     */
    public Observable<EntireDetectResponse> entireDetectAsync(Request body) {
        return entireDetectWithServiceResponseAsync(body).map(new Func1<ServiceResponse<EntireDetectResponse>, EntireDetectResponse>() {
            @Override
            public EntireDetectResponse call(ServiceResponse<EntireDetectResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * Detect anomalies for the entire series in batch.
     * This operation generates a model using an entire series, each point is detected with the same model. With this method, points before and after a certain point are used to determine whether it is an anomaly. The entire detection can give user an overall status of the time series.
     *
     * @param body Time series points and period if needed. Advanced model parameters can also be set in the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EntireDetectResponse object
     */
    public Observable<ServiceResponse<EntireDetectResponse>> entireDetectWithServiceResponseAsync(Request body) {
        if (this.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.endpoint() is required and cannot be null.");
        }
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        Validator.validate(body);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.endpoint());
        return service.entireDetect(body, this.acceptLanguage(), parameterizedHost, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<EntireDetectResponse>>>() {
                @Override
                public Observable<ServiceResponse<EntireDetectResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<EntireDetectResponse> clientResponse = entireDetectDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<EntireDetectResponse> entireDetectDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<EntireDetectResponse, APIErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<EntireDetectResponse>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }

    /**
     * Detect anomaly status of the latest point in time series.
     * This operation generates a model using points before the latest one. With this method, only historical points are used to determine whether the target point is an anomaly. The latest point detecting operation matches the scenario of real-time monitoring of business metrics.
     *
     * @param body Time series points and period if needed. Advanced model parameters can also be set in the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the LastDetectResponse object if successful.
     */
    public LastDetectResponse lastDetect(Request body) {
        return lastDetectWithServiceResponseAsync(body).toBlocking().single().body();
    }

    /**
     * Detect anomaly status of the latest point in time series.
     * This operation generates a model using points before the latest one. With this method, only historical points are used to determine whether the target point is an anomaly. The latest point detecting operation matches the scenario of real-time monitoring of business metrics.
     *
     * @param body Time series points and period if needed. Advanced model parameters can also be set in the request.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<LastDetectResponse> lastDetectAsync(Request body, final ServiceCallback<LastDetectResponse> serviceCallback) {
        return ServiceFuture.fromResponse(lastDetectWithServiceResponseAsync(body), serviceCallback);
    }

    /**
     * Detect anomaly status of the latest point in time series.
     * This operation generates a model using points before the latest one. With this method, only historical points are used to determine whether the target point is an anomaly. The latest point detecting operation matches the scenario of real-time monitoring of business metrics.
     *
     * @param body Time series points and period if needed. Advanced model parameters can also be set in the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the LastDetectResponse object
     */
    public Observable<LastDetectResponse> lastDetectAsync(Request body) {
        return lastDetectWithServiceResponseAsync(body).map(new Func1<ServiceResponse<LastDetectResponse>, LastDetectResponse>() {
            @Override
            public LastDetectResponse call(ServiceResponse<LastDetectResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * Detect anomaly status of the latest point in time series.
     * This operation generates a model using points before the latest one. With this method, only historical points are used to determine whether the target point is an anomaly. The latest point detecting operation matches the scenario of real-time monitoring of business metrics.
     *
     * @param body Time series points and period if needed. Advanced model parameters can also be set in the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the LastDetectResponse object
     */
    public Observable<ServiceResponse<LastDetectResponse>> lastDetectWithServiceResponseAsync(Request body) {
        if (this.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.endpoint() is required and cannot be null.");
        }
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        Validator.validate(body);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.endpoint());
        return service.lastDetect(body, this.acceptLanguage(), parameterizedHost, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<LastDetectResponse>>>() {
                @Override
                public Observable<ServiceResponse<LastDetectResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<LastDetectResponse> clientResponse = lastDetectDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<LastDetectResponse> lastDetectDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<LastDetectResponse, APIErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<LastDetectResponse>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }

}
