/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.cognitiveservices.anomalydetector.implementation;

import com.google.common.base.Joiner;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.AzureClient;
import com.microsoft.azure.AzureServiceClient;
import com.microsoft.azure.cognitiveservices.anomalydetector.AnomalyDetectorClient;
import com.microsoft.azure.cognitiveservices.anomalydetector.models.AnomalyDetectorErrorException;
import com.microsoft.azure.cognitiveservices.anomalydetector.models.ChangePointDetectRequest;
import com.microsoft.azure.cognitiveservices.anomalydetector.models.ChangePointDetectResponse;
import com.microsoft.azure.cognitiveservices.anomalydetector.models.DetectRequest;
import com.microsoft.azure.cognitiveservices.anomalydetector.models.EntireDetectResponse;
import com.microsoft.azure.cognitiveservices.anomalydetector.models.LastDetectResponse;
import com.microsoft.rest.credentials.ServiceClientCredentials;
import com.microsoft.rest.RestClient;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.IOException;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.POST;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * Initializes a new instance of the AnomalyDetectorClientImpl class.
 */
public class AnomalyDetectorClientImpl extends AzureServiceClient implements AnomalyDetectorClient {
    /** The Retrofit service to perform REST calls. */
    private AnomalyDetectorClientService service;
    /** the {@link AzureClient} used for long running operations. */
    private AzureClient azureClient;

    /**
     * Gets the {@link AzureClient} used for long running operations.
     * @return the azure client;
     */
    public AzureClient getAzureClient() {
        return this.azureClient;
    }

    /** Supported Cognitive Services endpoints (protocol and hostname, for example: https://westus2.api.cognitive.microsoft.com). */
    private String endpoint;

    /**
     * Gets Supported Cognitive Services endpoints (protocol and hostname, for example: https://westus2.api.cognitive.microsoft.com).
     *
     * @return the endpoint value.
     */
    public String endpoint() {
        return this.endpoint;
    }

    /**
     * Sets Supported Cognitive Services endpoints (protocol and hostname, for example: https://westus2.api.cognitive.microsoft.com).
     *
     * @param endpoint the endpoint value.
     * @return the service client itself
     */
    public AnomalyDetectorClientImpl withEndpoint(String endpoint) {
        this.endpoint = endpoint;
        return this;
    }

    /** The preferred language for the response. */
    private String acceptLanguage;

    /**
     * Gets The preferred language for the response.
     *
     * @return the acceptLanguage value.
     */
    public String acceptLanguage() {
        return this.acceptLanguage;
    }

    /**
     * Sets The preferred language for the response.
     *
     * @param acceptLanguage the acceptLanguage value.
     * @return the service client itself
     */
    public AnomalyDetectorClientImpl withAcceptLanguage(String acceptLanguage) {
        this.acceptLanguage = acceptLanguage;
        return this;
    }

    /** The retry timeout in seconds for Long Running Operations. Default value is 30. */
    private int longRunningOperationRetryTimeout;

    /**
     * Gets The retry timeout in seconds for Long Running Operations. Default value is 30.
     *
     * @return the longRunningOperationRetryTimeout value.
     */
    public int longRunningOperationRetryTimeout() {
        return this.longRunningOperationRetryTimeout;
    }

    /**
     * Sets The retry timeout in seconds for Long Running Operations. Default value is 30.
     *
     * @param longRunningOperationRetryTimeout the longRunningOperationRetryTimeout value.
     * @return the service client itself
     */
    public AnomalyDetectorClientImpl withLongRunningOperationRetryTimeout(int longRunningOperationRetryTimeout) {
        this.longRunningOperationRetryTimeout = longRunningOperationRetryTimeout;
        return this;
    }

    /** Whether a unique x-ms-client-request-id should be generated. When set to true a unique x-ms-client-request-id value is generated and included in each request. Default is true. */
    private boolean generateClientRequestId;

    /**
     * Gets Whether a unique x-ms-client-request-id should be generated. When set to true a unique x-ms-client-request-id value is generated and included in each request. Default is true.
     *
     * @return the generateClientRequestId value.
     */
    public boolean generateClientRequestId() {
        return this.generateClientRequestId;
    }

    /**
     * Sets Whether a unique x-ms-client-request-id should be generated. When set to true a unique x-ms-client-request-id value is generated and included in each request. Default is true.
     *
     * @param generateClientRequestId the generateClientRequestId value.
     * @return the service client itself
     */
    public AnomalyDetectorClientImpl withGenerateClientRequestId(boolean generateClientRequestId) {
        this.generateClientRequestId = generateClientRequestId;
        return this;
    }

    /**
     * Initializes an instance of AnomalyDetectorClient client.
     *
     * @param credentials the management credentials for Azure
     */
    public AnomalyDetectorClientImpl(ServiceClientCredentials credentials) {
        this("https://{Endpoint}/anomalydetector/v1.0", credentials);
    }

    /**
     * Initializes an instance of AnomalyDetectorClient client.
     *
     * @param baseUrl the base URL of the host
     * @param credentials the management credentials for Azure
     */
    private AnomalyDetectorClientImpl(String baseUrl, ServiceClientCredentials credentials) {
        super(baseUrl, credentials);
        initialize();
    }

    /**
     * Initializes an instance of AnomalyDetectorClient client.
     *
     * @param restClient the REST client to connect to Azure.
     */
    public AnomalyDetectorClientImpl(RestClient restClient) {
        super(restClient);
        initialize();
    }

    protected void initialize() {
        this.acceptLanguage = "en-US";
        this.longRunningOperationRetryTimeout = 30;
        this.generateClientRequestId = true;
        this.azureClient = new AzureClient(this);
        initializeService();
    }

    /**
     * Gets the User-Agent header for the client.
     *
     * @return the user agent string.
     */
    @Override
    public String userAgent() {
        return String.format("%s (%s, %s)", super.userAgent(), "AnomalyDetectorClient", "1.0");
    }

    private void initializeService() {
        service = restClient().retrofit().create(AnomalyDetectorClientService.class);
    }

    /**
     * The interface defining all the services for AnomalyDetectorClient to be
     * used by Retrofit to perform actually REST calls.
     */
    interface AnomalyDetectorClientService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.anomalydetector.AnomalyDetectorClient detectEntireSeries" })
        @POST("timeseries/entire/detect")
        Observable<Response<ResponseBody>> detectEntireSeries(@Body DetectRequest body, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.anomalydetector.AnomalyDetectorClient detectLastPoint" })
        @POST("timeseries/last/detect")
        Observable<Response<ResponseBody>> detectLastPoint(@Body DetectRequest body, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.anomalydetector.AnomalyDetectorClient detectChangePoint" })
        @POST("timeseries/changepoint/detect")
        Observable<Response<ResponseBody>> detectChangePoint(@Body ChangePointDetectRequest body, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

    }

    /**
     * Detect anomalies for the entire series in batch.
     * This operation generates a model using an entire series, each point is detected with the same model. With this method, points before and after a certain point are used to determine whether it is an anomaly. The entire detection can give user an overall status of the time series.
     *
     * @param body Time series points and period if needed. Advanced model parameters can also be set in the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws AnomalyDetectorErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the EntireDetectResponse object if successful.
     */
    public EntireDetectResponse detectEntireSeries(DetectRequest body) {
        return detectEntireSeriesWithServiceResponseAsync(body).toBlocking().single().body();
    }

    /**
     * Detect anomalies for the entire series in batch.
     * This operation generates a model using an entire series, each point is detected with the same model. With this method, points before and after a certain point are used to determine whether it is an anomaly. The entire detection can give user an overall status of the time series.
     *
     * @param body Time series points and period if needed. Advanced model parameters can also be set in the request.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<EntireDetectResponse> detectEntireSeriesAsync(DetectRequest body, final ServiceCallback<EntireDetectResponse> serviceCallback) {
        return ServiceFuture.fromResponse(detectEntireSeriesWithServiceResponseAsync(body), serviceCallback);
    }

    /**
     * Detect anomalies for the entire series in batch.
     * This operation generates a model using an entire series, each point is detected with the same model. With this method, points before and after a certain point are used to determine whether it is an anomaly. The entire detection can give user an overall status of the time series.
     *
     * @param body Time series points and period if needed. Advanced model parameters can also be set in the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EntireDetectResponse object
     */
    public Observable<EntireDetectResponse> detectEntireSeriesAsync(DetectRequest body) {
        return detectEntireSeriesWithServiceResponseAsync(body).map(new Func1<ServiceResponse<EntireDetectResponse>, EntireDetectResponse>() {
            @Override
            public EntireDetectResponse call(ServiceResponse<EntireDetectResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * Detect anomalies for the entire series in batch.
     * This operation generates a model using an entire series, each point is detected with the same model. With this method, points before and after a certain point are used to determine whether it is an anomaly. The entire detection can give user an overall status of the time series.
     *
     * @param body Time series points and period if needed. Advanced model parameters can also be set in the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EntireDetectResponse object
     */
    public Observable<ServiceResponse<EntireDetectResponse>> detectEntireSeriesWithServiceResponseAsync(DetectRequest body) {
        if (this.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.endpoint() is required and cannot be null.");
        }
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        Validator.validate(body);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.endpoint());
        return service.detectEntireSeries(body, this.acceptLanguage(), parameterizedHost, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<EntireDetectResponse>>>() {
                @Override
                public Observable<ServiceResponse<EntireDetectResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<EntireDetectResponse> clientResponse = detectEntireSeriesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<EntireDetectResponse> detectEntireSeriesDelegate(Response<ResponseBody> response) throws AnomalyDetectorErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<EntireDetectResponse, AnomalyDetectorErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<EntireDetectResponse>() { }.getType())
                .registerError(AnomalyDetectorErrorException.class)
                .build(response);
    }

    /**
     * Detect anomaly status of the latest point in time series.
     * This operation generates a model using points before the latest one. With this method, only historical points are used to determine whether the target point is an anomaly. The latest point detecting operation matches the scenario of real-time monitoring of business metrics.
     *
     * @param body Time series points and period if needed. Advanced model parameters can also be set in the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws AnomalyDetectorErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the LastDetectResponse object if successful.
     */
    public LastDetectResponse detectLastPoint(DetectRequest body) {
        return detectLastPointWithServiceResponseAsync(body).toBlocking().single().body();
    }

    /**
     * Detect anomaly status of the latest point in time series.
     * This operation generates a model using points before the latest one. With this method, only historical points are used to determine whether the target point is an anomaly. The latest point detecting operation matches the scenario of real-time monitoring of business metrics.
     *
     * @param body Time series points and period if needed. Advanced model parameters can also be set in the request.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<LastDetectResponse> detectLastPointAsync(DetectRequest body, final ServiceCallback<LastDetectResponse> serviceCallback) {
        return ServiceFuture.fromResponse(detectLastPointWithServiceResponseAsync(body), serviceCallback);
    }

    /**
     * Detect anomaly status of the latest point in time series.
     * This operation generates a model using points before the latest one. With this method, only historical points are used to determine whether the target point is an anomaly. The latest point detecting operation matches the scenario of real-time monitoring of business metrics.
     *
     * @param body Time series points and period if needed. Advanced model parameters can also be set in the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the LastDetectResponse object
     */
    public Observable<LastDetectResponse> detectLastPointAsync(DetectRequest body) {
        return detectLastPointWithServiceResponseAsync(body).map(new Func1<ServiceResponse<LastDetectResponse>, LastDetectResponse>() {
            @Override
            public LastDetectResponse call(ServiceResponse<LastDetectResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * Detect anomaly status of the latest point in time series.
     * This operation generates a model using points before the latest one. With this method, only historical points are used to determine whether the target point is an anomaly. The latest point detecting operation matches the scenario of real-time monitoring of business metrics.
     *
     * @param body Time series points and period if needed. Advanced model parameters can also be set in the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the LastDetectResponse object
     */
    public Observable<ServiceResponse<LastDetectResponse>> detectLastPointWithServiceResponseAsync(DetectRequest body) {
        if (this.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.endpoint() is required and cannot be null.");
        }
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        Validator.validate(body);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.endpoint());
        return service.detectLastPoint(body, this.acceptLanguage(), parameterizedHost, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<LastDetectResponse>>>() {
                @Override
                public Observable<ServiceResponse<LastDetectResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<LastDetectResponse> clientResponse = detectLastPointDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<LastDetectResponse> detectLastPointDelegate(Response<ResponseBody> response) throws AnomalyDetectorErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<LastDetectResponse, AnomalyDetectorErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<LastDetectResponse>() { }.getType())
                .registerError(AnomalyDetectorErrorException.class)
                .build(response);
    }

    /**
     * Detect change point for the entire series.
     * Evaluate change point score of every series point.
     *
     * @param body Time series points and granularity is needed. Advanced model parameters can also be set in the request if needed.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws AnomalyDetectorErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ChangePointDetectResponse object if successful.
     */
    public ChangePointDetectResponse detectChangePoint(ChangePointDetectRequest body) {
        return detectChangePointWithServiceResponseAsync(body).toBlocking().single().body();
    }

    /**
     * Detect change point for the entire series.
     * Evaluate change point score of every series point.
     *
     * @param body Time series points and granularity is needed. Advanced model parameters can also be set in the request if needed.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ChangePointDetectResponse> detectChangePointAsync(ChangePointDetectRequest body, final ServiceCallback<ChangePointDetectResponse> serviceCallback) {
        return ServiceFuture.fromResponse(detectChangePointWithServiceResponseAsync(body), serviceCallback);
    }

    /**
     * Detect change point for the entire series.
     * Evaluate change point score of every series point.
     *
     * @param body Time series points and granularity is needed. Advanced model parameters can also be set in the request if needed.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ChangePointDetectResponse object
     */
    public Observable<ChangePointDetectResponse> detectChangePointAsync(ChangePointDetectRequest body) {
        return detectChangePointWithServiceResponseAsync(body).map(new Func1<ServiceResponse<ChangePointDetectResponse>, ChangePointDetectResponse>() {
            @Override
            public ChangePointDetectResponse call(ServiceResponse<ChangePointDetectResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * Detect change point for the entire series.
     * Evaluate change point score of every series point.
     *
     * @param body Time series points and granularity is needed. Advanced model parameters can also be set in the request if needed.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ChangePointDetectResponse object
     */
    public Observable<ServiceResponse<ChangePointDetectResponse>> detectChangePointWithServiceResponseAsync(ChangePointDetectRequest body) {
        if (this.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.endpoint() is required and cannot be null.");
        }
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        Validator.validate(body);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.endpoint());
        return service.detectChangePoint(body, this.acceptLanguage(), parameterizedHost, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ChangePointDetectResponse>>>() {
                @Override
                public Observable<ServiceResponse<ChangePointDetectResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ChangePointDetectResponse> clientResponse = detectChangePointDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ChangePointDetectResponse> detectChangePointDelegate(Response<ResponseBody> response) throws AnomalyDetectorErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ChangePointDetectResponse, AnomalyDetectorErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ChangePointDetectResponse>() { }.getType())
                .registerError(AnomalyDetectorErrorException.class)
                .build(response);
    }

}
