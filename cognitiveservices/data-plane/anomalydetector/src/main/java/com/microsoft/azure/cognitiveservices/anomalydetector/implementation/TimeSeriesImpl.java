/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.cognitiveservices.anomalydetector.implementation;

import retrofit2.Retrofit;
import com.google.common.base.Joiner;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.cognitiveservices.anomalydetector.models.AnomalyDetectOnTimestampRequest;
import com.microsoft.azure.cognitiveservices.anomalydetector.models.AnomalyDetectOnTimestampResponse;
import com.microsoft.azure.cognitiveservices.anomalydetector.models.APIError;
import com.microsoft.azure.cognitiveservices.anomalydetector.models.APIErrorException;
import com.microsoft.azure.cognitiveservices.anomalydetector.models.ChangePointDetectOnTimestampRequest;
import com.microsoft.azure.cognitiveservices.anomalydetector.models.ChangePointDetectOnTimestampResponse;
import com.microsoft.azure.cognitiveservices.anomalydetector.models.Inconsistency;
import com.microsoft.azure.cognitiveservices.anomalydetector.models.InconsistencyDetectRequest;
import com.microsoft.azure.cognitiveservices.anomalydetector.models.LabelRequest;
import com.microsoft.azure.cognitiveservices.anomalydetector.models.Point;
import com.microsoft.azure.cognitiveservices.anomalydetector.models.TimeSeries;
import com.microsoft.azure.cognitiveservices.anomalydetector.models.TimeSeriesCreateRequest;
import com.microsoft.azure.cognitiveservices.anomalydetector.models.TimeSeriesList;
import com.microsoft.azure.cognitiveservices.anomalydetector.models.TimeSeriesQueryRequest;
import com.microsoft.azure.cognitiveservices.anomalydetector.models.TimeSeriesQueryResponse;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.List;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in TimeSeries.
 */
public class TimeSeriesImpl implements com.microsoft.azure.cognitiveservices.anomalydetector.TimeSeries {
    /** The Retrofit service to perform REST calls. */
    private TimeSeriesService service;
    /** The service client containing this operation class. */
    private AnomalyDetectorClientImpl client;

    /**
     * Initializes an instance of TimeSeriesImpl.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public TimeSeriesImpl(Retrofit retrofit, AnomalyDetectorClientImpl client) {
        this.service = retrofit.create(TimeSeriesService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for TimeSeries to be
     * used by Retrofit to perform actually REST calls.
     */
    interface TimeSeriesService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.anomalydetector.TimeSeries get" })
        @GET("timeseries/{timeSeriesId}")
        Observable<Response<ResponseBody>> get(@Path("timeSeriesId") String timeSeriesId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.anomalydetector.TimeSeries create" })
        @PUT("timeseries/{timeSeriesId}")
        Observable<Response<ResponseBody>> create(@Path("timeSeriesId") String timeSeriesId, @Body TimeSeriesCreateRequest body, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.anomalydetector.TimeSeries delete" })
        @HTTP(path = "timeseries/{timeSeriesId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> delete(@Path("timeSeriesId") String timeSeriesId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.anomalydetector.TimeSeries list" })
        @GET("timeseries")
        Observable<Response<ResponseBody>> list(@Query("next") String next, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.anomalydetector.TimeSeries write" })
        @POST("timeseries/{timeSeriesId}/write")
        Observable<Response<ResponseBody>> write(@Path("timeSeriesId") String timeSeriesId, @Body List<Point> body, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.anomalydetector.TimeSeries detectOnTimestamp" })
        @POST("timeseries/{timeSeriesId}/detect")
        Observable<Response<ResponseBody>> detectOnTimestamp(@Path("timeSeriesId") String timeSeriesId, @Body AnomalyDetectOnTimestampRequest body, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.anomalydetector.TimeSeries changePointDetectOnTimestamp" })
        @POST("timeseries/{timeSeriesId}/changepoint/detect")
        Observable<Response<ResponseBody>> changePointDetectOnTimestamp(@Path("timeSeriesId") String timeSeriesId, @Body ChangePointDetectOnTimestampRequest body, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.anomalydetector.TimeSeries label" })
        @POST("timeseries/{timeSeriesId}/label")
        Observable<Response<ResponseBody>> label(@Path("timeSeriesId") String timeSeriesId, @Body LabelRequest body, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.anomalydetector.TimeSeries query" })
        @POST("timeseries/{timeSeriesId}/query")
        Observable<Response<ResponseBody>> query(@Path("timeSeriesId") String timeSeriesId, @Body TimeSeriesQueryRequest body, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.anomalydetector.TimeSeries inconsistencyDetect" })
        @POST("timeseries/inconsistency/detect")
        Observable<Response<ResponseBody>> inconsistencyDetect(@Body InconsistencyDetectRequest body, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

    }

    /**
     * Get meta information of the specified timeseries.
     * corresponds to create series, get series meta with timeseries id.
     *
     * @param timeSeriesId Unique id for time series.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object get(String timeSeriesId) {
        return getWithServiceResponseAsync(timeSeriesId).toBlocking().single().body();
    }

    /**
     * Get meta information of the specified timeseries.
     * corresponds to create series, get series meta with timeseries id.
     *
     * @param timeSeriesId Unique id for time series.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getAsync(String timeSeriesId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(getWithServiceResponseAsync(timeSeriesId), serviceCallback);
    }

    /**
     * Get meta information of the specified timeseries.
     * corresponds to create series, get series meta with timeseries id.
     *
     * @param timeSeriesId Unique id for time series.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getAsync(String timeSeriesId) {
        return getWithServiceResponseAsync(timeSeriesId).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Get meta information of the specified timeseries.
     * corresponds to create series, get series meta with timeseries id.
     *
     * @param timeSeriesId Unique id for time series.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getWithServiceResponseAsync(String timeSeriesId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (timeSeriesId == null) {
            throw new IllegalArgumentException("Parameter timeSeriesId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.get(timeSeriesId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> getDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<TimeSeries>() { }.getType())
                .register(404, new TypeToken<APIError>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }

    /**
     * Creat a timeseries.
     * Create series, user need to provide timeSeriesId and granularity, if the series has dimension or name, description can be provided through the interface.
     *
     * @param timeSeriesId Unique id for time series.
     * @param body the TimeSeriesCreateRequest value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the APIError object if successful.
     */
    public APIError create(String timeSeriesId, TimeSeriesCreateRequest body) {
        return createWithServiceResponseAsync(timeSeriesId, body).toBlocking().single().body();
    }

    /**
     * Creat a timeseries.
     * Create series, user need to provide timeSeriesId and granularity, if the series has dimension or name, description can be provided through the interface.
     *
     * @param timeSeriesId Unique id for time series.
     * @param body the TimeSeriesCreateRequest value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<APIError> createAsync(String timeSeriesId, TimeSeriesCreateRequest body, final ServiceCallback<APIError> serviceCallback) {
        return ServiceFuture.fromResponse(createWithServiceResponseAsync(timeSeriesId, body), serviceCallback);
    }

    /**
     * Creat a timeseries.
     * Create series, user need to provide timeSeriesId and granularity, if the series has dimension or name, description can be provided through the interface.
     *
     * @param timeSeriesId Unique id for time series.
     * @param body the TimeSeriesCreateRequest value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the APIError object
     */
    public Observable<APIError> createAsync(String timeSeriesId, TimeSeriesCreateRequest body) {
        return createWithServiceResponseAsync(timeSeriesId, body).map(new Func1<ServiceResponse<APIError>, APIError>() {
            @Override
            public APIError call(ServiceResponse<APIError> response) {
                return response.body();
            }
        });
    }

    /**
     * Creat a timeseries.
     * Create series, user need to provide timeSeriesId and granularity, if the series has dimension or name, description can be provided through the interface.
     *
     * @param timeSeriesId Unique id for time series.
     * @param body the TimeSeriesCreateRequest value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the APIError object
     */
    public Observable<ServiceResponse<APIError>> createWithServiceResponseAsync(String timeSeriesId, TimeSeriesCreateRequest body) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (timeSeriesId == null) {
            throw new IllegalArgumentException("Parameter timeSeriesId is required and cannot be null.");
        }
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        Validator.validate(body);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.create(timeSeriesId, body, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<APIError>>>() {
                @Override
                public Observable<ServiceResponse<APIError>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<APIError> clientResponse = createDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<APIError> createDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<APIError, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(201, new TypeToken<Void>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .register(409, new TypeToken<APIError>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }

    /**
     * Delete the specified timeseries.
     * Delete the specified timeseries.
     *
     * @param timeSeriesId Unique id for time series.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void delete(String timeSeriesId) {
        deleteWithServiceResponseAsync(timeSeriesId).toBlocking().single().body();
    }

    /**
     * Delete the specified timeseries.
     * Delete the specified timeseries.
     *
     * @param timeSeriesId Unique id for time series.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteAsync(String timeSeriesId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteWithServiceResponseAsync(timeSeriesId), serviceCallback);
    }

    /**
     * Delete the specified timeseries.
     * Delete the specified timeseries.
     *
     * @param timeSeriesId Unique id for time series.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteAsync(String timeSeriesId) {
        return deleteWithServiceResponseAsync(timeSeriesId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete the specified timeseries.
     * Delete the specified timeseries.
     *
     * @param timeSeriesId Unique id for time series.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteWithServiceResponseAsync(String timeSeriesId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (timeSeriesId == null) {
            throw new IllegalArgumentException("Parameter timeSeriesId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.delete(timeSeriesId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }

    /**
     * List time series of each unique user.
     * List time series of each unique user.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TimeSeriesList object if successful.
     */
    public TimeSeriesList list() {
        return listWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * List time series of each unique user.
     * List time series of each unique user.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TimeSeriesList> listAsync(final ServiceCallback<TimeSeriesList> serviceCallback) {
        return ServiceFuture.fromResponse(listWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * List time series of each unique user.
     * List time series of each unique user.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TimeSeriesList object
     */
    public Observable<TimeSeriesList> listAsync() {
        return listWithServiceResponseAsync().map(new Func1<ServiceResponse<TimeSeriesList>, TimeSeriesList>() {
            @Override
            public TimeSeriesList call(ServiceResponse<TimeSeriesList> response) {
                return response.body();
            }
        });
    }

    /**
     * List time series of each unique user.
     * List time series of each unique user.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TimeSeriesList object
     */
    public Observable<ServiceResponse<TimeSeriesList>> listWithServiceResponseAsync() {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        final String next = null;
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.list(next, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<TimeSeriesList>>>() {
                @Override
                public Observable<ServiceResponse<TimeSeriesList>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<TimeSeriesList> clientResponse = listDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * List time series of each unique user.
     * List time series of each unique user.
     *
     * @param next Use "next" as query parameter to get next page data.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TimeSeriesList object if successful.
     */
    public TimeSeriesList list(String next) {
        return listWithServiceResponseAsync(next).toBlocking().single().body();
    }

    /**
     * List time series of each unique user.
     * List time series of each unique user.
     *
     * @param next Use "next" as query parameter to get next page data.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TimeSeriesList> listAsync(String next, final ServiceCallback<TimeSeriesList> serviceCallback) {
        return ServiceFuture.fromResponse(listWithServiceResponseAsync(next), serviceCallback);
    }

    /**
     * List time series of each unique user.
     * List time series of each unique user.
     *
     * @param next Use "next" as query parameter to get next page data.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TimeSeriesList object
     */
    public Observable<TimeSeriesList> listAsync(String next) {
        return listWithServiceResponseAsync(next).map(new Func1<ServiceResponse<TimeSeriesList>, TimeSeriesList>() {
            @Override
            public TimeSeriesList call(ServiceResponse<TimeSeriesList> response) {
                return response.body();
            }
        });
    }

    /**
     * List time series of each unique user.
     * List time series of each unique user.
     *
     * @param next Use "next" as query parameter to get next page data.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TimeSeriesList object
     */
    public Observable<ServiceResponse<TimeSeriesList>> listWithServiceResponseAsync(String next) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.list(next, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<TimeSeriesList>>>() {
                @Override
                public Observable<ServiceResponse<TimeSeriesList>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<TimeSeriesList> clientResponse = listDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<TimeSeriesList> listDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<TimeSeriesList, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<TimeSeriesList>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }

    /**
     * Insert or replace timeseries data for specified timeSeriesId. Note that this interface only stores data and do not detect these data.
     *
     * @param timeSeriesId Unique id for time series.
     * @param body Request body for writing timeseries.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the APIError object if successful.
     */
    public APIError write(String timeSeriesId, List<Point> body) {
        return writeWithServiceResponseAsync(timeSeriesId, body).toBlocking().single().body();
    }

    /**
     * Insert or replace timeseries data for specified timeSeriesId. Note that this interface only stores data and do not detect these data.
     *
     * @param timeSeriesId Unique id for time series.
     * @param body Request body for writing timeseries.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<APIError> writeAsync(String timeSeriesId, List<Point> body, final ServiceCallback<APIError> serviceCallback) {
        return ServiceFuture.fromResponse(writeWithServiceResponseAsync(timeSeriesId, body), serviceCallback);
    }

    /**
     * Insert or replace timeseries data for specified timeSeriesId. Note that this interface only stores data and do not detect these data.
     *
     * @param timeSeriesId Unique id for time series.
     * @param body Request body for writing timeseries.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the APIError object
     */
    public Observable<APIError> writeAsync(String timeSeriesId, List<Point> body) {
        return writeWithServiceResponseAsync(timeSeriesId, body).map(new Func1<ServiceResponse<APIError>, APIError>() {
            @Override
            public APIError call(ServiceResponse<APIError> response) {
                return response.body();
            }
        });
    }

    /**
     * Insert or replace timeseries data for specified timeSeriesId. Note that this interface only stores data and do not detect these data.
     *
     * @param timeSeriesId Unique id for time series.
     * @param body Request body for writing timeseries.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the APIError object
     */
    public Observable<ServiceResponse<APIError>> writeWithServiceResponseAsync(String timeSeriesId, List<Point> body) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (timeSeriesId == null) {
            throw new IllegalArgumentException("Parameter timeSeriesId is required and cannot be null.");
        }
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        Validator.validate(body);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.write(timeSeriesId, body, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<APIError>>>() {
                @Override
                public Observable<ServiceResponse<APIError>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<APIError> clientResponse = writeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<APIError> writeDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<APIError, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<APIError>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }

    /**
     * Detect anomaly status on a given timestamp.
     * This operation can be used in streaming monitoring scenario, when user would like to monitor a time series, the user only need to provide a time range, last detect API will check where last detection ends and will return detection results between last detection and the end time.
     *
     * @param timeSeriesId Unique id for time series.
     * @param body Timestamp is required in the request. Advanced model parameters (period, sensitivity, maxAnomalyRatio) can also be set in the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object detectOnTimestamp(String timeSeriesId, AnomalyDetectOnTimestampRequest body) {
        return detectOnTimestampWithServiceResponseAsync(timeSeriesId, body).toBlocking().single().body();
    }

    /**
     * Detect anomaly status on a given timestamp.
     * This operation can be used in streaming monitoring scenario, when user would like to monitor a time series, the user only need to provide a time range, last detect API will check where last detection ends and will return detection results between last detection and the end time.
     *
     * @param timeSeriesId Unique id for time series.
     * @param body Timestamp is required in the request. Advanced model parameters (period, sensitivity, maxAnomalyRatio) can also be set in the request.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> detectOnTimestampAsync(String timeSeriesId, AnomalyDetectOnTimestampRequest body, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(detectOnTimestampWithServiceResponseAsync(timeSeriesId, body), serviceCallback);
    }

    /**
     * Detect anomaly status on a given timestamp.
     * This operation can be used in streaming monitoring scenario, when user would like to monitor a time series, the user only need to provide a time range, last detect API will check where last detection ends and will return detection results between last detection and the end time.
     *
     * @param timeSeriesId Unique id for time series.
     * @param body Timestamp is required in the request. Advanced model parameters (period, sensitivity, maxAnomalyRatio) can also be set in the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> detectOnTimestampAsync(String timeSeriesId, AnomalyDetectOnTimestampRequest body) {
        return detectOnTimestampWithServiceResponseAsync(timeSeriesId, body).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Detect anomaly status on a given timestamp.
     * This operation can be used in streaming monitoring scenario, when user would like to monitor a time series, the user only need to provide a time range, last detect API will check where last detection ends and will return detection results between last detection and the end time.
     *
     * @param timeSeriesId Unique id for time series.
     * @param body Timestamp is required in the request. Advanced model parameters (period, sensitivity, maxAnomalyRatio) can also be set in the request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> detectOnTimestampWithServiceResponseAsync(String timeSeriesId, AnomalyDetectOnTimestampRequest body) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (timeSeriesId == null) {
            throw new IllegalArgumentException("Parameter timeSeriesId is required and cannot be null.");
        }
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        Validator.validate(body);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.detectOnTimestamp(timeSeriesId, body, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = detectOnTimestampDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> detectOnTimestampDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<AnomalyDetectOnTimestampResponse>() { }.getType())
                .register(404, new TypeToken<APIError>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }

    /**
     * Detect change point for the interval series.
     * Evaluate change point score of every series point between start and end.
     *
     * @param timeSeriesId Unique id for time series.
     * @param body Timestamp is needed. Advanced model parameters can also be set in the request if needed.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object changePointDetectOnTimestamp(String timeSeriesId, ChangePointDetectOnTimestampRequest body) {
        return changePointDetectOnTimestampWithServiceResponseAsync(timeSeriesId, body).toBlocking().single().body();
    }

    /**
     * Detect change point for the interval series.
     * Evaluate change point score of every series point between start and end.
     *
     * @param timeSeriesId Unique id for time series.
     * @param body Timestamp is needed. Advanced model parameters can also be set in the request if needed.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> changePointDetectOnTimestampAsync(String timeSeriesId, ChangePointDetectOnTimestampRequest body, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(changePointDetectOnTimestampWithServiceResponseAsync(timeSeriesId, body), serviceCallback);
    }

    /**
     * Detect change point for the interval series.
     * Evaluate change point score of every series point between start and end.
     *
     * @param timeSeriesId Unique id for time series.
     * @param body Timestamp is needed. Advanced model parameters can also be set in the request if needed.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> changePointDetectOnTimestampAsync(String timeSeriesId, ChangePointDetectOnTimestampRequest body) {
        return changePointDetectOnTimestampWithServiceResponseAsync(timeSeriesId, body).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Detect change point for the interval series.
     * Evaluate change point score of every series point between start and end.
     *
     * @param timeSeriesId Unique id for time series.
     * @param body Timestamp is needed. Advanced model parameters can also be set in the request if needed.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> changePointDetectOnTimestampWithServiceResponseAsync(String timeSeriesId, ChangePointDetectOnTimestampRequest body) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (timeSeriesId == null) {
            throw new IllegalArgumentException("Parameter timeSeriesId is required and cannot be null.");
        }
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        Validator.validate(body);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.changePointDetectOnTimestamp(timeSeriesId, body, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = changePointDetectOnTimestampDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> changePointDetectOnTimestampDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ChangePointDetectOnTimestampResponse>() { }.getType())
                .register(404, new TypeToken<APIError>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }

    /**
     * Label API is used for users to label detection status of a certain time stamp of a time series.
     * This operation is used for users to label Anomaly or ChangePoint states of a certain time stamp, these label will be used for regenerate detection model.
     *
     * @param timeSeriesId Unique id for time series.
     * @param body In Label request, user can set Anomaly|ChangePoint state (true, false, unknown) for a time range
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the APIError object if successful.
     */
    public APIError label(String timeSeriesId, LabelRequest body) {
        return labelWithServiceResponseAsync(timeSeriesId, body).toBlocking().single().body();
    }

    /**
     * Label API is used for users to label detection status of a certain time stamp of a time series.
     * This operation is used for users to label Anomaly or ChangePoint states of a certain time stamp, these label will be used for regenerate detection model.
     *
     * @param timeSeriesId Unique id for time series.
     * @param body In Label request, user can set Anomaly|ChangePoint state (true, false, unknown) for a time range
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<APIError> labelAsync(String timeSeriesId, LabelRequest body, final ServiceCallback<APIError> serviceCallback) {
        return ServiceFuture.fromResponse(labelWithServiceResponseAsync(timeSeriesId, body), serviceCallback);
    }

    /**
     * Label API is used for users to label detection status of a certain time stamp of a time series.
     * This operation is used for users to label Anomaly or ChangePoint states of a certain time stamp, these label will be used for regenerate detection model.
     *
     * @param timeSeriesId Unique id for time series.
     * @param body In Label request, user can set Anomaly|ChangePoint state (true, false, unknown) for a time range
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the APIError object
     */
    public Observable<APIError> labelAsync(String timeSeriesId, LabelRequest body) {
        return labelWithServiceResponseAsync(timeSeriesId, body).map(new Func1<ServiceResponse<APIError>, APIError>() {
            @Override
            public APIError call(ServiceResponse<APIError> response) {
                return response.body();
            }
        });
    }

    /**
     * Label API is used for users to label detection status of a certain time stamp of a time series.
     * This operation is used for users to label Anomaly or ChangePoint states of a certain time stamp, these label will be used for regenerate detection model.
     *
     * @param timeSeriesId Unique id for time series.
     * @param body In Label request, user can set Anomaly|ChangePoint state (true, false, unknown) for a time range
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the APIError object
     */
    public Observable<ServiceResponse<APIError>> labelWithServiceResponseAsync(String timeSeriesId, LabelRequest body) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (timeSeriesId == null) {
            throw new IllegalArgumentException("Parameter timeSeriesId is required and cannot be null.");
        }
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        Validator.validate(body);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.label(timeSeriesId, body, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<APIError>>>() {
                @Override
                public Observable<ServiceResponse<APIError>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<APIError> clientResponse = labelDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<APIError> labelDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<APIError, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<APIError>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }

    /**
     * Query timeseries with required field in each timestamp.
     *
     * @param timeSeriesId Unique id for time series.
     * @param body Request body for querying timeseries.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object query(String timeSeriesId, TimeSeriesQueryRequest body) {
        return queryWithServiceResponseAsync(timeSeriesId, body).toBlocking().single().body();
    }

    /**
     * Query timeseries with required field in each timestamp.
     *
     * @param timeSeriesId Unique id for time series.
     * @param body Request body for querying timeseries.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> queryAsync(String timeSeriesId, TimeSeriesQueryRequest body, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(queryWithServiceResponseAsync(timeSeriesId, body), serviceCallback);
    }

    /**
     * Query timeseries with required field in each timestamp.
     *
     * @param timeSeriesId Unique id for time series.
     * @param body Request body for querying timeseries.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> queryAsync(String timeSeriesId, TimeSeriesQueryRequest body) {
        return queryWithServiceResponseAsync(timeSeriesId, body).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Query timeseries with required field in each timestamp.
     *
     * @param timeSeriesId Unique id for time series.
     * @param body Request body for querying timeseries.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> queryWithServiceResponseAsync(String timeSeriesId, TimeSeriesQueryRequest body) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (timeSeriesId == null) {
            throw new IllegalArgumentException("Parameter timeSeriesId is required and cannot be null.");
        }
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        Validator.validate(body);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.query(timeSeriesId, body, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = queryDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> queryDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<TimeSeriesQueryResponse>() { }.getType())
                .register(404, new TypeToken<APIError>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }

    /**
     * Detect inconsistent time series from a group of similar time series.
     * This operation helps detect the inconsistent series among a group series with similar trend.
     *
     * @param body Timestamp is necessary, and a parameter called epsilon is needed to tune the result. Epsilon should be within 0 and 1. A list of time series ids need to be provided to the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object inconsistencyDetect(InconsistencyDetectRequest body) {
        return inconsistencyDetectWithServiceResponseAsync(body).toBlocking().single().body();
    }

    /**
     * Detect inconsistent time series from a group of similar time series.
     * This operation helps detect the inconsistent series among a group series with similar trend.
     *
     * @param body Timestamp is necessary, and a parameter called epsilon is needed to tune the result. Epsilon should be within 0 and 1. A list of time series ids need to be provided to the service.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> inconsistencyDetectAsync(InconsistencyDetectRequest body, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(inconsistencyDetectWithServiceResponseAsync(body), serviceCallback);
    }

    /**
     * Detect inconsistent time series from a group of similar time series.
     * This operation helps detect the inconsistent series among a group series with similar trend.
     *
     * @param body Timestamp is necessary, and a parameter called epsilon is needed to tune the result. Epsilon should be within 0 and 1. A list of time series ids need to be provided to the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> inconsistencyDetectAsync(InconsistencyDetectRequest body) {
        return inconsistencyDetectWithServiceResponseAsync(body).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Detect inconsistent time series from a group of similar time series.
     * This operation helps detect the inconsistent series among a group series with similar trend.
     *
     * @param body Timestamp is necessary, and a parameter called epsilon is needed to tune the result. Epsilon should be within 0 and 1. A list of time series ids need to be provided to the service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> inconsistencyDetectWithServiceResponseAsync(InconsistencyDetectRequest body) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException("Parameter this.client.endpoint() is required and cannot be null.");
        }
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        Validator.validate(body);
        String parameterizedHost = Joiner.on(", ").join("{Endpoint}", this.client.endpoint());
        return service.inconsistencyDetect(body, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = inconsistencyDetectDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> inconsistencyDetectDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Inconsistency>() { }.getType())
                .register(404, new TypeToken<APIError>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }

}
