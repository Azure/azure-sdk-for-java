/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.servicefabric.implementation;

import com.google.common.reflect.TypeToken;
import com.microsoft.azure.AzureClient;
import com.microsoft.azure.AzureServiceClient;
import com.microsoft.azure.CloudException;
import com.microsoft.azure.servicefabric.ApplicationDescription;
import com.microsoft.azure.servicefabric.ApplicationHealthPolicy;
import com.microsoft.azure.servicefabric.ApplicationUpgradeDescription;
import com.microsoft.azure.servicefabric.ApplicationUpgradeUpdateDescription;
import com.microsoft.azure.servicefabric.BackupPartitionDescription;
import com.microsoft.azure.servicefabric.BackupStorageDescription;
import com.microsoft.azure.servicefabric.ChaosParameters;
import com.microsoft.azure.servicefabric.ClusterConfigurationUpgradeDescription;
import com.microsoft.azure.servicefabric.ClusterHealthChunkQueryDescription;
import com.microsoft.azure.servicefabric.ClusterHealthPolicies;
import com.microsoft.azure.servicefabric.ClusterHealthPolicy;
import com.microsoft.azure.servicefabric.ComposeDeploymentUpgradeDescription;
import com.microsoft.azure.servicefabric.ContainerApiRequestBody;
import com.microsoft.azure.servicefabric.CreateComposeDeploymentDescription;
import com.microsoft.azure.servicefabric.DataLossMode;
import com.microsoft.azure.servicefabric.DeactivationIntent;
import com.microsoft.azure.servicefabric.DeactivationIntentDescription;
import com.microsoft.azure.servicefabric.DeployServicePackageToNodeDescription;
import com.microsoft.azure.servicefabric.EnableBackupDescription;
import com.microsoft.azure.servicefabric.FabricErrorException;
import com.microsoft.azure.servicefabric.GetBackupByStorageQueryDescription;
import com.microsoft.azure.servicefabric.HealthInformation;
import com.microsoft.azure.servicefabric.ImageStoreCopyDescription;
import com.microsoft.azure.servicefabric.NameDescription;
import com.microsoft.azure.servicefabric.NodeStatusFilter;
import com.microsoft.azure.servicefabric.NodeTransitionType;
import com.microsoft.azure.servicefabric.PropertyBatchDescriptionList;
import com.microsoft.azure.servicefabric.PropertyBatchInfo;
import com.microsoft.azure.servicefabric.PropertyBatchOperation;
import com.microsoft.azure.servicefabric.PropertyDescription;
import com.microsoft.azure.servicefabric.ProvisionApplicationTypeDescriptionBase;
import com.microsoft.azure.servicefabric.ProvisionFabricDescription;
import com.microsoft.azure.servicefabric.QuorumLossMode;
import com.microsoft.azure.servicefabric.RepairTaskApproveDescription;
import com.microsoft.azure.servicefabric.RepairTaskCancelDescription;
import com.microsoft.azure.servicefabric.RepairTaskDeleteDescription;
import com.microsoft.azure.servicefabric.RepairTaskUpdateHealthPolicyDescription;
import com.microsoft.azure.servicefabric.ReplicaHealthReportServiceKind;
import com.microsoft.azure.servicefabric.RestartDeployedCodePackageDescription;
import com.microsoft.azure.servicefabric.RestartNodeDescription;
import com.microsoft.azure.servicefabric.RestartPartitionMode;
import com.microsoft.azure.servicefabric.RestorePartitionDescription;
import com.microsoft.azure.servicefabric.ResumeApplicationUpgradeDescription;
import com.microsoft.azure.servicefabric.ResumeClusterUpgradeDescription;
import com.microsoft.azure.servicefabric.ServiceFromTemplateDescription;
import com.microsoft.azure.servicefabric.ServiceUpdateDescription;
import com.microsoft.azure.servicefabric.StartClusterUpgradeDescription;
import com.microsoft.azure.servicefabric.UnprovisionApplicationTypeDescriptionInfo;
import com.microsoft.azure.servicefabric.UnprovisionFabricDescription;
import com.microsoft.azure.servicefabric.UpdateClusterUpgradeDescription;
import com.microsoft.rest.credentials.ServiceClientCredentials;
import com.microsoft.rest.RestClient;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.List;
import java.util.UUID;
import okhttp3.ResponseBody;
import org.joda.time.DateTime;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * Initializes a new instance of the ServiceFabricClientAPIsImpl class.
 */
public class ServiceFabricClientAPIsImpl extends AzureServiceClient {
    /** The Retrofit service to perform REST calls. */
    private ServiceFabricClientAPIsService service;
    /** the {@link AzureClient} used for long running operations. */
    private AzureClient azureClient;

    /**
     * Gets the {@link AzureClient} used for long running operations.
     * @return the azure client;
     */
    public AzureClient getAzureClient() {
        return this.azureClient;
    }

    /** The preferred language for the response. */
    private String acceptLanguage;

    /**
     * Gets The preferred language for the response.
     *
     * @return the acceptLanguage value.
     */
    public String acceptLanguage() {
        return this.acceptLanguage;
    }

    /**
     * Sets The preferred language for the response.
     *
     * @param acceptLanguage the acceptLanguage value.
     * @return the service client itself
     */
    public ServiceFabricClientAPIsImpl withAcceptLanguage(String acceptLanguage) {
        this.acceptLanguage = acceptLanguage;
        return this;
    }

    /** The retry timeout in seconds for Long Running Operations. Default value is 30. */
    private int longRunningOperationRetryTimeout;

    /**
     * Gets The retry timeout in seconds for Long Running Operations. Default value is 30.
     *
     * @return the longRunningOperationRetryTimeout value.
     */
    public int longRunningOperationRetryTimeout() {
        return this.longRunningOperationRetryTimeout;
    }

    /**
     * Sets The retry timeout in seconds for Long Running Operations. Default value is 30.
     *
     * @param longRunningOperationRetryTimeout the longRunningOperationRetryTimeout value.
     * @return the service client itself
     */
    public ServiceFabricClientAPIsImpl withLongRunningOperationRetryTimeout(int longRunningOperationRetryTimeout) {
        this.longRunningOperationRetryTimeout = longRunningOperationRetryTimeout;
        return this;
    }

    /** Whether a unique x-ms-client-request-id should be generated. When set to true a unique x-ms-client-request-id value is generated and included in each request. Default is true. */
    private boolean generateClientRequestId;

    /**
     * Gets Whether a unique x-ms-client-request-id should be generated. When set to true a unique x-ms-client-request-id value is generated and included in each request. Default is true.
     *
     * @return the generateClientRequestId value.
     */
    public boolean generateClientRequestId() {
        return this.generateClientRequestId;
    }

    /**
     * Sets Whether a unique x-ms-client-request-id should be generated. When set to true a unique x-ms-client-request-id value is generated and included in each request. Default is true.
     *
     * @param generateClientRequestId the generateClientRequestId value.
     * @return the service client itself
     */
    public ServiceFabricClientAPIsImpl withGenerateClientRequestId(boolean generateClientRequestId) {
        this.generateClientRequestId = generateClientRequestId;
        return this;
    }

    /**
     * Initializes an instance of ServiceFabricClientAPIs client.
     *
     * @param credentials the management credentials for Azure
     */
    public ServiceFabricClientAPIsImpl(ServiceClientCredentials credentials) {
        this("http://localhost:19080", credentials);
    }

    /**
     * Initializes an instance of ServiceFabricClientAPIs client.
     *
     * @param baseUrl the base URL of the host
     * @param credentials the management credentials for Azure
     */
    public ServiceFabricClientAPIsImpl(String baseUrl, ServiceClientCredentials credentials) {
        super(baseUrl, credentials);
        initialize();
    }

    /**
     * Initializes an instance of ServiceFabricClientAPIs client.
     *
     * @param restClient the REST client to connect to Azure.
     */
    public ServiceFabricClientAPIsImpl(RestClient restClient) {
        super(restClient);
        initialize();
    }

    protected void initialize() {
        this.acceptLanguage = "en-US";
        this.longRunningOperationRetryTimeout = 30;
        this.generateClientRequestId = true;
        this.azureClient = new AzureClient(this);
        initializeService();
    }

    /**
     * Gets the User-Agent header for the client.
     *
     * @return the user agent string.
     */
    @Override
    public String userAgent() {
        return String.format("%s (%s, %s, auto-generated)", super.userAgent(), "ServiceFabricClientAPIs", "6.3.0.9");
    }

    private void initializeService() {
        service = restClient().retrofit().create(ServiceFabricClientAPIsService.class);
    }

    /**
     * The interface defining all the services for ServiceFabricClientAPIs to be
     * used by Retrofit to perform actually REST calls.
     */
    interface ServiceFabricClientAPIsService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getClusterManifest" })
        @GET("$/GetClusterManifest")
        Observable<Response<ResponseBody>> getClusterManifest(@Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getClusterHealth" })
        @GET("$/GetClusterHealth")
        Observable<Response<ResponseBody>> getClusterHealth(@Query("api-version") String apiVersion, @Query("NodesHealthStateFilter") Integer nodesHealthStateFilter, @Query("ApplicationsHealthStateFilter") Integer applicationsHealthStateFilter, @Query("EventsHealthStateFilter") Integer eventsHealthStateFilter, @Query("ExcludeHealthStatistics") Boolean excludeHealthStatistics, @Query("IncludeSystemApplicationHealthStatistics") Boolean includeSystemApplicationHealthStatistics, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getClusterHealthUsingPolicy" })
        @POST("$/GetClusterHealth")
        Observable<Response<ResponseBody>> getClusterHealthUsingPolicy(@Query("api-version") String apiVersion, @Query("NodesHealthStateFilter") Integer nodesHealthStateFilter, @Query("ApplicationsHealthStateFilter") Integer applicationsHealthStateFilter, @Query("EventsHealthStateFilter") Integer eventsHealthStateFilter, @Query("ExcludeHealthStatistics") Boolean excludeHealthStatistics, @Query("IncludeSystemApplicationHealthStatistics") Boolean includeSystemApplicationHealthStatistics, @Body ClusterHealthPolicies clusterHealthPolicies, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getClusterHealthChunk" })
        @GET("$/GetClusterHealthChunk")
        Observable<Response<ResponseBody>> getClusterHealthChunk(@Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getClusterHealthChunkUsingPolicyAndAdvancedFilters" })
        @POST("$/GetClusterHealthChunk")
        Observable<Response<ResponseBody>> getClusterHealthChunkUsingPolicyAndAdvancedFilters(@Query("api-version") String apiVersion, @Body ClusterHealthChunkQueryDescription clusterHealthChunkQueryDescription, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs reportClusterHealth" })
        @POST("$/ReportClusterHealth")
        Observable<Response<ResponseBody>> reportClusterHealth(@Query("api-version") String apiVersion, @Body HealthInformation healthInformation, @Query("Immediate") Boolean immediate, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getProvisionedFabricCodeVersionInfoList" })
        @GET("$/GetProvisionedCodeVersions")
        Observable<Response<ResponseBody>> getProvisionedFabricCodeVersionInfoList(@Query("api-version") String apiVersion, @Query("CodeVersion") String codeVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getProvisionedFabricConfigVersionInfoList" })
        @GET("$/GetProvisionedConfigVersions")
        Observable<Response<ResponseBody>> getProvisionedFabricConfigVersionInfoList(@Query("api-version") String apiVersion, @Query("ConfigVersion") String configVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getClusterUpgradeProgress" })
        @GET("$/GetUpgradeProgress")
        Observable<Response<ResponseBody>> getClusterUpgradeProgress(@Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getClusterConfiguration" })
        @GET("$/GetClusterConfiguration")
        Observable<Response<ResponseBody>> getClusterConfiguration(@Query("api-version") String apiVersion, @Query("ConfigurationApiVersion") String configurationApiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getClusterConfigurationUpgradeStatus" })
        @GET("$/GetClusterConfigurationUpgradeStatus")
        Observable<Response<ResponseBody>> getClusterConfigurationUpgradeStatus(@Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getUpgradeOrchestrationServiceState" })
        @GET("$/GetUpgradeOrchestrationServiceState")
        Observable<Response<ResponseBody>> getUpgradeOrchestrationServiceState(@Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs setUpgradeOrchestrationServiceState" })
        @POST("$/SetUpgradeOrchestrationServiceState")
        Observable<Response<ResponseBody>> setUpgradeOrchestrationServiceState(@Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Body UpgradeOrchestrationServiceStateInner upgradeOrchestrationServiceState, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs provisionCluster" })
        @POST("$/Provision")
        Observable<Response<ResponseBody>> provisionCluster(@Query("api-version") String apiVersion, @Body ProvisionFabricDescription provisionFabricDescription, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs unprovisionCluster" })
        @POST("$/Unprovision")
        Observable<Response<ResponseBody>> unprovisionCluster(@Query("api-version") String apiVersion, @Body UnprovisionFabricDescription unprovisionFabricDescription, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs rollbackClusterUpgrade" })
        @POST("$/RollbackUpgrade")
        Observable<Response<ResponseBody>> rollbackClusterUpgrade(@Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs resumeClusterUpgrade" })
        @POST("$/MoveToNextUpgradeDomain")
        Observable<Response<ResponseBody>> resumeClusterUpgrade(@Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Body ResumeClusterUpgradeDescription resumeClusterUpgradeDescription, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs startClusterUpgrade" })
        @POST("$/Upgrade")
        Observable<Response<ResponseBody>> startClusterUpgrade(@Query("api-version") String apiVersion, @Body StartClusterUpgradeDescription startClusterUpgradeDescription, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs startClusterConfigurationUpgrade" })
        @POST("$/StartClusterConfigurationUpgrade")
        Observable<Response<ResponseBody>> startClusterConfigurationUpgrade(@Query("api-version") String apiVersion, @Body ClusterConfigurationUpgradeDescription clusterConfigurationUpgradeDescription, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs updateClusterUpgrade" })
        @POST("$/UpdateUpgrade")
        Observable<Response<ResponseBody>> updateClusterUpgrade(@Query("api-version") String apiVersion, @Body UpdateClusterUpgradeDescription updateClusterUpgradeDescription, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getAadMetadata" })
        @GET("$/GetAadMetadata")
        Observable<Response<ResponseBody>> getAadMetadata(@Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getNodeInfoList" })
        @GET("Nodes")
        Observable<Response<ResponseBody>> getNodeInfoList(@Query("api-version") String apiVersion, @Query(value = "ContinuationToken", encoded = true) String continuationToken, @Query("NodeStatusFilter") NodeStatusFilter nodeStatusFilter1, @Query("MaxResults") Long maxResults, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getNodeInfo" })
        @GET("Nodes/{nodeName}")
        Observable<Response<ResponseBody>> getNodeInfo(@Path("nodeName") String nodeName, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getNodeHealth" })
        @GET("Nodes/{nodeName}/$/GetHealth")
        Observable<Response<ResponseBody>> getNodeHealth(@Path("nodeName") String nodeName, @Query("api-version") String apiVersion, @Query("EventsHealthStateFilter") Integer eventsHealthStateFilter, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getNodeHealthUsingPolicy" })
        @POST("Nodes/{nodeName}/$/GetHealth")
        Observable<Response<ResponseBody>> getNodeHealthUsingPolicy(@Path("nodeName") String nodeName, @Query("api-version") String apiVersion, @Query("EventsHealthStateFilter") Integer eventsHealthStateFilter, @Body ClusterHealthPolicy clusterHealthPolicy, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs reportNodeHealth" })
        @POST("Nodes/{nodeName}/$/ReportHealth")
        Observable<Response<ResponseBody>> reportNodeHealth(@Path("nodeName") String nodeName, @Query("api-version") String apiVersion, @Body HealthInformation healthInformation, @Query("Immediate") Boolean immediate, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getNodeLoadInfo" })
        @GET("Nodes/{nodeName}/$/GetLoadInformation")
        Observable<Response<ResponseBody>> getNodeLoadInfo(@Path("nodeName") String nodeName, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs disableNode" })
        @POST("Nodes/{nodeName}/$/Deactivate")
        Observable<Response<ResponseBody>> disableNode(@Path("nodeName") String nodeName, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Body DeactivationIntentDescription deactivationIntentDescription, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs enableNode" })
        @POST("Nodes/{nodeName}/$/Activate")
        Observable<Response<ResponseBody>> enableNode(@Path("nodeName") String nodeName, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs removeNodeState" })
        @POST("Nodes/{nodeName}/$/RemoveNodeState")
        Observable<Response<ResponseBody>> removeNodeState(@Path("nodeName") String nodeName, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs restartNode" })
        @POST("Nodes/{nodeName}/$/Restart")
        Observable<Response<ResponseBody>> restartNode(@Path("nodeName") String nodeName, @Query("api-version") String apiVersion, @Body RestartNodeDescription restartNodeDescription, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getApplicationTypeInfoList" })
        @GET("ApplicationTypes")
        Observable<Response<ResponseBody>> getApplicationTypeInfoList(@Query("api-version") String apiVersion, @Query("ApplicationTypeDefinitionKindFilter") Integer applicationTypeDefinitionKindFilter, @Query("ExcludeApplicationParameters") Boolean excludeApplicationParameters, @Query(value = "ContinuationToken", encoded = true) String continuationToken, @Query("MaxResults") Long maxResults, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getApplicationTypeInfoListByName" })
        @GET("ApplicationTypes/{applicationTypeName}")
        Observable<Response<ResponseBody>> getApplicationTypeInfoListByName(@Path("applicationTypeName") String applicationTypeName1, @Query("api-version") String apiVersion, @Query("ApplicationTypeVersion") String applicationTypeVersion, @Query("ExcludeApplicationParameters") Boolean excludeApplicationParameters, @Query(value = "ContinuationToken", encoded = true) String continuationToken, @Query("MaxResults") Long maxResults, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs provisionApplicationType" })
        @POST("ApplicationTypes/$/Provision")
        Observable<Response<ResponseBody>> provisionApplicationType(@Query("api-version") String apiVersion, @Body ProvisionApplicationTypeDescriptionBase provisionApplicationTypeDescriptionBaseRequiredBodyParam, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs unprovisionApplicationType" })
        @POST("ApplicationTypes/{applicationTypeName}/$/Unprovision")
        Observable<Response<ResponseBody>> unprovisionApplicationType(@Path("applicationTypeName") String applicationTypeName1, @Query("api-version") String apiVersion, @Body UnprovisionApplicationTypeDescriptionInfo unprovisionApplicationTypeDescriptionInfo, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getServiceTypeInfoList" })
        @GET("ApplicationTypes/{applicationTypeName}/$/GetServiceTypes")
        Observable<Response<ResponseBody>> getServiceTypeInfoList(@Path("applicationTypeName") String applicationTypeName1, @Query("api-version") String apiVersion, @Query("ApplicationTypeVersion") String applicationTypeVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getServiceTypeInfoByName" })
        @GET("ApplicationTypes/{applicationTypeName}/$/GetServiceTypes/{serviceTypeName}")
        Observable<Response<ResponseBody>> getServiceTypeInfoByName(@Path("applicationTypeName") String applicationTypeName1, @Path(value = "serviceTypeName", encoded = true) String serviceTypeName1, @Query("api-version") String apiVersion, @Query("ApplicationTypeVersion") String applicationTypeVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getServiceManifest" })
        @GET("ApplicationTypes/{applicationTypeName}/$/GetServiceManifest")
        Observable<Response<ResponseBody>> getServiceManifest(@Path("applicationTypeName") String applicationTypeName1, @Query("api-version") String apiVersion, @Query("ApplicationTypeVersion") String applicationTypeVersion, @Query("ServiceManifestName") String serviceManifestName, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getDeployedServiceTypeInfoList" })
        @GET("Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServiceTypes")
        Observable<Response<ResponseBody>> getDeployedServiceTypeInfoList(@Path("nodeName") String nodeName, @Path(value = "applicationId", encoded = true) String applicationId, @Query("api-version") String apiVersion, @Query("ServiceManifestName") String serviceManifestName, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getDeployedServiceTypeInfoByName" })
        @GET("Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServiceTypes/{serviceTypeName}")
        Observable<Response<ResponseBody>> getDeployedServiceTypeInfoByName(@Path("nodeName") String nodeName, @Path(value = "applicationId", encoded = true) String applicationId, @Path(value = "serviceTypeName", encoded = true) String serviceTypeName1, @Query("api-version") String apiVersion, @Query("ServiceManifestName") String serviceManifestName, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs createApplication" })
        @POST("Applications/$/Create")
        Observable<Response<ResponseBody>> createApplication(@Query("api-version") String apiVersion, @Body ApplicationDescription applicationDescription, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs deleteApplication" })
        @POST("Applications/{applicationId}/$/Delete")
        Observable<Response<ResponseBody>> deleteApplication(@Path(value = "applicationId", encoded = true) String applicationId, @Query("api-version") String apiVersion, @Query("ForceRemove") Boolean forceRemove, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getApplicationLoadInfo" })
        @GET("Applications/{applicationId}/$/GetLoadInformation")
        Observable<Response<ResponseBody>> getApplicationLoadInfo(@Path(value = "applicationId", encoded = true) String applicationId, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getApplicationInfoList" })
        @GET("Applications")
        Observable<Response<ResponseBody>> getApplicationInfoList(@Query("api-version") String apiVersion, @Query("ApplicationDefinitionKindFilter") Integer applicationDefinitionKindFilter, @Query("ApplicationTypeName") String applicationTypeName, @Query("ExcludeApplicationParameters") Boolean excludeApplicationParameters, @Query(value = "ContinuationToken", encoded = true) String continuationToken, @Query("MaxResults") Long maxResults, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getApplicationInfo" })
        @GET("Applications/{applicationId}")
        Observable<Response<ResponseBody>> getApplicationInfo(@Path(value = "applicationId", encoded = true) String applicationId, @Query("api-version") String apiVersion, @Query("ExcludeApplicationParameters") Boolean excludeApplicationParameters, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getApplicationHealth" })
        @GET("Applications/{applicationId}/$/GetHealth")
        Observable<Response<ResponseBody>> getApplicationHealth(@Path(value = "applicationId", encoded = true) String applicationId, @Query("api-version") String apiVersion, @Query("EventsHealthStateFilter") Integer eventsHealthStateFilter, @Query("DeployedApplicationsHealthStateFilter") Integer deployedApplicationsHealthStateFilter, @Query("ServicesHealthStateFilter") Integer servicesHealthStateFilter, @Query("ExcludeHealthStatistics") Boolean excludeHealthStatistics, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getApplicationHealthUsingPolicy" })
        @POST("Applications/{applicationId}/$/GetHealth")
        Observable<Response<ResponseBody>> getApplicationHealthUsingPolicy(@Path(value = "applicationId", encoded = true) String applicationId, @Query("api-version") String apiVersion, @Query("EventsHealthStateFilter") Integer eventsHealthStateFilter, @Query("DeployedApplicationsHealthStateFilter") Integer deployedApplicationsHealthStateFilter, @Query("ServicesHealthStateFilter") Integer servicesHealthStateFilter, @Query("ExcludeHealthStatistics") Boolean excludeHealthStatistics, @Body ApplicationHealthPolicy applicationHealthPolicy, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs reportApplicationHealth" })
        @POST("Applications/{applicationId}/$/ReportHealth")
        Observable<Response<ResponseBody>> reportApplicationHealth(@Path(value = "applicationId", encoded = true) String applicationId, @Query("api-version") String apiVersion, @Body HealthInformation healthInformation, @Query("Immediate") Boolean immediate, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs startApplicationUpgrade" })
        @POST("Applications/{applicationId}/$/Upgrade")
        Observable<Response<ResponseBody>> startApplicationUpgrade(@Path(value = "applicationId", encoded = true) String applicationId, @Query("api-version") String apiVersion, @Body ApplicationUpgradeDescription applicationUpgradeDescription, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getApplicationUpgrade" })
        @GET("Applications/{applicationId}/$/GetUpgradeProgress")
        Observable<Response<ResponseBody>> getApplicationUpgrade(@Path(value = "applicationId", encoded = true) String applicationId, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs updateApplicationUpgrade" })
        @POST("Applications/{applicationId}/$/UpdateUpgrade")
        Observable<Response<ResponseBody>> updateApplicationUpgrade(@Path(value = "applicationId", encoded = true) String applicationId, @Query("api-version") String apiVersion, @Body ApplicationUpgradeUpdateDescription applicationUpgradeUpdateDescription, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs resumeApplicationUpgrade" })
        @POST("Applications/{applicationId}/$/MoveToNextUpgradeDomain")
        Observable<Response<ResponseBody>> resumeApplicationUpgrade(@Path(value = "applicationId", encoded = true) String applicationId, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Body ResumeApplicationUpgradeDescription resumeApplicationUpgradeDescription, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs rollbackApplicationUpgrade" })
        @POST("Applications/{applicationId}/$/RollbackUpgrade")
        Observable<Response<ResponseBody>> rollbackApplicationUpgrade(@Path(value = "applicationId", encoded = true) String applicationId, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getDeployedApplicationInfoList" })
        @GET("Nodes/{nodeName}/$/GetApplications")
        Observable<Response<ResponseBody>> getDeployedApplicationInfoList(@Path("nodeName") String nodeName, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Query("IncludeHealthState") Boolean includeHealthState, @Query(value = "ContinuationToken", encoded = true) String continuationToken, @Query("MaxResults") Long maxResults, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getDeployedApplicationInfo" })
        @GET("Nodes/{nodeName}/$/GetApplications/{applicationId}")
        Observable<Response<ResponseBody>> getDeployedApplicationInfo(@Path("nodeName") String nodeName, @Path(value = "applicationId", encoded = true) String applicationId, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Query("IncludeHealthState") Boolean includeHealthState, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getDeployedApplicationHealth" })
        @GET("Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetHealth")
        Observable<Response<ResponseBody>> getDeployedApplicationHealth(@Path("nodeName") String nodeName, @Path(value = "applicationId", encoded = true) String applicationId, @Query("api-version") String apiVersion, @Query("EventsHealthStateFilter") Integer eventsHealthStateFilter, @Query("DeployedServicePackagesHealthStateFilter") Integer deployedServicePackagesHealthStateFilter, @Query("ExcludeHealthStatistics") Boolean excludeHealthStatistics, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getDeployedApplicationHealthUsingPolicy" })
        @POST("Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetHealth")
        Observable<Response<ResponseBody>> getDeployedApplicationHealthUsingPolicy(@Path("nodeName") String nodeName, @Path(value = "applicationId", encoded = true) String applicationId, @Query("api-version") String apiVersion, @Query("EventsHealthStateFilter") Integer eventsHealthStateFilter, @Query("DeployedServicePackagesHealthStateFilter") Integer deployedServicePackagesHealthStateFilter, @Body ApplicationHealthPolicy applicationHealthPolicy, @Query("ExcludeHealthStatistics") Boolean excludeHealthStatistics, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs reportDeployedApplicationHealth" })
        @POST("Nodes/{nodeName}/$/GetApplications/{applicationId}/$/ReportHealth")
        Observable<Response<ResponseBody>> reportDeployedApplicationHealth(@Path("nodeName") String nodeName, @Path(value = "applicationId", encoded = true) String applicationId, @Query("api-version") String apiVersion, @Body HealthInformation healthInformation, @Query("Immediate") Boolean immediate, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getApplicationManifest" })
        @GET("ApplicationTypes/{applicationTypeName}/$/GetApplicationManifest")
        Observable<Response<ResponseBody>> getApplicationManifest(@Path("applicationTypeName") String applicationTypeName1, @Query("api-version") String apiVersion, @Query("ApplicationTypeVersion") String applicationTypeVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getServiceInfoList" })
        @GET("Applications/{applicationId}/$/GetServices")
        Observable<Response<ResponseBody>> getServiceInfoList(@Path(value = "applicationId", encoded = true) String applicationId, @Query("ServiceTypeName") String serviceTypeName, @Query("api-version") String apiVersion, @Query(value = "ContinuationToken", encoded = true) String continuationToken, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getServiceInfo" })
        @GET("Applications/{applicationId}/$/GetServices/{serviceId}")
        Observable<Response<ResponseBody>> getServiceInfo(@Path(value = "applicationId", encoded = true) String applicationId, @Path(value = "serviceId", encoded = true) String serviceId, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getApplicationNameInfo" })
        @GET("Services/{serviceId}/$/GetApplicationName")
        Observable<Response<ResponseBody>> getApplicationNameInfo(@Path(value = "serviceId", encoded = true) String serviceId, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs createService" })
        @POST("Applications/{applicationId}/$/GetServices/$/Create")
        Observable<Response<ResponseBody>> createService(@Path(value = "applicationId", encoded = true) String applicationId, @Query("api-version") String apiVersion, @Body ServiceDescriptionInner serviceDescription, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs createServiceFromTemplate" })
        @POST("Applications/{applicationId}/$/GetServices/$/CreateFromTemplate")
        Observable<Response<ResponseBody>> createServiceFromTemplate(@Path(value = "applicationId", encoded = true) String applicationId, @Query("api-version") String apiVersion, @Body ServiceFromTemplateDescription serviceFromTemplateDescription, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs deleteService" })
        @POST("Services/{serviceId}/$/Delete")
        Observable<Response<ResponseBody>> deleteService(@Path(value = "serviceId", encoded = true) String serviceId, @Query("api-version") String apiVersion, @Query("ForceRemove") Boolean forceRemove, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs updateService" })
        @POST("Services/{serviceId}/$/Update")
        Observable<Response<ResponseBody>> updateService(@Path(value = "serviceId", encoded = true) String serviceId, @Query("api-version") String apiVersion, @Body ServiceUpdateDescription serviceUpdateDescription, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getServiceDescription" })
        @GET("Services/{serviceId}/$/GetDescription")
        Observable<Response<ResponseBody>> getServiceDescription(@Path(value = "serviceId", encoded = true) String serviceId, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getServiceHealth" })
        @GET("Services/{serviceId}/$/GetHealth")
        Observable<Response<ResponseBody>> getServiceHealth(@Path(value = "serviceId", encoded = true) String serviceId, @Query("api-version") String apiVersion, @Query("EventsHealthStateFilter") Integer eventsHealthStateFilter, @Query("PartitionsHealthStateFilter") Integer partitionsHealthStateFilter, @Query("ExcludeHealthStatistics") Boolean excludeHealthStatistics, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getServiceHealthUsingPolicy" })
        @POST("Services/{serviceId}/$/GetHealth")
        Observable<Response<ResponseBody>> getServiceHealthUsingPolicy(@Path(value = "serviceId", encoded = true) String serviceId, @Query("api-version") String apiVersion, @Query("EventsHealthStateFilter") Integer eventsHealthStateFilter, @Query("PartitionsHealthStateFilter") Integer partitionsHealthStateFilter, @Body ApplicationHealthPolicy applicationHealthPolicy, @Query("ExcludeHealthStatistics") Boolean excludeHealthStatistics, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs reportServiceHealth" })
        @POST("Services/{serviceId}/$/ReportHealth")
        Observable<Response<ResponseBody>> reportServiceHealth(@Path(value = "serviceId", encoded = true) String serviceId, @Query("api-version") String apiVersion, @Body HealthInformation healthInformation, @Query("Immediate") Boolean immediate, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs resolveService" })
        @GET("Services/{serviceId}/$/ResolvePartition")
        Observable<Response<ResponseBody>> resolveService(@Path(value = "serviceId", encoded = true) String serviceId, @Query("api-version") String apiVersion, @Query("PartitionKeyType") Integer partitionKeyType, @Query(value = "PartitionKeyValue", encoded = true) String partitionKeyValue, @Query(value = "PreviousRspVersion", encoded = true) String previousRspVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getPartitionInfoList" })
        @GET("Services/{serviceId}/$/GetPartitions")
        Observable<Response<ResponseBody>> getPartitionInfoList(@Path(value = "serviceId", encoded = true) String serviceId, @Query("api-version") String apiVersion, @Query(value = "ContinuationToken", encoded = true) String continuationToken, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getPartitionInfo" })
        @GET("Partitions/{partitionId}")
        Observable<Response<ResponseBody>> getPartitionInfo(@Path(value = "partitionId", encoded = true) UUID partitionId1, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getServiceNameInfo" })
        @GET("Partitions/{partitionId}/$/GetServiceName")
        Observable<Response<ResponseBody>> getServiceNameInfo(@Path(value = "partitionId", encoded = true) UUID partitionId1, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getPartitionHealth" })
        @GET("Partitions/{partitionId}/$/GetHealth")
        Observable<Response<ResponseBody>> getPartitionHealth(@Path(value = "partitionId", encoded = true) UUID partitionId1, @Query("api-version") String apiVersion, @Query("EventsHealthStateFilter") Integer eventsHealthStateFilter, @Query("ReplicasHealthStateFilter") Integer replicasHealthStateFilter, @Query("ExcludeHealthStatistics") Boolean excludeHealthStatistics, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getPartitionHealthUsingPolicy" })
        @POST("Partitions/{partitionId}/$/GetHealth")
        Observable<Response<ResponseBody>> getPartitionHealthUsingPolicy(@Path(value = "partitionId", encoded = true) UUID partitionId1, @Query("api-version") String apiVersion, @Query("EventsHealthStateFilter") Integer eventsHealthStateFilter, @Query("ReplicasHealthStateFilter") Integer replicasHealthStateFilter, @Body ApplicationHealthPolicy applicationHealthPolicy, @Query("ExcludeHealthStatistics") Boolean excludeHealthStatistics, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs reportPartitionHealth" })
        @POST("Partitions/{partitionId}/$/ReportHealth")
        Observable<Response<ResponseBody>> reportPartitionHealth(@Path(value = "partitionId", encoded = true) UUID partitionId1, @Query("api-version") String apiVersion, @Body HealthInformation healthInformation, @Query("Immediate") Boolean immediate, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getPartitionLoadInformation" })
        @GET("Partitions/{partitionId}/$/GetLoadInformation")
        Observable<Response<ResponseBody>> getPartitionLoadInformation(@Path(value = "partitionId", encoded = true) UUID partitionId1, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs resetPartitionLoad" })
        @POST("Partitions/{partitionId}/$/ResetLoad")
        Observable<Response<ResponseBody>> resetPartitionLoad(@Path(value = "partitionId", encoded = true) UUID partitionId1, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs recoverPartition" })
        @POST("Partitions/{partitionId}/$/Recover")
        Observable<Response<ResponseBody>> recoverPartition(@Path(value = "partitionId", encoded = true) UUID partitionId1, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs recoverServicePartitions" })
        @POST("Services/$/{serviceId}/$/GetPartitions/$/Recover")
        Observable<Response<ResponseBody>> recoverServicePartitions(@Path(value = "serviceId", encoded = true) String serviceId, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs recoverSystemPartitions" })
        @POST("$/RecoverSystemPartitions")
        Observable<Response<ResponseBody>> recoverSystemPartitions(@Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs recoverAllPartitions" })
        @POST("$/RecoverAllPartitions")
        Observable<Response<ResponseBody>> recoverAllPartitions(@Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs createRepairTask" })
        @POST("$/CreateRepairTask")
        Observable<Response<ResponseBody>> createRepairTask(@Query("api-version") String apiVersion, @Body RepairTaskInner repairTask, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs cancelRepairTask" })
        @POST("$/CancelRepairTask")
        Observable<Response<ResponseBody>> cancelRepairTask(@Query("api-version") String apiVersion, @Body RepairTaskCancelDescription repairTaskCancelDescription, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs deleteRepairTask" })
        @POST("$/DeleteRepairTask")
        Observable<Response<ResponseBody>> deleteRepairTask(@Query("api-version") String apiVersion, @Body RepairTaskDeleteDescription repairTaskDeleteDescription, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getRepairTaskList" })
        @GET("$/GetRepairTaskList")
        Observable<Response<ResponseBody>> getRepairTaskList(@Query("api-version") String apiVersion, @Query("TaskIdFilter") String taskIdFilter, @Query("StateFilter") Integer stateFilter, @Query("ExecutorFilter") String executorFilter, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs forceApproveRepairTask" })
        @POST("$/ForceApproveRepairTask")
        Observable<Response<ResponseBody>> forceApproveRepairTask(@Query("api-version") String apiVersion, @Body RepairTaskApproveDescription repairTaskApproveDescription, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs updateRepairTaskHealthPolicy" })
        @POST("$/UpdateRepairTaskHealthPolicy")
        Observable<Response<ResponseBody>> updateRepairTaskHealthPolicy(@Query("api-version") String apiVersion, @Body RepairTaskUpdateHealthPolicyDescription repairTaskUpdateHealthPolicyDescription, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs updateRepairExecutionState" })
        @POST("$/UpdateRepairExecutionState")
        Observable<Response<ResponseBody>> updateRepairExecutionState(@Query("api-version") String apiVersion, @Body RepairTaskInner repairTask, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getReplicaInfoList" })
        @GET("Partitions/{partitionId}/$/GetReplicas")
        Observable<Response<ResponseBody>> getReplicaInfoList(@Path(value = "partitionId", encoded = true) UUID partitionId1, @Query("api-version") String apiVersion, @Query(value = "ContinuationToken", encoded = true) String continuationToken, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getReplicaInfo" })
        @GET("Partitions/{partitionId}/$/GetReplicas/{replicaId}")
        Observable<Response<ResponseBody>> getReplicaInfo(@Path(value = "partitionId", encoded = true) UUID partitionId1, @Path(value = "replicaId", encoded = true) String replicaId, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getReplicaHealth" })
        @GET("Partitions/{partitionId}/$/GetReplicas/{replicaId}/$/GetHealth")
        Observable<Response<ResponseBody>> getReplicaHealth(@Path(value = "partitionId", encoded = true) UUID partitionId1, @Path(value = "replicaId", encoded = true) String replicaId, @Query("api-version") String apiVersion, @Query("EventsHealthStateFilter") Integer eventsHealthStateFilter, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getReplicaHealthUsingPolicy" })
        @POST("Partitions/{partitionId}/$/GetReplicas/{replicaId}/$/GetHealth")
        Observable<Response<ResponseBody>> getReplicaHealthUsingPolicy(@Path(value = "partitionId", encoded = true) UUID partitionId1, @Path(value = "replicaId", encoded = true) String replicaId, @Query("api-version") String apiVersion, @Query("EventsHealthStateFilter") Integer eventsHealthStateFilter, @Body ApplicationHealthPolicy applicationHealthPolicy, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs reportReplicaHealth" })
        @POST("Partitions/{partitionId}/$/GetReplicas/{replicaId}/$/ReportHealth")
        Observable<Response<ResponseBody>> reportReplicaHealth(@Path(value = "partitionId", encoded = true) UUID partitionId1, @Path(value = "replicaId", encoded = true) String replicaId, @Query("api-version") String apiVersion, @Query("ReplicaHealthReportServiceKind") ReplicaHealthReportServiceKind replicaHealthReportServiceKind1, @Body HealthInformation healthInformation, @Query("Immediate") Boolean immediate, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getDeployedServiceReplicaInfoList" })
        @GET("Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetReplicas")
        Observable<Response<ResponseBody>> getDeployedServiceReplicaInfoList(@Path("nodeName") String nodeName, @Path(value = "applicationId", encoded = true) String applicationId, @Query("api-version") String apiVersion, @Query("PartitionId") UUID partitionId, @Query("ServiceManifestName") String serviceManifestName, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getDeployedServiceReplicaDetailInfo" })
        @GET("Nodes/{nodeName}/$/GetPartitions/{partitionId}/$/GetReplicas/{replicaId}/$/GetDetail")
        Observable<Response<ResponseBody>> getDeployedServiceReplicaDetailInfo(@Path("nodeName") String nodeName, @Path(value = "partitionId", encoded = true) UUID partitionId1, @Path(value = "replicaId", encoded = true) String replicaId, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getDeployedServiceReplicaDetailInfoByPartitionId" })
        @GET("Nodes/{nodeName}/$/GetPartitions/{partitionId}/$/GetReplicas")
        Observable<Response<ResponseBody>> getDeployedServiceReplicaDetailInfoByPartitionId(@Path("nodeName") String nodeName, @Path(value = "partitionId", encoded = true) UUID partitionId1, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs restartReplica" })
        @POST("Nodes/{nodeName}/$/GetPartitions/{partitionId}/$/GetReplicas/{replicaId}/$/Restart")
        Observable<Response<ResponseBody>> restartReplica(@Path("nodeName") String nodeName, @Path(value = "partitionId", encoded = true) UUID partitionId1, @Path(value = "replicaId", encoded = true) String replicaId, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs removeReplica" })
        @POST("Nodes/{nodeName}/$/GetPartitions/{partitionId}/$/GetReplicas/{replicaId}/$/Delete")
        Observable<Response<ResponseBody>> removeReplica(@Path("nodeName") String nodeName, @Path(value = "partitionId", encoded = true) UUID partitionId1, @Path(value = "replicaId", encoded = true) String replicaId, @Query("api-version") String apiVersion, @Query("ForceRemove") Boolean forceRemove, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getDeployedServicePackageInfoList" })
        @GET("Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServicePackages")
        Observable<Response<ResponseBody>> getDeployedServicePackageInfoList(@Path("nodeName") String nodeName, @Path(value = "applicationId", encoded = true) String applicationId, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getDeployedServicePackageInfoListByName" })
        @GET("Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServicePackages/{servicePackageName}")
        Observable<Response<ResponseBody>> getDeployedServicePackageInfoListByName(@Path("nodeName") String nodeName, @Path(value = "applicationId", encoded = true) String applicationId, @Path(value = "servicePackageName", encoded = true) String servicePackageName, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getDeployedServicePackageHealth" })
        @GET("Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServicePackages/{servicePackageName}/$/GetHealth")
        Observable<Response<ResponseBody>> getDeployedServicePackageHealth(@Path("nodeName") String nodeName, @Path(value = "applicationId", encoded = true) String applicationId, @Path(value = "servicePackageName", encoded = true) String servicePackageName, @Query("api-version") String apiVersion, @Query("EventsHealthStateFilter") Integer eventsHealthStateFilter, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getDeployedServicePackageHealthUsingPolicy" })
        @POST("Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServicePackages/{servicePackageName}/$/GetHealth")
        Observable<Response<ResponseBody>> getDeployedServicePackageHealthUsingPolicy(@Path("nodeName") String nodeName, @Path(value = "applicationId", encoded = true) String applicationId, @Path(value = "servicePackageName", encoded = true) String servicePackageName, @Query("api-version") String apiVersion, @Query("EventsHealthStateFilter") Integer eventsHealthStateFilter, @Body ApplicationHealthPolicy applicationHealthPolicy, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs reportDeployedServicePackageHealth" })
        @POST("Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServicePackages/{servicePackageName}/$/ReportHealth")
        Observable<Response<ResponseBody>> reportDeployedServicePackageHealth(@Path("nodeName") String nodeName, @Path(value = "applicationId", encoded = true) String applicationId, @Path(value = "servicePackageName", encoded = true) String servicePackageName, @Query("api-version") String apiVersion, @Body HealthInformation healthInformation, @Query("Immediate") Boolean immediate, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs deployServicePackageToNode" })
        @POST("Nodes/{nodeName}/$/DeployServicePackage")
        Observable<Response<ResponseBody>> deployServicePackageToNode(@Path("nodeName") String nodeName, @Query("api-version") String apiVersion, @Body DeployServicePackageToNodeDescription deployServicePackageToNodeDescription, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getDeployedCodePackageInfoList" })
        @GET("Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetCodePackages")
        Observable<Response<ResponseBody>> getDeployedCodePackageInfoList(@Path("nodeName") String nodeName, @Path(value = "applicationId", encoded = true) String applicationId, @Query("api-version") String apiVersion, @Query("ServiceManifestName") String serviceManifestName, @Query("CodePackageName") String codePackageName, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs restartDeployedCodePackage" })
        @POST("Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetCodePackages/$/Restart")
        Observable<Response<ResponseBody>> restartDeployedCodePackage(@Path("nodeName") String nodeName, @Path(value = "applicationId", encoded = true) String applicationId, @Query("api-version") String apiVersion, @Body RestartDeployedCodePackageDescription restartDeployedCodePackageDescription, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getContainerLogsDeployedOnNode" })
        @GET("Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetCodePackages/$/ContainerLogs")
        Observable<Response<ResponseBody>> getContainerLogsDeployedOnNode(@Path("nodeName") String nodeName, @Path(value = "applicationId", encoded = true) String applicationId, @Query("api-version") String apiVersion, @Query("ServiceManifestName") String serviceManifestName, @Query("CodePackageName") String codePackageName, @Query("Tail") String tail, @Query("Previous") Boolean previous, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs invokeContainerApi" })
        @POST("Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetCodePackages/$/ContainerApi")
        Observable<Response<ResponseBody>> invokeContainerApi(@Path("nodeName") String nodeName, @Path(value = "applicationId", encoded = true) String applicationId, @Query("api-version") String apiVersion, @Query("ServiceManifestName") String serviceManifestName, @Query("CodePackageName") String codePackageName, @Query("CodePackageInstanceId") String codePackageInstanceId, @Query("timeout") Long timeout, @Body ContainerApiRequestBody containerApiRequestBody, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs createComposeDeployment" })
        @PUT("ComposeDeployments/$/Create")
        Observable<Response<ResponseBody>> createComposeDeployment(@Query("api-version") String apiVersion, @Body CreateComposeDeploymentDescription createComposeDeploymentDescription, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getComposeDeploymentStatus" })
        @GET("ComposeDeployments/{deploymentName}")
        Observable<Response<ResponseBody>> getComposeDeploymentStatus(@Path(value = "deploymentName", encoded = true) String deploymentName, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getComposeDeploymentStatusList" })
        @GET("ComposeDeployments")
        Observable<Response<ResponseBody>> getComposeDeploymentStatusList(@Query("api-version") String apiVersion, @Query(value = "ContinuationToken", encoded = true) String continuationToken, @Query("MaxResults") Long maxResults, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getComposeDeploymentUpgradeProgress" })
        @GET("ComposeDeployments/{deploymentName}/$/GetUpgradeProgress")
        Observable<Response<ResponseBody>> getComposeDeploymentUpgradeProgress(@Path(value = "deploymentName", encoded = true) String deploymentName, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs removeComposeDeployment" })
        @POST("ComposeDeployments/{deploymentName}/$/Delete")
        Observable<Response<ResponseBody>> removeComposeDeployment(@Path(value = "deploymentName", encoded = true) String deploymentName, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs startComposeDeploymentUpgrade" })
        @POST("ComposeDeployments/{deploymentName}/$/Upgrade")
        Observable<Response<ResponseBody>> startComposeDeploymentUpgrade(@Path(value = "deploymentName", encoded = true) String deploymentName, @Query("api-version") String apiVersion, @Body ComposeDeploymentUpgradeDescription composeDeploymentUpgradeDescription, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getChaos" })
        @GET("Tools/Chaos")
        Observable<Response<ResponseBody>> getChaos(@Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs startChaos" })
        @POST("Tools/Chaos/$/Start")
        Observable<Response<ResponseBody>> startChaos(@Query("api-version") String apiVersion, @Body ChaosParameters chaosParameters, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs stopChaos" })
        @POST("Tools/Chaos/$/Stop")
        Observable<Response<ResponseBody>> stopChaos(@Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getChaosEvents" })
        @GET("Tools/Chaos/Events")
        Observable<Response<ResponseBody>> getChaosEvents(@Query("api-version") String apiVersion, @Query(value = "ContinuationToken", encoded = true) String continuationToken, @Query("StartTimeUtc") String startTimeUtc, @Query("EndTimeUtc") String endTimeUtc, @Query("MaxResults") Long maxResults, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getChaosSchedule" })
        @GET("Tools/Chaos/Schedule")
        Observable<Response<ResponseBody>> getChaosSchedule(@Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs postChaosSchedule" })
        @POST("Tools/Chaos/Schedule")
        Observable<Response<ResponseBody>> postChaosSchedule(@Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Body ChaosScheduleDescriptionInner chaosSchedule, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs uploadFile" })
        @PUT("ImageStore/{contentPath}")
        Observable<Response<ResponseBody>> uploadFile(@Path("contentPath") String contentPath, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getImageStoreContent" })
        @GET("ImageStore/{contentPath}")
        Observable<Response<ResponseBody>> getImageStoreContent(@Path("contentPath") String contentPath, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs deleteImageStoreContent" })
        @HTTP(path = "ImageStore/{contentPath}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteImageStoreContent(@Path("contentPath") String contentPath, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getImageStoreRootContent" })
        @GET("ImageStore")
        Observable<Response<ResponseBody>> getImageStoreRootContent(@Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs copyImageStoreContent" })
        @POST("ImageStore/$/Copy")
        Observable<Response<ResponseBody>> copyImageStoreContent(@Query("api-version") String apiVersion, @Body ImageStoreCopyDescription imageStoreCopyDescription, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs deleteImageStoreUploadSession" })
        @HTTP(path = "ImageStore/$/DeleteUploadSession", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteImageStoreUploadSession(@Query("api-version") String apiVersion, @Query("session-id") UUID sessionId, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs commitImageStoreUploadSession" })
        @POST("ImageStore/$/CommitUploadSession")
        Observable<Response<ResponseBody>> commitImageStoreUploadSession(@Query("api-version") String apiVersion, @Query("session-id") UUID sessionId, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getImageStoreUploadSessionById" })
        @GET("ImageStore/$/GetUploadSession")
        Observable<Response<ResponseBody>> getImageStoreUploadSessionById(@Query("api-version") String apiVersion, @Query("session-id") UUID sessionId, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getImageStoreUploadSessionByPath" })
        @GET("ImageStore/{contentPath}/$/GetUploadSession")
        Observable<Response<ResponseBody>> getImageStoreUploadSessionByPath(@Path("contentPath") String contentPath, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs uploadFileChunk" })
        @PUT("ImageStore/{contentPath}/$/UploadChunk")
        Observable<Response<ResponseBody>> uploadFileChunk(@Path("contentPath") String contentPath, @Query("api-version") String apiVersion, @Query("session-id") UUID sessionId, @Header("Content-Range") String contentRange, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs invokeInfrastructureCommand" })
        @POST("$/InvokeInfrastructureCommand")
        Observable<Response<ResponseBody>> invokeInfrastructureCommand(@Query("api-version") String apiVersion, @Query("Command") String command, @Query("ServiceId") String serviceId1, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs invokeInfrastructureQuery" })
        @GET("$/InvokeInfrastructureQuery")
        Observable<Response<ResponseBody>> invokeInfrastructureQuery(@Query("api-version") String apiVersion, @Query("Command") String command, @Query("ServiceId") String serviceId1, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs startDataLoss" })
        @POST("Faults/Services/{serviceId}/$/GetPartitions/{partitionId}/$/StartDataLoss")
        Observable<Response<ResponseBody>> startDataLoss(@Path(value = "serviceId", encoded = true) String serviceId, @Path(value = "partitionId", encoded = true) UUID partitionId1, @Query("api-version") String apiVersion, @Query("OperationId") UUID operationId, @Query("DataLossMode") DataLossMode dataLossMode1, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getDataLossProgress" })
        @GET("Faults/Services/{serviceId}/$/GetPartitions/{partitionId}/$/GetDataLossProgress")
        Observable<Response<ResponseBody>> getDataLossProgress(@Path(value = "serviceId", encoded = true) String serviceId, @Path(value = "partitionId", encoded = true) UUID partitionId1, @Query("api-version") String apiVersion, @Query("OperationId") UUID operationId, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs startQuorumLoss" })
        @POST("Faults/Services/{serviceId}/$/GetPartitions/{partitionId}/$/StartQuorumLoss")
        Observable<Response<ResponseBody>> startQuorumLoss(@Path(value = "serviceId", encoded = true) String serviceId, @Path(value = "partitionId", encoded = true) UUID partitionId1, @Query("api-version") String apiVersion, @Query("OperationId") UUID operationId, @Query("QuorumLossMode") QuorumLossMode quorumLossMode1, @Query("QuorumLossDuration") int quorumLossDuration, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getQuorumLossProgress" })
        @GET("Faults/Services/{serviceId}/$/GetPartitions/{partitionId}/$/GetQuorumLossProgress")
        Observable<Response<ResponseBody>> getQuorumLossProgress(@Path(value = "serviceId", encoded = true) String serviceId, @Path(value = "partitionId", encoded = true) UUID partitionId1, @Query("api-version") String apiVersion, @Query("OperationId") UUID operationId, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs startPartitionRestart" })
        @POST("Faults/Services/{serviceId}/$/GetPartitions/{partitionId}/$/StartRestart")
        Observable<Response<ResponseBody>> startPartitionRestart(@Path(value = "serviceId", encoded = true) String serviceId, @Path(value = "partitionId", encoded = true) UUID partitionId1, @Query("api-version") String apiVersion, @Query("OperationId") UUID operationId, @Query("RestartPartitionMode") RestartPartitionMode restartPartitionMode1, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getPartitionRestartProgress" })
        @GET("Faults/Services/{serviceId}/$/GetPartitions/{partitionId}/$/GetRestartProgress")
        Observable<Response<ResponseBody>> getPartitionRestartProgress(@Path(value = "serviceId", encoded = true) String serviceId, @Path(value = "partitionId", encoded = true) UUID partitionId1, @Query("api-version") String apiVersion, @Query("OperationId") UUID operationId, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs startNodeTransition" })
        @POST("Faults/Nodes/{nodeName}/$/StartTransition/")
        Observable<Response<ResponseBody>> startNodeTransition(@Path("nodeName") String nodeName, @Query("api-version") String apiVersion, @Query("OperationId") UUID operationId, @Query("NodeTransitionType") NodeTransitionType nodeTransitionType1, @Query("NodeInstanceId") String nodeInstanceId, @Query("StopDurationInSeconds") int stopDurationInSeconds, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getNodeTransitionProgress" })
        @GET("Faults/Nodes/{nodeName}/$/GetTransitionProgress")
        Observable<Response<ResponseBody>> getNodeTransitionProgress(@Path("nodeName") String nodeName, @Query("api-version") String apiVersion, @Query("OperationId") UUID operationId, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getFaultOperationList" })
        @GET("Faults/")
        Observable<Response<ResponseBody>> getFaultOperationList(@Query("api-version") String apiVersion, @Query("TypeFilter") int typeFilter, @Query("StateFilter") int stateFilter, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs cancelOperation" })
        @POST("Faults/$/Cancel")
        Observable<Response<ResponseBody>> cancelOperation(@Query("api-version") String apiVersion, @Query("OperationId") UUID operationId, @Query("Force") boolean force, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs createBackupPolicy" })
        @POST("BackupRestore/BackupPolicies/$/Create")
        Observable<Response<ResponseBody>> createBackupPolicy(@Body BackupPolicyDescriptionInner backupPolicyDescription, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs deleteBackupPolicy" })
        @POST("BackupRestore/BackupPolicies/{backupPolicyName}/$/Delete")
        Observable<Response<ResponseBody>> deleteBackupPolicy(@Path("backupPolicyName") String backupPolicyName, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getBackupPolicyList" })
        @GET("BackupRestore/BackupPolicies")
        Observable<Response<ResponseBody>> getBackupPolicyList(@Query("api-version") String apiVersion, @Query(value = "ContinuationToken", encoded = true) String continuationToken, @Query("MaxResults") Long maxResults, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getBackupPolicyByName" })
        @GET("BackupRestore/BackupPolicies/{backupPolicyName}")
        Observable<Response<ResponseBody>> getBackupPolicyByName(@Path("backupPolicyName") String backupPolicyName, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getAllEntitiesBackedUpByPolicy" })
        @GET("BackupRestore/BackupPolicies/{backupPolicyName}/$/GetBackupEnabledEntities")
        Observable<Response<ResponseBody>> getAllEntitiesBackedUpByPolicy(@Path("backupPolicyName") String backupPolicyName, @Query("api-version") String apiVersion, @Query(value = "ContinuationToken", encoded = true) String continuationToken, @Query("MaxResults") Long maxResults, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs updateBackupPolicy" })
        @POST("BackupRestore/BackupPolicies/{backupPolicyName}/$/Update")
        Observable<Response<ResponseBody>> updateBackupPolicy(@Path("backupPolicyName") String backupPolicyName, @Body BackupPolicyDescriptionInner backupPolicyDescription, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs enableApplicationBackup" })
        @POST("Applications/{applicationId}/$/EnableBackup")
        Observable<Response<ResponseBody>> enableApplicationBackup(@Path(value = "applicationId", encoded = true) String applicationId, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Body EnableBackupDescription enableBackupDescription, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs disableApplicationBackup" })
        @POST("Applications/{applicationId}/$/DisableBackup")
        Observable<Response<ResponseBody>> disableApplicationBackup(@Path(value = "applicationId", encoded = true) String applicationId, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getApplicationBackupConfigurationInfo" })
        @GET("Applications/{applicationId}/$/GetBackupConfigurationInfo")
        Observable<Response<ResponseBody>> getApplicationBackupConfigurationInfo(@Path(value = "applicationId", encoded = true) String applicationId, @Query("api-version") String apiVersion, @Query(value = "ContinuationToken", encoded = true) String continuationToken, @Query("MaxResults") Long maxResults, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getApplicationBackupList" })
        @GET("Applications/{applicationId}/$/GetBackups")
        Observable<Response<ResponseBody>> getApplicationBackupList(@Path(value = "applicationId", encoded = true) String applicationId, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Query("Latest") Boolean latest, @Query("StartDateTimeFilter") DateTime startDateTimeFilter, @Query("EndDateTimeFilter") DateTime endDateTimeFilter, @Query(value = "ContinuationToken", encoded = true) String continuationToken, @Query("MaxResults") Long maxResults, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs suspendApplicationBackup" })
        @POST("Applications/{applicationId}/$/SuspendBackup")
        Observable<Response<ResponseBody>> suspendApplicationBackup(@Path(value = "applicationId", encoded = true) String applicationId, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs resumeApplicationBackup" })
        @POST("Applications/{applicationId}/$/ResumeBackup")
        Observable<Response<ResponseBody>> resumeApplicationBackup(@Path(value = "applicationId", encoded = true) String applicationId, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs enableServiceBackup" })
        @POST("Services/{serviceId}/$/EnableBackup")
        Observable<Response<ResponseBody>> enableServiceBackup(@Path(value = "serviceId", encoded = true) String serviceId, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Body EnableBackupDescription enableBackupDescription, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs disableServiceBackup" })
        @POST("Services/{serviceId}/$/DisableBackup")
        Observable<Response<ResponseBody>> disableServiceBackup(@Path(value = "serviceId", encoded = true) String serviceId, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getServiceBackupConfigurationInfo" })
        @GET("Services/{serviceId}/$/GetBackupConfigurationInfo")
        Observable<Response<ResponseBody>> getServiceBackupConfigurationInfo(@Path(value = "serviceId", encoded = true) String serviceId, @Query("api-version") String apiVersion, @Query(value = "ContinuationToken", encoded = true) String continuationToken, @Query("MaxResults") Long maxResults, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getServiceBackupList" })
        @GET("Services/{serviceId}/$/GetBackups")
        Observable<Response<ResponseBody>> getServiceBackupList(@Path(value = "serviceId", encoded = true) String serviceId, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Query("Latest") Boolean latest, @Query("StartDateTimeFilter") DateTime startDateTimeFilter, @Query("EndDateTimeFilter") DateTime endDateTimeFilter, @Query(value = "ContinuationToken", encoded = true) String continuationToken, @Query("MaxResults") Long maxResults, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs suspendServiceBackup" })
        @POST("Services/{serviceId}/$/SuspendBackup")
        Observable<Response<ResponseBody>> suspendServiceBackup(@Path(value = "serviceId", encoded = true) String serviceId, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs resumeServiceBackup" })
        @POST("Services/{serviceId}/$/ResumeBackup")
        Observable<Response<ResponseBody>> resumeServiceBackup(@Path(value = "serviceId", encoded = true) String serviceId, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs enablePartitionBackup" })
        @POST("Partitions/{partitionId}/$/EnableBackup")
        Observable<Response<ResponseBody>> enablePartitionBackup(@Path(value = "partitionId", encoded = true) UUID partitionId1, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Body EnableBackupDescription enableBackupDescription, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs disablePartitionBackup" })
        @POST("Partitions/{partitionId}/$/DisableBackup")
        Observable<Response<ResponseBody>> disablePartitionBackup(@Path(value = "partitionId", encoded = true) UUID partitionId1, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getPartitionBackupConfigurationInfo" })
        @GET("Partitions/{partitionId}/$/GetBackupConfigurationInfo")
        Observable<Response<ResponseBody>> getPartitionBackupConfigurationInfo(@Path(value = "partitionId", encoded = true) UUID partitionId1, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getPartitionBackupList" })
        @GET("Partitions/{partitionId}/$/GetBackups")
        Observable<Response<ResponseBody>> getPartitionBackupList(@Path(value = "partitionId", encoded = true) UUID partitionId1, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Query("Latest") Boolean latest, @Query("StartDateTimeFilter") DateTime startDateTimeFilter, @Query("EndDateTimeFilter") DateTime endDateTimeFilter, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs suspendPartitionBackup" })
        @POST("Partitions/{partitionId}/$/SuspendBackup")
        Observable<Response<ResponseBody>> suspendPartitionBackup(@Path(value = "partitionId", encoded = true) UUID partitionId1, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs resumePartitionBackup" })
        @POST("Partitions/{partitionId}/$/ResumeBackup")
        Observable<Response<ResponseBody>> resumePartitionBackup(@Path(value = "partitionId", encoded = true) UUID partitionId1, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs backupPartition" })
        @POST("Partitions/{partitionId}/$/Backup")
        Observable<Response<ResponseBody>> backupPartition(@Path(value = "partitionId", encoded = true) UUID partitionId1, @Query("BackupTimeout") Integer backupTimeout, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Body BackupPartitionDescription backupPartitionDescription, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getPartitionBackupProgress" })
        @GET("Partitions/{partitionId}/$/GetBackupProgress")
        Observable<Response<ResponseBody>> getPartitionBackupProgress(@Path(value = "partitionId", encoded = true) UUID partitionId1, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs restorePartition" })
        @POST("Partitions/{partitionId}/$/Restore")
        Observable<Response<ResponseBody>> restorePartition(@Path(value = "partitionId", encoded = true) UUID partitionId1, @Body RestorePartitionDescription restorePartitionDescription, @Query("RestoreTimeout") Integer restoreTimeout, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getPartitionRestoreProgress" })
        @GET("Partitions/{partitionId}/$/GetRestoreProgress")
        Observable<Response<ResponseBody>> getPartitionRestoreProgress(@Path(value = "partitionId", encoded = true) UUID partitionId1, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getBackupsFromBackupLocation" })
        @POST("BackupRestore/$/GetBackups")
        Observable<Response<ResponseBody>> getBackupsFromBackupLocation(@Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Query(value = "ContinuationToken", encoded = true) String continuationToken, @Query("MaxResults") Long maxResults, @Body GetBackupByStorageQueryDescription getBackupByStorageQueryDescription, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs createName" })
        @POST("Names/$/Create")
        Observable<Response<ResponseBody>> createName(@Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Body NameDescription nameDescription, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getNameExistsInfo" })
        @GET("Names/{nameId}")
        Observable<Response<ResponseBody>> getNameExistsInfo(@Path(value = "nameId", encoded = true) String nameId, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs deleteName" })
        @HTTP(path = "Names/{nameId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteName(@Path(value = "nameId", encoded = true) String nameId, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getSubNameInfoList" })
        @GET("Names/{nameId}/$/GetSubNames")
        Observable<Response<ResponseBody>> getSubNameInfoList(@Path(value = "nameId", encoded = true) String nameId, @Query("api-version") String apiVersion, @Query("Recursive") Boolean recursive, @Query(value = "ContinuationToken", encoded = true) String continuationToken, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getPropertyInfoList" })
        @GET("Names/{nameId}/$/GetProperties")
        Observable<Response<ResponseBody>> getPropertyInfoList(@Path(value = "nameId", encoded = true) String nameId, @Query("api-version") String apiVersion, @Query("IncludeValues") Boolean includeValues, @Query(value = "ContinuationToken", encoded = true) String continuationToken, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs putProperty" })
        @PUT("Names/{nameId}/$/GetProperty")
        Observable<Response<ResponseBody>> putProperty(@Path(value = "nameId", encoded = true) String nameId, @Query("api-version") String apiVersion, @Body PropertyDescription propertyDescription, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getPropertyInfo" })
        @GET("Names/{nameId}/$/GetProperty")
        Observable<Response<ResponseBody>> getPropertyInfo(@Path(value = "nameId", encoded = true) String nameId, @Query("api-version") String apiVersion, @Query("PropertyName") String propertyName, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs deleteProperty" })
        @HTTP(path = "Names/{nameId}/$/GetProperty", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteProperty(@Path(value = "nameId", encoded = true) String nameId, @Query("api-version") String apiVersion, @Query("PropertyName") String propertyName, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs submitPropertyBatch" })
        @POST("Names/{nameId}/$/GetProperties/$/SubmitBatch")
        Observable<Response<ResponseBody>> submitPropertyBatch(@Path(value = "nameId", encoded = true) String nameId, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Body PropertyBatchDescriptionList propertyBatchDescriptionList, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getClusterEventList" })
        @GET("EventsStore/Cluster/Events")
        Observable<Response<ResponseBody>> getClusterEventList(@Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Query("StartTimeUtc") String startTimeUtc, @Query("EndTimeUtc") String endTimeUtc, @Query("EventsTypesFilter") String eventsTypesFilter, @Query("ExcludeAnalysisEvents") Boolean excludeAnalysisEvents, @Query("SkipCorrelationLookup") Boolean skipCorrelationLookup, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getContainersEventList" })
        @GET("EventsStore/Containers/Events")
        Observable<Response<ResponseBody>> getContainersEventList(@Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Query("StartTimeUtc") String startTimeUtc, @Query("EndTimeUtc") String endTimeUtc, @Query("EventsTypesFilter") String eventsTypesFilter, @Query("ExcludeAnalysisEvents") Boolean excludeAnalysisEvents, @Query("SkipCorrelationLookup") Boolean skipCorrelationLookup, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getNodeEventList" })
        @GET("EventsStore/Nodes/{nodeName}/$/Events")
        Observable<Response<ResponseBody>> getNodeEventList(@Path("nodeName") String nodeName, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Query("StartTimeUtc") String startTimeUtc, @Query("EndTimeUtc") String endTimeUtc, @Query("EventsTypesFilter") String eventsTypesFilter, @Query("ExcludeAnalysisEvents") Boolean excludeAnalysisEvents, @Query("SkipCorrelationLookup") Boolean skipCorrelationLookup, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getNodesEventList" })
        @GET("EventsStore/Nodes/Events")
        Observable<Response<ResponseBody>> getNodesEventList(@Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Query("StartTimeUtc") String startTimeUtc, @Query("EndTimeUtc") String endTimeUtc, @Query("EventsTypesFilter") String eventsTypesFilter, @Query("ExcludeAnalysisEvents") Boolean excludeAnalysisEvents, @Query("SkipCorrelationLookup") Boolean skipCorrelationLookup, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getApplicationEventList" })
        @GET("EventsStore/Applications/{applicationId}/$/Events")
        Observable<Response<ResponseBody>> getApplicationEventList(@Path(value = "applicationId", encoded = true) String applicationId, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Query("StartTimeUtc") String startTimeUtc, @Query("EndTimeUtc") String endTimeUtc, @Query("EventsTypesFilter") String eventsTypesFilter, @Query("ExcludeAnalysisEvents") Boolean excludeAnalysisEvents, @Query("SkipCorrelationLookup") Boolean skipCorrelationLookup, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getApplicationsEventList" })
        @GET("EventsStore/Applications/Events")
        Observable<Response<ResponseBody>> getApplicationsEventList(@Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Query("StartTimeUtc") String startTimeUtc, @Query("EndTimeUtc") String endTimeUtc, @Query("EventsTypesFilter") String eventsTypesFilter, @Query("ExcludeAnalysisEvents") Boolean excludeAnalysisEvents, @Query("SkipCorrelationLookup") Boolean skipCorrelationLookup, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getServiceEventList" })
        @GET("EventsStore/Services/{serviceId}/$/Events")
        Observable<Response<ResponseBody>> getServiceEventList(@Path(value = "serviceId", encoded = true) String serviceId, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Query("StartTimeUtc") String startTimeUtc, @Query("EndTimeUtc") String endTimeUtc, @Query("EventsTypesFilter") String eventsTypesFilter, @Query("ExcludeAnalysisEvents") Boolean excludeAnalysisEvents, @Query("SkipCorrelationLookup") Boolean skipCorrelationLookup, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getServicesEventList" })
        @GET("EventsStore/Services/Events")
        Observable<Response<ResponseBody>> getServicesEventList(@Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Query("StartTimeUtc") String startTimeUtc, @Query("EndTimeUtc") String endTimeUtc, @Query("EventsTypesFilter") String eventsTypesFilter, @Query("ExcludeAnalysisEvents") Boolean excludeAnalysisEvents, @Query("SkipCorrelationLookup") Boolean skipCorrelationLookup, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getPartitionEventList" })
        @GET("EventsStore/Partitions/{partitionId}/$/Events")
        Observable<Response<ResponseBody>> getPartitionEventList(@Path(value = "partitionId", encoded = true) UUID partitionId1, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Query("StartTimeUtc") String startTimeUtc, @Query("EndTimeUtc") String endTimeUtc, @Query("EventsTypesFilter") String eventsTypesFilter, @Query("ExcludeAnalysisEvents") Boolean excludeAnalysisEvents, @Query("SkipCorrelationLookup") Boolean skipCorrelationLookup, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getPartitionsEventList" })
        @GET("EventsStore/Partitions/Events")
        Observable<Response<ResponseBody>> getPartitionsEventList(@Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Query("StartTimeUtc") String startTimeUtc, @Query("EndTimeUtc") String endTimeUtc, @Query("EventsTypesFilter") String eventsTypesFilter, @Query("ExcludeAnalysisEvents") Boolean excludeAnalysisEvents, @Query("SkipCorrelationLookup") Boolean skipCorrelationLookup, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getPartitionReplicaEventList" })
        @GET("EventsStore/Partitions/{partitionId}/$/Replicas/{replicaId}/$/Events")
        Observable<Response<ResponseBody>> getPartitionReplicaEventList(@Path(value = "partitionId", encoded = true) UUID partitionId1, @Path(value = "replicaId", encoded = true) String replicaId, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Query("StartTimeUtc") String startTimeUtc, @Query("EndTimeUtc") String endTimeUtc, @Query("EventsTypesFilter") String eventsTypesFilter, @Query("ExcludeAnalysisEvents") Boolean excludeAnalysisEvents, @Query("SkipCorrelationLookup") Boolean skipCorrelationLookup, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getPartitionReplicasEventList" })
        @GET("EventsStore/Partitions/{partitionId}/$/Replicas/Events")
        Observable<Response<ResponseBody>> getPartitionReplicasEventList(@Path(value = "partitionId", encoded = true) UUID partitionId1, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Query("StartTimeUtc") String startTimeUtc, @Query("EndTimeUtc") String endTimeUtc, @Query("EventsTypesFilter") String eventsTypesFilter, @Query("ExcludeAnalysisEvents") Boolean excludeAnalysisEvents, @Query("SkipCorrelationLookup") Boolean skipCorrelationLookup, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getCorrelatedEventList" })
        @GET("EventsStore/CorrelatedEvents/{eventInstanceId}/$/Events")
        Observable<Response<ResponseBody>> getCorrelatedEventList(@Path("eventInstanceId") String eventInstanceId, @Query("api-version") String apiVersion, @Query("timeout") Long timeout, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs createApplicationResource" })
        @PUT("Resources/Applications/{applicationResourceName}")
        Observable<Response<ResponseBody>> createApplicationResource(@Path(value = "applicationResourceName", encoded = true) String applicationResourceName, @Query("api-version") String apiVersion, @Body ApplicationResourceDescriptionInner applicationResourceDescription, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getApplicationResource" })
        @GET("Resources/Applications/{applicationResourceName}")
        Observable<Response<ResponseBody>> getApplicationResource(@Path(value = "applicationResourceName", encoded = true) String applicationResourceName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs deleteApplicationResource" })
        @HTTP(path = "Resources/Applications/{applicationResourceName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteApplicationResource(@Path(value = "applicationResourceName", encoded = true) String applicationResourceName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getServices" })
        @GET("Resources/Applications/{applicationResourceName}/Services")
        Observable<Response<ResponseBody>> getServices(@Path(value = "applicationResourceName", encoded = true) String applicationResourceName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getService" })
        @GET("Resources/Applications/{applicationResourceName}/Services/{serviceResourceName}")
        Observable<Response<ResponseBody>> getService(@Path(value = "applicationResourceName", encoded = true) String applicationResourceName, @Path(value = "serviceResourceName", encoded = true) String serviceResourceName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getReplicas" })
        @GET("Resources/Applications/{applicationResourceName}/Services/{serviceResourceName}/replicas")
        Observable<Response<ResponseBody>> getReplicas(@Path(value = "applicationResourceName", encoded = true) String applicationResourceName, @Path(value = "serviceResourceName", encoded = true) String serviceResourceName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getReplica" })
        @GET("Resources/Applications/{applicationResourceName}/Services/{serviceResourceName}/Replicas/{replicaName}")
        Observable<Response<ResponseBody>> getReplica(@Path(value = "applicationResourceName", encoded = true) String applicationResourceName, @Path(value = "serviceResourceName", encoded = true) String serviceResourceName, @Path(value = "replicaName", encoded = true) String replicaName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs createVolumeResource" })
        @PUT("Resources/Volumes/{volumeResourceName}")
        Observable<Response<ResponseBody>> createVolumeResource(@Path(value = "volumeResourceName", encoded = true) String volumeResourceName, @Query("api-version") String apiVersion, @Body VolumeResourceDescriptionInner volumeResourceDescription, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs getVolumeResource" })
        @GET("Resources/Volumes/{volumeResourceName}")
        Observable<Response<ResponseBody>> getVolumeResource(@Path(value = "volumeResourceName", encoded = true) String volumeResourceName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.servicefabric.ServiceFabricClientAPIs deleteVolumeResource" })
        @HTTP(path = "Resources/Volumes/{volumeResourceName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteVolumeResource(@Path(value = "volumeResourceName", encoded = true) String volumeResourceName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

    }

    /**
     * Get the Service Fabric cluster manifest.
     * Get the Service Fabric cluster manifest. The cluster manifest contains properties of the cluster that include different node types on the cluster,
     security configurations, fault, and upgrade domain topologies, etc.
     These properties are specified as part of the ClusterConfig.JSON file while deploying a stand-alone cluster. However, most of the information in the cluster manifest
     is generated internally by service fabric during cluster deployment in other deployment scenarios (e.g. when using Azure portal).
     The contents of the cluster manifest are for informational purposes only and users are not expected to take a dependency on the format of the file contents or its interpretation.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ClusterManifestInner object if successful.
     */
    public ClusterManifestInner getClusterManifest() {
        return getClusterManifestWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get the Service Fabric cluster manifest.
     * Get the Service Fabric cluster manifest. The cluster manifest contains properties of the cluster that include different node types on the cluster,
     security configurations, fault, and upgrade domain topologies, etc.
     These properties are specified as part of the ClusterConfig.JSON file while deploying a stand-alone cluster. However, most of the information in the cluster manifest
     is generated internally by service fabric during cluster deployment in other deployment scenarios (e.g. when using Azure portal).
     The contents of the cluster manifest are for informational purposes only and users are not expected to take a dependency on the format of the file contents or its interpretation.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ClusterManifestInner> getClusterManifestAsync(final ServiceCallback<ClusterManifestInner> serviceCallback) {
        return ServiceFuture.fromResponse(getClusterManifestWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get the Service Fabric cluster manifest.
     * Get the Service Fabric cluster manifest. The cluster manifest contains properties of the cluster that include different node types on the cluster,
     security configurations, fault, and upgrade domain topologies, etc.
     These properties are specified as part of the ClusterConfig.JSON file while deploying a stand-alone cluster. However, most of the information in the cluster manifest
     is generated internally by service fabric during cluster deployment in other deployment scenarios (e.g. when using Azure portal).
     The contents of the cluster manifest are for informational purposes only and users are not expected to take a dependency on the format of the file contents or its interpretation.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ClusterManifestInner object
     */
    public Observable<ClusterManifestInner> getClusterManifestAsync() {
        return getClusterManifestWithServiceResponseAsync().map(new Func1<ServiceResponse<ClusterManifestInner>, ClusterManifestInner>() {
            @Override
            public ClusterManifestInner call(ServiceResponse<ClusterManifestInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get the Service Fabric cluster manifest.
     * Get the Service Fabric cluster manifest. The cluster manifest contains properties of the cluster that include different node types on the cluster,
     security configurations, fault, and upgrade domain topologies, etc.
     These properties are specified as part of the ClusterConfig.JSON file while deploying a stand-alone cluster. However, most of the information in the cluster manifest
     is generated internally by service fabric during cluster deployment in other deployment scenarios (e.g. when using Azure portal).
     The contents of the cluster manifest are for informational purposes only and users are not expected to take a dependency on the format of the file contents or its interpretation.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ClusterManifestInner object
     */
    public Observable<ServiceResponse<ClusterManifestInner>> getClusterManifestWithServiceResponseAsync() {
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.getClusterManifest(apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ClusterManifestInner>>>() {
                @Override
                public Observable<ServiceResponse<ClusterManifestInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ClusterManifestInner> clientResponse = getClusterManifestDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get the Service Fabric cluster manifest.
     * Get the Service Fabric cluster manifest. The cluster manifest contains properties of the cluster that include different node types on the cluster,
     security configurations, fault, and upgrade domain topologies, etc.
     These properties are specified as part of the ClusterConfig.JSON file while deploying a stand-alone cluster. However, most of the information in the cluster manifest
     is generated internally by service fabric during cluster deployment in other deployment scenarios (e.g. when using Azure portal).
     The contents of the cluster manifest are for informational purposes only and users are not expected to take a dependency on the format of the file contents or its interpretation.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ClusterManifestInner object if successful.
     */
    public ClusterManifestInner getClusterManifest(Long timeout) {
        return getClusterManifestWithServiceResponseAsync(timeout).toBlocking().single().body();
    }

    /**
     * Get the Service Fabric cluster manifest.
     * Get the Service Fabric cluster manifest. The cluster manifest contains properties of the cluster that include different node types on the cluster,
     security configurations, fault, and upgrade domain topologies, etc.
     These properties are specified as part of the ClusterConfig.JSON file while deploying a stand-alone cluster. However, most of the information in the cluster manifest
     is generated internally by service fabric during cluster deployment in other deployment scenarios (e.g. when using Azure portal).
     The contents of the cluster manifest are for informational purposes only and users are not expected to take a dependency on the format of the file contents or its interpretation.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ClusterManifestInner> getClusterManifestAsync(Long timeout, final ServiceCallback<ClusterManifestInner> serviceCallback) {
        return ServiceFuture.fromResponse(getClusterManifestWithServiceResponseAsync(timeout), serviceCallback);
    }

    /**
     * Get the Service Fabric cluster manifest.
     * Get the Service Fabric cluster manifest. The cluster manifest contains properties of the cluster that include different node types on the cluster,
     security configurations, fault, and upgrade domain topologies, etc.
     These properties are specified as part of the ClusterConfig.JSON file while deploying a stand-alone cluster. However, most of the information in the cluster manifest
     is generated internally by service fabric during cluster deployment in other deployment scenarios (e.g. when using Azure portal).
     The contents of the cluster manifest are for informational purposes only and users are not expected to take a dependency on the format of the file contents or its interpretation.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ClusterManifestInner object
     */
    public Observable<ClusterManifestInner> getClusterManifestAsync(Long timeout) {
        return getClusterManifestWithServiceResponseAsync(timeout).map(new Func1<ServiceResponse<ClusterManifestInner>, ClusterManifestInner>() {
            @Override
            public ClusterManifestInner call(ServiceResponse<ClusterManifestInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get the Service Fabric cluster manifest.
     * Get the Service Fabric cluster manifest. The cluster manifest contains properties of the cluster that include different node types on the cluster,
     security configurations, fault, and upgrade domain topologies, etc.
     These properties are specified as part of the ClusterConfig.JSON file while deploying a stand-alone cluster. However, most of the information in the cluster manifest
     is generated internally by service fabric during cluster deployment in other deployment scenarios (e.g. when using Azure portal).
     The contents of the cluster manifest are for informational purposes only and users are not expected to take a dependency on the format of the file contents or its interpretation.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ClusterManifestInner object
     */
    public Observable<ServiceResponse<ClusterManifestInner>> getClusterManifestWithServiceResponseAsync(Long timeout) {
        final String apiVersion = "6.0";
        return service.getClusterManifest(apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ClusterManifestInner>>>() {
                @Override
                public Observable<ServiceResponse<ClusterManifestInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ClusterManifestInner> clientResponse = getClusterManifestDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ClusterManifestInner> getClusterManifestDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException {
        return this.restClient().responseBuilderFactory().<ClusterManifestInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ClusterManifestInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the health of a Service Fabric cluster.
     * Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.
     Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to filter the collection of nodes and applications returned based on their aggregated health state.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ClusterHealthInner object if successful.
     */
    public ClusterHealthInner getClusterHealth() {
        return getClusterHealthWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets the health of a Service Fabric cluster.
     * Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.
     Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to filter the collection of nodes and applications returned based on their aggregated health state.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ClusterHealthInner> getClusterHealthAsync(final ServiceCallback<ClusterHealthInner> serviceCallback) {
        return ServiceFuture.fromResponse(getClusterHealthWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets the health of a Service Fabric cluster.
     * Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.
     Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to filter the collection of nodes and applications returned based on their aggregated health state.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ClusterHealthInner object
     */
    public Observable<ClusterHealthInner> getClusterHealthAsync() {
        return getClusterHealthWithServiceResponseAsync().map(new Func1<ServiceResponse<ClusterHealthInner>, ClusterHealthInner>() {
            @Override
            public ClusterHealthInner call(ServiceResponse<ClusterHealthInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the health of a Service Fabric cluster.
     * Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.
     Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to filter the collection of nodes and applications returned based on their aggregated health state.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ClusterHealthInner object
     */
    public Observable<ServiceResponse<ClusterHealthInner>> getClusterHealthWithServiceResponseAsync() {
        final String apiVersion = "6.0";
        final Integer nodesHealthStateFilter = null;
        final Integer applicationsHealthStateFilter = null;
        final Integer eventsHealthStateFilter = null;
        final Boolean excludeHealthStatistics = null;
        final Boolean includeSystemApplicationHealthStatistics = null;
        final Long timeout = null;
        return service.getClusterHealth(apiVersion, nodesHealthStateFilter, applicationsHealthStateFilter, eventsHealthStateFilter, excludeHealthStatistics, includeSystemApplicationHealthStatistics, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ClusterHealthInner>>>() {
                @Override
                public Observable<ServiceResponse<ClusterHealthInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ClusterHealthInner> clientResponse = getClusterHealthDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the health of a Service Fabric cluster.
     * Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.
     Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to filter the collection of nodes and applications returned based on their aggregated health state.
     *
     * @param nodesHealthStateFilter Allows filtering of the node health state objects returned in the result of cluster health query
     based on their health state. The possible values for this parameter include integer value of one of the
     following health states. Only nodes that match the filter are returned. All nodes are used to evaluate the aggregated health state.
     If not specified, all entries are returned.
     The state values are flag-based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.
     For example, if the provided value is 6 then health state of nodes with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param applicationsHealthStateFilter Allows filtering of the application health state objects returned in the result of cluster health
     query based on their health state.
     The possible values for this parameter include integer value obtained from members or bitwise operations
     on members of HealthStateFilter enumeration. Only applications that match the filter are returned.
     All applications are used to evaluate the aggregated health state. If not specified, all entries are returned.
     The state values are flag-based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.
     For example, if the provided value is 6 then health state of applications with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param excludeHealthStatistics Indicates whether the health statistics should be returned as part of the query result. False by default.
     The statistics show the number of children entities in health state Ok, Warning, and Error.
     * @param includeSystemApplicationHealthStatistics Indicates whether the health statistics should include the fabric:/System application health statistics. False by default.
     If IncludeSystemApplicationHealthStatistics is set to true, the health statistics include the entities that belong to the fabric:/System application.
     Otherwise, the query result includes health statistics only for user applications.
     The health statistics must be included in the query result for this parameter to be applied.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ClusterHealthInner object if successful.
     */
    public ClusterHealthInner getClusterHealth(Integer nodesHealthStateFilter, Integer applicationsHealthStateFilter, Integer eventsHealthStateFilter, Boolean excludeHealthStatistics, Boolean includeSystemApplicationHealthStatistics, Long timeout) {
        return getClusterHealthWithServiceResponseAsync(nodesHealthStateFilter, applicationsHealthStateFilter, eventsHealthStateFilter, excludeHealthStatistics, includeSystemApplicationHealthStatistics, timeout).toBlocking().single().body();
    }

    /**
     * Gets the health of a Service Fabric cluster.
     * Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.
     Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to filter the collection of nodes and applications returned based on their aggregated health state.
     *
     * @param nodesHealthStateFilter Allows filtering of the node health state objects returned in the result of cluster health query
     based on their health state. The possible values for this parameter include integer value of one of the
     following health states. Only nodes that match the filter are returned. All nodes are used to evaluate the aggregated health state.
     If not specified, all entries are returned.
     The state values are flag-based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.
     For example, if the provided value is 6 then health state of nodes with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param applicationsHealthStateFilter Allows filtering of the application health state objects returned in the result of cluster health
     query based on their health state.
     The possible values for this parameter include integer value obtained from members or bitwise operations
     on members of HealthStateFilter enumeration. Only applications that match the filter are returned.
     All applications are used to evaluate the aggregated health state. If not specified, all entries are returned.
     The state values are flag-based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.
     For example, if the provided value is 6 then health state of applications with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param excludeHealthStatistics Indicates whether the health statistics should be returned as part of the query result. False by default.
     The statistics show the number of children entities in health state Ok, Warning, and Error.
     * @param includeSystemApplicationHealthStatistics Indicates whether the health statistics should include the fabric:/System application health statistics. False by default.
     If IncludeSystemApplicationHealthStatistics is set to true, the health statistics include the entities that belong to the fabric:/System application.
     Otherwise, the query result includes health statistics only for user applications.
     The health statistics must be included in the query result for this parameter to be applied.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ClusterHealthInner> getClusterHealthAsync(Integer nodesHealthStateFilter, Integer applicationsHealthStateFilter, Integer eventsHealthStateFilter, Boolean excludeHealthStatistics, Boolean includeSystemApplicationHealthStatistics, Long timeout, final ServiceCallback<ClusterHealthInner> serviceCallback) {
        return ServiceFuture.fromResponse(getClusterHealthWithServiceResponseAsync(nodesHealthStateFilter, applicationsHealthStateFilter, eventsHealthStateFilter, excludeHealthStatistics, includeSystemApplicationHealthStatistics, timeout), serviceCallback);
    }

    /**
     * Gets the health of a Service Fabric cluster.
     * Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.
     Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to filter the collection of nodes and applications returned based on their aggregated health state.
     *
     * @param nodesHealthStateFilter Allows filtering of the node health state objects returned in the result of cluster health query
     based on their health state. The possible values for this parameter include integer value of one of the
     following health states. Only nodes that match the filter are returned. All nodes are used to evaluate the aggregated health state.
     If not specified, all entries are returned.
     The state values are flag-based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.
     For example, if the provided value is 6 then health state of nodes with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param applicationsHealthStateFilter Allows filtering of the application health state objects returned in the result of cluster health
     query based on their health state.
     The possible values for this parameter include integer value obtained from members or bitwise operations
     on members of HealthStateFilter enumeration. Only applications that match the filter are returned.
     All applications are used to evaluate the aggregated health state. If not specified, all entries are returned.
     The state values are flag-based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.
     For example, if the provided value is 6 then health state of applications with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param excludeHealthStatistics Indicates whether the health statistics should be returned as part of the query result. False by default.
     The statistics show the number of children entities in health state Ok, Warning, and Error.
     * @param includeSystemApplicationHealthStatistics Indicates whether the health statistics should include the fabric:/System application health statistics. False by default.
     If IncludeSystemApplicationHealthStatistics is set to true, the health statistics include the entities that belong to the fabric:/System application.
     Otherwise, the query result includes health statistics only for user applications.
     The health statistics must be included in the query result for this parameter to be applied.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ClusterHealthInner object
     */
    public Observable<ClusterHealthInner> getClusterHealthAsync(Integer nodesHealthStateFilter, Integer applicationsHealthStateFilter, Integer eventsHealthStateFilter, Boolean excludeHealthStatistics, Boolean includeSystemApplicationHealthStatistics, Long timeout) {
        return getClusterHealthWithServiceResponseAsync(nodesHealthStateFilter, applicationsHealthStateFilter, eventsHealthStateFilter, excludeHealthStatistics, includeSystemApplicationHealthStatistics, timeout).map(new Func1<ServiceResponse<ClusterHealthInner>, ClusterHealthInner>() {
            @Override
            public ClusterHealthInner call(ServiceResponse<ClusterHealthInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the health of a Service Fabric cluster.
     * Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.
     Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to filter the collection of nodes and applications returned based on their aggregated health state.
     *
     * @param nodesHealthStateFilter Allows filtering of the node health state objects returned in the result of cluster health query
     based on their health state. The possible values for this parameter include integer value of one of the
     following health states. Only nodes that match the filter are returned. All nodes are used to evaluate the aggregated health state.
     If not specified, all entries are returned.
     The state values are flag-based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.
     For example, if the provided value is 6 then health state of nodes with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param applicationsHealthStateFilter Allows filtering of the application health state objects returned in the result of cluster health
     query based on their health state.
     The possible values for this parameter include integer value obtained from members or bitwise operations
     on members of HealthStateFilter enumeration. Only applications that match the filter are returned.
     All applications are used to evaluate the aggregated health state. If not specified, all entries are returned.
     The state values are flag-based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.
     For example, if the provided value is 6 then health state of applications with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param excludeHealthStatistics Indicates whether the health statistics should be returned as part of the query result. False by default.
     The statistics show the number of children entities in health state Ok, Warning, and Error.
     * @param includeSystemApplicationHealthStatistics Indicates whether the health statistics should include the fabric:/System application health statistics. False by default.
     If IncludeSystemApplicationHealthStatistics is set to true, the health statistics include the entities that belong to the fabric:/System application.
     Otherwise, the query result includes health statistics only for user applications.
     The health statistics must be included in the query result for this parameter to be applied.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ClusterHealthInner object
     */
    public Observable<ServiceResponse<ClusterHealthInner>> getClusterHealthWithServiceResponseAsync(Integer nodesHealthStateFilter, Integer applicationsHealthStateFilter, Integer eventsHealthStateFilter, Boolean excludeHealthStatistics, Boolean includeSystemApplicationHealthStatistics, Long timeout) {
        final String apiVersion = "6.0";
        return service.getClusterHealth(apiVersion, nodesHealthStateFilter, applicationsHealthStateFilter, eventsHealthStateFilter, excludeHealthStatistics, includeSystemApplicationHealthStatistics, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ClusterHealthInner>>>() {
                @Override
                public Observable<ServiceResponse<ClusterHealthInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ClusterHealthInner> clientResponse = getClusterHealthDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ClusterHealthInner> getClusterHealthDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException {
        return this.restClient().responseBuilderFactory().<ClusterHealthInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ClusterHealthInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the health of a Service Fabric cluster using the specified policy.
     * Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.
     Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to filter the collection of nodes and applications returned based on their aggregated health state.
     Use ClusterHealthPolicies to override the health policies used to evaluate the health.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ClusterHealthInner object if successful.
     */
    public ClusterHealthInner getClusterHealthUsingPolicy() {
        return getClusterHealthUsingPolicyWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets the health of a Service Fabric cluster using the specified policy.
     * Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.
     Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to filter the collection of nodes and applications returned based on their aggregated health state.
     Use ClusterHealthPolicies to override the health policies used to evaluate the health.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ClusterHealthInner> getClusterHealthUsingPolicyAsync(final ServiceCallback<ClusterHealthInner> serviceCallback) {
        return ServiceFuture.fromResponse(getClusterHealthUsingPolicyWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets the health of a Service Fabric cluster using the specified policy.
     * Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.
     Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to filter the collection of nodes and applications returned based on their aggregated health state.
     Use ClusterHealthPolicies to override the health policies used to evaluate the health.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ClusterHealthInner object
     */
    public Observable<ClusterHealthInner> getClusterHealthUsingPolicyAsync() {
        return getClusterHealthUsingPolicyWithServiceResponseAsync().map(new Func1<ServiceResponse<ClusterHealthInner>, ClusterHealthInner>() {
            @Override
            public ClusterHealthInner call(ServiceResponse<ClusterHealthInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the health of a Service Fabric cluster using the specified policy.
     * Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.
     Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to filter the collection of nodes and applications returned based on their aggregated health state.
     Use ClusterHealthPolicies to override the health policies used to evaluate the health.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ClusterHealthInner object
     */
    public Observable<ServiceResponse<ClusterHealthInner>> getClusterHealthUsingPolicyWithServiceResponseAsync() {
        final String apiVersion = "6.0";
        final Integer nodesHealthStateFilter = null;
        final Integer applicationsHealthStateFilter = null;
        final Integer eventsHealthStateFilter = null;
        final Boolean excludeHealthStatistics = null;
        final Boolean includeSystemApplicationHealthStatistics = null;
        final ClusterHealthPolicies clusterHealthPolicies = null;
        final Long timeout = null;
        return service.getClusterHealthUsingPolicy(apiVersion, nodesHealthStateFilter, applicationsHealthStateFilter, eventsHealthStateFilter, excludeHealthStatistics, includeSystemApplicationHealthStatistics, clusterHealthPolicies, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ClusterHealthInner>>>() {
                @Override
                public Observable<ServiceResponse<ClusterHealthInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ClusterHealthInner> clientResponse = getClusterHealthUsingPolicyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the health of a Service Fabric cluster using the specified policy.
     * Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.
     Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to filter the collection of nodes and applications returned based on their aggregated health state.
     Use ClusterHealthPolicies to override the health policies used to evaluate the health.
     *
     * @param nodesHealthStateFilter Allows filtering of the node health state objects returned in the result of cluster health query
     based on their health state. The possible values for this parameter include integer value of one of the
     following health states. Only nodes that match the filter are returned. All nodes are used to evaluate the aggregated health state.
     If not specified, all entries are returned.
     The state values are flag-based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.
     For example, if the provided value is 6 then health state of nodes with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param applicationsHealthStateFilter Allows filtering of the application health state objects returned in the result of cluster health
     query based on their health state.
     The possible values for this parameter include integer value obtained from members or bitwise operations
     on members of HealthStateFilter enumeration. Only applications that match the filter are returned.
     All applications are used to evaluate the aggregated health state. If not specified, all entries are returned.
     The state values are flag-based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.
     For example, if the provided value is 6 then health state of applications with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param excludeHealthStatistics Indicates whether the health statistics should be returned as part of the query result. False by default.
     The statistics show the number of children entities in health state Ok, Warning, and Error.
     * @param includeSystemApplicationHealthStatistics Indicates whether the health statistics should include the fabric:/System application health statistics. False by default.
     If IncludeSystemApplicationHealthStatistics is set to true, the health statistics include the entities that belong to the fabric:/System application.
     Otherwise, the query result includes health statistics only for user applications.
     The health statistics must be included in the query result for this parameter to be applied.
     * @param clusterHealthPolicies Describes the health policies used to evaluate the cluster health.
     If not present, the health evaluation uses the cluster health policy defined in the cluster manifest or the default cluster health policy.
     By default, each application is evaluated using its specific application health policy, defined in the application manifest, or the default health policy, if no policy is defined in manifest.
     If the application health policy map is specified, and it has an entry for an application, the specified application health policy
     is used to evaluate the application health.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ClusterHealthInner object if successful.
     */
    public ClusterHealthInner getClusterHealthUsingPolicy(Integer nodesHealthStateFilter, Integer applicationsHealthStateFilter, Integer eventsHealthStateFilter, Boolean excludeHealthStatistics, Boolean includeSystemApplicationHealthStatistics, ClusterHealthPolicies clusterHealthPolicies, Long timeout) {
        return getClusterHealthUsingPolicyWithServiceResponseAsync(nodesHealthStateFilter, applicationsHealthStateFilter, eventsHealthStateFilter, excludeHealthStatistics, includeSystemApplicationHealthStatistics, clusterHealthPolicies, timeout).toBlocking().single().body();
    }

    /**
     * Gets the health of a Service Fabric cluster using the specified policy.
     * Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.
     Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to filter the collection of nodes and applications returned based on their aggregated health state.
     Use ClusterHealthPolicies to override the health policies used to evaluate the health.
     *
     * @param nodesHealthStateFilter Allows filtering of the node health state objects returned in the result of cluster health query
     based on their health state. The possible values for this parameter include integer value of one of the
     following health states. Only nodes that match the filter are returned. All nodes are used to evaluate the aggregated health state.
     If not specified, all entries are returned.
     The state values are flag-based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.
     For example, if the provided value is 6 then health state of nodes with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param applicationsHealthStateFilter Allows filtering of the application health state objects returned in the result of cluster health
     query based on their health state.
     The possible values for this parameter include integer value obtained from members or bitwise operations
     on members of HealthStateFilter enumeration. Only applications that match the filter are returned.
     All applications are used to evaluate the aggregated health state. If not specified, all entries are returned.
     The state values are flag-based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.
     For example, if the provided value is 6 then health state of applications with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param excludeHealthStatistics Indicates whether the health statistics should be returned as part of the query result. False by default.
     The statistics show the number of children entities in health state Ok, Warning, and Error.
     * @param includeSystemApplicationHealthStatistics Indicates whether the health statistics should include the fabric:/System application health statistics. False by default.
     If IncludeSystemApplicationHealthStatistics is set to true, the health statistics include the entities that belong to the fabric:/System application.
     Otherwise, the query result includes health statistics only for user applications.
     The health statistics must be included in the query result for this parameter to be applied.
     * @param clusterHealthPolicies Describes the health policies used to evaluate the cluster health.
     If not present, the health evaluation uses the cluster health policy defined in the cluster manifest or the default cluster health policy.
     By default, each application is evaluated using its specific application health policy, defined in the application manifest, or the default health policy, if no policy is defined in manifest.
     If the application health policy map is specified, and it has an entry for an application, the specified application health policy
     is used to evaluate the application health.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ClusterHealthInner> getClusterHealthUsingPolicyAsync(Integer nodesHealthStateFilter, Integer applicationsHealthStateFilter, Integer eventsHealthStateFilter, Boolean excludeHealthStatistics, Boolean includeSystemApplicationHealthStatistics, ClusterHealthPolicies clusterHealthPolicies, Long timeout, final ServiceCallback<ClusterHealthInner> serviceCallback) {
        return ServiceFuture.fromResponse(getClusterHealthUsingPolicyWithServiceResponseAsync(nodesHealthStateFilter, applicationsHealthStateFilter, eventsHealthStateFilter, excludeHealthStatistics, includeSystemApplicationHealthStatistics, clusterHealthPolicies, timeout), serviceCallback);
    }

    /**
     * Gets the health of a Service Fabric cluster using the specified policy.
     * Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.
     Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to filter the collection of nodes and applications returned based on their aggregated health state.
     Use ClusterHealthPolicies to override the health policies used to evaluate the health.
     *
     * @param nodesHealthStateFilter Allows filtering of the node health state objects returned in the result of cluster health query
     based on their health state. The possible values for this parameter include integer value of one of the
     following health states. Only nodes that match the filter are returned. All nodes are used to evaluate the aggregated health state.
     If not specified, all entries are returned.
     The state values are flag-based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.
     For example, if the provided value is 6 then health state of nodes with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param applicationsHealthStateFilter Allows filtering of the application health state objects returned in the result of cluster health
     query based on their health state.
     The possible values for this parameter include integer value obtained from members or bitwise operations
     on members of HealthStateFilter enumeration. Only applications that match the filter are returned.
     All applications are used to evaluate the aggregated health state. If not specified, all entries are returned.
     The state values are flag-based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.
     For example, if the provided value is 6 then health state of applications with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param excludeHealthStatistics Indicates whether the health statistics should be returned as part of the query result. False by default.
     The statistics show the number of children entities in health state Ok, Warning, and Error.
     * @param includeSystemApplicationHealthStatistics Indicates whether the health statistics should include the fabric:/System application health statistics. False by default.
     If IncludeSystemApplicationHealthStatistics is set to true, the health statistics include the entities that belong to the fabric:/System application.
     Otherwise, the query result includes health statistics only for user applications.
     The health statistics must be included in the query result for this parameter to be applied.
     * @param clusterHealthPolicies Describes the health policies used to evaluate the cluster health.
     If not present, the health evaluation uses the cluster health policy defined in the cluster manifest or the default cluster health policy.
     By default, each application is evaluated using its specific application health policy, defined in the application manifest, or the default health policy, if no policy is defined in manifest.
     If the application health policy map is specified, and it has an entry for an application, the specified application health policy
     is used to evaluate the application health.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ClusterHealthInner object
     */
    public Observable<ClusterHealthInner> getClusterHealthUsingPolicyAsync(Integer nodesHealthStateFilter, Integer applicationsHealthStateFilter, Integer eventsHealthStateFilter, Boolean excludeHealthStatistics, Boolean includeSystemApplicationHealthStatistics, ClusterHealthPolicies clusterHealthPolicies, Long timeout) {
        return getClusterHealthUsingPolicyWithServiceResponseAsync(nodesHealthStateFilter, applicationsHealthStateFilter, eventsHealthStateFilter, excludeHealthStatistics, includeSystemApplicationHealthStatistics, clusterHealthPolicies, timeout).map(new Func1<ServiceResponse<ClusterHealthInner>, ClusterHealthInner>() {
            @Override
            public ClusterHealthInner call(ServiceResponse<ClusterHealthInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the health of a Service Fabric cluster using the specified policy.
     * Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.
     Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to filter the collection of nodes and applications returned based on their aggregated health state.
     Use ClusterHealthPolicies to override the health policies used to evaluate the health.
     *
     * @param nodesHealthStateFilter Allows filtering of the node health state objects returned in the result of cluster health query
     based on their health state. The possible values for this parameter include integer value of one of the
     following health states. Only nodes that match the filter are returned. All nodes are used to evaluate the aggregated health state.
     If not specified, all entries are returned.
     The state values are flag-based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.
     For example, if the provided value is 6 then health state of nodes with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param applicationsHealthStateFilter Allows filtering of the application health state objects returned in the result of cluster health
     query based on their health state.
     The possible values for this parameter include integer value obtained from members or bitwise operations
     on members of HealthStateFilter enumeration. Only applications that match the filter are returned.
     All applications are used to evaluate the aggregated health state. If not specified, all entries are returned.
     The state values are flag-based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.
     For example, if the provided value is 6 then health state of applications with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param excludeHealthStatistics Indicates whether the health statistics should be returned as part of the query result. False by default.
     The statistics show the number of children entities in health state Ok, Warning, and Error.
     * @param includeSystemApplicationHealthStatistics Indicates whether the health statistics should include the fabric:/System application health statistics. False by default.
     If IncludeSystemApplicationHealthStatistics is set to true, the health statistics include the entities that belong to the fabric:/System application.
     Otherwise, the query result includes health statistics only for user applications.
     The health statistics must be included in the query result for this parameter to be applied.
     * @param clusterHealthPolicies Describes the health policies used to evaluate the cluster health.
     If not present, the health evaluation uses the cluster health policy defined in the cluster manifest or the default cluster health policy.
     By default, each application is evaluated using its specific application health policy, defined in the application manifest, or the default health policy, if no policy is defined in manifest.
     If the application health policy map is specified, and it has an entry for an application, the specified application health policy
     is used to evaluate the application health.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ClusterHealthInner object
     */
    public Observable<ServiceResponse<ClusterHealthInner>> getClusterHealthUsingPolicyWithServiceResponseAsync(Integer nodesHealthStateFilter, Integer applicationsHealthStateFilter, Integer eventsHealthStateFilter, Boolean excludeHealthStatistics, Boolean includeSystemApplicationHealthStatistics, ClusterHealthPolicies clusterHealthPolicies, Long timeout) {
        Validator.validate(clusterHealthPolicies);
        final String apiVersion = "6.0";
        return service.getClusterHealthUsingPolicy(apiVersion, nodesHealthStateFilter, applicationsHealthStateFilter, eventsHealthStateFilter, excludeHealthStatistics, includeSystemApplicationHealthStatistics, clusterHealthPolicies, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ClusterHealthInner>>>() {
                @Override
                public Observable<ServiceResponse<ClusterHealthInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ClusterHealthInner> clientResponse = getClusterHealthUsingPolicyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ClusterHealthInner> getClusterHealthUsingPolicyDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException {
        return this.restClient().responseBuilderFactory().<ClusterHealthInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ClusterHealthInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the health of a Service Fabric cluster using health chunks.
     * Gets the health of a Service Fabric cluster using health chunks. Includes the aggregated health state of the cluster, but none of the cluster entities.
     To expand the cluster health and get the health state of all or some of the entities, use the POST URI and specify the cluster health chunk query description.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ClusterHealthChunkInner object if successful.
     */
    public ClusterHealthChunkInner getClusterHealthChunk() {
        return getClusterHealthChunkWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets the health of a Service Fabric cluster using health chunks.
     * Gets the health of a Service Fabric cluster using health chunks. Includes the aggregated health state of the cluster, but none of the cluster entities.
     To expand the cluster health and get the health state of all or some of the entities, use the POST URI and specify the cluster health chunk query description.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ClusterHealthChunkInner> getClusterHealthChunkAsync(final ServiceCallback<ClusterHealthChunkInner> serviceCallback) {
        return ServiceFuture.fromResponse(getClusterHealthChunkWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets the health of a Service Fabric cluster using health chunks.
     * Gets the health of a Service Fabric cluster using health chunks. Includes the aggregated health state of the cluster, but none of the cluster entities.
     To expand the cluster health and get the health state of all or some of the entities, use the POST URI and specify the cluster health chunk query description.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ClusterHealthChunkInner object
     */
    public Observable<ClusterHealthChunkInner> getClusterHealthChunkAsync() {
        return getClusterHealthChunkWithServiceResponseAsync().map(new Func1<ServiceResponse<ClusterHealthChunkInner>, ClusterHealthChunkInner>() {
            @Override
            public ClusterHealthChunkInner call(ServiceResponse<ClusterHealthChunkInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the health of a Service Fabric cluster using health chunks.
     * Gets the health of a Service Fabric cluster using health chunks. Includes the aggregated health state of the cluster, but none of the cluster entities.
     To expand the cluster health and get the health state of all or some of the entities, use the POST URI and specify the cluster health chunk query description.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ClusterHealthChunkInner object
     */
    public Observable<ServiceResponse<ClusterHealthChunkInner>> getClusterHealthChunkWithServiceResponseAsync() {
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.getClusterHealthChunk(apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ClusterHealthChunkInner>>>() {
                @Override
                public Observable<ServiceResponse<ClusterHealthChunkInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ClusterHealthChunkInner> clientResponse = getClusterHealthChunkDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the health of a Service Fabric cluster using health chunks.
     * Gets the health of a Service Fabric cluster using health chunks. Includes the aggregated health state of the cluster, but none of the cluster entities.
     To expand the cluster health and get the health state of all or some of the entities, use the POST URI and specify the cluster health chunk query description.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ClusterHealthChunkInner object if successful.
     */
    public ClusterHealthChunkInner getClusterHealthChunk(Long timeout) {
        return getClusterHealthChunkWithServiceResponseAsync(timeout).toBlocking().single().body();
    }

    /**
     * Gets the health of a Service Fabric cluster using health chunks.
     * Gets the health of a Service Fabric cluster using health chunks. Includes the aggregated health state of the cluster, but none of the cluster entities.
     To expand the cluster health and get the health state of all or some of the entities, use the POST URI and specify the cluster health chunk query description.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ClusterHealthChunkInner> getClusterHealthChunkAsync(Long timeout, final ServiceCallback<ClusterHealthChunkInner> serviceCallback) {
        return ServiceFuture.fromResponse(getClusterHealthChunkWithServiceResponseAsync(timeout), serviceCallback);
    }

    /**
     * Gets the health of a Service Fabric cluster using health chunks.
     * Gets the health of a Service Fabric cluster using health chunks. Includes the aggregated health state of the cluster, but none of the cluster entities.
     To expand the cluster health and get the health state of all or some of the entities, use the POST URI and specify the cluster health chunk query description.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ClusterHealthChunkInner object
     */
    public Observable<ClusterHealthChunkInner> getClusterHealthChunkAsync(Long timeout) {
        return getClusterHealthChunkWithServiceResponseAsync(timeout).map(new Func1<ServiceResponse<ClusterHealthChunkInner>, ClusterHealthChunkInner>() {
            @Override
            public ClusterHealthChunkInner call(ServiceResponse<ClusterHealthChunkInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the health of a Service Fabric cluster using health chunks.
     * Gets the health of a Service Fabric cluster using health chunks. Includes the aggregated health state of the cluster, but none of the cluster entities.
     To expand the cluster health and get the health state of all or some of the entities, use the POST URI and specify the cluster health chunk query description.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ClusterHealthChunkInner object
     */
    public Observable<ServiceResponse<ClusterHealthChunkInner>> getClusterHealthChunkWithServiceResponseAsync(Long timeout) {
        final String apiVersion = "6.0";
        return service.getClusterHealthChunk(apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ClusterHealthChunkInner>>>() {
                @Override
                public Observable<ServiceResponse<ClusterHealthChunkInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ClusterHealthChunkInner> clientResponse = getClusterHealthChunkDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ClusterHealthChunkInner> getClusterHealthChunkDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException {
        return this.restClient().responseBuilderFactory().<ClusterHealthChunkInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ClusterHealthChunkInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the health of a Service Fabric cluster using health chunks.
     * Gets the health of a Service Fabric cluster using health chunks. The health evaluation is done based on the input cluster health chunk query description.
     The query description allows users to specify health policies for evaluating the cluster and its children.
     Users can specify very flexible filters to select which cluster entities to return. The selection can be done based on the entities health state and based on the hierarchy.
     The query can return multi-level children of the entities based on the specified filters. For example, it can return one application with a specified name, and for this application, return
     only services that are in Error or Warning, and all partitions and replicas for one of these services.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ClusterHealthChunkInner object if successful.
     */
    public ClusterHealthChunkInner getClusterHealthChunkUsingPolicyAndAdvancedFilters() {
        return getClusterHealthChunkUsingPolicyAndAdvancedFiltersWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets the health of a Service Fabric cluster using health chunks.
     * Gets the health of a Service Fabric cluster using health chunks. The health evaluation is done based on the input cluster health chunk query description.
     The query description allows users to specify health policies for evaluating the cluster and its children.
     Users can specify very flexible filters to select which cluster entities to return. The selection can be done based on the entities health state and based on the hierarchy.
     The query can return multi-level children of the entities based on the specified filters. For example, it can return one application with a specified name, and for this application, return
     only services that are in Error or Warning, and all partitions and replicas for one of these services.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ClusterHealthChunkInner> getClusterHealthChunkUsingPolicyAndAdvancedFiltersAsync(final ServiceCallback<ClusterHealthChunkInner> serviceCallback) {
        return ServiceFuture.fromResponse(getClusterHealthChunkUsingPolicyAndAdvancedFiltersWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets the health of a Service Fabric cluster using health chunks.
     * Gets the health of a Service Fabric cluster using health chunks. The health evaluation is done based on the input cluster health chunk query description.
     The query description allows users to specify health policies for evaluating the cluster and its children.
     Users can specify very flexible filters to select which cluster entities to return. The selection can be done based on the entities health state and based on the hierarchy.
     The query can return multi-level children of the entities based on the specified filters. For example, it can return one application with a specified name, and for this application, return
     only services that are in Error or Warning, and all partitions and replicas for one of these services.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ClusterHealthChunkInner object
     */
    public Observable<ClusterHealthChunkInner> getClusterHealthChunkUsingPolicyAndAdvancedFiltersAsync() {
        return getClusterHealthChunkUsingPolicyAndAdvancedFiltersWithServiceResponseAsync().map(new Func1<ServiceResponse<ClusterHealthChunkInner>, ClusterHealthChunkInner>() {
            @Override
            public ClusterHealthChunkInner call(ServiceResponse<ClusterHealthChunkInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the health of a Service Fabric cluster using health chunks.
     * Gets the health of a Service Fabric cluster using health chunks. The health evaluation is done based on the input cluster health chunk query description.
     The query description allows users to specify health policies for evaluating the cluster and its children.
     Users can specify very flexible filters to select which cluster entities to return. The selection can be done based on the entities health state and based on the hierarchy.
     The query can return multi-level children of the entities based on the specified filters. For example, it can return one application with a specified name, and for this application, return
     only services that are in Error or Warning, and all partitions and replicas for one of these services.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ClusterHealthChunkInner object
     */
    public Observable<ServiceResponse<ClusterHealthChunkInner>> getClusterHealthChunkUsingPolicyAndAdvancedFiltersWithServiceResponseAsync() {
        final String apiVersion = "6.0";
        final ClusterHealthChunkQueryDescription clusterHealthChunkQueryDescription = null;
        final Long timeout = null;
        return service.getClusterHealthChunkUsingPolicyAndAdvancedFilters(apiVersion, clusterHealthChunkQueryDescription, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ClusterHealthChunkInner>>>() {
                @Override
                public Observable<ServiceResponse<ClusterHealthChunkInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ClusterHealthChunkInner> clientResponse = getClusterHealthChunkUsingPolicyAndAdvancedFiltersDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the health of a Service Fabric cluster using health chunks.
     * Gets the health of a Service Fabric cluster using health chunks. The health evaluation is done based on the input cluster health chunk query description.
     The query description allows users to specify health policies for evaluating the cluster and its children.
     Users can specify very flexible filters to select which cluster entities to return. The selection can be done based on the entities health state and based on the hierarchy.
     The query can return multi-level children of the entities based on the specified filters. For example, it can return one application with a specified name, and for this application, return
     only services that are in Error or Warning, and all partitions and replicas for one of these services.
     *
     * @param clusterHealthChunkQueryDescription Describes the cluster and application health policies used to evaluate the cluster health and the filters to select which cluster entities to be returned.
     If the cluster health policy is present, it is used to evaluate the cluster events and the cluster nodes. If not present, the health evaluation uses the cluster health policy defined in the cluster manifest or the default cluster health policy.
     By default, each application is evaluated using its specific application health policy, defined in the application manifest, or the default health policy, if no policy is defined in manifest.
     If the application health policy map is specified, and it has an entry for an application, the specified application health policy
     is used to evaluate the application health.
     Users can specify very flexible filters to select which cluster entities to include in response. The selection can be done based on the entities health state and based on the hierarchy.
     The query can return multi-level children of the entities based on the specified filters. For example, it can return one application with a specified name, and for this application, return
     only services that are in Error or Warning, and all partitions and replicas for one of these services.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ClusterHealthChunkInner object if successful.
     */
    public ClusterHealthChunkInner getClusterHealthChunkUsingPolicyAndAdvancedFilters(ClusterHealthChunkQueryDescription clusterHealthChunkQueryDescription, Long timeout) {
        return getClusterHealthChunkUsingPolicyAndAdvancedFiltersWithServiceResponseAsync(clusterHealthChunkQueryDescription, timeout).toBlocking().single().body();
    }

    /**
     * Gets the health of a Service Fabric cluster using health chunks.
     * Gets the health of a Service Fabric cluster using health chunks. The health evaluation is done based on the input cluster health chunk query description.
     The query description allows users to specify health policies for evaluating the cluster and its children.
     Users can specify very flexible filters to select which cluster entities to return. The selection can be done based on the entities health state and based on the hierarchy.
     The query can return multi-level children of the entities based on the specified filters. For example, it can return one application with a specified name, and for this application, return
     only services that are in Error or Warning, and all partitions and replicas for one of these services.
     *
     * @param clusterHealthChunkQueryDescription Describes the cluster and application health policies used to evaluate the cluster health and the filters to select which cluster entities to be returned.
     If the cluster health policy is present, it is used to evaluate the cluster events and the cluster nodes. If not present, the health evaluation uses the cluster health policy defined in the cluster manifest or the default cluster health policy.
     By default, each application is evaluated using its specific application health policy, defined in the application manifest, or the default health policy, if no policy is defined in manifest.
     If the application health policy map is specified, and it has an entry for an application, the specified application health policy
     is used to evaluate the application health.
     Users can specify very flexible filters to select which cluster entities to include in response. The selection can be done based on the entities health state and based on the hierarchy.
     The query can return multi-level children of the entities based on the specified filters. For example, it can return one application with a specified name, and for this application, return
     only services that are in Error or Warning, and all partitions and replicas for one of these services.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ClusterHealthChunkInner> getClusterHealthChunkUsingPolicyAndAdvancedFiltersAsync(ClusterHealthChunkQueryDescription clusterHealthChunkQueryDescription, Long timeout, final ServiceCallback<ClusterHealthChunkInner> serviceCallback) {
        return ServiceFuture.fromResponse(getClusterHealthChunkUsingPolicyAndAdvancedFiltersWithServiceResponseAsync(clusterHealthChunkQueryDescription, timeout), serviceCallback);
    }

    /**
     * Gets the health of a Service Fabric cluster using health chunks.
     * Gets the health of a Service Fabric cluster using health chunks. The health evaluation is done based on the input cluster health chunk query description.
     The query description allows users to specify health policies for evaluating the cluster and its children.
     Users can specify very flexible filters to select which cluster entities to return. The selection can be done based on the entities health state and based on the hierarchy.
     The query can return multi-level children of the entities based on the specified filters. For example, it can return one application with a specified name, and for this application, return
     only services that are in Error or Warning, and all partitions and replicas for one of these services.
     *
     * @param clusterHealthChunkQueryDescription Describes the cluster and application health policies used to evaluate the cluster health and the filters to select which cluster entities to be returned.
     If the cluster health policy is present, it is used to evaluate the cluster events and the cluster nodes. If not present, the health evaluation uses the cluster health policy defined in the cluster manifest or the default cluster health policy.
     By default, each application is evaluated using its specific application health policy, defined in the application manifest, or the default health policy, if no policy is defined in manifest.
     If the application health policy map is specified, and it has an entry for an application, the specified application health policy
     is used to evaluate the application health.
     Users can specify very flexible filters to select which cluster entities to include in response. The selection can be done based on the entities health state and based on the hierarchy.
     The query can return multi-level children of the entities based on the specified filters. For example, it can return one application with a specified name, and for this application, return
     only services that are in Error or Warning, and all partitions and replicas for one of these services.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ClusterHealthChunkInner object
     */
    public Observable<ClusterHealthChunkInner> getClusterHealthChunkUsingPolicyAndAdvancedFiltersAsync(ClusterHealthChunkQueryDescription clusterHealthChunkQueryDescription, Long timeout) {
        return getClusterHealthChunkUsingPolicyAndAdvancedFiltersWithServiceResponseAsync(clusterHealthChunkQueryDescription, timeout).map(new Func1<ServiceResponse<ClusterHealthChunkInner>, ClusterHealthChunkInner>() {
            @Override
            public ClusterHealthChunkInner call(ServiceResponse<ClusterHealthChunkInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the health of a Service Fabric cluster using health chunks.
     * Gets the health of a Service Fabric cluster using health chunks. The health evaluation is done based on the input cluster health chunk query description.
     The query description allows users to specify health policies for evaluating the cluster and its children.
     Users can specify very flexible filters to select which cluster entities to return. The selection can be done based on the entities health state and based on the hierarchy.
     The query can return multi-level children of the entities based on the specified filters. For example, it can return one application with a specified name, and for this application, return
     only services that are in Error or Warning, and all partitions and replicas for one of these services.
     *
     * @param clusterHealthChunkQueryDescription Describes the cluster and application health policies used to evaluate the cluster health and the filters to select which cluster entities to be returned.
     If the cluster health policy is present, it is used to evaluate the cluster events and the cluster nodes. If not present, the health evaluation uses the cluster health policy defined in the cluster manifest or the default cluster health policy.
     By default, each application is evaluated using its specific application health policy, defined in the application manifest, or the default health policy, if no policy is defined in manifest.
     If the application health policy map is specified, and it has an entry for an application, the specified application health policy
     is used to evaluate the application health.
     Users can specify very flexible filters to select which cluster entities to include in response. The selection can be done based on the entities health state and based on the hierarchy.
     The query can return multi-level children of the entities based on the specified filters. For example, it can return one application with a specified name, and for this application, return
     only services that are in Error or Warning, and all partitions and replicas for one of these services.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ClusterHealthChunkInner object
     */
    public Observable<ServiceResponse<ClusterHealthChunkInner>> getClusterHealthChunkUsingPolicyAndAdvancedFiltersWithServiceResponseAsync(ClusterHealthChunkQueryDescription clusterHealthChunkQueryDescription, Long timeout) {
        Validator.validate(clusterHealthChunkQueryDescription);
        final String apiVersion = "6.0";
        return service.getClusterHealthChunkUsingPolicyAndAdvancedFilters(apiVersion, clusterHealthChunkQueryDescription, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ClusterHealthChunkInner>>>() {
                @Override
                public Observable<ServiceResponse<ClusterHealthChunkInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ClusterHealthChunkInner> clientResponse = getClusterHealthChunkUsingPolicyAndAdvancedFiltersDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ClusterHealthChunkInner> getClusterHealthChunkUsingPolicyAndAdvancedFiltersDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException {
        return this.restClient().responseBuilderFactory().<ClusterHealthChunkInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ClusterHealthChunkInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Sends a health report on the Service Fabric cluster.
     * Sends a health report on a Service Fabric cluster. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway node, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, run GetClusterHealth and check that the report appears in the HealthEvents section.
     *
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void reportClusterHealth(HealthInformation healthInformation) {
        reportClusterHealthWithServiceResponseAsync(healthInformation).toBlocking().single().body();
    }

    /**
     * Sends a health report on the Service Fabric cluster.
     * Sends a health report on a Service Fabric cluster. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway node, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, run GetClusterHealth and check that the report appears in the HealthEvents section.
     *
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> reportClusterHealthAsync(HealthInformation healthInformation, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(reportClusterHealthWithServiceResponseAsync(healthInformation), serviceCallback);
    }

    /**
     * Sends a health report on the Service Fabric cluster.
     * Sends a health report on a Service Fabric cluster. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway node, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, run GetClusterHealth and check that the report appears in the HealthEvents section.
     *
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> reportClusterHealthAsync(HealthInformation healthInformation) {
        return reportClusterHealthWithServiceResponseAsync(healthInformation).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Sends a health report on the Service Fabric cluster.
     * Sends a health report on a Service Fabric cluster. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway node, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, run GetClusterHealth and check that the report appears in the HealthEvents section.
     *
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> reportClusterHealthWithServiceResponseAsync(HealthInformation healthInformation) {
        if (healthInformation == null) {
            throw new IllegalArgumentException("Parameter healthInformation is required and cannot be null.");
        }
        Validator.validate(healthInformation);
        final String apiVersion = "6.0";
        final Boolean immediate = null;
        final Long timeout = null;
        return service.reportClusterHealth(apiVersion, healthInformation, immediate, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = reportClusterHealthDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Sends a health report on the Service Fabric cluster.
     * Sends a health report on a Service Fabric cluster. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway node, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, run GetClusterHealth and check that the report appears in the HealthEvents section.
     *
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @param immediate A flag that indicates whether the report should be sent immediately.
     A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
     If Immediate is set to true, the report is sent immediately from HTTP Gateway to the health store, regardless of the fabric client settings that the HTTP Gateway Application is using.
     This is useful for critical reports that should be sent as soon as possible.
     Depending on timing and other conditions, sending the report may still fail, for example if the HTTP Gateway is closed or the message doesn't reach the Gateway.
     If Immediate is set to false, the report is sent based on the health client settings from the HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
     This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
     By default, reports are not sent immediately.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void reportClusterHealth(HealthInformation healthInformation, Boolean immediate, Long timeout) {
        reportClusterHealthWithServiceResponseAsync(healthInformation, immediate, timeout).toBlocking().single().body();
    }

    /**
     * Sends a health report on the Service Fabric cluster.
     * Sends a health report on a Service Fabric cluster. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway node, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, run GetClusterHealth and check that the report appears in the HealthEvents section.
     *
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @param immediate A flag that indicates whether the report should be sent immediately.
     A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
     If Immediate is set to true, the report is sent immediately from HTTP Gateway to the health store, regardless of the fabric client settings that the HTTP Gateway Application is using.
     This is useful for critical reports that should be sent as soon as possible.
     Depending on timing and other conditions, sending the report may still fail, for example if the HTTP Gateway is closed or the message doesn't reach the Gateway.
     If Immediate is set to false, the report is sent based on the health client settings from the HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
     This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
     By default, reports are not sent immediately.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> reportClusterHealthAsync(HealthInformation healthInformation, Boolean immediate, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(reportClusterHealthWithServiceResponseAsync(healthInformation, immediate, timeout), serviceCallback);
    }

    /**
     * Sends a health report on the Service Fabric cluster.
     * Sends a health report on a Service Fabric cluster. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway node, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, run GetClusterHealth and check that the report appears in the HealthEvents section.
     *
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @param immediate A flag that indicates whether the report should be sent immediately.
     A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
     If Immediate is set to true, the report is sent immediately from HTTP Gateway to the health store, regardless of the fabric client settings that the HTTP Gateway Application is using.
     This is useful for critical reports that should be sent as soon as possible.
     Depending on timing and other conditions, sending the report may still fail, for example if the HTTP Gateway is closed or the message doesn't reach the Gateway.
     If Immediate is set to false, the report is sent based on the health client settings from the HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
     This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
     By default, reports are not sent immediately.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> reportClusterHealthAsync(HealthInformation healthInformation, Boolean immediate, Long timeout) {
        return reportClusterHealthWithServiceResponseAsync(healthInformation, immediate, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Sends a health report on the Service Fabric cluster.
     * Sends a health report on a Service Fabric cluster. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway node, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, run GetClusterHealth and check that the report appears in the HealthEvents section.
     *
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @param immediate A flag that indicates whether the report should be sent immediately.
     A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
     If Immediate is set to true, the report is sent immediately from HTTP Gateway to the health store, regardless of the fabric client settings that the HTTP Gateway Application is using.
     This is useful for critical reports that should be sent as soon as possible.
     Depending on timing and other conditions, sending the report may still fail, for example if the HTTP Gateway is closed or the message doesn't reach the Gateway.
     If Immediate is set to false, the report is sent based on the health client settings from the HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
     This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
     By default, reports are not sent immediately.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> reportClusterHealthWithServiceResponseAsync(HealthInformation healthInformation, Boolean immediate, Long timeout) {
        if (healthInformation == null) {
            throw new IllegalArgumentException("Parameter healthInformation is required and cannot be null.");
        }
        Validator.validate(healthInformation);
        final String apiVersion = "6.0";
        return service.reportClusterHealth(apiVersion, healthInformation, immediate, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = reportClusterHealthDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> reportClusterHealthDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets a list of fabric code versions that are provisioned in a Service Fabric cluster.
     * Gets a list of information about fabric code versions that are provisioned in the cluster. The parameter CodeVersion can be used to optionally filter the output to only that particular version.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;FabricCodeVersionInfoInner&gt; object if successful.
     */
    public List<FabricCodeVersionInfoInner> getProvisionedFabricCodeVersionInfoList() {
        return getProvisionedFabricCodeVersionInfoListWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets a list of fabric code versions that are provisioned in a Service Fabric cluster.
     * Gets a list of information about fabric code versions that are provisioned in the cluster. The parameter CodeVersion can be used to optionally filter the output to only that particular version.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<FabricCodeVersionInfoInner>> getProvisionedFabricCodeVersionInfoListAsync(final ServiceCallback<List<FabricCodeVersionInfoInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getProvisionedFabricCodeVersionInfoListWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets a list of fabric code versions that are provisioned in a Service Fabric cluster.
     * Gets a list of information about fabric code versions that are provisioned in the cluster. The parameter CodeVersion can be used to optionally filter the output to only that particular version.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;FabricCodeVersionInfoInner&gt; object
     */
    public Observable<List<FabricCodeVersionInfoInner>> getProvisionedFabricCodeVersionInfoListAsync() {
        return getProvisionedFabricCodeVersionInfoListWithServiceResponseAsync().map(new Func1<ServiceResponse<List<FabricCodeVersionInfoInner>>, List<FabricCodeVersionInfoInner>>() {
            @Override
            public List<FabricCodeVersionInfoInner> call(ServiceResponse<List<FabricCodeVersionInfoInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of fabric code versions that are provisioned in a Service Fabric cluster.
     * Gets a list of information about fabric code versions that are provisioned in the cluster. The parameter CodeVersion can be used to optionally filter the output to only that particular version.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;FabricCodeVersionInfoInner&gt; object
     */
    public Observable<ServiceResponse<List<FabricCodeVersionInfoInner>>> getProvisionedFabricCodeVersionInfoListWithServiceResponseAsync() {
        final String apiVersion = "6.0";
        final String codeVersion = null;
        final Long timeout = null;
        return service.getProvisionedFabricCodeVersionInfoList(apiVersion, codeVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<FabricCodeVersionInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<FabricCodeVersionInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<FabricCodeVersionInfoInner>> clientResponse = getProvisionedFabricCodeVersionInfoListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets a list of fabric code versions that are provisioned in a Service Fabric cluster.
     * Gets a list of information about fabric code versions that are provisioned in the cluster. The parameter CodeVersion can be used to optionally filter the output to only that particular version.
     *
     * @param codeVersion The product version of Service Fabric.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;FabricCodeVersionInfoInner&gt; object if successful.
     */
    public List<FabricCodeVersionInfoInner> getProvisionedFabricCodeVersionInfoList(String codeVersion, Long timeout) {
        return getProvisionedFabricCodeVersionInfoListWithServiceResponseAsync(codeVersion, timeout).toBlocking().single().body();
    }

    /**
     * Gets a list of fabric code versions that are provisioned in a Service Fabric cluster.
     * Gets a list of information about fabric code versions that are provisioned in the cluster. The parameter CodeVersion can be used to optionally filter the output to only that particular version.
     *
     * @param codeVersion The product version of Service Fabric.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<FabricCodeVersionInfoInner>> getProvisionedFabricCodeVersionInfoListAsync(String codeVersion, Long timeout, final ServiceCallback<List<FabricCodeVersionInfoInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getProvisionedFabricCodeVersionInfoListWithServiceResponseAsync(codeVersion, timeout), serviceCallback);
    }

    /**
     * Gets a list of fabric code versions that are provisioned in a Service Fabric cluster.
     * Gets a list of information about fabric code versions that are provisioned in the cluster. The parameter CodeVersion can be used to optionally filter the output to only that particular version.
     *
     * @param codeVersion The product version of Service Fabric.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;FabricCodeVersionInfoInner&gt; object
     */
    public Observable<List<FabricCodeVersionInfoInner>> getProvisionedFabricCodeVersionInfoListAsync(String codeVersion, Long timeout) {
        return getProvisionedFabricCodeVersionInfoListWithServiceResponseAsync(codeVersion, timeout).map(new Func1<ServiceResponse<List<FabricCodeVersionInfoInner>>, List<FabricCodeVersionInfoInner>>() {
            @Override
            public List<FabricCodeVersionInfoInner> call(ServiceResponse<List<FabricCodeVersionInfoInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of fabric code versions that are provisioned in a Service Fabric cluster.
     * Gets a list of information about fabric code versions that are provisioned in the cluster. The parameter CodeVersion can be used to optionally filter the output to only that particular version.
     *
     * @param codeVersion The product version of Service Fabric.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;FabricCodeVersionInfoInner&gt; object
     */
    public Observable<ServiceResponse<List<FabricCodeVersionInfoInner>>> getProvisionedFabricCodeVersionInfoListWithServiceResponseAsync(String codeVersion, Long timeout) {
        final String apiVersion = "6.0";
        return service.getProvisionedFabricCodeVersionInfoList(apiVersion, codeVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<FabricCodeVersionInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<FabricCodeVersionInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<FabricCodeVersionInfoInner>> clientResponse = getProvisionedFabricCodeVersionInfoListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<FabricCodeVersionInfoInner>> getProvisionedFabricCodeVersionInfoListDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException {
        return this.restClient().responseBuilderFactory().<List<FabricCodeVersionInfoInner>, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<FabricCodeVersionInfoInner>>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets a list of fabric config versions that are provisioned in a Service Fabric cluster.
     * Gets a list of information about fabric config versions that are provisioned in the cluster. The parameter ConfigVersion can be used to optionally filter the output to only that particular version.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;FabricConfigVersionInfoInner&gt; object if successful.
     */
    public List<FabricConfigVersionInfoInner> getProvisionedFabricConfigVersionInfoList() {
        return getProvisionedFabricConfigVersionInfoListWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets a list of fabric config versions that are provisioned in a Service Fabric cluster.
     * Gets a list of information about fabric config versions that are provisioned in the cluster. The parameter ConfigVersion can be used to optionally filter the output to only that particular version.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<FabricConfigVersionInfoInner>> getProvisionedFabricConfigVersionInfoListAsync(final ServiceCallback<List<FabricConfigVersionInfoInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getProvisionedFabricConfigVersionInfoListWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets a list of fabric config versions that are provisioned in a Service Fabric cluster.
     * Gets a list of information about fabric config versions that are provisioned in the cluster. The parameter ConfigVersion can be used to optionally filter the output to only that particular version.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;FabricConfigVersionInfoInner&gt; object
     */
    public Observable<List<FabricConfigVersionInfoInner>> getProvisionedFabricConfigVersionInfoListAsync() {
        return getProvisionedFabricConfigVersionInfoListWithServiceResponseAsync().map(new Func1<ServiceResponse<List<FabricConfigVersionInfoInner>>, List<FabricConfigVersionInfoInner>>() {
            @Override
            public List<FabricConfigVersionInfoInner> call(ServiceResponse<List<FabricConfigVersionInfoInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of fabric config versions that are provisioned in a Service Fabric cluster.
     * Gets a list of information about fabric config versions that are provisioned in the cluster. The parameter ConfigVersion can be used to optionally filter the output to only that particular version.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;FabricConfigVersionInfoInner&gt; object
     */
    public Observable<ServiceResponse<List<FabricConfigVersionInfoInner>>> getProvisionedFabricConfigVersionInfoListWithServiceResponseAsync() {
        final String apiVersion = "6.0";
        final String configVersion = null;
        final Long timeout = null;
        return service.getProvisionedFabricConfigVersionInfoList(apiVersion, configVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<FabricConfigVersionInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<FabricConfigVersionInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<FabricConfigVersionInfoInner>> clientResponse = getProvisionedFabricConfigVersionInfoListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets a list of fabric config versions that are provisioned in a Service Fabric cluster.
     * Gets a list of information about fabric config versions that are provisioned in the cluster. The parameter ConfigVersion can be used to optionally filter the output to only that particular version.
     *
     * @param configVersion The config version of Service Fabric.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;FabricConfigVersionInfoInner&gt; object if successful.
     */
    public List<FabricConfigVersionInfoInner> getProvisionedFabricConfigVersionInfoList(String configVersion, Long timeout) {
        return getProvisionedFabricConfigVersionInfoListWithServiceResponseAsync(configVersion, timeout).toBlocking().single().body();
    }

    /**
     * Gets a list of fabric config versions that are provisioned in a Service Fabric cluster.
     * Gets a list of information about fabric config versions that are provisioned in the cluster. The parameter ConfigVersion can be used to optionally filter the output to only that particular version.
     *
     * @param configVersion The config version of Service Fabric.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<FabricConfigVersionInfoInner>> getProvisionedFabricConfigVersionInfoListAsync(String configVersion, Long timeout, final ServiceCallback<List<FabricConfigVersionInfoInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getProvisionedFabricConfigVersionInfoListWithServiceResponseAsync(configVersion, timeout), serviceCallback);
    }

    /**
     * Gets a list of fabric config versions that are provisioned in a Service Fabric cluster.
     * Gets a list of information about fabric config versions that are provisioned in the cluster. The parameter ConfigVersion can be used to optionally filter the output to only that particular version.
     *
     * @param configVersion The config version of Service Fabric.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;FabricConfigVersionInfoInner&gt; object
     */
    public Observable<List<FabricConfigVersionInfoInner>> getProvisionedFabricConfigVersionInfoListAsync(String configVersion, Long timeout) {
        return getProvisionedFabricConfigVersionInfoListWithServiceResponseAsync(configVersion, timeout).map(new Func1<ServiceResponse<List<FabricConfigVersionInfoInner>>, List<FabricConfigVersionInfoInner>>() {
            @Override
            public List<FabricConfigVersionInfoInner> call(ServiceResponse<List<FabricConfigVersionInfoInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of fabric config versions that are provisioned in a Service Fabric cluster.
     * Gets a list of information about fabric config versions that are provisioned in the cluster. The parameter ConfigVersion can be used to optionally filter the output to only that particular version.
     *
     * @param configVersion The config version of Service Fabric.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;FabricConfigVersionInfoInner&gt; object
     */
    public Observable<ServiceResponse<List<FabricConfigVersionInfoInner>>> getProvisionedFabricConfigVersionInfoListWithServiceResponseAsync(String configVersion, Long timeout) {
        final String apiVersion = "6.0";
        return service.getProvisionedFabricConfigVersionInfoList(apiVersion, configVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<FabricConfigVersionInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<FabricConfigVersionInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<FabricConfigVersionInfoInner>> clientResponse = getProvisionedFabricConfigVersionInfoListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<FabricConfigVersionInfoInner>> getProvisionedFabricConfigVersionInfoListDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException {
        return this.restClient().responseBuilderFactory().<List<FabricConfigVersionInfoInner>, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<FabricConfigVersionInfoInner>>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the progress of the current cluster upgrade.
     * Gets the current progress of the ongoing cluster upgrade. If no upgrade is currently in progress, get the last state of the previous cluster upgrade.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ClusterUpgradeProgressObjectInner object if successful.
     */
    public ClusterUpgradeProgressObjectInner getClusterUpgradeProgress() {
        return getClusterUpgradeProgressWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets the progress of the current cluster upgrade.
     * Gets the current progress of the ongoing cluster upgrade. If no upgrade is currently in progress, get the last state of the previous cluster upgrade.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ClusterUpgradeProgressObjectInner> getClusterUpgradeProgressAsync(final ServiceCallback<ClusterUpgradeProgressObjectInner> serviceCallback) {
        return ServiceFuture.fromResponse(getClusterUpgradeProgressWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets the progress of the current cluster upgrade.
     * Gets the current progress of the ongoing cluster upgrade. If no upgrade is currently in progress, get the last state of the previous cluster upgrade.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ClusterUpgradeProgressObjectInner object
     */
    public Observable<ClusterUpgradeProgressObjectInner> getClusterUpgradeProgressAsync() {
        return getClusterUpgradeProgressWithServiceResponseAsync().map(new Func1<ServiceResponse<ClusterUpgradeProgressObjectInner>, ClusterUpgradeProgressObjectInner>() {
            @Override
            public ClusterUpgradeProgressObjectInner call(ServiceResponse<ClusterUpgradeProgressObjectInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the progress of the current cluster upgrade.
     * Gets the current progress of the ongoing cluster upgrade. If no upgrade is currently in progress, get the last state of the previous cluster upgrade.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ClusterUpgradeProgressObjectInner object
     */
    public Observable<ServiceResponse<ClusterUpgradeProgressObjectInner>> getClusterUpgradeProgressWithServiceResponseAsync() {
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.getClusterUpgradeProgress(apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ClusterUpgradeProgressObjectInner>>>() {
                @Override
                public Observable<ServiceResponse<ClusterUpgradeProgressObjectInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ClusterUpgradeProgressObjectInner> clientResponse = getClusterUpgradeProgressDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the progress of the current cluster upgrade.
     * Gets the current progress of the ongoing cluster upgrade. If no upgrade is currently in progress, get the last state of the previous cluster upgrade.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ClusterUpgradeProgressObjectInner object if successful.
     */
    public ClusterUpgradeProgressObjectInner getClusterUpgradeProgress(Long timeout) {
        return getClusterUpgradeProgressWithServiceResponseAsync(timeout).toBlocking().single().body();
    }

    /**
     * Gets the progress of the current cluster upgrade.
     * Gets the current progress of the ongoing cluster upgrade. If no upgrade is currently in progress, get the last state of the previous cluster upgrade.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ClusterUpgradeProgressObjectInner> getClusterUpgradeProgressAsync(Long timeout, final ServiceCallback<ClusterUpgradeProgressObjectInner> serviceCallback) {
        return ServiceFuture.fromResponse(getClusterUpgradeProgressWithServiceResponseAsync(timeout), serviceCallback);
    }

    /**
     * Gets the progress of the current cluster upgrade.
     * Gets the current progress of the ongoing cluster upgrade. If no upgrade is currently in progress, get the last state of the previous cluster upgrade.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ClusterUpgradeProgressObjectInner object
     */
    public Observable<ClusterUpgradeProgressObjectInner> getClusterUpgradeProgressAsync(Long timeout) {
        return getClusterUpgradeProgressWithServiceResponseAsync(timeout).map(new Func1<ServiceResponse<ClusterUpgradeProgressObjectInner>, ClusterUpgradeProgressObjectInner>() {
            @Override
            public ClusterUpgradeProgressObjectInner call(ServiceResponse<ClusterUpgradeProgressObjectInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the progress of the current cluster upgrade.
     * Gets the current progress of the ongoing cluster upgrade. If no upgrade is currently in progress, get the last state of the previous cluster upgrade.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ClusterUpgradeProgressObjectInner object
     */
    public Observable<ServiceResponse<ClusterUpgradeProgressObjectInner>> getClusterUpgradeProgressWithServiceResponseAsync(Long timeout) {
        final String apiVersion = "6.0";
        return service.getClusterUpgradeProgress(apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ClusterUpgradeProgressObjectInner>>>() {
                @Override
                public Observable<ServiceResponse<ClusterUpgradeProgressObjectInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ClusterUpgradeProgressObjectInner> clientResponse = getClusterUpgradeProgressDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ClusterUpgradeProgressObjectInner> getClusterUpgradeProgressDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException {
        return this.restClient().responseBuilderFactory().<ClusterUpgradeProgressObjectInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ClusterUpgradeProgressObjectInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Get the Service Fabric standalone cluster configuration.
     * The cluster configuration contains properties of the cluster that include different node types on the cluster,
     security configurations, fault, and upgrade domain topologies, etc.
     *
     * @param configurationApiVersion The API version of the Standalone cluster json configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ClusterConfigurationInner object if successful.
     */
    public ClusterConfigurationInner getClusterConfiguration(String configurationApiVersion) {
        return getClusterConfigurationWithServiceResponseAsync(configurationApiVersion).toBlocking().single().body();
    }

    /**
     * Get the Service Fabric standalone cluster configuration.
     * The cluster configuration contains properties of the cluster that include different node types on the cluster,
     security configurations, fault, and upgrade domain topologies, etc.
     *
     * @param configurationApiVersion The API version of the Standalone cluster json configuration.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ClusterConfigurationInner> getClusterConfigurationAsync(String configurationApiVersion, final ServiceCallback<ClusterConfigurationInner> serviceCallback) {
        return ServiceFuture.fromResponse(getClusterConfigurationWithServiceResponseAsync(configurationApiVersion), serviceCallback);
    }

    /**
     * Get the Service Fabric standalone cluster configuration.
     * The cluster configuration contains properties of the cluster that include different node types on the cluster,
     security configurations, fault, and upgrade domain topologies, etc.
     *
     * @param configurationApiVersion The API version of the Standalone cluster json configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ClusterConfigurationInner object
     */
    public Observable<ClusterConfigurationInner> getClusterConfigurationAsync(String configurationApiVersion) {
        return getClusterConfigurationWithServiceResponseAsync(configurationApiVersion).map(new Func1<ServiceResponse<ClusterConfigurationInner>, ClusterConfigurationInner>() {
            @Override
            public ClusterConfigurationInner call(ServiceResponse<ClusterConfigurationInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get the Service Fabric standalone cluster configuration.
     * The cluster configuration contains properties of the cluster that include different node types on the cluster,
     security configurations, fault, and upgrade domain topologies, etc.
     *
     * @param configurationApiVersion The API version of the Standalone cluster json configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ClusterConfigurationInner object
     */
    public Observable<ServiceResponse<ClusterConfigurationInner>> getClusterConfigurationWithServiceResponseAsync(String configurationApiVersion) {
        if (configurationApiVersion == null) {
            throw new IllegalArgumentException("Parameter configurationApiVersion is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.getClusterConfiguration(apiVersion, configurationApiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ClusterConfigurationInner>>>() {
                @Override
                public Observable<ServiceResponse<ClusterConfigurationInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ClusterConfigurationInner> clientResponse = getClusterConfigurationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get the Service Fabric standalone cluster configuration.
     * The cluster configuration contains properties of the cluster that include different node types on the cluster,
     security configurations, fault, and upgrade domain topologies, etc.
     *
     * @param configurationApiVersion The API version of the Standalone cluster json configuration.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ClusterConfigurationInner object if successful.
     */
    public ClusterConfigurationInner getClusterConfiguration(String configurationApiVersion, Long timeout) {
        return getClusterConfigurationWithServiceResponseAsync(configurationApiVersion, timeout).toBlocking().single().body();
    }

    /**
     * Get the Service Fabric standalone cluster configuration.
     * The cluster configuration contains properties of the cluster that include different node types on the cluster,
     security configurations, fault, and upgrade domain topologies, etc.
     *
     * @param configurationApiVersion The API version of the Standalone cluster json configuration.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ClusterConfigurationInner> getClusterConfigurationAsync(String configurationApiVersion, Long timeout, final ServiceCallback<ClusterConfigurationInner> serviceCallback) {
        return ServiceFuture.fromResponse(getClusterConfigurationWithServiceResponseAsync(configurationApiVersion, timeout), serviceCallback);
    }

    /**
     * Get the Service Fabric standalone cluster configuration.
     * The cluster configuration contains properties of the cluster that include different node types on the cluster,
     security configurations, fault, and upgrade domain topologies, etc.
     *
     * @param configurationApiVersion The API version of the Standalone cluster json configuration.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ClusterConfigurationInner object
     */
    public Observable<ClusterConfigurationInner> getClusterConfigurationAsync(String configurationApiVersion, Long timeout) {
        return getClusterConfigurationWithServiceResponseAsync(configurationApiVersion, timeout).map(new Func1<ServiceResponse<ClusterConfigurationInner>, ClusterConfigurationInner>() {
            @Override
            public ClusterConfigurationInner call(ServiceResponse<ClusterConfigurationInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get the Service Fabric standalone cluster configuration.
     * The cluster configuration contains properties of the cluster that include different node types on the cluster,
     security configurations, fault, and upgrade domain topologies, etc.
     *
     * @param configurationApiVersion The API version of the Standalone cluster json configuration.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ClusterConfigurationInner object
     */
    public Observable<ServiceResponse<ClusterConfigurationInner>> getClusterConfigurationWithServiceResponseAsync(String configurationApiVersion, Long timeout) {
        if (configurationApiVersion == null) {
            throw new IllegalArgumentException("Parameter configurationApiVersion is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.getClusterConfiguration(apiVersion, configurationApiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ClusterConfigurationInner>>>() {
                @Override
                public Observable<ServiceResponse<ClusterConfigurationInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ClusterConfigurationInner> clientResponse = getClusterConfigurationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ClusterConfigurationInner> getClusterConfigurationDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ClusterConfigurationInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ClusterConfigurationInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Get the cluster configuration upgrade status of a Service Fabric standalone cluster.
     * Get the cluster configuration upgrade status details of a Service Fabric standalone cluster.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ClusterConfigurationUpgradeStatusInfoInner object if successful.
     */
    public ClusterConfigurationUpgradeStatusInfoInner getClusterConfigurationUpgradeStatus() {
        return getClusterConfigurationUpgradeStatusWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get the cluster configuration upgrade status of a Service Fabric standalone cluster.
     * Get the cluster configuration upgrade status details of a Service Fabric standalone cluster.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ClusterConfigurationUpgradeStatusInfoInner> getClusterConfigurationUpgradeStatusAsync(final ServiceCallback<ClusterConfigurationUpgradeStatusInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getClusterConfigurationUpgradeStatusWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get the cluster configuration upgrade status of a Service Fabric standalone cluster.
     * Get the cluster configuration upgrade status details of a Service Fabric standalone cluster.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ClusterConfigurationUpgradeStatusInfoInner object
     */
    public Observable<ClusterConfigurationUpgradeStatusInfoInner> getClusterConfigurationUpgradeStatusAsync() {
        return getClusterConfigurationUpgradeStatusWithServiceResponseAsync().map(new Func1<ServiceResponse<ClusterConfigurationUpgradeStatusInfoInner>, ClusterConfigurationUpgradeStatusInfoInner>() {
            @Override
            public ClusterConfigurationUpgradeStatusInfoInner call(ServiceResponse<ClusterConfigurationUpgradeStatusInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get the cluster configuration upgrade status of a Service Fabric standalone cluster.
     * Get the cluster configuration upgrade status details of a Service Fabric standalone cluster.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ClusterConfigurationUpgradeStatusInfoInner object
     */
    public Observable<ServiceResponse<ClusterConfigurationUpgradeStatusInfoInner>> getClusterConfigurationUpgradeStatusWithServiceResponseAsync() {
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.getClusterConfigurationUpgradeStatus(apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ClusterConfigurationUpgradeStatusInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<ClusterConfigurationUpgradeStatusInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ClusterConfigurationUpgradeStatusInfoInner> clientResponse = getClusterConfigurationUpgradeStatusDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get the cluster configuration upgrade status of a Service Fabric standalone cluster.
     * Get the cluster configuration upgrade status details of a Service Fabric standalone cluster.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ClusterConfigurationUpgradeStatusInfoInner object if successful.
     */
    public ClusterConfigurationUpgradeStatusInfoInner getClusterConfigurationUpgradeStatus(Long timeout) {
        return getClusterConfigurationUpgradeStatusWithServiceResponseAsync(timeout).toBlocking().single().body();
    }

    /**
     * Get the cluster configuration upgrade status of a Service Fabric standalone cluster.
     * Get the cluster configuration upgrade status details of a Service Fabric standalone cluster.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ClusterConfigurationUpgradeStatusInfoInner> getClusterConfigurationUpgradeStatusAsync(Long timeout, final ServiceCallback<ClusterConfigurationUpgradeStatusInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getClusterConfigurationUpgradeStatusWithServiceResponseAsync(timeout), serviceCallback);
    }

    /**
     * Get the cluster configuration upgrade status of a Service Fabric standalone cluster.
     * Get the cluster configuration upgrade status details of a Service Fabric standalone cluster.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ClusterConfigurationUpgradeStatusInfoInner object
     */
    public Observable<ClusterConfigurationUpgradeStatusInfoInner> getClusterConfigurationUpgradeStatusAsync(Long timeout) {
        return getClusterConfigurationUpgradeStatusWithServiceResponseAsync(timeout).map(new Func1<ServiceResponse<ClusterConfigurationUpgradeStatusInfoInner>, ClusterConfigurationUpgradeStatusInfoInner>() {
            @Override
            public ClusterConfigurationUpgradeStatusInfoInner call(ServiceResponse<ClusterConfigurationUpgradeStatusInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get the cluster configuration upgrade status of a Service Fabric standalone cluster.
     * Get the cluster configuration upgrade status details of a Service Fabric standalone cluster.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ClusterConfigurationUpgradeStatusInfoInner object
     */
    public Observable<ServiceResponse<ClusterConfigurationUpgradeStatusInfoInner>> getClusterConfigurationUpgradeStatusWithServiceResponseAsync(Long timeout) {
        final String apiVersion = "6.0";
        return service.getClusterConfigurationUpgradeStatus(apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ClusterConfigurationUpgradeStatusInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<ClusterConfigurationUpgradeStatusInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ClusterConfigurationUpgradeStatusInfoInner> clientResponse = getClusterConfigurationUpgradeStatusDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ClusterConfigurationUpgradeStatusInfoInner> getClusterConfigurationUpgradeStatusDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException {
        return this.restClient().responseBuilderFactory().<ClusterConfigurationUpgradeStatusInfoInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ClusterConfigurationUpgradeStatusInfoInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Get the service state of Service Fabric Upgrade Orchestration Service.
     * Get the service state of Service Fabric Upgrade Orchestration Service. This API is internally used for support purposes.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UpgradeOrchestrationServiceStateInner object if successful.
     */
    public UpgradeOrchestrationServiceStateInner getUpgradeOrchestrationServiceState() {
        return getUpgradeOrchestrationServiceStateWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get the service state of Service Fabric Upgrade Orchestration Service.
     * Get the service state of Service Fabric Upgrade Orchestration Service. This API is internally used for support purposes.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UpgradeOrchestrationServiceStateInner> getUpgradeOrchestrationServiceStateAsync(final ServiceCallback<UpgradeOrchestrationServiceStateInner> serviceCallback) {
        return ServiceFuture.fromResponse(getUpgradeOrchestrationServiceStateWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get the service state of Service Fabric Upgrade Orchestration Service.
     * Get the service state of Service Fabric Upgrade Orchestration Service. This API is internally used for support purposes.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UpgradeOrchestrationServiceStateInner object
     */
    public Observable<UpgradeOrchestrationServiceStateInner> getUpgradeOrchestrationServiceStateAsync() {
        return getUpgradeOrchestrationServiceStateWithServiceResponseAsync().map(new Func1<ServiceResponse<UpgradeOrchestrationServiceStateInner>, UpgradeOrchestrationServiceStateInner>() {
            @Override
            public UpgradeOrchestrationServiceStateInner call(ServiceResponse<UpgradeOrchestrationServiceStateInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get the service state of Service Fabric Upgrade Orchestration Service.
     * Get the service state of Service Fabric Upgrade Orchestration Service. This API is internally used for support purposes.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UpgradeOrchestrationServiceStateInner object
     */
    public Observable<ServiceResponse<UpgradeOrchestrationServiceStateInner>> getUpgradeOrchestrationServiceStateWithServiceResponseAsync() {
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.getUpgradeOrchestrationServiceState(apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UpgradeOrchestrationServiceStateInner>>>() {
                @Override
                public Observable<ServiceResponse<UpgradeOrchestrationServiceStateInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UpgradeOrchestrationServiceStateInner> clientResponse = getUpgradeOrchestrationServiceStateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get the service state of Service Fabric Upgrade Orchestration Service.
     * Get the service state of Service Fabric Upgrade Orchestration Service. This API is internally used for support purposes.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UpgradeOrchestrationServiceStateInner object if successful.
     */
    public UpgradeOrchestrationServiceStateInner getUpgradeOrchestrationServiceState(Long timeout) {
        return getUpgradeOrchestrationServiceStateWithServiceResponseAsync(timeout).toBlocking().single().body();
    }

    /**
     * Get the service state of Service Fabric Upgrade Orchestration Service.
     * Get the service state of Service Fabric Upgrade Orchestration Service. This API is internally used for support purposes.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UpgradeOrchestrationServiceStateInner> getUpgradeOrchestrationServiceStateAsync(Long timeout, final ServiceCallback<UpgradeOrchestrationServiceStateInner> serviceCallback) {
        return ServiceFuture.fromResponse(getUpgradeOrchestrationServiceStateWithServiceResponseAsync(timeout), serviceCallback);
    }

    /**
     * Get the service state of Service Fabric Upgrade Orchestration Service.
     * Get the service state of Service Fabric Upgrade Orchestration Service. This API is internally used for support purposes.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UpgradeOrchestrationServiceStateInner object
     */
    public Observable<UpgradeOrchestrationServiceStateInner> getUpgradeOrchestrationServiceStateAsync(Long timeout) {
        return getUpgradeOrchestrationServiceStateWithServiceResponseAsync(timeout).map(new Func1<ServiceResponse<UpgradeOrchestrationServiceStateInner>, UpgradeOrchestrationServiceStateInner>() {
            @Override
            public UpgradeOrchestrationServiceStateInner call(ServiceResponse<UpgradeOrchestrationServiceStateInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get the service state of Service Fabric Upgrade Orchestration Service.
     * Get the service state of Service Fabric Upgrade Orchestration Service. This API is internally used for support purposes.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UpgradeOrchestrationServiceStateInner object
     */
    public Observable<ServiceResponse<UpgradeOrchestrationServiceStateInner>> getUpgradeOrchestrationServiceStateWithServiceResponseAsync(Long timeout) {
        final String apiVersion = "6.0";
        return service.getUpgradeOrchestrationServiceState(apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UpgradeOrchestrationServiceStateInner>>>() {
                @Override
                public Observable<ServiceResponse<UpgradeOrchestrationServiceStateInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UpgradeOrchestrationServiceStateInner> clientResponse = getUpgradeOrchestrationServiceStateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<UpgradeOrchestrationServiceStateInner> getUpgradeOrchestrationServiceStateDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException {
        return this.restClient().responseBuilderFactory().<UpgradeOrchestrationServiceStateInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<UpgradeOrchestrationServiceStateInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Update the service state of Service Fabric Upgrade Orchestration Service.
     * Update the service state of Service Fabric Upgrade Orchestration Service. This API is internally used for support purposes.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UpgradeOrchestrationServiceStateSummaryInner object if successful.
     */
    public UpgradeOrchestrationServiceStateSummaryInner setUpgradeOrchestrationServiceState() {
        return setUpgradeOrchestrationServiceStateWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Update the service state of Service Fabric Upgrade Orchestration Service.
     * Update the service state of Service Fabric Upgrade Orchestration Service. This API is internally used for support purposes.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UpgradeOrchestrationServiceStateSummaryInner> setUpgradeOrchestrationServiceStateAsync(final ServiceCallback<UpgradeOrchestrationServiceStateSummaryInner> serviceCallback) {
        return ServiceFuture.fromResponse(setUpgradeOrchestrationServiceStateWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Update the service state of Service Fabric Upgrade Orchestration Service.
     * Update the service state of Service Fabric Upgrade Orchestration Service. This API is internally used for support purposes.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UpgradeOrchestrationServiceStateSummaryInner object
     */
    public Observable<UpgradeOrchestrationServiceStateSummaryInner> setUpgradeOrchestrationServiceStateAsync() {
        return setUpgradeOrchestrationServiceStateWithServiceResponseAsync().map(new Func1<ServiceResponse<UpgradeOrchestrationServiceStateSummaryInner>, UpgradeOrchestrationServiceStateSummaryInner>() {
            @Override
            public UpgradeOrchestrationServiceStateSummaryInner call(ServiceResponse<UpgradeOrchestrationServiceStateSummaryInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Update the service state of Service Fabric Upgrade Orchestration Service.
     * Update the service state of Service Fabric Upgrade Orchestration Service. This API is internally used for support purposes.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UpgradeOrchestrationServiceStateSummaryInner object
     */
    public Observable<ServiceResponse<UpgradeOrchestrationServiceStateSummaryInner>> setUpgradeOrchestrationServiceStateWithServiceResponseAsync() {
        final String apiVersion = "6.0";
        final Long timeout = null;
        final String serviceState = null;
        UpgradeOrchestrationServiceStateInner upgradeOrchestrationServiceState = new UpgradeOrchestrationServiceStateInner();
        upgradeOrchestrationServiceState.withServiceState(null);
        return service.setUpgradeOrchestrationServiceState(apiVersion, timeout, this.acceptLanguage(), upgradeOrchestrationServiceState, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UpgradeOrchestrationServiceStateSummaryInner>>>() {
                @Override
                public Observable<ServiceResponse<UpgradeOrchestrationServiceStateSummaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UpgradeOrchestrationServiceStateSummaryInner> clientResponse = setUpgradeOrchestrationServiceStateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Update the service state of Service Fabric Upgrade Orchestration Service.
     * Update the service state of Service Fabric Upgrade Orchestration Service. This API is internally used for support purposes.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceState The state of Service Fabric Upgrade Orchestration Service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UpgradeOrchestrationServiceStateSummaryInner object if successful.
     */
    public UpgradeOrchestrationServiceStateSummaryInner setUpgradeOrchestrationServiceState(Long timeout, String serviceState) {
        return setUpgradeOrchestrationServiceStateWithServiceResponseAsync(timeout, serviceState).toBlocking().single().body();
    }

    /**
     * Update the service state of Service Fabric Upgrade Orchestration Service.
     * Update the service state of Service Fabric Upgrade Orchestration Service. This API is internally used for support purposes.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceState The state of Service Fabric Upgrade Orchestration Service.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UpgradeOrchestrationServiceStateSummaryInner> setUpgradeOrchestrationServiceStateAsync(Long timeout, String serviceState, final ServiceCallback<UpgradeOrchestrationServiceStateSummaryInner> serviceCallback) {
        return ServiceFuture.fromResponse(setUpgradeOrchestrationServiceStateWithServiceResponseAsync(timeout, serviceState), serviceCallback);
    }

    /**
     * Update the service state of Service Fabric Upgrade Orchestration Service.
     * Update the service state of Service Fabric Upgrade Orchestration Service. This API is internally used for support purposes.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceState The state of Service Fabric Upgrade Orchestration Service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UpgradeOrchestrationServiceStateSummaryInner object
     */
    public Observable<UpgradeOrchestrationServiceStateSummaryInner> setUpgradeOrchestrationServiceStateAsync(Long timeout, String serviceState) {
        return setUpgradeOrchestrationServiceStateWithServiceResponseAsync(timeout, serviceState).map(new Func1<ServiceResponse<UpgradeOrchestrationServiceStateSummaryInner>, UpgradeOrchestrationServiceStateSummaryInner>() {
            @Override
            public UpgradeOrchestrationServiceStateSummaryInner call(ServiceResponse<UpgradeOrchestrationServiceStateSummaryInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Update the service state of Service Fabric Upgrade Orchestration Service.
     * Update the service state of Service Fabric Upgrade Orchestration Service. This API is internally used for support purposes.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceState The state of Service Fabric Upgrade Orchestration Service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UpgradeOrchestrationServiceStateSummaryInner object
     */
    public Observable<ServiceResponse<UpgradeOrchestrationServiceStateSummaryInner>> setUpgradeOrchestrationServiceStateWithServiceResponseAsync(Long timeout, String serviceState) {
        final String apiVersion = "6.0";
        UpgradeOrchestrationServiceStateInner upgradeOrchestrationServiceState = new UpgradeOrchestrationServiceStateInner();
        upgradeOrchestrationServiceState.withServiceState(serviceState);
        return service.setUpgradeOrchestrationServiceState(apiVersion, timeout, this.acceptLanguage(), upgradeOrchestrationServiceState, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UpgradeOrchestrationServiceStateSummaryInner>>>() {
                @Override
                public Observable<ServiceResponse<UpgradeOrchestrationServiceStateSummaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UpgradeOrchestrationServiceStateSummaryInner> clientResponse = setUpgradeOrchestrationServiceStateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<UpgradeOrchestrationServiceStateSummaryInner> setUpgradeOrchestrationServiceStateDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException {
        return this.restClient().responseBuilderFactory().<UpgradeOrchestrationServiceStateSummaryInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<UpgradeOrchestrationServiceStateSummaryInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Provision the code or configuration packages of a Service Fabric cluster.
     * Validate and provision the code or configuration packages of a Service Fabric cluster.
     *
     * @param provisionFabricDescription Describes the parameters for provisioning a cluster.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void provisionCluster(ProvisionFabricDescription provisionFabricDescription) {
        provisionClusterWithServiceResponseAsync(provisionFabricDescription).toBlocking().single().body();
    }

    /**
     * Provision the code or configuration packages of a Service Fabric cluster.
     * Validate and provision the code or configuration packages of a Service Fabric cluster.
     *
     * @param provisionFabricDescription Describes the parameters for provisioning a cluster.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> provisionClusterAsync(ProvisionFabricDescription provisionFabricDescription, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(provisionClusterWithServiceResponseAsync(provisionFabricDescription), serviceCallback);
    }

    /**
     * Provision the code or configuration packages of a Service Fabric cluster.
     * Validate and provision the code or configuration packages of a Service Fabric cluster.
     *
     * @param provisionFabricDescription Describes the parameters for provisioning a cluster.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> provisionClusterAsync(ProvisionFabricDescription provisionFabricDescription) {
        return provisionClusterWithServiceResponseAsync(provisionFabricDescription).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Provision the code or configuration packages of a Service Fabric cluster.
     * Validate and provision the code or configuration packages of a Service Fabric cluster.
     *
     * @param provisionFabricDescription Describes the parameters for provisioning a cluster.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> provisionClusterWithServiceResponseAsync(ProvisionFabricDescription provisionFabricDescription) {
        if (provisionFabricDescription == null) {
            throw new IllegalArgumentException("Parameter provisionFabricDescription is required and cannot be null.");
        }
        Validator.validate(provisionFabricDescription);
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.provisionCluster(apiVersion, provisionFabricDescription, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = provisionClusterDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Provision the code or configuration packages of a Service Fabric cluster.
     * Validate and provision the code or configuration packages of a Service Fabric cluster.
     *
     * @param provisionFabricDescription Describes the parameters for provisioning a cluster.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void provisionCluster(ProvisionFabricDescription provisionFabricDescription, Long timeout) {
        provisionClusterWithServiceResponseAsync(provisionFabricDescription, timeout).toBlocking().single().body();
    }

    /**
     * Provision the code or configuration packages of a Service Fabric cluster.
     * Validate and provision the code or configuration packages of a Service Fabric cluster.
     *
     * @param provisionFabricDescription Describes the parameters for provisioning a cluster.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> provisionClusterAsync(ProvisionFabricDescription provisionFabricDescription, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(provisionClusterWithServiceResponseAsync(provisionFabricDescription, timeout), serviceCallback);
    }

    /**
     * Provision the code or configuration packages of a Service Fabric cluster.
     * Validate and provision the code or configuration packages of a Service Fabric cluster.
     *
     * @param provisionFabricDescription Describes the parameters for provisioning a cluster.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> provisionClusterAsync(ProvisionFabricDescription provisionFabricDescription, Long timeout) {
        return provisionClusterWithServiceResponseAsync(provisionFabricDescription, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Provision the code or configuration packages of a Service Fabric cluster.
     * Validate and provision the code or configuration packages of a Service Fabric cluster.
     *
     * @param provisionFabricDescription Describes the parameters for provisioning a cluster.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> provisionClusterWithServiceResponseAsync(ProvisionFabricDescription provisionFabricDescription, Long timeout) {
        if (provisionFabricDescription == null) {
            throw new IllegalArgumentException("Parameter provisionFabricDescription is required and cannot be null.");
        }
        Validator.validate(provisionFabricDescription);
        final String apiVersion = "6.0";
        return service.provisionCluster(apiVersion, provisionFabricDescription, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = provisionClusterDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> provisionClusterDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Unprovision the code or configuration packages of a Service Fabric cluster.
     * It is supported to unprovision code and configuration separately.
     *
     * @param unprovisionFabricDescription Describes the parameters for unprovisioning a cluster.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void unprovisionCluster(UnprovisionFabricDescription unprovisionFabricDescription) {
        unprovisionClusterWithServiceResponseAsync(unprovisionFabricDescription).toBlocking().single().body();
    }

    /**
     * Unprovision the code or configuration packages of a Service Fabric cluster.
     * It is supported to unprovision code and configuration separately.
     *
     * @param unprovisionFabricDescription Describes the parameters for unprovisioning a cluster.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> unprovisionClusterAsync(UnprovisionFabricDescription unprovisionFabricDescription, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(unprovisionClusterWithServiceResponseAsync(unprovisionFabricDescription), serviceCallback);
    }

    /**
     * Unprovision the code or configuration packages of a Service Fabric cluster.
     * It is supported to unprovision code and configuration separately.
     *
     * @param unprovisionFabricDescription Describes the parameters for unprovisioning a cluster.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> unprovisionClusterAsync(UnprovisionFabricDescription unprovisionFabricDescription) {
        return unprovisionClusterWithServiceResponseAsync(unprovisionFabricDescription).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Unprovision the code or configuration packages of a Service Fabric cluster.
     * It is supported to unprovision code and configuration separately.
     *
     * @param unprovisionFabricDescription Describes the parameters for unprovisioning a cluster.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> unprovisionClusterWithServiceResponseAsync(UnprovisionFabricDescription unprovisionFabricDescription) {
        if (unprovisionFabricDescription == null) {
            throw new IllegalArgumentException("Parameter unprovisionFabricDescription is required and cannot be null.");
        }
        Validator.validate(unprovisionFabricDescription);
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.unprovisionCluster(apiVersion, unprovisionFabricDescription, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = unprovisionClusterDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Unprovision the code or configuration packages of a Service Fabric cluster.
     * It is supported to unprovision code and configuration separately.
     *
     * @param unprovisionFabricDescription Describes the parameters for unprovisioning a cluster.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void unprovisionCluster(UnprovisionFabricDescription unprovisionFabricDescription, Long timeout) {
        unprovisionClusterWithServiceResponseAsync(unprovisionFabricDescription, timeout).toBlocking().single().body();
    }

    /**
     * Unprovision the code or configuration packages of a Service Fabric cluster.
     * It is supported to unprovision code and configuration separately.
     *
     * @param unprovisionFabricDescription Describes the parameters for unprovisioning a cluster.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> unprovisionClusterAsync(UnprovisionFabricDescription unprovisionFabricDescription, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(unprovisionClusterWithServiceResponseAsync(unprovisionFabricDescription, timeout), serviceCallback);
    }

    /**
     * Unprovision the code or configuration packages of a Service Fabric cluster.
     * It is supported to unprovision code and configuration separately.
     *
     * @param unprovisionFabricDescription Describes the parameters for unprovisioning a cluster.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> unprovisionClusterAsync(UnprovisionFabricDescription unprovisionFabricDescription, Long timeout) {
        return unprovisionClusterWithServiceResponseAsync(unprovisionFabricDescription, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Unprovision the code or configuration packages of a Service Fabric cluster.
     * It is supported to unprovision code and configuration separately.
     *
     * @param unprovisionFabricDescription Describes the parameters for unprovisioning a cluster.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> unprovisionClusterWithServiceResponseAsync(UnprovisionFabricDescription unprovisionFabricDescription, Long timeout) {
        if (unprovisionFabricDescription == null) {
            throw new IllegalArgumentException("Parameter unprovisionFabricDescription is required and cannot be null.");
        }
        Validator.validate(unprovisionFabricDescription);
        final String apiVersion = "6.0";
        return service.unprovisionCluster(apiVersion, unprovisionFabricDescription, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = unprovisionClusterDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> unprovisionClusterDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Rollback the upgrade of a Service Fabric cluster.
     * Rollback the code or configuration upgrade of a Service Fabric cluster.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void rollbackClusterUpgrade() {
        rollbackClusterUpgradeWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Rollback the upgrade of a Service Fabric cluster.
     * Rollback the code or configuration upgrade of a Service Fabric cluster.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> rollbackClusterUpgradeAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(rollbackClusterUpgradeWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Rollback the upgrade of a Service Fabric cluster.
     * Rollback the code or configuration upgrade of a Service Fabric cluster.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> rollbackClusterUpgradeAsync() {
        return rollbackClusterUpgradeWithServiceResponseAsync().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Rollback the upgrade of a Service Fabric cluster.
     * Rollback the code or configuration upgrade of a Service Fabric cluster.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> rollbackClusterUpgradeWithServiceResponseAsync() {
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.rollbackClusterUpgrade(apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = rollbackClusterUpgradeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Rollback the upgrade of a Service Fabric cluster.
     * Rollback the code or configuration upgrade of a Service Fabric cluster.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void rollbackClusterUpgrade(Long timeout) {
        rollbackClusterUpgradeWithServiceResponseAsync(timeout).toBlocking().single().body();
    }

    /**
     * Rollback the upgrade of a Service Fabric cluster.
     * Rollback the code or configuration upgrade of a Service Fabric cluster.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> rollbackClusterUpgradeAsync(Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(rollbackClusterUpgradeWithServiceResponseAsync(timeout), serviceCallback);
    }

    /**
     * Rollback the upgrade of a Service Fabric cluster.
     * Rollback the code or configuration upgrade of a Service Fabric cluster.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> rollbackClusterUpgradeAsync(Long timeout) {
        return rollbackClusterUpgradeWithServiceResponseAsync(timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Rollback the upgrade of a Service Fabric cluster.
     * Rollback the code or configuration upgrade of a Service Fabric cluster.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> rollbackClusterUpgradeWithServiceResponseAsync(Long timeout) {
        final String apiVersion = "6.0";
        return service.rollbackClusterUpgrade(apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = rollbackClusterUpgradeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> rollbackClusterUpgradeDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Make the cluster upgrade move on to the next upgrade domain.
     * Make the cluster code or configuration upgrade move on to the next upgrade domain if appropriate.
     *
     * @param upgradeDomain The next upgrade domain for this cluster upgrade.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void resumeClusterUpgrade(String upgradeDomain) {
        resumeClusterUpgradeWithServiceResponseAsync(upgradeDomain).toBlocking().single().body();
    }

    /**
     * Make the cluster upgrade move on to the next upgrade domain.
     * Make the cluster code or configuration upgrade move on to the next upgrade domain if appropriate.
     *
     * @param upgradeDomain The next upgrade domain for this cluster upgrade.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> resumeClusterUpgradeAsync(String upgradeDomain, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(resumeClusterUpgradeWithServiceResponseAsync(upgradeDomain), serviceCallback);
    }

    /**
     * Make the cluster upgrade move on to the next upgrade domain.
     * Make the cluster code or configuration upgrade move on to the next upgrade domain if appropriate.
     *
     * @param upgradeDomain The next upgrade domain for this cluster upgrade.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> resumeClusterUpgradeAsync(String upgradeDomain) {
        return resumeClusterUpgradeWithServiceResponseAsync(upgradeDomain).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Make the cluster upgrade move on to the next upgrade domain.
     * Make the cluster code or configuration upgrade move on to the next upgrade domain if appropriate.
     *
     * @param upgradeDomain The next upgrade domain for this cluster upgrade.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> resumeClusterUpgradeWithServiceResponseAsync(String upgradeDomain) {
        if (upgradeDomain == null) {
            throw new IllegalArgumentException("Parameter upgradeDomain is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        ResumeClusterUpgradeDescription resumeClusterUpgradeDescription = new ResumeClusterUpgradeDescription();
        resumeClusterUpgradeDescription.withUpgradeDomain(upgradeDomain);
        return service.resumeClusterUpgrade(apiVersion, timeout, this.acceptLanguage(), resumeClusterUpgradeDescription, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = resumeClusterUpgradeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Make the cluster upgrade move on to the next upgrade domain.
     * Make the cluster code or configuration upgrade move on to the next upgrade domain if appropriate.
     *
     * @param upgradeDomain The next upgrade domain for this cluster upgrade.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void resumeClusterUpgrade(String upgradeDomain, Long timeout) {
        resumeClusterUpgradeWithServiceResponseAsync(upgradeDomain, timeout).toBlocking().single().body();
    }

    /**
     * Make the cluster upgrade move on to the next upgrade domain.
     * Make the cluster code or configuration upgrade move on to the next upgrade domain if appropriate.
     *
     * @param upgradeDomain The next upgrade domain for this cluster upgrade.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> resumeClusterUpgradeAsync(String upgradeDomain, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(resumeClusterUpgradeWithServiceResponseAsync(upgradeDomain, timeout), serviceCallback);
    }

    /**
     * Make the cluster upgrade move on to the next upgrade domain.
     * Make the cluster code or configuration upgrade move on to the next upgrade domain if appropriate.
     *
     * @param upgradeDomain The next upgrade domain for this cluster upgrade.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> resumeClusterUpgradeAsync(String upgradeDomain, Long timeout) {
        return resumeClusterUpgradeWithServiceResponseAsync(upgradeDomain, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Make the cluster upgrade move on to the next upgrade domain.
     * Make the cluster code or configuration upgrade move on to the next upgrade domain if appropriate.
     *
     * @param upgradeDomain The next upgrade domain for this cluster upgrade.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> resumeClusterUpgradeWithServiceResponseAsync(String upgradeDomain, Long timeout) {
        if (upgradeDomain == null) {
            throw new IllegalArgumentException("Parameter upgradeDomain is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        ResumeClusterUpgradeDescription resumeClusterUpgradeDescription = new ResumeClusterUpgradeDescription();
        resumeClusterUpgradeDescription.withUpgradeDomain(upgradeDomain);
        return service.resumeClusterUpgrade(apiVersion, timeout, this.acceptLanguage(), resumeClusterUpgradeDescription, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = resumeClusterUpgradeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> resumeClusterUpgradeDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Start upgrading the code or configuration version of a Service Fabric cluster.
     * Validate the supplied upgrade parameters and start upgrading the code or configuration version of a Service Fabric cluster if the parameters are valid.
     *
     * @param startClusterUpgradeDescription Describes the parameters for starting a cluster upgrade.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void startClusterUpgrade(StartClusterUpgradeDescription startClusterUpgradeDescription) {
        startClusterUpgradeWithServiceResponseAsync(startClusterUpgradeDescription).toBlocking().single().body();
    }

    /**
     * Start upgrading the code or configuration version of a Service Fabric cluster.
     * Validate the supplied upgrade parameters and start upgrading the code or configuration version of a Service Fabric cluster if the parameters are valid.
     *
     * @param startClusterUpgradeDescription Describes the parameters for starting a cluster upgrade.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> startClusterUpgradeAsync(StartClusterUpgradeDescription startClusterUpgradeDescription, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(startClusterUpgradeWithServiceResponseAsync(startClusterUpgradeDescription), serviceCallback);
    }

    /**
     * Start upgrading the code or configuration version of a Service Fabric cluster.
     * Validate the supplied upgrade parameters and start upgrading the code or configuration version of a Service Fabric cluster if the parameters are valid.
     *
     * @param startClusterUpgradeDescription Describes the parameters for starting a cluster upgrade.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> startClusterUpgradeAsync(StartClusterUpgradeDescription startClusterUpgradeDescription) {
        return startClusterUpgradeWithServiceResponseAsync(startClusterUpgradeDescription).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Start upgrading the code or configuration version of a Service Fabric cluster.
     * Validate the supplied upgrade parameters and start upgrading the code or configuration version of a Service Fabric cluster if the parameters are valid.
     *
     * @param startClusterUpgradeDescription Describes the parameters for starting a cluster upgrade.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> startClusterUpgradeWithServiceResponseAsync(StartClusterUpgradeDescription startClusterUpgradeDescription) {
        if (startClusterUpgradeDescription == null) {
            throw new IllegalArgumentException("Parameter startClusterUpgradeDescription is required and cannot be null.");
        }
        Validator.validate(startClusterUpgradeDescription);
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.startClusterUpgrade(apiVersion, startClusterUpgradeDescription, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = startClusterUpgradeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Start upgrading the code or configuration version of a Service Fabric cluster.
     * Validate the supplied upgrade parameters and start upgrading the code or configuration version of a Service Fabric cluster if the parameters are valid.
     *
     * @param startClusterUpgradeDescription Describes the parameters for starting a cluster upgrade.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void startClusterUpgrade(StartClusterUpgradeDescription startClusterUpgradeDescription, Long timeout) {
        startClusterUpgradeWithServiceResponseAsync(startClusterUpgradeDescription, timeout).toBlocking().single().body();
    }

    /**
     * Start upgrading the code or configuration version of a Service Fabric cluster.
     * Validate the supplied upgrade parameters and start upgrading the code or configuration version of a Service Fabric cluster if the parameters are valid.
     *
     * @param startClusterUpgradeDescription Describes the parameters for starting a cluster upgrade.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> startClusterUpgradeAsync(StartClusterUpgradeDescription startClusterUpgradeDescription, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(startClusterUpgradeWithServiceResponseAsync(startClusterUpgradeDescription, timeout), serviceCallback);
    }

    /**
     * Start upgrading the code or configuration version of a Service Fabric cluster.
     * Validate the supplied upgrade parameters and start upgrading the code or configuration version of a Service Fabric cluster if the parameters are valid.
     *
     * @param startClusterUpgradeDescription Describes the parameters for starting a cluster upgrade.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> startClusterUpgradeAsync(StartClusterUpgradeDescription startClusterUpgradeDescription, Long timeout) {
        return startClusterUpgradeWithServiceResponseAsync(startClusterUpgradeDescription, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Start upgrading the code or configuration version of a Service Fabric cluster.
     * Validate the supplied upgrade parameters and start upgrading the code or configuration version of a Service Fabric cluster if the parameters are valid.
     *
     * @param startClusterUpgradeDescription Describes the parameters for starting a cluster upgrade.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> startClusterUpgradeWithServiceResponseAsync(StartClusterUpgradeDescription startClusterUpgradeDescription, Long timeout) {
        if (startClusterUpgradeDescription == null) {
            throw new IllegalArgumentException("Parameter startClusterUpgradeDescription is required and cannot be null.");
        }
        Validator.validate(startClusterUpgradeDescription);
        final String apiVersion = "6.0";
        return service.startClusterUpgrade(apiVersion, startClusterUpgradeDescription, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = startClusterUpgradeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> startClusterUpgradeDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Start upgrading the configuration of a Service Fabric standalone cluster.
     * Validate the supplied configuration upgrade parameters and start upgrading the cluster configuration if the parameters are valid.
     *
     * @param clusterConfigurationUpgradeDescription Parameters for a standalone cluster configuration upgrade.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void startClusterConfigurationUpgrade(ClusterConfigurationUpgradeDescription clusterConfigurationUpgradeDescription) {
        startClusterConfigurationUpgradeWithServiceResponseAsync(clusterConfigurationUpgradeDescription).toBlocking().single().body();
    }

    /**
     * Start upgrading the configuration of a Service Fabric standalone cluster.
     * Validate the supplied configuration upgrade parameters and start upgrading the cluster configuration if the parameters are valid.
     *
     * @param clusterConfigurationUpgradeDescription Parameters for a standalone cluster configuration upgrade.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> startClusterConfigurationUpgradeAsync(ClusterConfigurationUpgradeDescription clusterConfigurationUpgradeDescription, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(startClusterConfigurationUpgradeWithServiceResponseAsync(clusterConfigurationUpgradeDescription), serviceCallback);
    }

    /**
     * Start upgrading the configuration of a Service Fabric standalone cluster.
     * Validate the supplied configuration upgrade parameters and start upgrading the cluster configuration if the parameters are valid.
     *
     * @param clusterConfigurationUpgradeDescription Parameters for a standalone cluster configuration upgrade.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> startClusterConfigurationUpgradeAsync(ClusterConfigurationUpgradeDescription clusterConfigurationUpgradeDescription) {
        return startClusterConfigurationUpgradeWithServiceResponseAsync(clusterConfigurationUpgradeDescription).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Start upgrading the configuration of a Service Fabric standalone cluster.
     * Validate the supplied configuration upgrade parameters and start upgrading the cluster configuration if the parameters are valid.
     *
     * @param clusterConfigurationUpgradeDescription Parameters for a standalone cluster configuration upgrade.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> startClusterConfigurationUpgradeWithServiceResponseAsync(ClusterConfigurationUpgradeDescription clusterConfigurationUpgradeDescription) {
        if (clusterConfigurationUpgradeDescription == null) {
            throw new IllegalArgumentException("Parameter clusterConfigurationUpgradeDescription is required and cannot be null.");
        }
        Validator.validate(clusterConfigurationUpgradeDescription);
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.startClusterConfigurationUpgrade(apiVersion, clusterConfigurationUpgradeDescription, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = startClusterConfigurationUpgradeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Start upgrading the configuration of a Service Fabric standalone cluster.
     * Validate the supplied configuration upgrade parameters and start upgrading the cluster configuration if the parameters are valid.
     *
     * @param clusterConfigurationUpgradeDescription Parameters for a standalone cluster configuration upgrade.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void startClusterConfigurationUpgrade(ClusterConfigurationUpgradeDescription clusterConfigurationUpgradeDescription, Long timeout) {
        startClusterConfigurationUpgradeWithServiceResponseAsync(clusterConfigurationUpgradeDescription, timeout).toBlocking().single().body();
    }

    /**
     * Start upgrading the configuration of a Service Fabric standalone cluster.
     * Validate the supplied configuration upgrade parameters and start upgrading the cluster configuration if the parameters are valid.
     *
     * @param clusterConfigurationUpgradeDescription Parameters for a standalone cluster configuration upgrade.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> startClusterConfigurationUpgradeAsync(ClusterConfigurationUpgradeDescription clusterConfigurationUpgradeDescription, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(startClusterConfigurationUpgradeWithServiceResponseAsync(clusterConfigurationUpgradeDescription, timeout), serviceCallback);
    }

    /**
     * Start upgrading the configuration of a Service Fabric standalone cluster.
     * Validate the supplied configuration upgrade parameters and start upgrading the cluster configuration if the parameters are valid.
     *
     * @param clusterConfigurationUpgradeDescription Parameters for a standalone cluster configuration upgrade.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> startClusterConfigurationUpgradeAsync(ClusterConfigurationUpgradeDescription clusterConfigurationUpgradeDescription, Long timeout) {
        return startClusterConfigurationUpgradeWithServiceResponseAsync(clusterConfigurationUpgradeDescription, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Start upgrading the configuration of a Service Fabric standalone cluster.
     * Validate the supplied configuration upgrade parameters and start upgrading the cluster configuration if the parameters are valid.
     *
     * @param clusterConfigurationUpgradeDescription Parameters for a standalone cluster configuration upgrade.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> startClusterConfigurationUpgradeWithServiceResponseAsync(ClusterConfigurationUpgradeDescription clusterConfigurationUpgradeDescription, Long timeout) {
        if (clusterConfigurationUpgradeDescription == null) {
            throw new IllegalArgumentException("Parameter clusterConfigurationUpgradeDescription is required and cannot be null.");
        }
        Validator.validate(clusterConfigurationUpgradeDescription);
        final String apiVersion = "6.0";
        return service.startClusterConfigurationUpgrade(apiVersion, clusterConfigurationUpgradeDescription, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = startClusterConfigurationUpgradeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> startClusterConfigurationUpgradeDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Update the upgrade parameters of a Service Fabric cluster upgrade.
     * Update the upgrade parameters used during a Service Fabric cluster upgrade.
     *
     * @param updateClusterUpgradeDescription Parameters for updating a cluster upgrade.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void updateClusterUpgrade(UpdateClusterUpgradeDescription updateClusterUpgradeDescription) {
        updateClusterUpgradeWithServiceResponseAsync(updateClusterUpgradeDescription).toBlocking().single().body();
    }

    /**
     * Update the upgrade parameters of a Service Fabric cluster upgrade.
     * Update the upgrade parameters used during a Service Fabric cluster upgrade.
     *
     * @param updateClusterUpgradeDescription Parameters for updating a cluster upgrade.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> updateClusterUpgradeAsync(UpdateClusterUpgradeDescription updateClusterUpgradeDescription, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(updateClusterUpgradeWithServiceResponseAsync(updateClusterUpgradeDescription), serviceCallback);
    }

    /**
     * Update the upgrade parameters of a Service Fabric cluster upgrade.
     * Update the upgrade parameters used during a Service Fabric cluster upgrade.
     *
     * @param updateClusterUpgradeDescription Parameters for updating a cluster upgrade.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> updateClusterUpgradeAsync(UpdateClusterUpgradeDescription updateClusterUpgradeDescription) {
        return updateClusterUpgradeWithServiceResponseAsync(updateClusterUpgradeDescription).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Update the upgrade parameters of a Service Fabric cluster upgrade.
     * Update the upgrade parameters used during a Service Fabric cluster upgrade.
     *
     * @param updateClusterUpgradeDescription Parameters for updating a cluster upgrade.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> updateClusterUpgradeWithServiceResponseAsync(UpdateClusterUpgradeDescription updateClusterUpgradeDescription) {
        if (updateClusterUpgradeDescription == null) {
            throw new IllegalArgumentException("Parameter updateClusterUpgradeDescription is required and cannot be null.");
        }
        Validator.validate(updateClusterUpgradeDescription);
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.updateClusterUpgrade(apiVersion, updateClusterUpgradeDescription, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = updateClusterUpgradeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Update the upgrade parameters of a Service Fabric cluster upgrade.
     * Update the upgrade parameters used during a Service Fabric cluster upgrade.
     *
     * @param updateClusterUpgradeDescription Parameters for updating a cluster upgrade.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void updateClusterUpgrade(UpdateClusterUpgradeDescription updateClusterUpgradeDescription, Long timeout) {
        updateClusterUpgradeWithServiceResponseAsync(updateClusterUpgradeDescription, timeout).toBlocking().single().body();
    }

    /**
     * Update the upgrade parameters of a Service Fabric cluster upgrade.
     * Update the upgrade parameters used during a Service Fabric cluster upgrade.
     *
     * @param updateClusterUpgradeDescription Parameters for updating a cluster upgrade.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> updateClusterUpgradeAsync(UpdateClusterUpgradeDescription updateClusterUpgradeDescription, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(updateClusterUpgradeWithServiceResponseAsync(updateClusterUpgradeDescription, timeout), serviceCallback);
    }

    /**
     * Update the upgrade parameters of a Service Fabric cluster upgrade.
     * Update the upgrade parameters used during a Service Fabric cluster upgrade.
     *
     * @param updateClusterUpgradeDescription Parameters for updating a cluster upgrade.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> updateClusterUpgradeAsync(UpdateClusterUpgradeDescription updateClusterUpgradeDescription, Long timeout) {
        return updateClusterUpgradeWithServiceResponseAsync(updateClusterUpgradeDescription, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Update the upgrade parameters of a Service Fabric cluster upgrade.
     * Update the upgrade parameters used during a Service Fabric cluster upgrade.
     *
     * @param updateClusterUpgradeDescription Parameters for updating a cluster upgrade.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> updateClusterUpgradeWithServiceResponseAsync(UpdateClusterUpgradeDescription updateClusterUpgradeDescription, Long timeout) {
        if (updateClusterUpgradeDescription == null) {
            throw new IllegalArgumentException("Parameter updateClusterUpgradeDescription is required and cannot be null.");
        }
        Validator.validate(updateClusterUpgradeDescription);
        final String apiVersion = "6.0";
        return service.updateClusterUpgrade(apiVersion, updateClusterUpgradeDescription, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = updateClusterUpgradeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> updateClusterUpgradeDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the Azure Active Directory metadata used for secured connection to cluster.
     * Gets the Azure Active Directory metadata used for secured connection to cluster.
     This API is not supposed to be called separately. It provides information needed to set up an Azure Active Directory secured connection with a Service Fabric cluster.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the AadMetadataObjectInner object if successful.
     */
    public AadMetadataObjectInner getAadMetadata() {
        return getAadMetadataWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets the Azure Active Directory metadata used for secured connection to cluster.
     * Gets the Azure Active Directory metadata used for secured connection to cluster.
     This API is not supposed to be called separately. It provides information needed to set up an Azure Active Directory secured connection with a Service Fabric cluster.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<AadMetadataObjectInner> getAadMetadataAsync(final ServiceCallback<AadMetadataObjectInner> serviceCallback) {
        return ServiceFuture.fromResponse(getAadMetadataWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets the Azure Active Directory metadata used for secured connection to cluster.
     * Gets the Azure Active Directory metadata used for secured connection to cluster.
     This API is not supposed to be called separately. It provides information needed to set up an Azure Active Directory secured connection with a Service Fabric cluster.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the AadMetadataObjectInner object
     */
    public Observable<AadMetadataObjectInner> getAadMetadataAsync() {
        return getAadMetadataWithServiceResponseAsync().map(new Func1<ServiceResponse<AadMetadataObjectInner>, AadMetadataObjectInner>() {
            @Override
            public AadMetadataObjectInner call(ServiceResponse<AadMetadataObjectInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the Azure Active Directory metadata used for secured connection to cluster.
     * Gets the Azure Active Directory metadata used for secured connection to cluster.
     This API is not supposed to be called separately. It provides information needed to set up an Azure Active Directory secured connection with a Service Fabric cluster.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the AadMetadataObjectInner object
     */
    public Observable<ServiceResponse<AadMetadataObjectInner>> getAadMetadataWithServiceResponseAsync() {
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.getAadMetadata(apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<AadMetadataObjectInner>>>() {
                @Override
                public Observable<ServiceResponse<AadMetadataObjectInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<AadMetadataObjectInner> clientResponse = getAadMetadataDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the Azure Active Directory metadata used for secured connection to cluster.
     * Gets the Azure Active Directory metadata used for secured connection to cluster.
     This API is not supposed to be called separately. It provides information needed to set up an Azure Active Directory secured connection with a Service Fabric cluster.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the AadMetadataObjectInner object if successful.
     */
    public AadMetadataObjectInner getAadMetadata(Long timeout) {
        return getAadMetadataWithServiceResponseAsync(timeout).toBlocking().single().body();
    }

    /**
     * Gets the Azure Active Directory metadata used for secured connection to cluster.
     * Gets the Azure Active Directory metadata used for secured connection to cluster.
     This API is not supposed to be called separately. It provides information needed to set up an Azure Active Directory secured connection with a Service Fabric cluster.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<AadMetadataObjectInner> getAadMetadataAsync(Long timeout, final ServiceCallback<AadMetadataObjectInner> serviceCallback) {
        return ServiceFuture.fromResponse(getAadMetadataWithServiceResponseAsync(timeout), serviceCallback);
    }

    /**
     * Gets the Azure Active Directory metadata used for secured connection to cluster.
     * Gets the Azure Active Directory metadata used for secured connection to cluster.
     This API is not supposed to be called separately. It provides information needed to set up an Azure Active Directory secured connection with a Service Fabric cluster.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the AadMetadataObjectInner object
     */
    public Observable<AadMetadataObjectInner> getAadMetadataAsync(Long timeout) {
        return getAadMetadataWithServiceResponseAsync(timeout).map(new Func1<ServiceResponse<AadMetadataObjectInner>, AadMetadataObjectInner>() {
            @Override
            public AadMetadataObjectInner call(ServiceResponse<AadMetadataObjectInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the Azure Active Directory metadata used for secured connection to cluster.
     * Gets the Azure Active Directory metadata used for secured connection to cluster.
     This API is not supposed to be called separately. It provides information needed to set up an Azure Active Directory secured connection with a Service Fabric cluster.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the AadMetadataObjectInner object
     */
    public Observable<ServiceResponse<AadMetadataObjectInner>> getAadMetadataWithServiceResponseAsync(Long timeout) {
        final String apiVersion = "6.0";
        return service.getAadMetadata(apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<AadMetadataObjectInner>>>() {
                @Override
                public Observable<ServiceResponse<AadMetadataObjectInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<AadMetadataObjectInner> clientResponse = getAadMetadataDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<AadMetadataObjectInner> getAadMetadataDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException {
        return this.restClient().responseBuilderFactory().<AadMetadataObjectInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<AadMetadataObjectInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the list of nodes in the Service Fabric cluster.
     * The response includes the name, status, ID, health, uptime, and other details about the nodes.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedNodeInfoListInner object if successful.
     */
    public PagedNodeInfoListInner getNodeInfoList() {
        return getNodeInfoListWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets the list of nodes in the Service Fabric cluster.
     * The response includes the name, status, ID, health, uptime, and other details about the nodes.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedNodeInfoListInner> getNodeInfoListAsync(final ServiceCallback<PagedNodeInfoListInner> serviceCallback) {
        return ServiceFuture.fromResponse(getNodeInfoListWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets the list of nodes in the Service Fabric cluster.
     * The response includes the name, status, ID, health, uptime, and other details about the nodes.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedNodeInfoListInner object
     */
    public Observable<PagedNodeInfoListInner> getNodeInfoListAsync() {
        return getNodeInfoListWithServiceResponseAsync().map(new Func1<ServiceResponse<PagedNodeInfoListInner>, PagedNodeInfoListInner>() {
            @Override
            public PagedNodeInfoListInner call(ServiceResponse<PagedNodeInfoListInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the list of nodes in the Service Fabric cluster.
     * The response includes the name, status, ID, health, uptime, and other details about the nodes.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedNodeInfoListInner object
     */
    public Observable<ServiceResponse<PagedNodeInfoListInner>> getNodeInfoListWithServiceResponseAsync() {
        final String apiVersion = "6.3";
        final String continuationToken = null;
        final NodeStatusFilter nodeStatusFilter = null;
        final Long maxResults = null;
        final Long timeout = null;
        return service.getNodeInfoList(apiVersion, continuationToken, nodeStatusFilter, maxResults, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedNodeInfoListInner>>>() {
                @Override
                public Observable<ServiceResponse<PagedNodeInfoListInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedNodeInfoListInner> clientResponse = getNodeInfoListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the list of nodes in the Service Fabric cluster.
     * The response includes the name, status, ID, health, uptime, and other details about the nodes.
     *
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param nodeStatusFilter Allows filtering the nodes based on the NodeStatus. Only the nodes that are matching the specified filter value will be returned. The filter value can be one of the following. Possible values include: 'default', 'all', 'up', 'down', 'enabling', 'disabling', 'disabled', 'unknown', 'removed'
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedNodeInfoListInner object if successful.
     */
    public PagedNodeInfoListInner getNodeInfoList(String continuationToken, NodeStatusFilter nodeStatusFilter, Long maxResults, Long timeout) {
        return getNodeInfoListWithServiceResponseAsync(continuationToken, nodeStatusFilter, maxResults, timeout).toBlocking().single().body();
    }

    /**
     * Gets the list of nodes in the Service Fabric cluster.
     * The response includes the name, status, ID, health, uptime, and other details about the nodes.
     *
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param nodeStatusFilter Allows filtering the nodes based on the NodeStatus. Only the nodes that are matching the specified filter value will be returned. The filter value can be one of the following. Possible values include: 'default', 'all', 'up', 'down', 'enabling', 'disabling', 'disabled', 'unknown', 'removed'
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedNodeInfoListInner> getNodeInfoListAsync(String continuationToken, NodeStatusFilter nodeStatusFilter, Long maxResults, Long timeout, final ServiceCallback<PagedNodeInfoListInner> serviceCallback) {
        return ServiceFuture.fromResponse(getNodeInfoListWithServiceResponseAsync(continuationToken, nodeStatusFilter, maxResults, timeout), serviceCallback);
    }

    /**
     * Gets the list of nodes in the Service Fabric cluster.
     * The response includes the name, status, ID, health, uptime, and other details about the nodes.
     *
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param nodeStatusFilter Allows filtering the nodes based on the NodeStatus. Only the nodes that are matching the specified filter value will be returned. The filter value can be one of the following. Possible values include: 'default', 'all', 'up', 'down', 'enabling', 'disabling', 'disabled', 'unknown', 'removed'
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedNodeInfoListInner object
     */
    public Observable<PagedNodeInfoListInner> getNodeInfoListAsync(String continuationToken, NodeStatusFilter nodeStatusFilter, Long maxResults, Long timeout) {
        return getNodeInfoListWithServiceResponseAsync(continuationToken, nodeStatusFilter, maxResults, timeout).map(new Func1<ServiceResponse<PagedNodeInfoListInner>, PagedNodeInfoListInner>() {
            @Override
            public PagedNodeInfoListInner call(ServiceResponse<PagedNodeInfoListInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the list of nodes in the Service Fabric cluster.
     * The response includes the name, status, ID, health, uptime, and other details about the nodes.
     *
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param nodeStatusFilter Allows filtering the nodes based on the NodeStatus. Only the nodes that are matching the specified filter value will be returned. The filter value can be one of the following. Possible values include: 'default', 'all', 'up', 'down', 'enabling', 'disabling', 'disabled', 'unknown', 'removed'
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedNodeInfoListInner object
     */
    public Observable<ServiceResponse<PagedNodeInfoListInner>> getNodeInfoListWithServiceResponseAsync(String continuationToken, NodeStatusFilter nodeStatusFilter, Long maxResults, Long timeout) {
        final String apiVersion = "6.3";
        return service.getNodeInfoList(apiVersion, continuationToken, nodeStatusFilter, maxResults, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedNodeInfoListInner>>>() {
                @Override
                public Observable<ServiceResponse<PagedNodeInfoListInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedNodeInfoListInner> clientResponse = getNodeInfoListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PagedNodeInfoListInner> getNodeInfoListDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException {
        return this.restClient().responseBuilderFactory().<PagedNodeInfoListInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PagedNodeInfoListInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the information about a specific node in the Service Fabric cluster.
     * The response includes the name, status, ID, health, uptime, and other details about the node.
     *
     * @param nodeName The name of the node.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the NodeInfoInner object if successful.
     */
    public NodeInfoInner getNodeInfo(String nodeName) {
        return getNodeInfoWithServiceResponseAsync(nodeName).toBlocking().single().body();
    }

    /**
     * Gets the information about a specific node in the Service Fabric cluster.
     * The response includes the name, status, ID, health, uptime, and other details about the node.
     *
     * @param nodeName The name of the node.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<NodeInfoInner> getNodeInfoAsync(String nodeName, final ServiceCallback<NodeInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getNodeInfoWithServiceResponseAsync(nodeName), serviceCallback);
    }

    /**
     * Gets the information about a specific node in the Service Fabric cluster.
     * The response includes the name, status, ID, health, uptime, and other details about the node.
     *
     * @param nodeName The name of the node.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the NodeInfoInner object
     */
    public Observable<NodeInfoInner> getNodeInfoAsync(String nodeName) {
        return getNodeInfoWithServiceResponseAsync(nodeName).map(new Func1<ServiceResponse<NodeInfoInner>, NodeInfoInner>() {
            @Override
            public NodeInfoInner call(ServiceResponse<NodeInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the information about a specific node in the Service Fabric cluster.
     * The response includes the name, status, ID, health, uptime, and other details about the node.
     *
     * @param nodeName The name of the node.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the NodeInfoInner object
     */
    public Observable<ServiceResponse<NodeInfoInner>> getNodeInfoWithServiceResponseAsync(String nodeName) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.getNodeInfo(nodeName, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<NodeInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<NodeInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<NodeInfoInner> clientResponse = getNodeInfoDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the information about a specific node in the Service Fabric cluster.
     * The response includes the name, status, ID, health, uptime, and other details about the node.
     *
     * @param nodeName The name of the node.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the NodeInfoInner object if successful.
     */
    public NodeInfoInner getNodeInfo(String nodeName, Long timeout) {
        return getNodeInfoWithServiceResponseAsync(nodeName, timeout).toBlocking().single().body();
    }

    /**
     * Gets the information about a specific node in the Service Fabric cluster.
     * The response includes the name, status, ID, health, uptime, and other details about the node.
     *
     * @param nodeName The name of the node.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<NodeInfoInner> getNodeInfoAsync(String nodeName, Long timeout, final ServiceCallback<NodeInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getNodeInfoWithServiceResponseAsync(nodeName, timeout), serviceCallback);
    }

    /**
     * Gets the information about a specific node in the Service Fabric cluster.
     * The response includes the name, status, ID, health, uptime, and other details about the node.
     *
     * @param nodeName The name of the node.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the NodeInfoInner object
     */
    public Observable<NodeInfoInner> getNodeInfoAsync(String nodeName, Long timeout) {
        return getNodeInfoWithServiceResponseAsync(nodeName, timeout).map(new Func1<ServiceResponse<NodeInfoInner>, NodeInfoInner>() {
            @Override
            public NodeInfoInner call(ServiceResponse<NodeInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the information about a specific node in the Service Fabric cluster.
     * The response includes the name, status, ID, health, uptime, and other details about the node.
     *
     * @param nodeName The name of the node.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the NodeInfoInner object
     */
    public Observable<ServiceResponse<NodeInfoInner>> getNodeInfoWithServiceResponseAsync(String nodeName, Long timeout) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.getNodeInfo(nodeName, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<NodeInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<NodeInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<NodeInfoInner> clientResponse = getNodeInfoDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<NodeInfoInner> getNodeInfoDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<NodeInfoInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<NodeInfoInner>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the health of a Service Fabric node.
     * Gets the health of a Service Fabric node. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. If the node that you specify by name does not exist in the health store, this returns an error.
     *
     * @param nodeName The name of the node.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the NodeHealthInner object if successful.
     */
    public NodeHealthInner getNodeHealth(String nodeName) {
        return getNodeHealthWithServiceResponseAsync(nodeName).toBlocking().single().body();
    }

    /**
     * Gets the health of a Service Fabric node.
     * Gets the health of a Service Fabric node. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. If the node that you specify by name does not exist in the health store, this returns an error.
     *
     * @param nodeName The name of the node.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<NodeHealthInner> getNodeHealthAsync(String nodeName, final ServiceCallback<NodeHealthInner> serviceCallback) {
        return ServiceFuture.fromResponse(getNodeHealthWithServiceResponseAsync(nodeName), serviceCallback);
    }

    /**
     * Gets the health of a Service Fabric node.
     * Gets the health of a Service Fabric node. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. If the node that you specify by name does not exist in the health store, this returns an error.
     *
     * @param nodeName The name of the node.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the NodeHealthInner object
     */
    public Observable<NodeHealthInner> getNodeHealthAsync(String nodeName) {
        return getNodeHealthWithServiceResponseAsync(nodeName).map(new Func1<ServiceResponse<NodeHealthInner>, NodeHealthInner>() {
            @Override
            public NodeHealthInner call(ServiceResponse<NodeHealthInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the health of a Service Fabric node.
     * Gets the health of a Service Fabric node. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. If the node that you specify by name does not exist in the health store, this returns an error.
     *
     * @param nodeName The name of the node.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the NodeHealthInner object
     */
    public Observable<ServiceResponse<NodeHealthInner>> getNodeHealthWithServiceResponseAsync(String nodeName) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Integer eventsHealthStateFilter = null;
        final Long timeout = null;
        return service.getNodeHealth(nodeName, apiVersion, eventsHealthStateFilter, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<NodeHealthInner>>>() {
                @Override
                public Observable<ServiceResponse<NodeHealthInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<NodeHealthInner> clientResponse = getNodeHealthDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the health of a Service Fabric node.
     * Gets the health of a Service Fabric node. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. If the node that you specify by name does not exist in the health store, this returns an error.
     *
     * @param nodeName The name of the node.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the NodeHealthInner object if successful.
     */
    public NodeHealthInner getNodeHealth(String nodeName, Integer eventsHealthStateFilter, Long timeout) {
        return getNodeHealthWithServiceResponseAsync(nodeName, eventsHealthStateFilter, timeout).toBlocking().single().body();
    }

    /**
     * Gets the health of a Service Fabric node.
     * Gets the health of a Service Fabric node. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. If the node that you specify by name does not exist in the health store, this returns an error.
     *
     * @param nodeName The name of the node.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<NodeHealthInner> getNodeHealthAsync(String nodeName, Integer eventsHealthStateFilter, Long timeout, final ServiceCallback<NodeHealthInner> serviceCallback) {
        return ServiceFuture.fromResponse(getNodeHealthWithServiceResponseAsync(nodeName, eventsHealthStateFilter, timeout), serviceCallback);
    }

    /**
     * Gets the health of a Service Fabric node.
     * Gets the health of a Service Fabric node. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. If the node that you specify by name does not exist in the health store, this returns an error.
     *
     * @param nodeName The name of the node.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the NodeHealthInner object
     */
    public Observable<NodeHealthInner> getNodeHealthAsync(String nodeName, Integer eventsHealthStateFilter, Long timeout) {
        return getNodeHealthWithServiceResponseAsync(nodeName, eventsHealthStateFilter, timeout).map(new Func1<ServiceResponse<NodeHealthInner>, NodeHealthInner>() {
            @Override
            public NodeHealthInner call(ServiceResponse<NodeHealthInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the health of a Service Fabric node.
     * Gets the health of a Service Fabric node. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. If the node that you specify by name does not exist in the health store, this returns an error.
     *
     * @param nodeName The name of the node.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the NodeHealthInner object
     */
    public Observable<ServiceResponse<NodeHealthInner>> getNodeHealthWithServiceResponseAsync(String nodeName, Integer eventsHealthStateFilter, Long timeout) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.getNodeHealth(nodeName, apiVersion, eventsHealthStateFilter, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<NodeHealthInner>>>() {
                @Override
                public Observable<ServiceResponse<NodeHealthInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<NodeHealthInner> clientResponse = getNodeHealthDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<NodeHealthInner> getNodeHealthDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<NodeHealthInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<NodeHealthInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the health of a Service Fabric node, by using the specified health policy.
     * Gets the health of a Service Fabric node. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. Use ClusterHealthPolicy in the POST body to override the health policies used to evaluate the health. If the node that you specify by name does not exist in the health store, this returns an error.
     *
     * @param nodeName The name of the node.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the NodeHealthInner object if successful.
     */
    public NodeHealthInner getNodeHealthUsingPolicy(String nodeName) {
        return getNodeHealthUsingPolicyWithServiceResponseAsync(nodeName).toBlocking().single().body();
    }

    /**
     * Gets the health of a Service Fabric node, by using the specified health policy.
     * Gets the health of a Service Fabric node. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. Use ClusterHealthPolicy in the POST body to override the health policies used to evaluate the health. If the node that you specify by name does not exist in the health store, this returns an error.
     *
     * @param nodeName The name of the node.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<NodeHealthInner> getNodeHealthUsingPolicyAsync(String nodeName, final ServiceCallback<NodeHealthInner> serviceCallback) {
        return ServiceFuture.fromResponse(getNodeHealthUsingPolicyWithServiceResponseAsync(nodeName), serviceCallback);
    }

    /**
     * Gets the health of a Service Fabric node, by using the specified health policy.
     * Gets the health of a Service Fabric node. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. Use ClusterHealthPolicy in the POST body to override the health policies used to evaluate the health. If the node that you specify by name does not exist in the health store, this returns an error.
     *
     * @param nodeName The name of the node.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the NodeHealthInner object
     */
    public Observable<NodeHealthInner> getNodeHealthUsingPolicyAsync(String nodeName) {
        return getNodeHealthUsingPolicyWithServiceResponseAsync(nodeName).map(new Func1<ServiceResponse<NodeHealthInner>, NodeHealthInner>() {
            @Override
            public NodeHealthInner call(ServiceResponse<NodeHealthInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the health of a Service Fabric node, by using the specified health policy.
     * Gets the health of a Service Fabric node. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. Use ClusterHealthPolicy in the POST body to override the health policies used to evaluate the health. If the node that you specify by name does not exist in the health store, this returns an error.
     *
     * @param nodeName The name of the node.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the NodeHealthInner object
     */
    public Observable<ServiceResponse<NodeHealthInner>> getNodeHealthUsingPolicyWithServiceResponseAsync(String nodeName) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Integer eventsHealthStateFilter = null;
        final ClusterHealthPolicy clusterHealthPolicy = null;
        final Long timeout = null;
        return service.getNodeHealthUsingPolicy(nodeName, apiVersion, eventsHealthStateFilter, clusterHealthPolicy, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<NodeHealthInner>>>() {
                @Override
                public Observable<ServiceResponse<NodeHealthInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<NodeHealthInner> clientResponse = getNodeHealthUsingPolicyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the health of a Service Fabric node, by using the specified health policy.
     * Gets the health of a Service Fabric node. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. Use ClusterHealthPolicy in the POST body to override the health policies used to evaluate the health. If the node that you specify by name does not exist in the health store, this returns an error.
     *
     * @param nodeName The name of the node.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param clusterHealthPolicy Describes the health policies used to evaluate the health of a cluster or node. If not present, the health evaluation uses the health policy from cluster manifest or the default health policy.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the NodeHealthInner object if successful.
     */
    public NodeHealthInner getNodeHealthUsingPolicy(String nodeName, Integer eventsHealthStateFilter, ClusterHealthPolicy clusterHealthPolicy, Long timeout) {
        return getNodeHealthUsingPolicyWithServiceResponseAsync(nodeName, eventsHealthStateFilter, clusterHealthPolicy, timeout).toBlocking().single().body();
    }

    /**
     * Gets the health of a Service Fabric node, by using the specified health policy.
     * Gets the health of a Service Fabric node. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. Use ClusterHealthPolicy in the POST body to override the health policies used to evaluate the health. If the node that you specify by name does not exist in the health store, this returns an error.
     *
     * @param nodeName The name of the node.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param clusterHealthPolicy Describes the health policies used to evaluate the health of a cluster or node. If not present, the health evaluation uses the health policy from cluster manifest or the default health policy.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<NodeHealthInner> getNodeHealthUsingPolicyAsync(String nodeName, Integer eventsHealthStateFilter, ClusterHealthPolicy clusterHealthPolicy, Long timeout, final ServiceCallback<NodeHealthInner> serviceCallback) {
        return ServiceFuture.fromResponse(getNodeHealthUsingPolicyWithServiceResponseAsync(nodeName, eventsHealthStateFilter, clusterHealthPolicy, timeout), serviceCallback);
    }

    /**
     * Gets the health of a Service Fabric node, by using the specified health policy.
     * Gets the health of a Service Fabric node. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. Use ClusterHealthPolicy in the POST body to override the health policies used to evaluate the health. If the node that you specify by name does not exist in the health store, this returns an error.
     *
     * @param nodeName The name of the node.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param clusterHealthPolicy Describes the health policies used to evaluate the health of a cluster or node. If not present, the health evaluation uses the health policy from cluster manifest or the default health policy.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the NodeHealthInner object
     */
    public Observable<NodeHealthInner> getNodeHealthUsingPolicyAsync(String nodeName, Integer eventsHealthStateFilter, ClusterHealthPolicy clusterHealthPolicy, Long timeout) {
        return getNodeHealthUsingPolicyWithServiceResponseAsync(nodeName, eventsHealthStateFilter, clusterHealthPolicy, timeout).map(new Func1<ServiceResponse<NodeHealthInner>, NodeHealthInner>() {
            @Override
            public NodeHealthInner call(ServiceResponse<NodeHealthInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the health of a Service Fabric node, by using the specified health policy.
     * Gets the health of a Service Fabric node. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. Use ClusterHealthPolicy in the POST body to override the health policies used to evaluate the health. If the node that you specify by name does not exist in the health store, this returns an error.
     *
     * @param nodeName The name of the node.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param clusterHealthPolicy Describes the health policies used to evaluate the health of a cluster or node. If not present, the health evaluation uses the health policy from cluster manifest or the default health policy.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the NodeHealthInner object
     */
    public Observable<ServiceResponse<NodeHealthInner>> getNodeHealthUsingPolicyWithServiceResponseAsync(String nodeName, Integer eventsHealthStateFilter, ClusterHealthPolicy clusterHealthPolicy, Long timeout) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        Validator.validate(clusterHealthPolicy);
        final String apiVersion = "6.0";
        return service.getNodeHealthUsingPolicy(nodeName, apiVersion, eventsHealthStateFilter, clusterHealthPolicy, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<NodeHealthInner>>>() {
                @Override
                public Observable<ServiceResponse<NodeHealthInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<NodeHealthInner> clientResponse = getNodeHealthUsingPolicyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<NodeHealthInner> getNodeHealthUsingPolicyDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<NodeHealthInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<NodeHealthInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Sends a health report on the Service Fabric node.
     * Reports health state of the specified Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway node, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, run GetNodeHealth and check that the report appears in the HealthEvents section.
     *
     * @param nodeName The name of the node.
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void reportNodeHealth(String nodeName, HealthInformation healthInformation) {
        reportNodeHealthWithServiceResponseAsync(nodeName, healthInformation).toBlocking().single().body();
    }

    /**
     * Sends a health report on the Service Fabric node.
     * Reports health state of the specified Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway node, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, run GetNodeHealth and check that the report appears in the HealthEvents section.
     *
     * @param nodeName The name of the node.
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> reportNodeHealthAsync(String nodeName, HealthInformation healthInformation, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(reportNodeHealthWithServiceResponseAsync(nodeName, healthInformation), serviceCallback);
    }

    /**
     * Sends a health report on the Service Fabric node.
     * Reports health state of the specified Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway node, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, run GetNodeHealth and check that the report appears in the HealthEvents section.
     *
     * @param nodeName The name of the node.
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> reportNodeHealthAsync(String nodeName, HealthInformation healthInformation) {
        return reportNodeHealthWithServiceResponseAsync(nodeName, healthInformation).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Sends a health report on the Service Fabric node.
     * Reports health state of the specified Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway node, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, run GetNodeHealth and check that the report appears in the HealthEvents section.
     *
     * @param nodeName The name of the node.
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> reportNodeHealthWithServiceResponseAsync(String nodeName, HealthInformation healthInformation) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (healthInformation == null) {
            throw new IllegalArgumentException("Parameter healthInformation is required and cannot be null.");
        }
        Validator.validate(healthInformation);
        final String apiVersion = "6.0";
        final Boolean immediate = null;
        final Long timeout = null;
        return service.reportNodeHealth(nodeName, apiVersion, healthInformation, immediate, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = reportNodeHealthDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Sends a health report on the Service Fabric node.
     * Reports health state of the specified Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway node, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, run GetNodeHealth and check that the report appears in the HealthEvents section.
     *
     * @param nodeName The name of the node.
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @param immediate A flag that indicates whether the report should be sent immediately.
     A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
     If Immediate is set to true, the report is sent immediately from HTTP Gateway to the health store, regardless of the fabric client settings that the HTTP Gateway Application is using.
     This is useful for critical reports that should be sent as soon as possible.
     Depending on timing and other conditions, sending the report may still fail, for example if the HTTP Gateway is closed or the message doesn't reach the Gateway.
     If Immediate is set to false, the report is sent based on the health client settings from the HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
     This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
     By default, reports are not sent immediately.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void reportNodeHealth(String nodeName, HealthInformation healthInformation, Boolean immediate, Long timeout) {
        reportNodeHealthWithServiceResponseAsync(nodeName, healthInformation, immediate, timeout).toBlocking().single().body();
    }

    /**
     * Sends a health report on the Service Fabric node.
     * Reports health state of the specified Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway node, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, run GetNodeHealth and check that the report appears in the HealthEvents section.
     *
     * @param nodeName The name of the node.
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @param immediate A flag that indicates whether the report should be sent immediately.
     A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
     If Immediate is set to true, the report is sent immediately from HTTP Gateway to the health store, regardless of the fabric client settings that the HTTP Gateway Application is using.
     This is useful for critical reports that should be sent as soon as possible.
     Depending on timing and other conditions, sending the report may still fail, for example if the HTTP Gateway is closed or the message doesn't reach the Gateway.
     If Immediate is set to false, the report is sent based on the health client settings from the HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
     This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
     By default, reports are not sent immediately.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> reportNodeHealthAsync(String nodeName, HealthInformation healthInformation, Boolean immediate, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(reportNodeHealthWithServiceResponseAsync(nodeName, healthInformation, immediate, timeout), serviceCallback);
    }

    /**
     * Sends a health report on the Service Fabric node.
     * Reports health state of the specified Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway node, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, run GetNodeHealth and check that the report appears in the HealthEvents section.
     *
     * @param nodeName The name of the node.
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @param immediate A flag that indicates whether the report should be sent immediately.
     A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
     If Immediate is set to true, the report is sent immediately from HTTP Gateway to the health store, regardless of the fabric client settings that the HTTP Gateway Application is using.
     This is useful for critical reports that should be sent as soon as possible.
     Depending on timing and other conditions, sending the report may still fail, for example if the HTTP Gateway is closed or the message doesn't reach the Gateway.
     If Immediate is set to false, the report is sent based on the health client settings from the HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
     This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
     By default, reports are not sent immediately.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> reportNodeHealthAsync(String nodeName, HealthInformation healthInformation, Boolean immediate, Long timeout) {
        return reportNodeHealthWithServiceResponseAsync(nodeName, healthInformation, immediate, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Sends a health report on the Service Fabric node.
     * Reports health state of the specified Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway node, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, run GetNodeHealth and check that the report appears in the HealthEvents section.
     *
     * @param nodeName The name of the node.
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @param immediate A flag that indicates whether the report should be sent immediately.
     A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
     If Immediate is set to true, the report is sent immediately from HTTP Gateway to the health store, regardless of the fabric client settings that the HTTP Gateway Application is using.
     This is useful for critical reports that should be sent as soon as possible.
     Depending on timing and other conditions, sending the report may still fail, for example if the HTTP Gateway is closed or the message doesn't reach the Gateway.
     If Immediate is set to false, the report is sent based on the health client settings from the HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
     This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
     By default, reports are not sent immediately.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> reportNodeHealthWithServiceResponseAsync(String nodeName, HealthInformation healthInformation, Boolean immediate, Long timeout) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (healthInformation == null) {
            throw new IllegalArgumentException("Parameter healthInformation is required and cannot be null.");
        }
        Validator.validate(healthInformation);
        final String apiVersion = "6.0";
        return service.reportNodeHealth(nodeName, apiVersion, healthInformation, immediate, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = reportNodeHealthDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> reportNodeHealthDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the load information of a Service Fabric node.
     * Retrieves the load information of a Service Fabric node for all the metrics that have load or capacity defined.
     *
     * @param nodeName The name of the node.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the NodeLoadInfoInner object if successful.
     */
    public NodeLoadInfoInner getNodeLoadInfo(String nodeName) {
        return getNodeLoadInfoWithServiceResponseAsync(nodeName).toBlocking().single().body();
    }

    /**
     * Gets the load information of a Service Fabric node.
     * Retrieves the load information of a Service Fabric node for all the metrics that have load or capacity defined.
     *
     * @param nodeName The name of the node.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<NodeLoadInfoInner> getNodeLoadInfoAsync(String nodeName, final ServiceCallback<NodeLoadInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getNodeLoadInfoWithServiceResponseAsync(nodeName), serviceCallback);
    }

    /**
     * Gets the load information of a Service Fabric node.
     * Retrieves the load information of a Service Fabric node for all the metrics that have load or capacity defined.
     *
     * @param nodeName The name of the node.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the NodeLoadInfoInner object
     */
    public Observable<NodeLoadInfoInner> getNodeLoadInfoAsync(String nodeName) {
        return getNodeLoadInfoWithServiceResponseAsync(nodeName).map(new Func1<ServiceResponse<NodeLoadInfoInner>, NodeLoadInfoInner>() {
            @Override
            public NodeLoadInfoInner call(ServiceResponse<NodeLoadInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the load information of a Service Fabric node.
     * Retrieves the load information of a Service Fabric node for all the metrics that have load or capacity defined.
     *
     * @param nodeName The name of the node.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the NodeLoadInfoInner object
     */
    public Observable<ServiceResponse<NodeLoadInfoInner>> getNodeLoadInfoWithServiceResponseAsync(String nodeName) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.getNodeLoadInfo(nodeName, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<NodeLoadInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<NodeLoadInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<NodeLoadInfoInner> clientResponse = getNodeLoadInfoDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the load information of a Service Fabric node.
     * Retrieves the load information of a Service Fabric node for all the metrics that have load or capacity defined.
     *
     * @param nodeName The name of the node.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the NodeLoadInfoInner object if successful.
     */
    public NodeLoadInfoInner getNodeLoadInfo(String nodeName, Long timeout) {
        return getNodeLoadInfoWithServiceResponseAsync(nodeName, timeout).toBlocking().single().body();
    }

    /**
     * Gets the load information of a Service Fabric node.
     * Retrieves the load information of a Service Fabric node for all the metrics that have load or capacity defined.
     *
     * @param nodeName The name of the node.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<NodeLoadInfoInner> getNodeLoadInfoAsync(String nodeName, Long timeout, final ServiceCallback<NodeLoadInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getNodeLoadInfoWithServiceResponseAsync(nodeName, timeout), serviceCallback);
    }

    /**
     * Gets the load information of a Service Fabric node.
     * Retrieves the load information of a Service Fabric node for all the metrics that have load or capacity defined.
     *
     * @param nodeName The name of the node.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the NodeLoadInfoInner object
     */
    public Observable<NodeLoadInfoInner> getNodeLoadInfoAsync(String nodeName, Long timeout) {
        return getNodeLoadInfoWithServiceResponseAsync(nodeName, timeout).map(new Func1<ServiceResponse<NodeLoadInfoInner>, NodeLoadInfoInner>() {
            @Override
            public NodeLoadInfoInner call(ServiceResponse<NodeLoadInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the load information of a Service Fabric node.
     * Retrieves the load information of a Service Fabric node for all the metrics that have load or capacity defined.
     *
     * @param nodeName The name of the node.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the NodeLoadInfoInner object
     */
    public Observable<ServiceResponse<NodeLoadInfoInner>> getNodeLoadInfoWithServiceResponseAsync(String nodeName, Long timeout) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.getNodeLoadInfo(nodeName, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<NodeLoadInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<NodeLoadInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<NodeLoadInfoInner> clientResponse = getNodeLoadInfoDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<NodeLoadInfoInner> getNodeLoadInfoDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<NodeLoadInfoInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<NodeLoadInfoInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Deactivate a Service Fabric cluster node with the specified deactivation intent.
     * Deactivate a Service Fabric cluster node with the specified deactivation intent. Once the deactivation is in progress, the deactivation intent can be increased, but not decreased (for example, a node that is deactivated with the Pause intent can be deactivated further with Restart, but not the other way around. Nodes may be reactivated using the Activate a node operation any time after they are deactivated. If the deactivation is not complete, this will cancel the deactivation. A node that goes down and comes back up while deactivated will still need to be reactivated before services will be placed on that node.
     *
     * @param nodeName The name of the node.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void disableNode(String nodeName) {
        disableNodeWithServiceResponseAsync(nodeName).toBlocking().single().body();
    }

    /**
     * Deactivate a Service Fabric cluster node with the specified deactivation intent.
     * Deactivate a Service Fabric cluster node with the specified deactivation intent. Once the deactivation is in progress, the deactivation intent can be increased, but not decreased (for example, a node that is deactivated with the Pause intent can be deactivated further with Restart, but not the other way around. Nodes may be reactivated using the Activate a node operation any time after they are deactivated. If the deactivation is not complete, this will cancel the deactivation. A node that goes down and comes back up while deactivated will still need to be reactivated before services will be placed on that node.
     *
     * @param nodeName The name of the node.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> disableNodeAsync(String nodeName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(disableNodeWithServiceResponseAsync(nodeName), serviceCallback);
    }

    /**
     * Deactivate a Service Fabric cluster node with the specified deactivation intent.
     * Deactivate a Service Fabric cluster node with the specified deactivation intent. Once the deactivation is in progress, the deactivation intent can be increased, but not decreased (for example, a node that is deactivated with the Pause intent can be deactivated further with Restart, but not the other way around. Nodes may be reactivated using the Activate a node operation any time after they are deactivated. If the deactivation is not complete, this will cancel the deactivation. A node that goes down and comes back up while deactivated will still need to be reactivated before services will be placed on that node.
     *
     * @param nodeName The name of the node.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> disableNodeAsync(String nodeName) {
        return disableNodeWithServiceResponseAsync(nodeName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deactivate a Service Fabric cluster node with the specified deactivation intent.
     * Deactivate a Service Fabric cluster node with the specified deactivation intent. Once the deactivation is in progress, the deactivation intent can be increased, but not decreased (for example, a node that is deactivated with the Pause intent can be deactivated further with Restart, but not the other way around. Nodes may be reactivated using the Activate a node operation any time after they are deactivated. If the deactivation is not complete, this will cancel the deactivation. A node that goes down and comes back up while deactivated will still need to be reactivated before services will be placed on that node.
     *
     * @param nodeName The name of the node.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> disableNodeWithServiceResponseAsync(String nodeName) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        final DeactivationIntent deactivationIntent = null;
        DeactivationIntentDescription deactivationIntentDescription = new DeactivationIntentDescription();
        deactivationIntentDescription.withDeactivationIntent(null);
        return service.disableNode(nodeName, apiVersion, timeout, this.acceptLanguage(), deactivationIntentDescription, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = disableNodeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Deactivate a Service Fabric cluster node with the specified deactivation intent.
     * Deactivate a Service Fabric cluster node with the specified deactivation intent. Once the deactivation is in progress, the deactivation intent can be increased, but not decreased (for example, a node that is deactivated with the Pause intent can be deactivated further with Restart, but not the other way around. Nodes may be reactivated using the Activate a node operation any time after they are deactivated. If the deactivation is not complete, this will cancel the deactivation. A node that goes down and comes back up while deactivated will still need to be reactivated before services will be placed on that node.
     *
     * @param nodeName The name of the node.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param deactivationIntent Describes the intent or reason for deactivating the node. The possible values are following. Possible values include: 'Pause', 'Restart', 'RemoveData'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void disableNode(String nodeName, Long timeout, DeactivationIntent deactivationIntent) {
        disableNodeWithServiceResponseAsync(nodeName, timeout, deactivationIntent).toBlocking().single().body();
    }

    /**
     * Deactivate a Service Fabric cluster node with the specified deactivation intent.
     * Deactivate a Service Fabric cluster node with the specified deactivation intent. Once the deactivation is in progress, the deactivation intent can be increased, but not decreased (for example, a node that is deactivated with the Pause intent can be deactivated further with Restart, but not the other way around. Nodes may be reactivated using the Activate a node operation any time after they are deactivated. If the deactivation is not complete, this will cancel the deactivation. A node that goes down and comes back up while deactivated will still need to be reactivated before services will be placed on that node.
     *
     * @param nodeName The name of the node.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param deactivationIntent Describes the intent or reason for deactivating the node. The possible values are following. Possible values include: 'Pause', 'Restart', 'RemoveData'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> disableNodeAsync(String nodeName, Long timeout, DeactivationIntent deactivationIntent, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(disableNodeWithServiceResponseAsync(nodeName, timeout, deactivationIntent), serviceCallback);
    }

    /**
     * Deactivate a Service Fabric cluster node with the specified deactivation intent.
     * Deactivate a Service Fabric cluster node with the specified deactivation intent. Once the deactivation is in progress, the deactivation intent can be increased, but not decreased (for example, a node that is deactivated with the Pause intent can be deactivated further with Restart, but not the other way around. Nodes may be reactivated using the Activate a node operation any time after they are deactivated. If the deactivation is not complete, this will cancel the deactivation. A node that goes down and comes back up while deactivated will still need to be reactivated before services will be placed on that node.
     *
     * @param nodeName The name of the node.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param deactivationIntent Describes the intent or reason for deactivating the node. The possible values are following. Possible values include: 'Pause', 'Restart', 'RemoveData'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> disableNodeAsync(String nodeName, Long timeout, DeactivationIntent deactivationIntent) {
        return disableNodeWithServiceResponseAsync(nodeName, timeout, deactivationIntent).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deactivate a Service Fabric cluster node with the specified deactivation intent.
     * Deactivate a Service Fabric cluster node with the specified deactivation intent. Once the deactivation is in progress, the deactivation intent can be increased, but not decreased (for example, a node that is deactivated with the Pause intent can be deactivated further with Restart, but not the other way around. Nodes may be reactivated using the Activate a node operation any time after they are deactivated. If the deactivation is not complete, this will cancel the deactivation. A node that goes down and comes back up while deactivated will still need to be reactivated before services will be placed on that node.
     *
     * @param nodeName The name of the node.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param deactivationIntent Describes the intent or reason for deactivating the node. The possible values are following. Possible values include: 'Pause', 'Restart', 'RemoveData'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> disableNodeWithServiceResponseAsync(String nodeName, Long timeout, DeactivationIntent deactivationIntent) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        DeactivationIntentDescription deactivationIntentDescription = new DeactivationIntentDescription();
        deactivationIntentDescription.withDeactivationIntent(deactivationIntent);
        return service.disableNode(nodeName, apiVersion, timeout, this.acceptLanguage(), deactivationIntentDescription, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = disableNodeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> disableNodeDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Activate a Service Fabric cluster node that is currently deactivated.
     * Activates a Service Fabric cluster node that is currently deactivated. Once activated, the node will again become a viable target for placing new replicas, and any deactivated replicas remaining on the node will be reactivated.
     *
     * @param nodeName The name of the node.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void enableNode(String nodeName) {
        enableNodeWithServiceResponseAsync(nodeName).toBlocking().single().body();
    }

    /**
     * Activate a Service Fabric cluster node that is currently deactivated.
     * Activates a Service Fabric cluster node that is currently deactivated. Once activated, the node will again become a viable target for placing new replicas, and any deactivated replicas remaining on the node will be reactivated.
     *
     * @param nodeName The name of the node.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> enableNodeAsync(String nodeName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(enableNodeWithServiceResponseAsync(nodeName), serviceCallback);
    }

    /**
     * Activate a Service Fabric cluster node that is currently deactivated.
     * Activates a Service Fabric cluster node that is currently deactivated. Once activated, the node will again become a viable target for placing new replicas, and any deactivated replicas remaining on the node will be reactivated.
     *
     * @param nodeName The name of the node.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> enableNodeAsync(String nodeName) {
        return enableNodeWithServiceResponseAsync(nodeName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Activate a Service Fabric cluster node that is currently deactivated.
     * Activates a Service Fabric cluster node that is currently deactivated. Once activated, the node will again become a viable target for placing new replicas, and any deactivated replicas remaining on the node will be reactivated.
     *
     * @param nodeName The name of the node.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> enableNodeWithServiceResponseAsync(String nodeName) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.enableNode(nodeName, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = enableNodeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Activate a Service Fabric cluster node that is currently deactivated.
     * Activates a Service Fabric cluster node that is currently deactivated. Once activated, the node will again become a viable target for placing new replicas, and any deactivated replicas remaining on the node will be reactivated.
     *
     * @param nodeName The name of the node.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void enableNode(String nodeName, Long timeout) {
        enableNodeWithServiceResponseAsync(nodeName, timeout).toBlocking().single().body();
    }

    /**
     * Activate a Service Fabric cluster node that is currently deactivated.
     * Activates a Service Fabric cluster node that is currently deactivated. Once activated, the node will again become a viable target for placing new replicas, and any deactivated replicas remaining on the node will be reactivated.
     *
     * @param nodeName The name of the node.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> enableNodeAsync(String nodeName, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(enableNodeWithServiceResponseAsync(nodeName, timeout), serviceCallback);
    }

    /**
     * Activate a Service Fabric cluster node that is currently deactivated.
     * Activates a Service Fabric cluster node that is currently deactivated. Once activated, the node will again become a viable target for placing new replicas, and any deactivated replicas remaining on the node will be reactivated.
     *
     * @param nodeName The name of the node.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> enableNodeAsync(String nodeName, Long timeout) {
        return enableNodeWithServiceResponseAsync(nodeName, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Activate a Service Fabric cluster node that is currently deactivated.
     * Activates a Service Fabric cluster node that is currently deactivated. Once activated, the node will again become a viable target for placing new replicas, and any deactivated replicas remaining on the node will be reactivated.
     *
     * @param nodeName The name of the node.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> enableNodeWithServiceResponseAsync(String nodeName, Long timeout) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.enableNode(nodeName, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = enableNodeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> enableNodeDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Notifies Service Fabric that the persisted state on a node has been permanently removed or lost.
     * This implies that it is not possible to recover the persisted state of that node. This generally happens if a hard disk has been wiped clean, or if a hard disk crashes. The node has to be down for this operation to be successful. This operation lets Service Fabric know that the replicas on that node no longer exist, and that Service Fabric should stop waiting for those replicas to come back up. Do not run this cmdlet if the state on the node has not been removed and the node can come back up with its state intact.
     *
     * @param nodeName The name of the node.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void removeNodeState(String nodeName) {
        removeNodeStateWithServiceResponseAsync(nodeName).toBlocking().single().body();
    }

    /**
     * Notifies Service Fabric that the persisted state on a node has been permanently removed or lost.
     * This implies that it is not possible to recover the persisted state of that node. This generally happens if a hard disk has been wiped clean, or if a hard disk crashes. The node has to be down for this operation to be successful. This operation lets Service Fabric know that the replicas on that node no longer exist, and that Service Fabric should stop waiting for those replicas to come back up. Do not run this cmdlet if the state on the node has not been removed and the node can come back up with its state intact.
     *
     * @param nodeName The name of the node.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> removeNodeStateAsync(String nodeName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(removeNodeStateWithServiceResponseAsync(nodeName), serviceCallback);
    }

    /**
     * Notifies Service Fabric that the persisted state on a node has been permanently removed or lost.
     * This implies that it is not possible to recover the persisted state of that node. This generally happens if a hard disk has been wiped clean, or if a hard disk crashes. The node has to be down for this operation to be successful. This operation lets Service Fabric know that the replicas on that node no longer exist, and that Service Fabric should stop waiting for those replicas to come back up. Do not run this cmdlet if the state on the node has not been removed and the node can come back up with its state intact.
     *
     * @param nodeName The name of the node.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> removeNodeStateAsync(String nodeName) {
        return removeNodeStateWithServiceResponseAsync(nodeName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Notifies Service Fabric that the persisted state on a node has been permanently removed or lost.
     * This implies that it is not possible to recover the persisted state of that node. This generally happens if a hard disk has been wiped clean, or if a hard disk crashes. The node has to be down for this operation to be successful. This operation lets Service Fabric know that the replicas on that node no longer exist, and that Service Fabric should stop waiting for those replicas to come back up. Do not run this cmdlet if the state on the node has not been removed and the node can come back up with its state intact.
     *
     * @param nodeName The name of the node.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> removeNodeStateWithServiceResponseAsync(String nodeName) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.removeNodeState(nodeName, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = removeNodeStateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Notifies Service Fabric that the persisted state on a node has been permanently removed or lost.
     * This implies that it is not possible to recover the persisted state of that node. This generally happens if a hard disk has been wiped clean, or if a hard disk crashes. The node has to be down for this operation to be successful. This operation lets Service Fabric know that the replicas on that node no longer exist, and that Service Fabric should stop waiting for those replicas to come back up. Do not run this cmdlet if the state on the node has not been removed and the node can come back up with its state intact.
     *
     * @param nodeName The name of the node.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void removeNodeState(String nodeName, Long timeout) {
        removeNodeStateWithServiceResponseAsync(nodeName, timeout).toBlocking().single().body();
    }

    /**
     * Notifies Service Fabric that the persisted state on a node has been permanently removed or lost.
     * This implies that it is not possible to recover the persisted state of that node. This generally happens if a hard disk has been wiped clean, or if a hard disk crashes. The node has to be down for this operation to be successful. This operation lets Service Fabric know that the replicas on that node no longer exist, and that Service Fabric should stop waiting for those replicas to come back up. Do not run this cmdlet if the state on the node has not been removed and the node can come back up with its state intact.
     *
     * @param nodeName The name of the node.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> removeNodeStateAsync(String nodeName, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(removeNodeStateWithServiceResponseAsync(nodeName, timeout), serviceCallback);
    }

    /**
     * Notifies Service Fabric that the persisted state on a node has been permanently removed or lost.
     * This implies that it is not possible to recover the persisted state of that node. This generally happens if a hard disk has been wiped clean, or if a hard disk crashes. The node has to be down for this operation to be successful. This operation lets Service Fabric know that the replicas on that node no longer exist, and that Service Fabric should stop waiting for those replicas to come back up. Do not run this cmdlet if the state on the node has not been removed and the node can come back up with its state intact.
     *
     * @param nodeName The name of the node.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> removeNodeStateAsync(String nodeName, Long timeout) {
        return removeNodeStateWithServiceResponseAsync(nodeName, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Notifies Service Fabric that the persisted state on a node has been permanently removed or lost.
     * This implies that it is not possible to recover the persisted state of that node. This generally happens if a hard disk has been wiped clean, or if a hard disk crashes. The node has to be down for this operation to be successful. This operation lets Service Fabric know that the replicas on that node no longer exist, and that Service Fabric should stop waiting for those replicas to come back up. Do not run this cmdlet if the state on the node has not been removed and the node can come back up with its state intact.
     *
     * @param nodeName The name of the node.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> removeNodeStateWithServiceResponseAsync(String nodeName, Long timeout) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.removeNodeState(nodeName, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = removeNodeStateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> removeNodeStateDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Restarts a Service Fabric cluster node.
     * Restarts a Service Fabric cluster node that is already started.
     *
     * @param nodeName The name of the node.
     * @param restartNodeDescription The instance of the node to be restarted and a flag indicating the need to take dump of the fabric process.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void restartNode(String nodeName, RestartNodeDescription restartNodeDescription) {
        restartNodeWithServiceResponseAsync(nodeName, restartNodeDescription).toBlocking().single().body();
    }

    /**
     * Restarts a Service Fabric cluster node.
     * Restarts a Service Fabric cluster node that is already started.
     *
     * @param nodeName The name of the node.
     * @param restartNodeDescription The instance of the node to be restarted and a flag indicating the need to take dump of the fabric process.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> restartNodeAsync(String nodeName, RestartNodeDescription restartNodeDescription, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(restartNodeWithServiceResponseAsync(nodeName, restartNodeDescription), serviceCallback);
    }

    /**
     * Restarts a Service Fabric cluster node.
     * Restarts a Service Fabric cluster node that is already started.
     *
     * @param nodeName The name of the node.
     * @param restartNodeDescription The instance of the node to be restarted and a flag indicating the need to take dump of the fabric process.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> restartNodeAsync(String nodeName, RestartNodeDescription restartNodeDescription) {
        return restartNodeWithServiceResponseAsync(nodeName, restartNodeDescription).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Restarts a Service Fabric cluster node.
     * Restarts a Service Fabric cluster node that is already started.
     *
     * @param nodeName The name of the node.
     * @param restartNodeDescription The instance of the node to be restarted and a flag indicating the need to take dump of the fabric process.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> restartNodeWithServiceResponseAsync(String nodeName, RestartNodeDescription restartNodeDescription) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (restartNodeDescription == null) {
            throw new IllegalArgumentException("Parameter restartNodeDescription is required and cannot be null.");
        }
        Validator.validate(restartNodeDescription);
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.restartNode(nodeName, apiVersion, restartNodeDescription, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = restartNodeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Restarts a Service Fabric cluster node.
     * Restarts a Service Fabric cluster node that is already started.
     *
     * @param nodeName The name of the node.
     * @param restartNodeDescription The instance of the node to be restarted and a flag indicating the need to take dump of the fabric process.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void restartNode(String nodeName, RestartNodeDescription restartNodeDescription, Long timeout) {
        restartNodeWithServiceResponseAsync(nodeName, restartNodeDescription, timeout).toBlocking().single().body();
    }

    /**
     * Restarts a Service Fabric cluster node.
     * Restarts a Service Fabric cluster node that is already started.
     *
     * @param nodeName The name of the node.
     * @param restartNodeDescription The instance of the node to be restarted and a flag indicating the need to take dump of the fabric process.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> restartNodeAsync(String nodeName, RestartNodeDescription restartNodeDescription, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(restartNodeWithServiceResponseAsync(nodeName, restartNodeDescription, timeout), serviceCallback);
    }

    /**
     * Restarts a Service Fabric cluster node.
     * Restarts a Service Fabric cluster node that is already started.
     *
     * @param nodeName The name of the node.
     * @param restartNodeDescription The instance of the node to be restarted and a flag indicating the need to take dump of the fabric process.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> restartNodeAsync(String nodeName, RestartNodeDescription restartNodeDescription, Long timeout) {
        return restartNodeWithServiceResponseAsync(nodeName, restartNodeDescription, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Restarts a Service Fabric cluster node.
     * Restarts a Service Fabric cluster node that is already started.
     *
     * @param nodeName The name of the node.
     * @param restartNodeDescription The instance of the node to be restarted and a flag indicating the need to take dump of the fabric process.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> restartNodeWithServiceResponseAsync(String nodeName, RestartNodeDescription restartNodeDescription, Long timeout) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (restartNodeDescription == null) {
            throw new IllegalArgumentException("Parameter restartNodeDescription is required and cannot be null.");
        }
        Validator.validate(restartNodeDescription);
        final String apiVersion = "6.0";
        return service.restartNode(nodeName, apiVersion, restartNodeDescription, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = restartNodeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> restartNodeDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the list of application types in the Service Fabric cluster.
     * Returns the information about the application types that are provisioned or in the process of being provisioned in the Service Fabric cluster. Each version of an application type is returned as one application type. The response includes the name, version, status, and other details about the application type. This is a paged query, meaning that if not all of the application types fit in a page, one page of results is returned as well as a continuation token, which can be used to get the next page. For example, if there are 10 application types but a page only fits the first three application types, or if max results is set to 3, then three is returned. To access the rest of the results, retrieve subsequent pages by using the returned continuation token in the next query. An empty continuation token is returned if there are no subsequent pages.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedApplicationTypeInfoListInner object if successful.
     */
    public PagedApplicationTypeInfoListInner getApplicationTypeInfoList() {
        return getApplicationTypeInfoListWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets the list of application types in the Service Fabric cluster.
     * Returns the information about the application types that are provisioned or in the process of being provisioned in the Service Fabric cluster. Each version of an application type is returned as one application type. The response includes the name, version, status, and other details about the application type. This is a paged query, meaning that if not all of the application types fit in a page, one page of results is returned as well as a continuation token, which can be used to get the next page. For example, if there are 10 application types but a page only fits the first three application types, or if max results is set to 3, then three is returned. To access the rest of the results, retrieve subsequent pages by using the returned continuation token in the next query. An empty continuation token is returned if there are no subsequent pages.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedApplicationTypeInfoListInner> getApplicationTypeInfoListAsync(final ServiceCallback<PagedApplicationTypeInfoListInner> serviceCallback) {
        return ServiceFuture.fromResponse(getApplicationTypeInfoListWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets the list of application types in the Service Fabric cluster.
     * Returns the information about the application types that are provisioned or in the process of being provisioned in the Service Fabric cluster. Each version of an application type is returned as one application type. The response includes the name, version, status, and other details about the application type. This is a paged query, meaning that if not all of the application types fit in a page, one page of results is returned as well as a continuation token, which can be used to get the next page. For example, if there are 10 application types but a page only fits the first three application types, or if max results is set to 3, then three is returned. To access the rest of the results, retrieve subsequent pages by using the returned continuation token in the next query. An empty continuation token is returned if there are no subsequent pages.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedApplicationTypeInfoListInner object
     */
    public Observable<PagedApplicationTypeInfoListInner> getApplicationTypeInfoListAsync() {
        return getApplicationTypeInfoListWithServiceResponseAsync().map(new Func1<ServiceResponse<PagedApplicationTypeInfoListInner>, PagedApplicationTypeInfoListInner>() {
            @Override
            public PagedApplicationTypeInfoListInner call(ServiceResponse<PagedApplicationTypeInfoListInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the list of application types in the Service Fabric cluster.
     * Returns the information about the application types that are provisioned or in the process of being provisioned in the Service Fabric cluster. Each version of an application type is returned as one application type. The response includes the name, version, status, and other details about the application type. This is a paged query, meaning that if not all of the application types fit in a page, one page of results is returned as well as a continuation token, which can be used to get the next page. For example, if there are 10 application types but a page only fits the first three application types, or if max results is set to 3, then three is returned. To access the rest of the results, retrieve subsequent pages by using the returned continuation token in the next query. An empty continuation token is returned if there are no subsequent pages.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedApplicationTypeInfoListInner object
     */
    public Observable<ServiceResponse<PagedApplicationTypeInfoListInner>> getApplicationTypeInfoListWithServiceResponseAsync() {
        final String apiVersion = "6.0";
        final Integer applicationTypeDefinitionKindFilter = null;
        final Boolean excludeApplicationParameters = null;
        final String continuationToken = null;
        final Long maxResults = null;
        final Long timeout = null;
        return service.getApplicationTypeInfoList(apiVersion, applicationTypeDefinitionKindFilter, excludeApplicationParameters, continuationToken, maxResults, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedApplicationTypeInfoListInner>>>() {
                @Override
                public Observable<ServiceResponse<PagedApplicationTypeInfoListInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedApplicationTypeInfoListInner> clientResponse = getApplicationTypeInfoListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the list of application types in the Service Fabric cluster.
     * Returns the information about the application types that are provisioned or in the process of being provisioned in the Service Fabric cluster. Each version of an application type is returned as one application type. The response includes the name, version, status, and other details about the application type. This is a paged query, meaning that if not all of the application types fit in a page, one page of results is returned as well as a continuation token, which can be used to get the next page. For example, if there are 10 application types but a page only fits the first three application types, or if max results is set to 3, then three is returned. To access the rest of the results, retrieve subsequent pages by using the returned continuation token in the next query. An empty continuation token is returned if there are no subsequent pages.
     *
     * @param applicationTypeDefinitionKindFilter Used to filter on ApplicationTypeDefinitionKind which is the mechanism used to define a Service Fabric application type.
     - Default - Default value, which performs the same function as selecting "All". The value is 0.
     - All - Filter that matches input with any ApplicationTypeDefinitionKind value. The value is 65535.
     - ServiceFabricApplicationPackage - Filter that matches input with ApplicationTypeDefinitionKind value ServiceFabricApplicationPackage. The value is 1.
     - Compose - Filter that matches input with ApplicationTypeDefinitionKind value Compose. The value is 2.
     * @param excludeApplicationParameters The flag that specifies whether application parameters will be excluded from the result.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedApplicationTypeInfoListInner object if successful.
     */
    public PagedApplicationTypeInfoListInner getApplicationTypeInfoList(Integer applicationTypeDefinitionKindFilter, Boolean excludeApplicationParameters, String continuationToken, Long maxResults, Long timeout) {
        return getApplicationTypeInfoListWithServiceResponseAsync(applicationTypeDefinitionKindFilter, excludeApplicationParameters, continuationToken, maxResults, timeout).toBlocking().single().body();
    }

    /**
     * Gets the list of application types in the Service Fabric cluster.
     * Returns the information about the application types that are provisioned or in the process of being provisioned in the Service Fabric cluster. Each version of an application type is returned as one application type. The response includes the name, version, status, and other details about the application type. This is a paged query, meaning that if not all of the application types fit in a page, one page of results is returned as well as a continuation token, which can be used to get the next page. For example, if there are 10 application types but a page only fits the first three application types, or if max results is set to 3, then three is returned. To access the rest of the results, retrieve subsequent pages by using the returned continuation token in the next query. An empty continuation token is returned if there are no subsequent pages.
     *
     * @param applicationTypeDefinitionKindFilter Used to filter on ApplicationTypeDefinitionKind which is the mechanism used to define a Service Fabric application type.
     - Default - Default value, which performs the same function as selecting "All". The value is 0.
     - All - Filter that matches input with any ApplicationTypeDefinitionKind value. The value is 65535.
     - ServiceFabricApplicationPackage - Filter that matches input with ApplicationTypeDefinitionKind value ServiceFabricApplicationPackage. The value is 1.
     - Compose - Filter that matches input with ApplicationTypeDefinitionKind value Compose. The value is 2.
     * @param excludeApplicationParameters The flag that specifies whether application parameters will be excluded from the result.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedApplicationTypeInfoListInner> getApplicationTypeInfoListAsync(Integer applicationTypeDefinitionKindFilter, Boolean excludeApplicationParameters, String continuationToken, Long maxResults, Long timeout, final ServiceCallback<PagedApplicationTypeInfoListInner> serviceCallback) {
        return ServiceFuture.fromResponse(getApplicationTypeInfoListWithServiceResponseAsync(applicationTypeDefinitionKindFilter, excludeApplicationParameters, continuationToken, maxResults, timeout), serviceCallback);
    }

    /**
     * Gets the list of application types in the Service Fabric cluster.
     * Returns the information about the application types that are provisioned or in the process of being provisioned in the Service Fabric cluster. Each version of an application type is returned as one application type. The response includes the name, version, status, and other details about the application type. This is a paged query, meaning that if not all of the application types fit in a page, one page of results is returned as well as a continuation token, which can be used to get the next page. For example, if there are 10 application types but a page only fits the first three application types, or if max results is set to 3, then three is returned. To access the rest of the results, retrieve subsequent pages by using the returned continuation token in the next query. An empty continuation token is returned if there are no subsequent pages.
     *
     * @param applicationTypeDefinitionKindFilter Used to filter on ApplicationTypeDefinitionKind which is the mechanism used to define a Service Fabric application type.
     - Default - Default value, which performs the same function as selecting "All". The value is 0.
     - All - Filter that matches input with any ApplicationTypeDefinitionKind value. The value is 65535.
     - ServiceFabricApplicationPackage - Filter that matches input with ApplicationTypeDefinitionKind value ServiceFabricApplicationPackage. The value is 1.
     - Compose - Filter that matches input with ApplicationTypeDefinitionKind value Compose. The value is 2.
     * @param excludeApplicationParameters The flag that specifies whether application parameters will be excluded from the result.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedApplicationTypeInfoListInner object
     */
    public Observable<PagedApplicationTypeInfoListInner> getApplicationTypeInfoListAsync(Integer applicationTypeDefinitionKindFilter, Boolean excludeApplicationParameters, String continuationToken, Long maxResults, Long timeout) {
        return getApplicationTypeInfoListWithServiceResponseAsync(applicationTypeDefinitionKindFilter, excludeApplicationParameters, continuationToken, maxResults, timeout).map(new Func1<ServiceResponse<PagedApplicationTypeInfoListInner>, PagedApplicationTypeInfoListInner>() {
            @Override
            public PagedApplicationTypeInfoListInner call(ServiceResponse<PagedApplicationTypeInfoListInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the list of application types in the Service Fabric cluster.
     * Returns the information about the application types that are provisioned or in the process of being provisioned in the Service Fabric cluster. Each version of an application type is returned as one application type. The response includes the name, version, status, and other details about the application type. This is a paged query, meaning that if not all of the application types fit in a page, one page of results is returned as well as a continuation token, which can be used to get the next page. For example, if there are 10 application types but a page only fits the first three application types, or if max results is set to 3, then three is returned. To access the rest of the results, retrieve subsequent pages by using the returned continuation token in the next query. An empty continuation token is returned if there are no subsequent pages.
     *
     * @param applicationTypeDefinitionKindFilter Used to filter on ApplicationTypeDefinitionKind which is the mechanism used to define a Service Fabric application type.
     - Default - Default value, which performs the same function as selecting "All". The value is 0.
     - All - Filter that matches input with any ApplicationTypeDefinitionKind value. The value is 65535.
     - ServiceFabricApplicationPackage - Filter that matches input with ApplicationTypeDefinitionKind value ServiceFabricApplicationPackage. The value is 1.
     - Compose - Filter that matches input with ApplicationTypeDefinitionKind value Compose. The value is 2.
     * @param excludeApplicationParameters The flag that specifies whether application parameters will be excluded from the result.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedApplicationTypeInfoListInner object
     */
    public Observable<ServiceResponse<PagedApplicationTypeInfoListInner>> getApplicationTypeInfoListWithServiceResponseAsync(Integer applicationTypeDefinitionKindFilter, Boolean excludeApplicationParameters, String continuationToken, Long maxResults, Long timeout) {
        final String apiVersion = "6.0";
        return service.getApplicationTypeInfoList(apiVersion, applicationTypeDefinitionKindFilter, excludeApplicationParameters, continuationToken, maxResults, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedApplicationTypeInfoListInner>>>() {
                @Override
                public Observable<ServiceResponse<PagedApplicationTypeInfoListInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedApplicationTypeInfoListInner> clientResponse = getApplicationTypeInfoListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PagedApplicationTypeInfoListInner> getApplicationTypeInfoListDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException {
        return this.restClient().responseBuilderFactory().<PagedApplicationTypeInfoListInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PagedApplicationTypeInfoListInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the list of application types in the Service Fabric cluster matching exactly the specified name.
     * Returns the information about the application types that are provisioned or in the process of being provisioned in the Service Fabric cluster. These results are of application types whose name match exactly the one specified as the parameter, and which comply with the given query parameters. All versions of the application type matching the application type name are returned, with each version returned as one application type. The response includes the name, version, status, and other details about the application type. This is a paged query, meaning that if not all of the application types fit in a page, one page of results is returned as well as a continuation token, which can be used to get the next page. For example, if there are 10 application types but a page only fits the first three application types, or if max results is set to 3, then three is returned. To access the rest of the results, retrieve subsequent pages by using the returned continuation token in the next query. An empty continuation token is returned if there are no subsequent pages.
     *
     * @param applicationTypeName The name of the application type.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedApplicationTypeInfoListInner object if successful.
     */
    public PagedApplicationTypeInfoListInner getApplicationTypeInfoListByName(String applicationTypeName) {
        return getApplicationTypeInfoListByNameWithServiceResponseAsync(applicationTypeName).toBlocking().single().body();
    }

    /**
     * Gets the list of application types in the Service Fabric cluster matching exactly the specified name.
     * Returns the information about the application types that are provisioned or in the process of being provisioned in the Service Fabric cluster. These results are of application types whose name match exactly the one specified as the parameter, and which comply with the given query parameters. All versions of the application type matching the application type name are returned, with each version returned as one application type. The response includes the name, version, status, and other details about the application type. This is a paged query, meaning that if not all of the application types fit in a page, one page of results is returned as well as a continuation token, which can be used to get the next page. For example, if there are 10 application types but a page only fits the first three application types, or if max results is set to 3, then three is returned. To access the rest of the results, retrieve subsequent pages by using the returned continuation token in the next query. An empty continuation token is returned if there are no subsequent pages.
     *
     * @param applicationTypeName The name of the application type.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedApplicationTypeInfoListInner> getApplicationTypeInfoListByNameAsync(String applicationTypeName, final ServiceCallback<PagedApplicationTypeInfoListInner> serviceCallback) {
        return ServiceFuture.fromResponse(getApplicationTypeInfoListByNameWithServiceResponseAsync(applicationTypeName), serviceCallback);
    }

    /**
     * Gets the list of application types in the Service Fabric cluster matching exactly the specified name.
     * Returns the information about the application types that are provisioned or in the process of being provisioned in the Service Fabric cluster. These results are of application types whose name match exactly the one specified as the parameter, and which comply with the given query parameters. All versions of the application type matching the application type name are returned, with each version returned as one application type. The response includes the name, version, status, and other details about the application type. This is a paged query, meaning that if not all of the application types fit in a page, one page of results is returned as well as a continuation token, which can be used to get the next page. For example, if there are 10 application types but a page only fits the first three application types, or if max results is set to 3, then three is returned. To access the rest of the results, retrieve subsequent pages by using the returned continuation token in the next query. An empty continuation token is returned if there are no subsequent pages.
     *
     * @param applicationTypeName The name of the application type.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedApplicationTypeInfoListInner object
     */
    public Observable<PagedApplicationTypeInfoListInner> getApplicationTypeInfoListByNameAsync(String applicationTypeName) {
        return getApplicationTypeInfoListByNameWithServiceResponseAsync(applicationTypeName).map(new Func1<ServiceResponse<PagedApplicationTypeInfoListInner>, PagedApplicationTypeInfoListInner>() {
            @Override
            public PagedApplicationTypeInfoListInner call(ServiceResponse<PagedApplicationTypeInfoListInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the list of application types in the Service Fabric cluster matching exactly the specified name.
     * Returns the information about the application types that are provisioned or in the process of being provisioned in the Service Fabric cluster. These results are of application types whose name match exactly the one specified as the parameter, and which comply with the given query parameters. All versions of the application type matching the application type name are returned, with each version returned as one application type. The response includes the name, version, status, and other details about the application type. This is a paged query, meaning that if not all of the application types fit in a page, one page of results is returned as well as a continuation token, which can be used to get the next page. For example, if there are 10 application types but a page only fits the first three application types, or if max results is set to 3, then three is returned. To access the rest of the results, retrieve subsequent pages by using the returned continuation token in the next query. An empty continuation token is returned if there are no subsequent pages.
     *
     * @param applicationTypeName The name of the application type.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedApplicationTypeInfoListInner object
     */
    public Observable<ServiceResponse<PagedApplicationTypeInfoListInner>> getApplicationTypeInfoListByNameWithServiceResponseAsync(String applicationTypeName) {
        if (applicationTypeName == null) {
            throw new IllegalArgumentException("Parameter applicationTypeName is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final String applicationTypeVersion = null;
        final Boolean excludeApplicationParameters = null;
        final String continuationToken = null;
        final Long maxResults = null;
        final Long timeout = null;
        return service.getApplicationTypeInfoListByName(applicationTypeName, apiVersion, applicationTypeVersion, excludeApplicationParameters, continuationToken, maxResults, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedApplicationTypeInfoListInner>>>() {
                @Override
                public Observable<ServiceResponse<PagedApplicationTypeInfoListInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedApplicationTypeInfoListInner> clientResponse = getApplicationTypeInfoListByNameDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the list of application types in the Service Fabric cluster matching exactly the specified name.
     * Returns the information about the application types that are provisioned or in the process of being provisioned in the Service Fabric cluster. These results are of application types whose name match exactly the one specified as the parameter, and which comply with the given query parameters. All versions of the application type matching the application type name are returned, with each version returned as one application type. The response includes the name, version, status, and other details about the application type. This is a paged query, meaning that if not all of the application types fit in a page, one page of results is returned as well as a continuation token, which can be used to get the next page. For example, if there are 10 application types but a page only fits the first three application types, or if max results is set to 3, then three is returned. To access the rest of the results, retrieve subsequent pages by using the returned continuation token in the next query. An empty continuation token is returned if there are no subsequent pages.
     *
     * @param applicationTypeName The name of the application type.
     * @param applicationTypeVersion The version of the application type.
     * @param excludeApplicationParameters The flag that specifies whether application parameters will be excluded from the result.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedApplicationTypeInfoListInner object if successful.
     */
    public PagedApplicationTypeInfoListInner getApplicationTypeInfoListByName(String applicationTypeName, String applicationTypeVersion, Boolean excludeApplicationParameters, String continuationToken, Long maxResults, Long timeout) {
        return getApplicationTypeInfoListByNameWithServiceResponseAsync(applicationTypeName, applicationTypeVersion, excludeApplicationParameters, continuationToken, maxResults, timeout).toBlocking().single().body();
    }

    /**
     * Gets the list of application types in the Service Fabric cluster matching exactly the specified name.
     * Returns the information about the application types that are provisioned or in the process of being provisioned in the Service Fabric cluster. These results are of application types whose name match exactly the one specified as the parameter, and which comply with the given query parameters. All versions of the application type matching the application type name are returned, with each version returned as one application type. The response includes the name, version, status, and other details about the application type. This is a paged query, meaning that if not all of the application types fit in a page, one page of results is returned as well as a continuation token, which can be used to get the next page. For example, if there are 10 application types but a page only fits the first three application types, or if max results is set to 3, then three is returned. To access the rest of the results, retrieve subsequent pages by using the returned continuation token in the next query. An empty continuation token is returned if there are no subsequent pages.
     *
     * @param applicationTypeName The name of the application type.
     * @param applicationTypeVersion The version of the application type.
     * @param excludeApplicationParameters The flag that specifies whether application parameters will be excluded from the result.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedApplicationTypeInfoListInner> getApplicationTypeInfoListByNameAsync(String applicationTypeName, String applicationTypeVersion, Boolean excludeApplicationParameters, String continuationToken, Long maxResults, Long timeout, final ServiceCallback<PagedApplicationTypeInfoListInner> serviceCallback) {
        return ServiceFuture.fromResponse(getApplicationTypeInfoListByNameWithServiceResponseAsync(applicationTypeName, applicationTypeVersion, excludeApplicationParameters, continuationToken, maxResults, timeout), serviceCallback);
    }

    /**
     * Gets the list of application types in the Service Fabric cluster matching exactly the specified name.
     * Returns the information about the application types that are provisioned or in the process of being provisioned in the Service Fabric cluster. These results are of application types whose name match exactly the one specified as the parameter, and which comply with the given query parameters. All versions of the application type matching the application type name are returned, with each version returned as one application type. The response includes the name, version, status, and other details about the application type. This is a paged query, meaning that if not all of the application types fit in a page, one page of results is returned as well as a continuation token, which can be used to get the next page. For example, if there are 10 application types but a page only fits the first three application types, or if max results is set to 3, then three is returned. To access the rest of the results, retrieve subsequent pages by using the returned continuation token in the next query. An empty continuation token is returned if there are no subsequent pages.
     *
     * @param applicationTypeName The name of the application type.
     * @param applicationTypeVersion The version of the application type.
     * @param excludeApplicationParameters The flag that specifies whether application parameters will be excluded from the result.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedApplicationTypeInfoListInner object
     */
    public Observable<PagedApplicationTypeInfoListInner> getApplicationTypeInfoListByNameAsync(String applicationTypeName, String applicationTypeVersion, Boolean excludeApplicationParameters, String continuationToken, Long maxResults, Long timeout) {
        return getApplicationTypeInfoListByNameWithServiceResponseAsync(applicationTypeName, applicationTypeVersion, excludeApplicationParameters, continuationToken, maxResults, timeout).map(new Func1<ServiceResponse<PagedApplicationTypeInfoListInner>, PagedApplicationTypeInfoListInner>() {
            @Override
            public PagedApplicationTypeInfoListInner call(ServiceResponse<PagedApplicationTypeInfoListInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the list of application types in the Service Fabric cluster matching exactly the specified name.
     * Returns the information about the application types that are provisioned or in the process of being provisioned in the Service Fabric cluster. These results are of application types whose name match exactly the one specified as the parameter, and which comply with the given query parameters. All versions of the application type matching the application type name are returned, with each version returned as one application type. The response includes the name, version, status, and other details about the application type. This is a paged query, meaning that if not all of the application types fit in a page, one page of results is returned as well as a continuation token, which can be used to get the next page. For example, if there are 10 application types but a page only fits the first three application types, or if max results is set to 3, then three is returned. To access the rest of the results, retrieve subsequent pages by using the returned continuation token in the next query. An empty continuation token is returned if there are no subsequent pages.
     *
     * @param applicationTypeName The name of the application type.
     * @param applicationTypeVersion The version of the application type.
     * @param excludeApplicationParameters The flag that specifies whether application parameters will be excluded from the result.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedApplicationTypeInfoListInner object
     */
    public Observable<ServiceResponse<PagedApplicationTypeInfoListInner>> getApplicationTypeInfoListByNameWithServiceResponseAsync(String applicationTypeName, String applicationTypeVersion, Boolean excludeApplicationParameters, String continuationToken, Long maxResults, Long timeout) {
        if (applicationTypeName == null) {
            throw new IllegalArgumentException("Parameter applicationTypeName is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.getApplicationTypeInfoListByName(applicationTypeName, apiVersion, applicationTypeVersion, excludeApplicationParameters, continuationToken, maxResults, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedApplicationTypeInfoListInner>>>() {
                @Override
                public Observable<ServiceResponse<PagedApplicationTypeInfoListInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedApplicationTypeInfoListInner> clientResponse = getApplicationTypeInfoListByNameDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PagedApplicationTypeInfoListInner> getApplicationTypeInfoListByNameDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<PagedApplicationTypeInfoListInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PagedApplicationTypeInfoListInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Provisions or registers a Service Fabric application type with the cluster using the '.sfpkg' package in the external store or using the application package in the image store.
     * Provisions a Service Fabric application type with the cluster. The provision is required before any new applications can be instantiated.
     The provision operation can be performed either on the application package specified by the relativePathInImageStore, or by using the URI of the external '.sfpkg'.
     *
     * @param provisionApplicationTypeDescriptionBaseRequiredBodyParam The base type of provision application type description which supports either image store-based provision or external store-based provision.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void provisionApplicationType(ProvisionApplicationTypeDescriptionBase provisionApplicationTypeDescriptionBaseRequiredBodyParam) {
        provisionApplicationTypeWithServiceResponseAsync(provisionApplicationTypeDescriptionBaseRequiredBodyParam).toBlocking().single().body();
    }

    /**
     * Provisions or registers a Service Fabric application type with the cluster using the '.sfpkg' package in the external store or using the application package in the image store.
     * Provisions a Service Fabric application type with the cluster. The provision is required before any new applications can be instantiated.
     The provision operation can be performed either on the application package specified by the relativePathInImageStore, or by using the URI of the external '.sfpkg'.
     *
     * @param provisionApplicationTypeDescriptionBaseRequiredBodyParam The base type of provision application type description which supports either image store-based provision or external store-based provision.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> provisionApplicationTypeAsync(ProvisionApplicationTypeDescriptionBase provisionApplicationTypeDescriptionBaseRequiredBodyParam, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(provisionApplicationTypeWithServiceResponseAsync(provisionApplicationTypeDescriptionBaseRequiredBodyParam), serviceCallback);
    }

    /**
     * Provisions or registers a Service Fabric application type with the cluster using the '.sfpkg' package in the external store or using the application package in the image store.
     * Provisions a Service Fabric application type with the cluster. The provision is required before any new applications can be instantiated.
     The provision operation can be performed either on the application package specified by the relativePathInImageStore, or by using the URI of the external '.sfpkg'.
     *
     * @param provisionApplicationTypeDescriptionBaseRequiredBodyParam The base type of provision application type description which supports either image store-based provision or external store-based provision.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> provisionApplicationTypeAsync(ProvisionApplicationTypeDescriptionBase provisionApplicationTypeDescriptionBaseRequiredBodyParam) {
        return provisionApplicationTypeWithServiceResponseAsync(provisionApplicationTypeDescriptionBaseRequiredBodyParam).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Provisions or registers a Service Fabric application type with the cluster using the '.sfpkg' package in the external store or using the application package in the image store.
     * Provisions a Service Fabric application type with the cluster. The provision is required before any new applications can be instantiated.
     The provision operation can be performed either on the application package specified by the relativePathInImageStore, or by using the URI of the external '.sfpkg'.
     *
     * @param provisionApplicationTypeDescriptionBaseRequiredBodyParam The base type of provision application type description which supports either image store-based provision or external store-based provision.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> provisionApplicationTypeWithServiceResponseAsync(ProvisionApplicationTypeDescriptionBase provisionApplicationTypeDescriptionBaseRequiredBodyParam) {
        if (provisionApplicationTypeDescriptionBaseRequiredBodyParam == null) {
            throw new IllegalArgumentException("Parameter provisionApplicationTypeDescriptionBaseRequiredBodyParam is required and cannot be null.");
        }
        Validator.validate(provisionApplicationTypeDescriptionBaseRequiredBodyParam);
        final String apiVersion = "6.2";
        final Long timeout = null;
        return service.provisionApplicationType(apiVersion, provisionApplicationTypeDescriptionBaseRequiredBodyParam, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = provisionApplicationTypeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Provisions or registers a Service Fabric application type with the cluster using the '.sfpkg' package in the external store or using the application package in the image store.
     * Provisions a Service Fabric application type with the cluster. The provision is required before any new applications can be instantiated.
     The provision operation can be performed either on the application package specified by the relativePathInImageStore, or by using the URI of the external '.sfpkg'.
     *
     * @param provisionApplicationTypeDescriptionBaseRequiredBodyParam The base type of provision application type description which supports either image store-based provision or external store-based provision.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void provisionApplicationType(ProvisionApplicationTypeDescriptionBase provisionApplicationTypeDescriptionBaseRequiredBodyParam, Long timeout) {
        provisionApplicationTypeWithServiceResponseAsync(provisionApplicationTypeDescriptionBaseRequiredBodyParam, timeout).toBlocking().single().body();
    }

    /**
     * Provisions or registers a Service Fabric application type with the cluster using the '.sfpkg' package in the external store or using the application package in the image store.
     * Provisions a Service Fabric application type with the cluster. The provision is required before any new applications can be instantiated.
     The provision operation can be performed either on the application package specified by the relativePathInImageStore, or by using the URI of the external '.sfpkg'.
     *
     * @param provisionApplicationTypeDescriptionBaseRequiredBodyParam The base type of provision application type description which supports either image store-based provision or external store-based provision.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> provisionApplicationTypeAsync(ProvisionApplicationTypeDescriptionBase provisionApplicationTypeDescriptionBaseRequiredBodyParam, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(provisionApplicationTypeWithServiceResponseAsync(provisionApplicationTypeDescriptionBaseRequiredBodyParam, timeout), serviceCallback);
    }

    /**
     * Provisions or registers a Service Fabric application type with the cluster using the '.sfpkg' package in the external store or using the application package in the image store.
     * Provisions a Service Fabric application type with the cluster. The provision is required before any new applications can be instantiated.
     The provision operation can be performed either on the application package specified by the relativePathInImageStore, or by using the URI of the external '.sfpkg'.
     *
     * @param provisionApplicationTypeDescriptionBaseRequiredBodyParam The base type of provision application type description which supports either image store-based provision or external store-based provision.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> provisionApplicationTypeAsync(ProvisionApplicationTypeDescriptionBase provisionApplicationTypeDescriptionBaseRequiredBodyParam, Long timeout) {
        return provisionApplicationTypeWithServiceResponseAsync(provisionApplicationTypeDescriptionBaseRequiredBodyParam, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Provisions or registers a Service Fabric application type with the cluster using the '.sfpkg' package in the external store or using the application package in the image store.
     * Provisions a Service Fabric application type with the cluster. The provision is required before any new applications can be instantiated.
     The provision operation can be performed either on the application package specified by the relativePathInImageStore, or by using the URI of the external '.sfpkg'.
     *
     * @param provisionApplicationTypeDescriptionBaseRequiredBodyParam The base type of provision application type description which supports either image store-based provision or external store-based provision.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> provisionApplicationTypeWithServiceResponseAsync(ProvisionApplicationTypeDescriptionBase provisionApplicationTypeDescriptionBaseRequiredBodyParam, Long timeout) {
        if (provisionApplicationTypeDescriptionBaseRequiredBodyParam == null) {
            throw new IllegalArgumentException("Parameter provisionApplicationTypeDescriptionBaseRequiredBodyParam is required and cannot be null.");
        }
        Validator.validate(provisionApplicationTypeDescriptionBaseRequiredBodyParam);
        final String apiVersion = "6.2";
        return service.provisionApplicationType(apiVersion, provisionApplicationTypeDescriptionBaseRequiredBodyParam, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = provisionApplicationTypeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> provisionApplicationTypeDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Removes or unregisters a Service Fabric application type from the cluster.
     * This operation can only be performed if all application instances of the application type have been deleted. Once the application type is unregistered, no new application instances can be created for this particular application type.
     *
     * @param applicationTypeName The name of the application type.
     * @param unprovisionApplicationTypeDescriptionInfo The relative path for the application package in the image store specified during the prior copy operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void unprovisionApplicationType(String applicationTypeName, UnprovisionApplicationTypeDescriptionInfo unprovisionApplicationTypeDescriptionInfo) {
        unprovisionApplicationTypeWithServiceResponseAsync(applicationTypeName, unprovisionApplicationTypeDescriptionInfo).toBlocking().single().body();
    }

    /**
     * Removes or unregisters a Service Fabric application type from the cluster.
     * This operation can only be performed if all application instances of the application type have been deleted. Once the application type is unregistered, no new application instances can be created for this particular application type.
     *
     * @param applicationTypeName The name of the application type.
     * @param unprovisionApplicationTypeDescriptionInfo The relative path for the application package in the image store specified during the prior copy operation.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> unprovisionApplicationTypeAsync(String applicationTypeName, UnprovisionApplicationTypeDescriptionInfo unprovisionApplicationTypeDescriptionInfo, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(unprovisionApplicationTypeWithServiceResponseAsync(applicationTypeName, unprovisionApplicationTypeDescriptionInfo), serviceCallback);
    }

    /**
     * Removes or unregisters a Service Fabric application type from the cluster.
     * This operation can only be performed if all application instances of the application type have been deleted. Once the application type is unregistered, no new application instances can be created for this particular application type.
     *
     * @param applicationTypeName The name of the application type.
     * @param unprovisionApplicationTypeDescriptionInfo The relative path for the application package in the image store specified during the prior copy operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> unprovisionApplicationTypeAsync(String applicationTypeName, UnprovisionApplicationTypeDescriptionInfo unprovisionApplicationTypeDescriptionInfo) {
        return unprovisionApplicationTypeWithServiceResponseAsync(applicationTypeName, unprovisionApplicationTypeDescriptionInfo).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Removes or unregisters a Service Fabric application type from the cluster.
     * This operation can only be performed if all application instances of the application type have been deleted. Once the application type is unregistered, no new application instances can be created for this particular application type.
     *
     * @param applicationTypeName The name of the application type.
     * @param unprovisionApplicationTypeDescriptionInfo The relative path for the application package in the image store specified during the prior copy operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> unprovisionApplicationTypeWithServiceResponseAsync(String applicationTypeName, UnprovisionApplicationTypeDescriptionInfo unprovisionApplicationTypeDescriptionInfo) {
        if (applicationTypeName == null) {
            throw new IllegalArgumentException("Parameter applicationTypeName is required and cannot be null.");
        }
        if (unprovisionApplicationTypeDescriptionInfo == null) {
            throw new IllegalArgumentException("Parameter unprovisionApplicationTypeDescriptionInfo is required and cannot be null.");
        }
        Validator.validate(unprovisionApplicationTypeDescriptionInfo);
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.unprovisionApplicationType(applicationTypeName, apiVersion, unprovisionApplicationTypeDescriptionInfo, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = unprovisionApplicationTypeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Removes or unregisters a Service Fabric application type from the cluster.
     * This operation can only be performed if all application instances of the application type have been deleted. Once the application type is unregistered, no new application instances can be created for this particular application type.
     *
     * @param applicationTypeName The name of the application type.
     * @param unprovisionApplicationTypeDescriptionInfo The relative path for the application package in the image store specified during the prior copy operation.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void unprovisionApplicationType(String applicationTypeName, UnprovisionApplicationTypeDescriptionInfo unprovisionApplicationTypeDescriptionInfo, Long timeout) {
        unprovisionApplicationTypeWithServiceResponseAsync(applicationTypeName, unprovisionApplicationTypeDescriptionInfo, timeout).toBlocking().single().body();
    }

    /**
     * Removes or unregisters a Service Fabric application type from the cluster.
     * This operation can only be performed if all application instances of the application type have been deleted. Once the application type is unregistered, no new application instances can be created for this particular application type.
     *
     * @param applicationTypeName The name of the application type.
     * @param unprovisionApplicationTypeDescriptionInfo The relative path for the application package in the image store specified during the prior copy operation.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> unprovisionApplicationTypeAsync(String applicationTypeName, UnprovisionApplicationTypeDescriptionInfo unprovisionApplicationTypeDescriptionInfo, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(unprovisionApplicationTypeWithServiceResponseAsync(applicationTypeName, unprovisionApplicationTypeDescriptionInfo, timeout), serviceCallback);
    }

    /**
     * Removes or unregisters a Service Fabric application type from the cluster.
     * This operation can only be performed if all application instances of the application type have been deleted. Once the application type is unregistered, no new application instances can be created for this particular application type.
     *
     * @param applicationTypeName The name of the application type.
     * @param unprovisionApplicationTypeDescriptionInfo The relative path for the application package in the image store specified during the prior copy operation.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> unprovisionApplicationTypeAsync(String applicationTypeName, UnprovisionApplicationTypeDescriptionInfo unprovisionApplicationTypeDescriptionInfo, Long timeout) {
        return unprovisionApplicationTypeWithServiceResponseAsync(applicationTypeName, unprovisionApplicationTypeDescriptionInfo, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Removes or unregisters a Service Fabric application type from the cluster.
     * This operation can only be performed if all application instances of the application type have been deleted. Once the application type is unregistered, no new application instances can be created for this particular application type.
     *
     * @param applicationTypeName The name of the application type.
     * @param unprovisionApplicationTypeDescriptionInfo The relative path for the application package in the image store specified during the prior copy operation.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> unprovisionApplicationTypeWithServiceResponseAsync(String applicationTypeName, UnprovisionApplicationTypeDescriptionInfo unprovisionApplicationTypeDescriptionInfo, Long timeout) {
        if (applicationTypeName == null) {
            throw new IllegalArgumentException("Parameter applicationTypeName is required and cannot be null.");
        }
        if (unprovisionApplicationTypeDescriptionInfo == null) {
            throw new IllegalArgumentException("Parameter unprovisionApplicationTypeDescriptionInfo is required and cannot be null.");
        }
        Validator.validate(unprovisionApplicationTypeDescriptionInfo);
        final String apiVersion = "6.0";
        return service.unprovisionApplicationType(applicationTypeName, apiVersion, unprovisionApplicationTypeDescriptionInfo, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = unprovisionApplicationTypeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> unprovisionApplicationTypeDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the list containing the information about service types that are supported by a provisioned application type in a Service Fabric cluster.
     * Gets the list containing the information about service types that are supported by a provisioned application type in a Service Fabric cluster. The provided application type must exist. Otherwise, a 404 status is returned.
     *
     * @param applicationTypeName The name of the application type.
     * @param applicationTypeVersion The version of the application type.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ServiceTypeInfoInner&gt; object if successful.
     */
    public List<ServiceTypeInfoInner> getServiceTypeInfoList(String applicationTypeName, String applicationTypeVersion) {
        return getServiceTypeInfoListWithServiceResponseAsync(applicationTypeName, applicationTypeVersion).toBlocking().single().body();
    }

    /**
     * Gets the list containing the information about service types that are supported by a provisioned application type in a Service Fabric cluster.
     * Gets the list containing the information about service types that are supported by a provisioned application type in a Service Fabric cluster. The provided application type must exist. Otherwise, a 404 status is returned.
     *
     * @param applicationTypeName The name of the application type.
     * @param applicationTypeVersion The version of the application type.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ServiceTypeInfoInner>> getServiceTypeInfoListAsync(String applicationTypeName, String applicationTypeVersion, final ServiceCallback<List<ServiceTypeInfoInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getServiceTypeInfoListWithServiceResponseAsync(applicationTypeName, applicationTypeVersion), serviceCallback);
    }

    /**
     * Gets the list containing the information about service types that are supported by a provisioned application type in a Service Fabric cluster.
     * Gets the list containing the information about service types that are supported by a provisioned application type in a Service Fabric cluster. The provided application type must exist. Otherwise, a 404 status is returned.
     *
     * @param applicationTypeName The name of the application type.
     * @param applicationTypeVersion The version of the application type.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ServiceTypeInfoInner&gt; object
     */
    public Observable<List<ServiceTypeInfoInner>> getServiceTypeInfoListAsync(String applicationTypeName, String applicationTypeVersion) {
        return getServiceTypeInfoListWithServiceResponseAsync(applicationTypeName, applicationTypeVersion).map(new Func1<ServiceResponse<List<ServiceTypeInfoInner>>, List<ServiceTypeInfoInner>>() {
            @Override
            public List<ServiceTypeInfoInner> call(ServiceResponse<List<ServiceTypeInfoInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the list containing the information about service types that are supported by a provisioned application type in a Service Fabric cluster.
     * Gets the list containing the information about service types that are supported by a provisioned application type in a Service Fabric cluster. The provided application type must exist. Otherwise, a 404 status is returned.
     *
     * @param applicationTypeName The name of the application type.
     * @param applicationTypeVersion The version of the application type.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ServiceTypeInfoInner&gt; object
     */
    public Observable<ServiceResponse<List<ServiceTypeInfoInner>>> getServiceTypeInfoListWithServiceResponseAsync(String applicationTypeName, String applicationTypeVersion) {
        if (applicationTypeName == null) {
            throw new IllegalArgumentException("Parameter applicationTypeName is required and cannot be null.");
        }
        if (applicationTypeVersion == null) {
            throw new IllegalArgumentException("Parameter applicationTypeVersion is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.getServiceTypeInfoList(applicationTypeName, apiVersion, applicationTypeVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ServiceTypeInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<ServiceTypeInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<ServiceTypeInfoInner>> clientResponse = getServiceTypeInfoListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the list containing the information about service types that are supported by a provisioned application type in a Service Fabric cluster.
     * Gets the list containing the information about service types that are supported by a provisioned application type in a Service Fabric cluster. The provided application type must exist. Otherwise, a 404 status is returned.
     *
     * @param applicationTypeName The name of the application type.
     * @param applicationTypeVersion The version of the application type.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ServiceTypeInfoInner&gt; object if successful.
     */
    public List<ServiceTypeInfoInner> getServiceTypeInfoList(String applicationTypeName, String applicationTypeVersion, Long timeout) {
        return getServiceTypeInfoListWithServiceResponseAsync(applicationTypeName, applicationTypeVersion, timeout).toBlocking().single().body();
    }

    /**
     * Gets the list containing the information about service types that are supported by a provisioned application type in a Service Fabric cluster.
     * Gets the list containing the information about service types that are supported by a provisioned application type in a Service Fabric cluster. The provided application type must exist. Otherwise, a 404 status is returned.
     *
     * @param applicationTypeName The name of the application type.
     * @param applicationTypeVersion The version of the application type.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ServiceTypeInfoInner>> getServiceTypeInfoListAsync(String applicationTypeName, String applicationTypeVersion, Long timeout, final ServiceCallback<List<ServiceTypeInfoInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getServiceTypeInfoListWithServiceResponseAsync(applicationTypeName, applicationTypeVersion, timeout), serviceCallback);
    }

    /**
     * Gets the list containing the information about service types that are supported by a provisioned application type in a Service Fabric cluster.
     * Gets the list containing the information about service types that are supported by a provisioned application type in a Service Fabric cluster. The provided application type must exist. Otherwise, a 404 status is returned.
     *
     * @param applicationTypeName The name of the application type.
     * @param applicationTypeVersion The version of the application type.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ServiceTypeInfoInner&gt; object
     */
    public Observable<List<ServiceTypeInfoInner>> getServiceTypeInfoListAsync(String applicationTypeName, String applicationTypeVersion, Long timeout) {
        return getServiceTypeInfoListWithServiceResponseAsync(applicationTypeName, applicationTypeVersion, timeout).map(new Func1<ServiceResponse<List<ServiceTypeInfoInner>>, List<ServiceTypeInfoInner>>() {
            @Override
            public List<ServiceTypeInfoInner> call(ServiceResponse<List<ServiceTypeInfoInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the list containing the information about service types that are supported by a provisioned application type in a Service Fabric cluster.
     * Gets the list containing the information about service types that are supported by a provisioned application type in a Service Fabric cluster. The provided application type must exist. Otherwise, a 404 status is returned.
     *
     * @param applicationTypeName The name of the application type.
     * @param applicationTypeVersion The version of the application type.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ServiceTypeInfoInner&gt; object
     */
    public Observable<ServiceResponse<List<ServiceTypeInfoInner>>> getServiceTypeInfoListWithServiceResponseAsync(String applicationTypeName, String applicationTypeVersion, Long timeout) {
        if (applicationTypeName == null) {
            throw new IllegalArgumentException("Parameter applicationTypeName is required and cannot be null.");
        }
        if (applicationTypeVersion == null) {
            throw new IllegalArgumentException("Parameter applicationTypeVersion is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.getServiceTypeInfoList(applicationTypeName, apiVersion, applicationTypeVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ServiceTypeInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<ServiceTypeInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<ServiceTypeInfoInner>> clientResponse = getServiceTypeInfoListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<ServiceTypeInfoInner>> getServiceTypeInfoListDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<ServiceTypeInfoInner>, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<ServiceTypeInfoInner>>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the information about a specific service type that is supported by a provisioned application type in a Service Fabric cluster.
     * Gets the information about a specific service type that is supported by a provisioned application type in a Service Fabric cluster. The provided application type must exist. Otherwise, a 404 status is returned. A 204 response is returned if the specified service type is not found in the cluster.
     *
     * @param applicationTypeName The name of the application type.
     * @param serviceTypeName Specifies the name of a Service Fabric service type.
     * @param applicationTypeVersion The version of the application type.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ServiceTypeInfoInner object if successful.
     */
    public ServiceTypeInfoInner getServiceTypeInfoByName(String applicationTypeName, String serviceTypeName, String applicationTypeVersion) {
        return getServiceTypeInfoByNameWithServiceResponseAsync(applicationTypeName, serviceTypeName, applicationTypeVersion).toBlocking().single().body();
    }

    /**
     * Gets the information about a specific service type that is supported by a provisioned application type in a Service Fabric cluster.
     * Gets the information about a specific service type that is supported by a provisioned application type in a Service Fabric cluster. The provided application type must exist. Otherwise, a 404 status is returned. A 204 response is returned if the specified service type is not found in the cluster.
     *
     * @param applicationTypeName The name of the application type.
     * @param serviceTypeName Specifies the name of a Service Fabric service type.
     * @param applicationTypeVersion The version of the application type.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ServiceTypeInfoInner> getServiceTypeInfoByNameAsync(String applicationTypeName, String serviceTypeName, String applicationTypeVersion, final ServiceCallback<ServiceTypeInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getServiceTypeInfoByNameWithServiceResponseAsync(applicationTypeName, serviceTypeName, applicationTypeVersion), serviceCallback);
    }

    /**
     * Gets the information about a specific service type that is supported by a provisioned application type in a Service Fabric cluster.
     * Gets the information about a specific service type that is supported by a provisioned application type in a Service Fabric cluster. The provided application type must exist. Otherwise, a 404 status is returned. A 204 response is returned if the specified service type is not found in the cluster.
     *
     * @param applicationTypeName The name of the application type.
     * @param serviceTypeName Specifies the name of a Service Fabric service type.
     * @param applicationTypeVersion The version of the application type.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServiceTypeInfoInner object
     */
    public Observable<ServiceTypeInfoInner> getServiceTypeInfoByNameAsync(String applicationTypeName, String serviceTypeName, String applicationTypeVersion) {
        return getServiceTypeInfoByNameWithServiceResponseAsync(applicationTypeName, serviceTypeName, applicationTypeVersion).map(new Func1<ServiceResponse<ServiceTypeInfoInner>, ServiceTypeInfoInner>() {
            @Override
            public ServiceTypeInfoInner call(ServiceResponse<ServiceTypeInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the information about a specific service type that is supported by a provisioned application type in a Service Fabric cluster.
     * Gets the information about a specific service type that is supported by a provisioned application type in a Service Fabric cluster. The provided application type must exist. Otherwise, a 404 status is returned. A 204 response is returned if the specified service type is not found in the cluster.
     *
     * @param applicationTypeName The name of the application type.
     * @param serviceTypeName Specifies the name of a Service Fabric service type.
     * @param applicationTypeVersion The version of the application type.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServiceTypeInfoInner object
     */
    public Observable<ServiceResponse<ServiceTypeInfoInner>> getServiceTypeInfoByNameWithServiceResponseAsync(String applicationTypeName, String serviceTypeName, String applicationTypeVersion) {
        if (applicationTypeName == null) {
            throw new IllegalArgumentException("Parameter applicationTypeName is required and cannot be null.");
        }
        if (serviceTypeName == null) {
            throw new IllegalArgumentException("Parameter serviceTypeName is required and cannot be null.");
        }
        if (applicationTypeVersion == null) {
            throw new IllegalArgumentException("Parameter applicationTypeVersion is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.getServiceTypeInfoByName(applicationTypeName, serviceTypeName, apiVersion, applicationTypeVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ServiceTypeInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<ServiceTypeInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ServiceTypeInfoInner> clientResponse = getServiceTypeInfoByNameDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the information about a specific service type that is supported by a provisioned application type in a Service Fabric cluster.
     * Gets the information about a specific service type that is supported by a provisioned application type in a Service Fabric cluster. The provided application type must exist. Otherwise, a 404 status is returned. A 204 response is returned if the specified service type is not found in the cluster.
     *
     * @param applicationTypeName The name of the application type.
     * @param serviceTypeName Specifies the name of a Service Fabric service type.
     * @param applicationTypeVersion The version of the application type.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ServiceTypeInfoInner object if successful.
     */
    public ServiceTypeInfoInner getServiceTypeInfoByName(String applicationTypeName, String serviceTypeName, String applicationTypeVersion, Long timeout) {
        return getServiceTypeInfoByNameWithServiceResponseAsync(applicationTypeName, serviceTypeName, applicationTypeVersion, timeout).toBlocking().single().body();
    }

    /**
     * Gets the information about a specific service type that is supported by a provisioned application type in a Service Fabric cluster.
     * Gets the information about a specific service type that is supported by a provisioned application type in a Service Fabric cluster. The provided application type must exist. Otherwise, a 404 status is returned. A 204 response is returned if the specified service type is not found in the cluster.
     *
     * @param applicationTypeName The name of the application type.
     * @param serviceTypeName Specifies the name of a Service Fabric service type.
     * @param applicationTypeVersion The version of the application type.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ServiceTypeInfoInner> getServiceTypeInfoByNameAsync(String applicationTypeName, String serviceTypeName, String applicationTypeVersion, Long timeout, final ServiceCallback<ServiceTypeInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getServiceTypeInfoByNameWithServiceResponseAsync(applicationTypeName, serviceTypeName, applicationTypeVersion, timeout), serviceCallback);
    }

    /**
     * Gets the information about a specific service type that is supported by a provisioned application type in a Service Fabric cluster.
     * Gets the information about a specific service type that is supported by a provisioned application type in a Service Fabric cluster. The provided application type must exist. Otherwise, a 404 status is returned. A 204 response is returned if the specified service type is not found in the cluster.
     *
     * @param applicationTypeName The name of the application type.
     * @param serviceTypeName Specifies the name of a Service Fabric service type.
     * @param applicationTypeVersion The version of the application type.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServiceTypeInfoInner object
     */
    public Observable<ServiceTypeInfoInner> getServiceTypeInfoByNameAsync(String applicationTypeName, String serviceTypeName, String applicationTypeVersion, Long timeout) {
        return getServiceTypeInfoByNameWithServiceResponseAsync(applicationTypeName, serviceTypeName, applicationTypeVersion, timeout).map(new Func1<ServiceResponse<ServiceTypeInfoInner>, ServiceTypeInfoInner>() {
            @Override
            public ServiceTypeInfoInner call(ServiceResponse<ServiceTypeInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the information about a specific service type that is supported by a provisioned application type in a Service Fabric cluster.
     * Gets the information about a specific service type that is supported by a provisioned application type in a Service Fabric cluster. The provided application type must exist. Otherwise, a 404 status is returned. A 204 response is returned if the specified service type is not found in the cluster.
     *
     * @param applicationTypeName The name of the application type.
     * @param serviceTypeName Specifies the name of a Service Fabric service type.
     * @param applicationTypeVersion The version of the application type.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServiceTypeInfoInner object
     */
    public Observable<ServiceResponse<ServiceTypeInfoInner>> getServiceTypeInfoByNameWithServiceResponseAsync(String applicationTypeName, String serviceTypeName, String applicationTypeVersion, Long timeout) {
        if (applicationTypeName == null) {
            throw new IllegalArgumentException("Parameter applicationTypeName is required and cannot be null.");
        }
        if (serviceTypeName == null) {
            throw new IllegalArgumentException("Parameter serviceTypeName is required and cannot be null.");
        }
        if (applicationTypeVersion == null) {
            throw new IllegalArgumentException("Parameter applicationTypeVersion is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.getServiceTypeInfoByName(applicationTypeName, serviceTypeName, apiVersion, applicationTypeVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ServiceTypeInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<ServiceTypeInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ServiceTypeInfoInner> clientResponse = getServiceTypeInfoByNameDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ServiceTypeInfoInner> getServiceTypeInfoByNameDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ServiceTypeInfoInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ServiceTypeInfoInner>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the manifest describing a service type.
     * Gets the manifest describing a service type. The response contains the service manifest XML as a string.
     *
     * @param applicationTypeName The name of the application type.
     * @param applicationTypeVersion The version of the application type.
     * @param serviceManifestName The name of a service manifest registered as part of an application type in a Service Fabric cluster.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ServiceTypeManifestInner object if successful.
     */
    public ServiceTypeManifestInner getServiceManifest(String applicationTypeName, String applicationTypeVersion, String serviceManifestName) {
        return getServiceManifestWithServiceResponseAsync(applicationTypeName, applicationTypeVersion, serviceManifestName).toBlocking().single().body();
    }

    /**
     * Gets the manifest describing a service type.
     * Gets the manifest describing a service type. The response contains the service manifest XML as a string.
     *
     * @param applicationTypeName The name of the application type.
     * @param applicationTypeVersion The version of the application type.
     * @param serviceManifestName The name of a service manifest registered as part of an application type in a Service Fabric cluster.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ServiceTypeManifestInner> getServiceManifestAsync(String applicationTypeName, String applicationTypeVersion, String serviceManifestName, final ServiceCallback<ServiceTypeManifestInner> serviceCallback) {
        return ServiceFuture.fromResponse(getServiceManifestWithServiceResponseAsync(applicationTypeName, applicationTypeVersion, serviceManifestName), serviceCallback);
    }

    /**
     * Gets the manifest describing a service type.
     * Gets the manifest describing a service type. The response contains the service manifest XML as a string.
     *
     * @param applicationTypeName The name of the application type.
     * @param applicationTypeVersion The version of the application type.
     * @param serviceManifestName The name of a service manifest registered as part of an application type in a Service Fabric cluster.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServiceTypeManifestInner object
     */
    public Observable<ServiceTypeManifestInner> getServiceManifestAsync(String applicationTypeName, String applicationTypeVersion, String serviceManifestName) {
        return getServiceManifestWithServiceResponseAsync(applicationTypeName, applicationTypeVersion, serviceManifestName).map(new Func1<ServiceResponse<ServiceTypeManifestInner>, ServiceTypeManifestInner>() {
            @Override
            public ServiceTypeManifestInner call(ServiceResponse<ServiceTypeManifestInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the manifest describing a service type.
     * Gets the manifest describing a service type. The response contains the service manifest XML as a string.
     *
     * @param applicationTypeName The name of the application type.
     * @param applicationTypeVersion The version of the application type.
     * @param serviceManifestName The name of a service manifest registered as part of an application type in a Service Fabric cluster.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServiceTypeManifestInner object
     */
    public Observable<ServiceResponse<ServiceTypeManifestInner>> getServiceManifestWithServiceResponseAsync(String applicationTypeName, String applicationTypeVersion, String serviceManifestName) {
        if (applicationTypeName == null) {
            throw new IllegalArgumentException("Parameter applicationTypeName is required and cannot be null.");
        }
        if (applicationTypeVersion == null) {
            throw new IllegalArgumentException("Parameter applicationTypeVersion is required and cannot be null.");
        }
        if (serviceManifestName == null) {
            throw new IllegalArgumentException("Parameter serviceManifestName is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.getServiceManifest(applicationTypeName, apiVersion, applicationTypeVersion, serviceManifestName, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ServiceTypeManifestInner>>>() {
                @Override
                public Observable<ServiceResponse<ServiceTypeManifestInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ServiceTypeManifestInner> clientResponse = getServiceManifestDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the manifest describing a service type.
     * Gets the manifest describing a service type. The response contains the service manifest XML as a string.
     *
     * @param applicationTypeName The name of the application type.
     * @param applicationTypeVersion The version of the application type.
     * @param serviceManifestName The name of a service manifest registered as part of an application type in a Service Fabric cluster.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ServiceTypeManifestInner object if successful.
     */
    public ServiceTypeManifestInner getServiceManifest(String applicationTypeName, String applicationTypeVersion, String serviceManifestName, Long timeout) {
        return getServiceManifestWithServiceResponseAsync(applicationTypeName, applicationTypeVersion, serviceManifestName, timeout).toBlocking().single().body();
    }

    /**
     * Gets the manifest describing a service type.
     * Gets the manifest describing a service type. The response contains the service manifest XML as a string.
     *
     * @param applicationTypeName The name of the application type.
     * @param applicationTypeVersion The version of the application type.
     * @param serviceManifestName The name of a service manifest registered as part of an application type in a Service Fabric cluster.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ServiceTypeManifestInner> getServiceManifestAsync(String applicationTypeName, String applicationTypeVersion, String serviceManifestName, Long timeout, final ServiceCallback<ServiceTypeManifestInner> serviceCallback) {
        return ServiceFuture.fromResponse(getServiceManifestWithServiceResponseAsync(applicationTypeName, applicationTypeVersion, serviceManifestName, timeout), serviceCallback);
    }

    /**
     * Gets the manifest describing a service type.
     * Gets the manifest describing a service type. The response contains the service manifest XML as a string.
     *
     * @param applicationTypeName The name of the application type.
     * @param applicationTypeVersion The version of the application type.
     * @param serviceManifestName The name of a service manifest registered as part of an application type in a Service Fabric cluster.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServiceTypeManifestInner object
     */
    public Observable<ServiceTypeManifestInner> getServiceManifestAsync(String applicationTypeName, String applicationTypeVersion, String serviceManifestName, Long timeout) {
        return getServiceManifestWithServiceResponseAsync(applicationTypeName, applicationTypeVersion, serviceManifestName, timeout).map(new Func1<ServiceResponse<ServiceTypeManifestInner>, ServiceTypeManifestInner>() {
            @Override
            public ServiceTypeManifestInner call(ServiceResponse<ServiceTypeManifestInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the manifest describing a service type.
     * Gets the manifest describing a service type. The response contains the service manifest XML as a string.
     *
     * @param applicationTypeName The name of the application type.
     * @param applicationTypeVersion The version of the application type.
     * @param serviceManifestName The name of a service manifest registered as part of an application type in a Service Fabric cluster.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServiceTypeManifestInner object
     */
    public Observable<ServiceResponse<ServiceTypeManifestInner>> getServiceManifestWithServiceResponseAsync(String applicationTypeName, String applicationTypeVersion, String serviceManifestName, Long timeout) {
        if (applicationTypeName == null) {
            throw new IllegalArgumentException("Parameter applicationTypeName is required and cannot be null.");
        }
        if (applicationTypeVersion == null) {
            throw new IllegalArgumentException("Parameter applicationTypeVersion is required and cannot be null.");
        }
        if (serviceManifestName == null) {
            throw new IllegalArgumentException("Parameter serviceManifestName is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.getServiceManifest(applicationTypeName, apiVersion, applicationTypeVersion, serviceManifestName, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ServiceTypeManifestInner>>>() {
                @Override
                public Observable<ServiceResponse<ServiceTypeManifestInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ServiceTypeManifestInner> clientResponse = getServiceManifestDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ServiceTypeManifestInner> getServiceManifestDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ServiceTypeManifestInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ServiceTypeManifestInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the list containing the information about service types from the applications deployed on a node in a Service Fabric cluster.
     * Gets the list containing the information about service types from the applications deployed on a node in a Service Fabric cluster. The response includes the name of the service type, its registration status, the code package that registered it and activation ID of the service package.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;DeployedServiceTypeInfoInner&gt; object if successful.
     */
    public List<DeployedServiceTypeInfoInner> getDeployedServiceTypeInfoList(String nodeName, String applicationId) {
        return getDeployedServiceTypeInfoListWithServiceResponseAsync(nodeName, applicationId).toBlocking().single().body();
    }

    /**
     * Gets the list containing the information about service types from the applications deployed on a node in a Service Fabric cluster.
     * Gets the list containing the information about service types from the applications deployed on a node in a Service Fabric cluster. The response includes the name of the service type, its registration status, the code package that registered it and activation ID of the service package.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<DeployedServiceTypeInfoInner>> getDeployedServiceTypeInfoListAsync(String nodeName, String applicationId, final ServiceCallback<List<DeployedServiceTypeInfoInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getDeployedServiceTypeInfoListWithServiceResponseAsync(nodeName, applicationId), serviceCallback);
    }

    /**
     * Gets the list containing the information about service types from the applications deployed on a node in a Service Fabric cluster.
     * Gets the list containing the information about service types from the applications deployed on a node in a Service Fabric cluster. The response includes the name of the service type, its registration status, the code package that registered it and activation ID of the service package.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;DeployedServiceTypeInfoInner&gt; object
     */
    public Observable<List<DeployedServiceTypeInfoInner>> getDeployedServiceTypeInfoListAsync(String nodeName, String applicationId) {
        return getDeployedServiceTypeInfoListWithServiceResponseAsync(nodeName, applicationId).map(new Func1<ServiceResponse<List<DeployedServiceTypeInfoInner>>, List<DeployedServiceTypeInfoInner>>() {
            @Override
            public List<DeployedServiceTypeInfoInner> call(ServiceResponse<List<DeployedServiceTypeInfoInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the list containing the information about service types from the applications deployed on a node in a Service Fabric cluster.
     * Gets the list containing the information about service types from the applications deployed on a node in a Service Fabric cluster. The response includes the name of the service type, its registration status, the code package that registered it and activation ID of the service package.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;DeployedServiceTypeInfoInner&gt; object
     */
    public Observable<ServiceResponse<List<DeployedServiceTypeInfoInner>>> getDeployedServiceTypeInfoListWithServiceResponseAsync(String nodeName, String applicationId) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final String serviceManifestName = null;
        final Long timeout = null;
        return service.getDeployedServiceTypeInfoList(nodeName, applicationId, apiVersion, serviceManifestName, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<DeployedServiceTypeInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<DeployedServiceTypeInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<DeployedServiceTypeInfoInner>> clientResponse = getDeployedServiceTypeInfoListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the list containing the information about service types from the applications deployed on a node in a Service Fabric cluster.
     * Gets the list containing the information about service types from the applications deployed on a node in a Service Fabric cluster. The response includes the name of the service type, its registration status, the code package that registered it and activation ID of the service package.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceManifestName The name of the service manifest to filter the list of deployed service type information. If specified, the response will only contain the information about service types that are defined in this service manifest.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;DeployedServiceTypeInfoInner&gt; object if successful.
     */
    public List<DeployedServiceTypeInfoInner> getDeployedServiceTypeInfoList(String nodeName, String applicationId, String serviceManifestName, Long timeout) {
        return getDeployedServiceTypeInfoListWithServiceResponseAsync(nodeName, applicationId, serviceManifestName, timeout).toBlocking().single().body();
    }

    /**
     * Gets the list containing the information about service types from the applications deployed on a node in a Service Fabric cluster.
     * Gets the list containing the information about service types from the applications deployed on a node in a Service Fabric cluster. The response includes the name of the service type, its registration status, the code package that registered it and activation ID of the service package.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceManifestName The name of the service manifest to filter the list of deployed service type information. If specified, the response will only contain the information about service types that are defined in this service manifest.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<DeployedServiceTypeInfoInner>> getDeployedServiceTypeInfoListAsync(String nodeName, String applicationId, String serviceManifestName, Long timeout, final ServiceCallback<List<DeployedServiceTypeInfoInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getDeployedServiceTypeInfoListWithServiceResponseAsync(nodeName, applicationId, serviceManifestName, timeout), serviceCallback);
    }

    /**
     * Gets the list containing the information about service types from the applications deployed on a node in a Service Fabric cluster.
     * Gets the list containing the information about service types from the applications deployed on a node in a Service Fabric cluster. The response includes the name of the service type, its registration status, the code package that registered it and activation ID of the service package.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceManifestName The name of the service manifest to filter the list of deployed service type information. If specified, the response will only contain the information about service types that are defined in this service manifest.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;DeployedServiceTypeInfoInner&gt; object
     */
    public Observable<List<DeployedServiceTypeInfoInner>> getDeployedServiceTypeInfoListAsync(String nodeName, String applicationId, String serviceManifestName, Long timeout) {
        return getDeployedServiceTypeInfoListWithServiceResponseAsync(nodeName, applicationId, serviceManifestName, timeout).map(new Func1<ServiceResponse<List<DeployedServiceTypeInfoInner>>, List<DeployedServiceTypeInfoInner>>() {
            @Override
            public List<DeployedServiceTypeInfoInner> call(ServiceResponse<List<DeployedServiceTypeInfoInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the list containing the information about service types from the applications deployed on a node in a Service Fabric cluster.
     * Gets the list containing the information about service types from the applications deployed on a node in a Service Fabric cluster. The response includes the name of the service type, its registration status, the code package that registered it and activation ID of the service package.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceManifestName The name of the service manifest to filter the list of deployed service type information. If specified, the response will only contain the information about service types that are defined in this service manifest.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;DeployedServiceTypeInfoInner&gt; object
     */
    public Observable<ServiceResponse<List<DeployedServiceTypeInfoInner>>> getDeployedServiceTypeInfoListWithServiceResponseAsync(String nodeName, String applicationId, String serviceManifestName, Long timeout) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.getDeployedServiceTypeInfoList(nodeName, applicationId, apiVersion, serviceManifestName, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<DeployedServiceTypeInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<DeployedServiceTypeInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<DeployedServiceTypeInfoInner>> clientResponse = getDeployedServiceTypeInfoListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<DeployedServiceTypeInfoInner>> getDeployedServiceTypeInfoListDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<DeployedServiceTypeInfoInner>, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<DeployedServiceTypeInfoInner>>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the information about a specified service type of the application deployed on a node in a Service Fabric cluster.
     * Gets the list containing the information about a specific service type from the applications deployed on a node in a Service Fabric cluster. The response includes the name of the service type, its registration status, the code package that registered it and activation ID of the service package. Each entry represents one activation of a service type, differentiated by the activation ID.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceTypeName Specifies the name of a Service Fabric service type.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;DeployedServiceTypeInfoInner&gt; object if successful.
     */
    public List<DeployedServiceTypeInfoInner> getDeployedServiceTypeInfoByName(String nodeName, String applicationId, String serviceTypeName) {
        return getDeployedServiceTypeInfoByNameWithServiceResponseAsync(nodeName, applicationId, serviceTypeName).toBlocking().single().body();
    }

    /**
     * Gets the information about a specified service type of the application deployed on a node in a Service Fabric cluster.
     * Gets the list containing the information about a specific service type from the applications deployed on a node in a Service Fabric cluster. The response includes the name of the service type, its registration status, the code package that registered it and activation ID of the service package. Each entry represents one activation of a service type, differentiated by the activation ID.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceTypeName Specifies the name of a Service Fabric service type.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<DeployedServiceTypeInfoInner>> getDeployedServiceTypeInfoByNameAsync(String nodeName, String applicationId, String serviceTypeName, final ServiceCallback<List<DeployedServiceTypeInfoInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getDeployedServiceTypeInfoByNameWithServiceResponseAsync(nodeName, applicationId, serviceTypeName), serviceCallback);
    }

    /**
     * Gets the information about a specified service type of the application deployed on a node in a Service Fabric cluster.
     * Gets the list containing the information about a specific service type from the applications deployed on a node in a Service Fabric cluster. The response includes the name of the service type, its registration status, the code package that registered it and activation ID of the service package. Each entry represents one activation of a service type, differentiated by the activation ID.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceTypeName Specifies the name of a Service Fabric service type.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;DeployedServiceTypeInfoInner&gt; object
     */
    public Observable<List<DeployedServiceTypeInfoInner>> getDeployedServiceTypeInfoByNameAsync(String nodeName, String applicationId, String serviceTypeName) {
        return getDeployedServiceTypeInfoByNameWithServiceResponseAsync(nodeName, applicationId, serviceTypeName).map(new Func1<ServiceResponse<List<DeployedServiceTypeInfoInner>>, List<DeployedServiceTypeInfoInner>>() {
            @Override
            public List<DeployedServiceTypeInfoInner> call(ServiceResponse<List<DeployedServiceTypeInfoInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the information about a specified service type of the application deployed on a node in a Service Fabric cluster.
     * Gets the list containing the information about a specific service type from the applications deployed on a node in a Service Fabric cluster. The response includes the name of the service type, its registration status, the code package that registered it and activation ID of the service package. Each entry represents one activation of a service type, differentiated by the activation ID.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceTypeName Specifies the name of a Service Fabric service type.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;DeployedServiceTypeInfoInner&gt; object
     */
    public Observable<ServiceResponse<List<DeployedServiceTypeInfoInner>>> getDeployedServiceTypeInfoByNameWithServiceResponseAsync(String nodeName, String applicationId, String serviceTypeName) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        if (serviceTypeName == null) {
            throw new IllegalArgumentException("Parameter serviceTypeName is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final String serviceManifestName = null;
        final Long timeout = null;
        return service.getDeployedServiceTypeInfoByName(nodeName, applicationId, serviceTypeName, apiVersion, serviceManifestName, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<DeployedServiceTypeInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<DeployedServiceTypeInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<DeployedServiceTypeInfoInner>> clientResponse = getDeployedServiceTypeInfoByNameDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the information about a specified service type of the application deployed on a node in a Service Fabric cluster.
     * Gets the list containing the information about a specific service type from the applications deployed on a node in a Service Fabric cluster. The response includes the name of the service type, its registration status, the code package that registered it and activation ID of the service package. Each entry represents one activation of a service type, differentiated by the activation ID.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceTypeName Specifies the name of a Service Fabric service type.
     * @param serviceManifestName The name of the service manifest to filter the list of deployed service type information. If specified, the response will only contain the information about service types that are defined in this service manifest.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;DeployedServiceTypeInfoInner&gt; object if successful.
     */
    public List<DeployedServiceTypeInfoInner> getDeployedServiceTypeInfoByName(String nodeName, String applicationId, String serviceTypeName, String serviceManifestName, Long timeout) {
        return getDeployedServiceTypeInfoByNameWithServiceResponseAsync(nodeName, applicationId, serviceTypeName, serviceManifestName, timeout).toBlocking().single().body();
    }

    /**
     * Gets the information about a specified service type of the application deployed on a node in a Service Fabric cluster.
     * Gets the list containing the information about a specific service type from the applications deployed on a node in a Service Fabric cluster. The response includes the name of the service type, its registration status, the code package that registered it and activation ID of the service package. Each entry represents one activation of a service type, differentiated by the activation ID.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceTypeName Specifies the name of a Service Fabric service type.
     * @param serviceManifestName The name of the service manifest to filter the list of deployed service type information. If specified, the response will only contain the information about service types that are defined in this service manifest.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<DeployedServiceTypeInfoInner>> getDeployedServiceTypeInfoByNameAsync(String nodeName, String applicationId, String serviceTypeName, String serviceManifestName, Long timeout, final ServiceCallback<List<DeployedServiceTypeInfoInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getDeployedServiceTypeInfoByNameWithServiceResponseAsync(nodeName, applicationId, serviceTypeName, serviceManifestName, timeout), serviceCallback);
    }

    /**
     * Gets the information about a specified service type of the application deployed on a node in a Service Fabric cluster.
     * Gets the list containing the information about a specific service type from the applications deployed on a node in a Service Fabric cluster. The response includes the name of the service type, its registration status, the code package that registered it and activation ID of the service package. Each entry represents one activation of a service type, differentiated by the activation ID.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceTypeName Specifies the name of a Service Fabric service type.
     * @param serviceManifestName The name of the service manifest to filter the list of deployed service type information. If specified, the response will only contain the information about service types that are defined in this service manifest.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;DeployedServiceTypeInfoInner&gt; object
     */
    public Observable<List<DeployedServiceTypeInfoInner>> getDeployedServiceTypeInfoByNameAsync(String nodeName, String applicationId, String serviceTypeName, String serviceManifestName, Long timeout) {
        return getDeployedServiceTypeInfoByNameWithServiceResponseAsync(nodeName, applicationId, serviceTypeName, serviceManifestName, timeout).map(new Func1<ServiceResponse<List<DeployedServiceTypeInfoInner>>, List<DeployedServiceTypeInfoInner>>() {
            @Override
            public List<DeployedServiceTypeInfoInner> call(ServiceResponse<List<DeployedServiceTypeInfoInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the information about a specified service type of the application deployed on a node in a Service Fabric cluster.
     * Gets the list containing the information about a specific service type from the applications deployed on a node in a Service Fabric cluster. The response includes the name of the service type, its registration status, the code package that registered it and activation ID of the service package. Each entry represents one activation of a service type, differentiated by the activation ID.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceTypeName Specifies the name of a Service Fabric service type.
     * @param serviceManifestName The name of the service manifest to filter the list of deployed service type information. If specified, the response will only contain the information about service types that are defined in this service manifest.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;DeployedServiceTypeInfoInner&gt; object
     */
    public Observable<ServiceResponse<List<DeployedServiceTypeInfoInner>>> getDeployedServiceTypeInfoByNameWithServiceResponseAsync(String nodeName, String applicationId, String serviceTypeName, String serviceManifestName, Long timeout) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        if (serviceTypeName == null) {
            throw new IllegalArgumentException("Parameter serviceTypeName is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.getDeployedServiceTypeInfoByName(nodeName, applicationId, serviceTypeName, apiVersion, serviceManifestName, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<DeployedServiceTypeInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<DeployedServiceTypeInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<DeployedServiceTypeInfoInner>> clientResponse = getDeployedServiceTypeInfoByNameDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<DeployedServiceTypeInfoInner>> getDeployedServiceTypeInfoByNameDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<DeployedServiceTypeInfoInner>, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<DeployedServiceTypeInfoInner>>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Creates a Service Fabric application.
     * Creates a Service Fabric application using the specified description.
     *
     * @param applicationDescription Description for creating an application.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void createApplication(ApplicationDescription applicationDescription) {
        createApplicationWithServiceResponseAsync(applicationDescription).toBlocking().single().body();
    }

    /**
     * Creates a Service Fabric application.
     * Creates a Service Fabric application using the specified description.
     *
     * @param applicationDescription Description for creating an application.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> createApplicationAsync(ApplicationDescription applicationDescription, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(createApplicationWithServiceResponseAsync(applicationDescription), serviceCallback);
    }

    /**
     * Creates a Service Fabric application.
     * Creates a Service Fabric application using the specified description.
     *
     * @param applicationDescription Description for creating an application.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> createApplicationAsync(ApplicationDescription applicationDescription) {
        return createApplicationWithServiceResponseAsync(applicationDescription).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a Service Fabric application.
     * Creates a Service Fabric application using the specified description.
     *
     * @param applicationDescription Description for creating an application.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> createApplicationWithServiceResponseAsync(ApplicationDescription applicationDescription) {
        if (applicationDescription == null) {
            throw new IllegalArgumentException("Parameter applicationDescription is required and cannot be null.");
        }
        Validator.validate(applicationDescription);
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.createApplication(apiVersion, applicationDescription, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = createApplicationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Creates a Service Fabric application.
     * Creates a Service Fabric application using the specified description.
     *
     * @param applicationDescription Description for creating an application.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void createApplication(ApplicationDescription applicationDescription, Long timeout) {
        createApplicationWithServiceResponseAsync(applicationDescription, timeout).toBlocking().single().body();
    }

    /**
     * Creates a Service Fabric application.
     * Creates a Service Fabric application using the specified description.
     *
     * @param applicationDescription Description for creating an application.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> createApplicationAsync(ApplicationDescription applicationDescription, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(createApplicationWithServiceResponseAsync(applicationDescription, timeout), serviceCallback);
    }

    /**
     * Creates a Service Fabric application.
     * Creates a Service Fabric application using the specified description.
     *
     * @param applicationDescription Description for creating an application.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> createApplicationAsync(ApplicationDescription applicationDescription, Long timeout) {
        return createApplicationWithServiceResponseAsync(applicationDescription, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a Service Fabric application.
     * Creates a Service Fabric application using the specified description.
     *
     * @param applicationDescription Description for creating an application.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> createApplicationWithServiceResponseAsync(ApplicationDescription applicationDescription, Long timeout) {
        if (applicationDescription == null) {
            throw new IllegalArgumentException("Parameter applicationDescription is required and cannot be null.");
        }
        Validator.validate(applicationDescription);
        final String apiVersion = "6.0";
        return service.createApplication(apiVersion, applicationDescription, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = createApplicationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> createApplicationDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(201, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Deletes an existing Service Fabric application.
     * An application must be created before it can be deleted. Deleting an application will delete all services that are part of that application. By default, Service Fabric will try to close service replicas in a graceful manner and then delete the service. However, if a service is having issues closing the replica gracefully, the delete operation may take a long time or get stuck. Use the optional ForceRemove flag to skip the graceful close sequence and forcefully delete the application and all of its services.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteApplication(String applicationId) {
        deleteApplicationWithServiceResponseAsync(applicationId).toBlocking().single().body();
    }

    /**
     * Deletes an existing Service Fabric application.
     * An application must be created before it can be deleted. Deleting an application will delete all services that are part of that application. By default, Service Fabric will try to close service replicas in a graceful manner and then delete the service. However, if a service is having issues closing the replica gracefully, the delete operation may take a long time or get stuck. Use the optional ForceRemove flag to skip the graceful close sequence and forcefully delete the application and all of its services.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteApplicationAsync(String applicationId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteApplicationWithServiceResponseAsync(applicationId), serviceCallback);
    }

    /**
     * Deletes an existing Service Fabric application.
     * An application must be created before it can be deleted. Deleting an application will delete all services that are part of that application. By default, Service Fabric will try to close service replicas in a graceful manner and then delete the service. However, if a service is having issues closing the replica gracefully, the delete operation may take a long time or get stuck. Use the optional ForceRemove flag to skip the graceful close sequence and forcefully delete the application and all of its services.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteApplicationAsync(String applicationId) {
        return deleteApplicationWithServiceResponseAsync(applicationId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes an existing Service Fabric application.
     * An application must be created before it can be deleted. Deleting an application will delete all services that are part of that application. By default, Service Fabric will try to close service replicas in a graceful manner and then delete the service. However, if a service is having issues closing the replica gracefully, the delete operation may take a long time or get stuck. Use the optional ForceRemove flag to skip the graceful close sequence and forcefully delete the application and all of its services.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteApplicationWithServiceResponseAsync(String applicationId) {
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Boolean forceRemove = null;
        final Long timeout = null;
        return service.deleteApplication(applicationId, apiVersion, forceRemove, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteApplicationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Deletes an existing Service Fabric application.
     * An application must be created before it can be deleted. Deleting an application will delete all services that are part of that application. By default, Service Fabric will try to close service replicas in a graceful manner and then delete the service. However, if a service is having issues closing the replica gracefully, the delete operation may take a long time or get stuck. Use the optional ForceRemove flag to skip the graceful close sequence and forcefully delete the application and all of its services.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param forceRemove Remove a Service Fabric application or service forcefully without going through the graceful shutdown sequence. This parameter can be used to forcefully delete an application or service for which delete is timing out due to issues in the service code that prevents graceful close of replicas.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteApplication(String applicationId, Boolean forceRemove, Long timeout) {
        deleteApplicationWithServiceResponseAsync(applicationId, forceRemove, timeout).toBlocking().single().body();
    }

    /**
     * Deletes an existing Service Fabric application.
     * An application must be created before it can be deleted. Deleting an application will delete all services that are part of that application. By default, Service Fabric will try to close service replicas in a graceful manner and then delete the service. However, if a service is having issues closing the replica gracefully, the delete operation may take a long time or get stuck. Use the optional ForceRemove flag to skip the graceful close sequence and forcefully delete the application and all of its services.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param forceRemove Remove a Service Fabric application or service forcefully without going through the graceful shutdown sequence. This parameter can be used to forcefully delete an application or service for which delete is timing out due to issues in the service code that prevents graceful close of replicas.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteApplicationAsync(String applicationId, Boolean forceRemove, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteApplicationWithServiceResponseAsync(applicationId, forceRemove, timeout), serviceCallback);
    }

    /**
     * Deletes an existing Service Fabric application.
     * An application must be created before it can be deleted. Deleting an application will delete all services that are part of that application. By default, Service Fabric will try to close service replicas in a graceful manner and then delete the service. However, if a service is having issues closing the replica gracefully, the delete operation may take a long time or get stuck. Use the optional ForceRemove flag to skip the graceful close sequence and forcefully delete the application and all of its services.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param forceRemove Remove a Service Fabric application or service forcefully without going through the graceful shutdown sequence. This parameter can be used to forcefully delete an application or service for which delete is timing out due to issues in the service code that prevents graceful close of replicas.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteApplicationAsync(String applicationId, Boolean forceRemove, Long timeout) {
        return deleteApplicationWithServiceResponseAsync(applicationId, forceRemove, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes an existing Service Fabric application.
     * An application must be created before it can be deleted. Deleting an application will delete all services that are part of that application. By default, Service Fabric will try to close service replicas in a graceful manner and then delete the service. However, if a service is having issues closing the replica gracefully, the delete operation may take a long time or get stuck. Use the optional ForceRemove flag to skip the graceful close sequence and forcefully delete the application and all of its services.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param forceRemove Remove a Service Fabric application or service forcefully without going through the graceful shutdown sequence. This parameter can be used to forcefully delete an application or service for which delete is timing out due to issues in the service code that prevents graceful close of replicas.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteApplicationWithServiceResponseAsync(String applicationId, Boolean forceRemove, Long timeout) {
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.deleteApplication(applicationId, apiVersion, forceRemove, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteApplicationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteApplicationDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets load information about a Service Fabric application.
     * Returns the load information about the application that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, minimum nodes, maximum nodes, the number of nodes the application is occupying currently, and application load metric information about the application.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ApplicationLoadInfoInner object if successful.
     */
    public ApplicationLoadInfoInner getApplicationLoadInfo(String applicationId) {
        return getApplicationLoadInfoWithServiceResponseAsync(applicationId).toBlocking().single().body();
    }

    /**
     * Gets load information about a Service Fabric application.
     * Returns the load information about the application that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, minimum nodes, maximum nodes, the number of nodes the application is occupying currently, and application load metric information about the application.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ApplicationLoadInfoInner> getApplicationLoadInfoAsync(String applicationId, final ServiceCallback<ApplicationLoadInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getApplicationLoadInfoWithServiceResponseAsync(applicationId), serviceCallback);
    }

    /**
     * Gets load information about a Service Fabric application.
     * Returns the load information about the application that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, minimum nodes, maximum nodes, the number of nodes the application is occupying currently, and application load metric information about the application.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationLoadInfoInner object
     */
    public Observable<ApplicationLoadInfoInner> getApplicationLoadInfoAsync(String applicationId) {
        return getApplicationLoadInfoWithServiceResponseAsync(applicationId).map(new Func1<ServiceResponse<ApplicationLoadInfoInner>, ApplicationLoadInfoInner>() {
            @Override
            public ApplicationLoadInfoInner call(ServiceResponse<ApplicationLoadInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets load information about a Service Fabric application.
     * Returns the load information about the application that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, minimum nodes, maximum nodes, the number of nodes the application is occupying currently, and application load metric information about the application.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationLoadInfoInner object
     */
    public Observable<ServiceResponse<ApplicationLoadInfoInner>> getApplicationLoadInfoWithServiceResponseAsync(String applicationId) {
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.getApplicationLoadInfo(applicationId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ApplicationLoadInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<ApplicationLoadInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ApplicationLoadInfoInner> clientResponse = getApplicationLoadInfoDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets load information about a Service Fabric application.
     * Returns the load information about the application that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, minimum nodes, maximum nodes, the number of nodes the application is occupying currently, and application load metric information about the application.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ApplicationLoadInfoInner object if successful.
     */
    public ApplicationLoadInfoInner getApplicationLoadInfo(String applicationId, Long timeout) {
        return getApplicationLoadInfoWithServiceResponseAsync(applicationId, timeout).toBlocking().single().body();
    }

    /**
     * Gets load information about a Service Fabric application.
     * Returns the load information about the application that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, minimum nodes, maximum nodes, the number of nodes the application is occupying currently, and application load metric information about the application.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ApplicationLoadInfoInner> getApplicationLoadInfoAsync(String applicationId, Long timeout, final ServiceCallback<ApplicationLoadInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getApplicationLoadInfoWithServiceResponseAsync(applicationId, timeout), serviceCallback);
    }

    /**
     * Gets load information about a Service Fabric application.
     * Returns the load information about the application that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, minimum nodes, maximum nodes, the number of nodes the application is occupying currently, and application load metric information about the application.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationLoadInfoInner object
     */
    public Observable<ApplicationLoadInfoInner> getApplicationLoadInfoAsync(String applicationId, Long timeout) {
        return getApplicationLoadInfoWithServiceResponseAsync(applicationId, timeout).map(new Func1<ServiceResponse<ApplicationLoadInfoInner>, ApplicationLoadInfoInner>() {
            @Override
            public ApplicationLoadInfoInner call(ServiceResponse<ApplicationLoadInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets load information about a Service Fabric application.
     * Returns the load information about the application that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, minimum nodes, maximum nodes, the number of nodes the application is occupying currently, and application load metric information about the application.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationLoadInfoInner object
     */
    public Observable<ServiceResponse<ApplicationLoadInfoInner>> getApplicationLoadInfoWithServiceResponseAsync(String applicationId, Long timeout) {
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.getApplicationLoadInfo(applicationId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ApplicationLoadInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<ApplicationLoadInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ApplicationLoadInfoInner> clientResponse = getApplicationLoadInfoDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ApplicationLoadInfoInner> getApplicationLoadInfoDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ApplicationLoadInfoInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ApplicationLoadInfoInner>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the list of applications created in the Service Fabric cluster that match the specified filters.
     * Gets the information about the applications that were created or in the process of being created in the Service Fabric cluster and match the specified filters. The response includes the name, type, status, parameters, and other details about the application. If the applications do not fit in a page, one page of results is returned as well as a continuation token, which can be used to get the next page. Filters ApplicationTypeName and ApplicationDefinitionKindFilter cannot be specified at the same time.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedApplicationInfoListInner object if successful.
     */
    public PagedApplicationInfoListInner getApplicationInfoList() {
        return getApplicationInfoListWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets the list of applications created in the Service Fabric cluster that match the specified filters.
     * Gets the information about the applications that were created or in the process of being created in the Service Fabric cluster and match the specified filters. The response includes the name, type, status, parameters, and other details about the application. If the applications do not fit in a page, one page of results is returned as well as a continuation token, which can be used to get the next page. Filters ApplicationTypeName and ApplicationDefinitionKindFilter cannot be specified at the same time.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedApplicationInfoListInner> getApplicationInfoListAsync(final ServiceCallback<PagedApplicationInfoListInner> serviceCallback) {
        return ServiceFuture.fromResponse(getApplicationInfoListWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets the list of applications created in the Service Fabric cluster that match the specified filters.
     * Gets the information about the applications that were created or in the process of being created in the Service Fabric cluster and match the specified filters. The response includes the name, type, status, parameters, and other details about the application. If the applications do not fit in a page, one page of results is returned as well as a continuation token, which can be used to get the next page. Filters ApplicationTypeName and ApplicationDefinitionKindFilter cannot be specified at the same time.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedApplicationInfoListInner object
     */
    public Observable<PagedApplicationInfoListInner> getApplicationInfoListAsync() {
        return getApplicationInfoListWithServiceResponseAsync().map(new Func1<ServiceResponse<PagedApplicationInfoListInner>, PagedApplicationInfoListInner>() {
            @Override
            public PagedApplicationInfoListInner call(ServiceResponse<PagedApplicationInfoListInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the list of applications created in the Service Fabric cluster that match the specified filters.
     * Gets the information about the applications that were created or in the process of being created in the Service Fabric cluster and match the specified filters. The response includes the name, type, status, parameters, and other details about the application. If the applications do not fit in a page, one page of results is returned as well as a continuation token, which can be used to get the next page. Filters ApplicationTypeName and ApplicationDefinitionKindFilter cannot be specified at the same time.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedApplicationInfoListInner object
     */
    public Observable<ServiceResponse<PagedApplicationInfoListInner>> getApplicationInfoListWithServiceResponseAsync() {
        final String apiVersion = "6.1";
        final Integer applicationDefinitionKindFilter = null;
        final String applicationTypeName = null;
        final Boolean excludeApplicationParameters = null;
        final String continuationToken = null;
        final Long maxResults = null;
        final Long timeout = null;
        return service.getApplicationInfoList(apiVersion, applicationDefinitionKindFilter, applicationTypeName, excludeApplicationParameters, continuationToken, maxResults, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedApplicationInfoListInner>>>() {
                @Override
                public Observable<ServiceResponse<PagedApplicationInfoListInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedApplicationInfoListInner> clientResponse = getApplicationInfoListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the list of applications created in the Service Fabric cluster that match the specified filters.
     * Gets the information about the applications that were created or in the process of being created in the Service Fabric cluster and match the specified filters. The response includes the name, type, status, parameters, and other details about the application. If the applications do not fit in a page, one page of results is returned as well as a continuation token, which can be used to get the next page. Filters ApplicationTypeName and ApplicationDefinitionKindFilter cannot be specified at the same time.
     *
     * @param applicationDefinitionKindFilter Used to filter on ApplicationDefinitionKind, which is the mechanism used to define a Service Fabric application.
     - Default - Default value, which performs the same function as selecting "All". The value is 0.
     - All - Filter that matches input with any ApplicationDefinitionKind value. The value is 65535.
     - ServiceFabricApplicationDescription - Filter that matches input with ApplicationDefinitionKind value ServiceFabricApplicationDescription. The value is 1.
     - Compose - Filter that matches input with ApplicationDefinitionKind value Compose. The value is 2.
     * @param applicationTypeName The application type name used to filter the applications to query for. This value should not contain the application type version.
     * @param excludeApplicationParameters The flag that specifies whether application parameters will be excluded from the result.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedApplicationInfoListInner object if successful.
     */
    public PagedApplicationInfoListInner getApplicationInfoList(Integer applicationDefinitionKindFilter, String applicationTypeName, Boolean excludeApplicationParameters, String continuationToken, Long maxResults, Long timeout) {
        return getApplicationInfoListWithServiceResponseAsync(applicationDefinitionKindFilter, applicationTypeName, excludeApplicationParameters, continuationToken, maxResults, timeout).toBlocking().single().body();
    }

    /**
     * Gets the list of applications created in the Service Fabric cluster that match the specified filters.
     * Gets the information about the applications that were created or in the process of being created in the Service Fabric cluster and match the specified filters. The response includes the name, type, status, parameters, and other details about the application. If the applications do not fit in a page, one page of results is returned as well as a continuation token, which can be used to get the next page. Filters ApplicationTypeName and ApplicationDefinitionKindFilter cannot be specified at the same time.
     *
     * @param applicationDefinitionKindFilter Used to filter on ApplicationDefinitionKind, which is the mechanism used to define a Service Fabric application.
     - Default - Default value, which performs the same function as selecting "All". The value is 0.
     - All - Filter that matches input with any ApplicationDefinitionKind value. The value is 65535.
     - ServiceFabricApplicationDescription - Filter that matches input with ApplicationDefinitionKind value ServiceFabricApplicationDescription. The value is 1.
     - Compose - Filter that matches input with ApplicationDefinitionKind value Compose. The value is 2.
     * @param applicationTypeName The application type name used to filter the applications to query for. This value should not contain the application type version.
     * @param excludeApplicationParameters The flag that specifies whether application parameters will be excluded from the result.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedApplicationInfoListInner> getApplicationInfoListAsync(Integer applicationDefinitionKindFilter, String applicationTypeName, Boolean excludeApplicationParameters, String continuationToken, Long maxResults, Long timeout, final ServiceCallback<PagedApplicationInfoListInner> serviceCallback) {
        return ServiceFuture.fromResponse(getApplicationInfoListWithServiceResponseAsync(applicationDefinitionKindFilter, applicationTypeName, excludeApplicationParameters, continuationToken, maxResults, timeout), serviceCallback);
    }

    /**
     * Gets the list of applications created in the Service Fabric cluster that match the specified filters.
     * Gets the information about the applications that were created or in the process of being created in the Service Fabric cluster and match the specified filters. The response includes the name, type, status, parameters, and other details about the application. If the applications do not fit in a page, one page of results is returned as well as a continuation token, which can be used to get the next page. Filters ApplicationTypeName and ApplicationDefinitionKindFilter cannot be specified at the same time.
     *
     * @param applicationDefinitionKindFilter Used to filter on ApplicationDefinitionKind, which is the mechanism used to define a Service Fabric application.
     - Default - Default value, which performs the same function as selecting "All". The value is 0.
     - All - Filter that matches input with any ApplicationDefinitionKind value. The value is 65535.
     - ServiceFabricApplicationDescription - Filter that matches input with ApplicationDefinitionKind value ServiceFabricApplicationDescription. The value is 1.
     - Compose - Filter that matches input with ApplicationDefinitionKind value Compose. The value is 2.
     * @param applicationTypeName The application type name used to filter the applications to query for. This value should not contain the application type version.
     * @param excludeApplicationParameters The flag that specifies whether application parameters will be excluded from the result.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedApplicationInfoListInner object
     */
    public Observable<PagedApplicationInfoListInner> getApplicationInfoListAsync(Integer applicationDefinitionKindFilter, String applicationTypeName, Boolean excludeApplicationParameters, String continuationToken, Long maxResults, Long timeout) {
        return getApplicationInfoListWithServiceResponseAsync(applicationDefinitionKindFilter, applicationTypeName, excludeApplicationParameters, continuationToken, maxResults, timeout).map(new Func1<ServiceResponse<PagedApplicationInfoListInner>, PagedApplicationInfoListInner>() {
            @Override
            public PagedApplicationInfoListInner call(ServiceResponse<PagedApplicationInfoListInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the list of applications created in the Service Fabric cluster that match the specified filters.
     * Gets the information about the applications that were created or in the process of being created in the Service Fabric cluster and match the specified filters. The response includes the name, type, status, parameters, and other details about the application. If the applications do not fit in a page, one page of results is returned as well as a continuation token, which can be used to get the next page. Filters ApplicationTypeName and ApplicationDefinitionKindFilter cannot be specified at the same time.
     *
     * @param applicationDefinitionKindFilter Used to filter on ApplicationDefinitionKind, which is the mechanism used to define a Service Fabric application.
     - Default - Default value, which performs the same function as selecting "All". The value is 0.
     - All - Filter that matches input with any ApplicationDefinitionKind value. The value is 65535.
     - ServiceFabricApplicationDescription - Filter that matches input with ApplicationDefinitionKind value ServiceFabricApplicationDescription. The value is 1.
     - Compose - Filter that matches input with ApplicationDefinitionKind value Compose. The value is 2.
     * @param applicationTypeName The application type name used to filter the applications to query for. This value should not contain the application type version.
     * @param excludeApplicationParameters The flag that specifies whether application parameters will be excluded from the result.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedApplicationInfoListInner object
     */
    public Observable<ServiceResponse<PagedApplicationInfoListInner>> getApplicationInfoListWithServiceResponseAsync(Integer applicationDefinitionKindFilter, String applicationTypeName, Boolean excludeApplicationParameters, String continuationToken, Long maxResults, Long timeout) {
        final String apiVersion = "6.1";
        return service.getApplicationInfoList(apiVersion, applicationDefinitionKindFilter, applicationTypeName, excludeApplicationParameters, continuationToken, maxResults, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedApplicationInfoListInner>>>() {
                @Override
                public Observable<ServiceResponse<PagedApplicationInfoListInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedApplicationInfoListInner> clientResponse = getApplicationInfoListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PagedApplicationInfoListInner> getApplicationInfoListDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException {
        return this.restClient().responseBuilderFactory().<PagedApplicationInfoListInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PagedApplicationInfoListInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets information about a Service Fabric application.
     * Returns the information about the application that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, type, status, parameters, and other details about the application.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ApplicationInfoInner object if successful.
     */
    public ApplicationInfoInner getApplicationInfo(String applicationId) {
        return getApplicationInfoWithServiceResponseAsync(applicationId).toBlocking().single().body();
    }

    /**
     * Gets information about a Service Fabric application.
     * Returns the information about the application that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, type, status, parameters, and other details about the application.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ApplicationInfoInner> getApplicationInfoAsync(String applicationId, final ServiceCallback<ApplicationInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getApplicationInfoWithServiceResponseAsync(applicationId), serviceCallback);
    }

    /**
     * Gets information about a Service Fabric application.
     * Returns the information about the application that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, type, status, parameters, and other details about the application.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationInfoInner object
     */
    public Observable<ApplicationInfoInner> getApplicationInfoAsync(String applicationId) {
        return getApplicationInfoWithServiceResponseAsync(applicationId).map(new Func1<ServiceResponse<ApplicationInfoInner>, ApplicationInfoInner>() {
            @Override
            public ApplicationInfoInner call(ServiceResponse<ApplicationInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets information about a Service Fabric application.
     * Returns the information about the application that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, type, status, parameters, and other details about the application.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationInfoInner object
     */
    public Observable<ServiceResponse<ApplicationInfoInner>> getApplicationInfoWithServiceResponseAsync(String applicationId) {
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Boolean excludeApplicationParameters = null;
        final Long timeout = null;
        return service.getApplicationInfo(applicationId, apiVersion, excludeApplicationParameters, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ApplicationInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<ApplicationInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ApplicationInfoInner> clientResponse = getApplicationInfoDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets information about a Service Fabric application.
     * Returns the information about the application that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, type, status, parameters, and other details about the application.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param excludeApplicationParameters The flag that specifies whether application parameters will be excluded from the result.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ApplicationInfoInner object if successful.
     */
    public ApplicationInfoInner getApplicationInfo(String applicationId, Boolean excludeApplicationParameters, Long timeout) {
        return getApplicationInfoWithServiceResponseAsync(applicationId, excludeApplicationParameters, timeout).toBlocking().single().body();
    }

    /**
     * Gets information about a Service Fabric application.
     * Returns the information about the application that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, type, status, parameters, and other details about the application.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param excludeApplicationParameters The flag that specifies whether application parameters will be excluded from the result.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ApplicationInfoInner> getApplicationInfoAsync(String applicationId, Boolean excludeApplicationParameters, Long timeout, final ServiceCallback<ApplicationInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getApplicationInfoWithServiceResponseAsync(applicationId, excludeApplicationParameters, timeout), serviceCallback);
    }

    /**
     * Gets information about a Service Fabric application.
     * Returns the information about the application that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, type, status, parameters, and other details about the application.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param excludeApplicationParameters The flag that specifies whether application parameters will be excluded from the result.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationInfoInner object
     */
    public Observable<ApplicationInfoInner> getApplicationInfoAsync(String applicationId, Boolean excludeApplicationParameters, Long timeout) {
        return getApplicationInfoWithServiceResponseAsync(applicationId, excludeApplicationParameters, timeout).map(new Func1<ServiceResponse<ApplicationInfoInner>, ApplicationInfoInner>() {
            @Override
            public ApplicationInfoInner call(ServiceResponse<ApplicationInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets information about a Service Fabric application.
     * Returns the information about the application that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, type, status, parameters, and other details about the application.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param excludeApplicationParameters The flag that specifies whether application parameters will be excluded from the result.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationInfoInner object
     */
    public Observable<ServiceResponse<ApplicationInfoInner>> getApplicationInfoWithServiceResponseAsync(String applicationId, Boolean excludeApplicationParameters, Long timeout) {
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.getApplicationInfo(applicationId, apiVersion, excludeApplicationParameters, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ApplicationInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<ApplicationInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ApplicationInfoInner> clientResponse = getApplicationInfoDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ApplicationInfoInner> getApplicationInfoDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ApplicationInfoInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ApplicationInfoInner>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the health of the service fabric application.
     * Returns the heath state of the service fabric application. The response reports either Ok, Error or Warning health state. If the entity is not found in the health store, it will return Error.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ApplicationHealthInner object if successful.
     */
    public ApplicationHealthInner getApplicationHealth(String applicationId) {
        return getApplicationHealthWithServiceResponseAsync(applicationId).toBlocking().single().body();
    }

    /**
     * Gets the health of the service fabric application.
     * Returns the heath state of the service fabric application. The response reports either Ok, Error or Warning health state. If the entity is not found in the health store, it will return Error.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ApplicationHealthInner> getApplicationHealthAsync(String applicationId, final ServiceCallback<ApplicationHealthInner> serviceCallback) {
        return ServiceFuture.fromResponse(getApplicationHealthWithServiceResponseAsync(applicationId), serviceCallback);
    }

    /**
     * Gets the health of the service fabric application.
     * Returns the heath state of the service fabric application. The response reports either Ok, Error or Warning health state. If the entity is not found in the health store, it will return Error.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationHealthInner object
     */
    public Observable<ApplicationHealthInner> getApplicationHealthAsync(String applicationId) {
        return getApplicationHealthWithServiceResponseAsync(applicationId).map(new Func1<ServiceResponse<ApplicationHealthInner>, ApplicationHealthInner>() {
            @Override
            public ApplicationHealthInner call(ServiceResponse<ApplicationHealthInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the health of the service fabric application.
     * Returns the heath state of the service fabric application. The response reports either Ok, Error or Warning health state. If the entity is not found in the health store, it will return Error.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationHealthInner object
     */
    public Observable<ServiceResponse<ApplicationHealthInner>> getApplicationHealthWithServiceResponseAsync(String applicationId) {
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Integer eventsHealthStateFilter = null;
        final Integer deployedApplicationsHealthStateFilter = null;
        final Integer servicesHealthStateFilter = null;
        final Boolean excludeHealthStatistics = null;
        final Long timeout = null;
        return service.getApplicationHealth(applicationId, apiVersion, eventsHealthStateFilter, deployedApplicationsHealthStateFilter, servicesHealthStateFilter, excludeHealthStatistics, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ApplicationHealthInner>>>() {
                @Override
                public Observable<ServiceResponse<ApplicationHealthInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ApplicationHealthInner> clientResponse = getApplicationHealthDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the health of the service fabric application.
     * Returns the heath state of the service fabric application. The response reports either Ok, Error or Warning health state. If the entity is not found in the health store, it will return Error.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param deployedApplicationsHealthStateFilter Allows filtering of the deployed applications health state objects returned in the result of application health query based on their health state.
     The possible values for this parameter include integer value of one of the following health states. Only deployed applications that match the filter will be returned.
     All deployed applications are used to evaluate the aggregated health state. If not specified, all entries are returned.
     The state values are flag-based enumeration, so the value could be a combination of these values, obtained using bitwise 'OR' operator.
     For example, if the provided value is 6 then health state of deployed applications with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param servicesHealthStateFilter Allows filtering of the services health state objects returned in the result of services health query based on their health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only services that match the filter are returned. All services are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values,
     obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of services with HealthState value of OK (2) and Warning (4) will be returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param excludeHealthStatistics Indicates whether the health statistics should be returned as part of the query result. False by default.
     The statistics show the number of children entities in health state Ok, Warning, and Error.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ApplicationHealthInner object if successful.
     */
    public ApplicationHealthInner getApplicationHealth(String applicationId, Integer eventsHealthStateFilter, Integer deployedApplicationsHealthStateFilter, Integer servicesHealthStateFilter, Boolean excludeHealthStatistics, Long timeout) {
        return getApplicationHealthWithServiceResponseAsync(applicationId, eventsHealthStateFilter, deployedApplicationsHealthStateFilter, servicesHealthStateFilter, excludeHealthStatistics, timeout).toBlocking().single().body();
    }

    /**
     * Gets the health of the service fabric application.
     * Returns the heath state of the service fabric application. The response reports either Ok, Error or Warning health state. If the entity is not found in the health store, it will return Error.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param deployedApplicationsHealthStateFilter Allows filtering of the deployed applications health state objects returned in the result of application health query based on their health state.
     The possible values for this parameter include integer value of one of the following health states. Only deployed applications that match the filter will be returned.
     All deployed applications are used to evaluate the aggregated health state. If not specified, all entries are returned.
     The state values are flag-based enumeration, so the value could be a combination of these values, obtained using bitwise 'OR' operator.
     For example, if the provided value is 6 then health state of deployed applications with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param servicesHealthStateFilter Allows filtering of the services health state objects returned in the result of services health query based on their health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only services that match the filter are returned. All services are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values,
     obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of services with HealthState value of OK (2) and Warning (4) will be returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param excludeHealthStatistics Indicates whether the health statistics should be returned as part of the query result. False by default.
     The statistics show the number of children entities in health state Ok, Warning, and Error.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ApplicationHealthInner> getApplicationHealthAsync(String applicationId, Integer eventsHealthStateFilter, Integer deployedApplicationsHealthStateFilter, Integer servicesHealthStateFilter, Boolean excludeHealthStatistics, Long timeout, final ServiceCallback<ApplicationHealthInner> serviceCallback) {
        return ServiceFuture.fromResponse(getApplicationHealthWithServiceResponseAsync(applicationId, eventsHealthStateFilter, deployedApplicationsHealthStateFilter, servicesHealthStateFilter, excludeHealthStatistics, timeout), serviceCallback);
    }

    /**
     * Gets the health of the service fabric application.
     * Returns the heath state of the service fabric application. The response reports either Ok, Error or Warning health state. If the entity is not found in the health store, it will return Error.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param deployedApplicationsHealthStateFilter Allows filtering of the deployed applications health state objects returned in the result of application health query based on their health state.
     The possible values for this parameter include integer value of one of the following health states. Only deployed applications that match the filter will be returned.
     All deployed applications are used to evaluate the aggregated health state. If not specified, all entries are returned.
     The state values are flag-based enumeration, so the value could be a combination of these values, obtained using bitwise 'OR' operator.
     For example, if the provided value is 6 then health state of deployed applications with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param servicesHealthStateFilter Allows filtering of the services health state objects returned in the result of services health query based on their health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only services that match the filter are returned. All services are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values,
     obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of services with HealthState value of OK (2) and Warning (4) will be returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param excludeHealthStatistics Indicates whether the health statistics should be returned as part of the query result. False by default.
     The statistics show the number of children entities in health state Ok, Warning, and Error.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationHealthInner object
     */
    public Observable<ApplicationHealthInner> getApplicationHealthAsync(String applicationId, Integer eventsHealthStateFilter, Integer deployedApplicationsHealthStateFilter, Integer servicesHealthStateFilter, Boolean excludeHealthStatistics, Long timeout) {
        return getApplicationHealthWithServiceResponseAsync(applicationId, eventsHealthStateFilter, deployedApplicationsHealthStateFilter, servicesHealthStateFilter, excludeHealthStatistics, timeout).map(new Func1<ServiceResponse<ApplicationHealthInner>, ApplicationHealthInner>() {
            @Override
            public ApplicationHealthInner call(ServiceResponse<ApplicationHealthInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the health of the service fabric application.
     * Returns the heath state of the service fabric application. The response reports either Ok, Error or Warning health state. If the entity is not found in the health store, it will return Error.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param deployedApplicationsHealthStateFilter Allows filtering of the deployed applications health state objects returned in the result of application health query based on their health state.
     The possible values for this parameter include integer value of one of the following health states. Only deployed applications that match the filter will be returned.
     All deployed applications are used to evaluate the aggregated health state. If not specified, all entries are returned.
     The state values are flag-based enumeration, so the value could be a combination of these values, obtained using bitwise 'OR' operator.
     For example, if the provided value is 6 then health state of deployed applications with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param servicesHealthStateFilter Allows filtering of the services health state objects returned in the result of services health query based on their health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only services that match the filter are returned. All services are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values,
     obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of services with HealthState value of OK (2) and Warning (4) will be returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param excludeHealthStatistics Indicates whether the health statistics should be returned as part of the query result. False by default.
     The statistics show the number of children entities in health state Ok, Warning, and Error.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationHealthInner object
     */
    public Observable<ServiceResponse<ApplicationHealthInner>> getApplicationHealthWithServiceResponseAsync(String applicationId, Integer eventsHealthStateFilter, Integer deployedApplicationsHealthStateFilter, Integer servicesHealthStateFilter, Boolean excludeHealthStatistics, Long timeout) {
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.getApplicationHealth(applicationId, apiVersion, eventsHealthStateFilter, deployedApplicationsHealthStateFilter, servicesHealthStateFilter, excludeHealthStatistics, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ApplicationHealthInner>>>() {
                @Override
                public Observable<ServiceResponse<ApplicationHealthInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ApplicationHealthInner> clientResponse = getApplicationHealthDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ApplicationHealthInner> getApplicationHealthDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ApplicationHealthInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ApplicationHealthInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the health of a Service Fabric application using the specified policy.
     * Gets the health of a Service Fabric application. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. Use ClusterHealthPolicies to override the health policies used to evaluate the health.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ApplicationHealthInner object if successful.
     */
    public ApplicationHealthInner getApplicationHealthUsingPolicy(String applicationId) {
        return getApplicationHealthUsingPolicyWithServiceResponseAsync(applicationId).toBlocking().single().body();
    }

    /**
     * Gets the health of a Service Fabric application using the specified policy.
     * Gets the health of a Service Fabric application. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. Use ClusterHealthPolicies to override the health policies used to evaluate the health.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ApplicationHealthInner> getApplicationHealthUsingPolicyAsync(String applicationId, final ServiceCallback<ApplicationHealthInner> serviceCallback) {
        return ServiceFuture.fromResponse(getApplicationHealthUsingPolicyWithServiceResponseAsync(applicationId), serviceCallback);
    }

    /**
     * Gets the health of a Service Fabric application using the specified policy.
     * Gets the health of a Service Fabric application. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. Use ClusterHealthPolicies to override the health policies used to evaluate the health.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationHealthInner object
     */
    public Observable<ApplicationHealthInner> getApplicationHealthUsingPolicyAsync(String applicationId) {
        return getApplicationHealthUsingPolicyWithServiceResponseAsync(applicationId).map(new Func1<ServiceResponse<ApplicationHealthInner>, ApplicationHealthInner>() {
            @Override
            public ApplicationHealthInner call(ServiceResponse<ApplicationHealthInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the health of a Service Fabric application using the specified policy.
     * Gets the health of a Service Fabric application. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. Use ClusterHealthPolicies to override the health policies used to evaluate the health.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationHealthInner object
     */
    public Observable<ServiceResponse<ApplicationHealthInner>> getApplicationHealthUsingPolicyWithServiceResponseAsync(String applicationId) {
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Integer eventsHealthStateFilter = null;
        final Integer deployedApplicationsHealthStateFilter = null;
        final Integer servicesHealthStateFilter = null;
        final Boolean excludeHealthStatistics = null;
        final ApplicationHealthPolicy applicationHealthPolicy = null;
        final Long timeout = null;
        return service.getApplicationHealthUsingPolicy(applicationId, apiVersion, eventsHealthStateFilter, deployedApplicationsHealthStateFilter, servicesHealthStateFilter, excludeHealthStatistics, applicationHealthPolicy, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ApplicationHealthInner>>>() {
                @Override
                public Observable<ServiceResponse<ApplicationHealthInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ApplicationHealthInner> clientResponse = getApplicationHealthUsingPolicyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the health of a Service Fabric application using the specified policy.
     * Gets the health of a Service Fabric application. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. Use ClusterHealthPolicies to override the health policies used to evaluate the health.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param deployedApplicationsHealthStateFilter Allows filtering of the deployed applications health state objects returned in the result of application health query based on their health state.
     The possible values for this parameter include integer value of one of the following health states. Only deployed applications that match the filter will be returned.
     All deployed applications are used to evaluate the aggregated health state. If not specified, all entries are returned.
     The state values are flag-based enumeration, so the value could be a combination of these values, obtained using bitwise 'OR' operator.
     For example, if the provided value is 6 then health state of deployed applications with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param servicesHealthStateFilter Allows filtering of the services health state objects returned in the result of services health query based on their health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only services that match the filter are returned. All services are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values,
     obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of services with HealthState value of OK (2) and Warning (4) will be returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param excludeHealthStatistics Indicates whether the health statistics should be returned as part of the query result. False by default.
     The statistics show the number of children entities in health state Ok, Warning, and Error.
     * @param applicationHealthPolicy Describes the health policies used to evaluate the health of an application or one of its children.
     If not present, the health evaluation uses the health policy from application manifest or the default health policy.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ApplicationHealthInner object if successful.
     */
    public ApplicationHealthInner getApplicationHealthUsingPolicy(String applicationId, Integer eventsHealthStateFilter, Integer deployedApplicationsHealthStateFilter, Integer servicesHealthStateFilter, Boolean excludeHealthStatistics, ApplicationHealthPolicy applicationHealthPolicy, Long timeout) {
        return getApplicationHealthUsingPolicyWithServiceResponseAsync(applicationId, eventsHealthStateFilter, deployedApplicationsHealthStateFilter, servicesHealthStateFilter, excludeHealthStatistics, applicationHealthPolicy, timeout).toBlocking().single().body();
    }

    /**
     * Gets the health of a Service Fabric application using the specified policy.
     * Gets the health of a Service Fabric application. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. Use ClusterHealthPolicies to override the health policies used to evaluate the health.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param deployedApplicationsHealthStateFilter Allows filtering of the deployed applications health state objects returned in the result of application health query based on their health state.
     The possible values for this parameter include integer value of one of the following health states. Only deployed applications that match the filter will be returned.
     All deployed applications are used to evaluate the aggregated health state. If not specified, all entries are returned.
     The state values are flag-based enumeration, so the value could be a combination of these values, obtained using bitwise 'OR' operator.
     For example, if the provided value is 6 then health state of deployed applications with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param servicesHealthStateFilter Allows filtering of the services health state objects returned in the result of services health query based on their health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only services that match the filter are returned. All services are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values,
     obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of services with HealthState value of OK (2) and Warning (4) will be returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param excludeHealthStatistics Indicates whether the health statistics should be returned as part of the query result. False by default.
     The statistics show the number of children entities in health state Ok, Warning, and Error.
     * @param applicationHealthPolicy Describes the health policies used to evaluate the health of an application or one of its children.
     If not present, the health evaluation uses the health policy from application manifest or the default health policy.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ApplicationHealthInner> getApplicationHealthUsingPolicyAsync(String applicationId, Integer eventsHealthStateFilter, Integer deployedApplicationsHealthStateFilter, Integer servicesHealthStateFilter, Boolean excludeHealthStatistics, ApplicationHealthPolicy applicationHealthPolicy, Long timeout, final ServiceCallback<ApplicationHealthInner> serviceCallback) {
        return ServiceFuture.fromResponse(getApplicationHealthUsingPolicyWithServiceResponseAsync(applicationId, eventsHealthStateFilter, deployedApplicationsHealthStateFilter, servicesHealthStateFilter, excludeHealthStatistics, applicationHealthPolicy, timeout), serviceCallback);
    }

    /**
     * Gets the health of a Service Fabric application using the specified policy.
     * Gets the health of a Service Fabric application. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. Use ClusterHealthPolicies to override the health policies used to evaluate the health.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param deployedApplicationsHealthStateFilter Allows filtering of the deployed applications health state objects returned in the result of application health query based on their health state.
     The possible values for this parameter include integer value of one of the following health states. Only deployed applications that match the filter will be returned.
     All deployed applications are used to evaluate the aggregated health state. If not specified, all entries are returned.
     The state values are flag-based enumeration, so the value could be a combination of these values, obtained using bitwise 'OR' operator.
     For example, if the provided value is 6 then health state of deployed applications with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param servicesHealthStateFilter Allows filtering of the services health state objects returned in the result of services health query based on their health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only services that match the filter are returned. All services are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values,
     obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of services with HealthState value of OK (2) and Warning (4) will be returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param excludeHealthStatistics Indicates whether the health statistics should be returned as part of the query result. False by default.
     The statistics show the number of children entities in health state Ok, Warning, and Error.
     * @param applicationHealthPolicy Describes the health policies used to evaluate the health of an application or one of its children.
     If not present, the health evaluation uses the health policy from application manifest or the default health policy.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationHealthInner object
     */
    public Observable<ApplicationHealthInner> getApplicationHealthUsingPolicyAsync(String applicationId, Integer eventsHealthStateFilter, Integer deployedApplicationsHealthStateFilter, Integer servicesHealthStateFilter, Boolean excludeHealthStatistics, ApplicationHealthPolicy applicationHealthPolicy, Long timeout) {
        return getApplicationHealthUsingPolicyWithServiceResponseAsync(applicationId, eventsHealthStateFilter, deployedApplicationsHealthStateFilter, servicesHealthStateFilter, excludeHealthStatistics, applicationHealthPolicy, timeout).map(new Func1<ServiceResponse<ApplicationHealthInner>, ApplicationHealthInner>() {
            @Override
            public ApplicationHealthInner call(ServiceResponse<ApplicationHealthInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the health of a Service Fabric application using the specified policy.
     * Gets the health of a Service Fabric application. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. Use ClusterHealthPolicies to override the health policies used to evaluate the health.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param deployedApplicationsHealthStateFilter Allows filtering of the deployed applications health state objects returned in the result of application health query based on their health state.
     The possible values for this parameter include integer value of one of the following health states. Only deployed applications that match the filter will be returned.
     All deployed applications are used to evaluate the aggregated health state. If not specified, all entries are returned.
     The state values are flag-based enumeration, so the value could be a combination of these values, obtained using bitwise 'OR' operator.
     For example, if the provided value is 6 then health state of deployed applications with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param servicesHealthStateFilter Allows filtering of the services health state objects returned in the result of services health query based on their health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only services that match the filter are returned. All services are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values,
     obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of services with HealthState value of OK (2) and Warning (4) will be returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param excludeHealthStatistics Indicates whether the health statistics should be returned as part of the query result. False by default.
     The statistics show the number of children entities in health state Ok, Warning, and Error.
     * @param applicationHealthPolicy Describes the health policies used to evaluate the health of an application or one of its children.
     If not present, the health evaluation uses the health policy from application manifest or the default health policy.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationHealthInner object
     */
    public Observable<ServiceResponse<ApplicationHealthInner>> getApplicationHealthUsingPolicyWithServiceResponseAsync(String applicationId, Integer eventsHealthStateFilter, Integer deployedApplicationsHealthStateFilter, Integer servicesHealthStateFilter, Boolean excludeHealthStatistics, ApplicationHealthPolicy applicationHealthPolicy, Long timeout) {
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        Validator.validate(applicationHealthPolicy);
        final String apiVersion = "6.0";
        return service.getApplicationHealthUsingPolicy(applicationId, apiVersion, eventsHealthStateFilter, deployedApplicationsHealthStateFilter, servicesHealthStateFilter, excludeHealthStatistics, applicationHealthPolicy, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ApplicationHealthInner>>>() {
                @Override
                public Observable<ServiceResponse<ApplicationHealthInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ApplicationHealthInner> clientResponse = getApplicationHealthUsingPolicyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ApplicationHealthInner> getApplicationHealthUsingPolicyDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ApplicationHealthInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ApplicationHealthInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Sends a health report on the Service Fabric application.
     * Reports health state of the specified Service Fabric application. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway Application, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, get application health and check that the report appears in the HealthEvents section.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void reportApplicationHealth(String applicationId, HealthInformation healthInformation) {
        reportApplicationHealthWithServiceResponseAsync(applicationId, healthInformation).toBlocking().single().body();
    }

    /**
     * Sends a health report on the Service Fabric application.
     * Reports health state of the specified Service Fabric application. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway Application, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, get application health and check that the report appears in the HealthEvents section.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> reportApplicationHealthAsync(String applicationId, HealthInformation healthInformation, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(reportApplicationHealthWithServiceResponseAsync(applicationId, healthInformation), serviceCallback);
    }

    /**
     * Sends a health report on the Service Fabric application.
     * Reports health state of the specified Service Fabric application. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway Application, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, get application health and check that the report appears in the HealthEvents section.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> reportApplicationHealthAsync(String applicationId, HealthInformation healthInformation) {
        return reportApplicationHealthWithServiceResponseAsync(applicationId, healthInformation).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Sends a health report on the Service Fabric application.
     * Reports health state of the specified Service Fabric application. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway Application, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, get application health and check that the report appears in the HealthEvents section.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> reportApplicationHealthWithServiceResponseAsync(String applicationId, HealthInformation healthInformation) {
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        if (healthInformation == null) {
            throw new IllegalArgumentException("Parameter healthInformation is required and cannot be null.");
        }
        Validator.validate(healthInformation);
        final String apiVersion = "6.0";
        final Boolean immediate = null;
        final Long timeout = null;
        return service.reportApplicationHealth(applicationId, apiVersion, healthInformation, immediate, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = reportApplicationHealthDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Sends a health report on the Service Fabric application.
     * Reports health state of the specified Service Fabric application. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway Application, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, get application health and check that the report appears in the HealthEvents section.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @param immediate A flag that indicates whether the report should be sent immediately.
     A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
     If Immediate is set to true, the report is sent immediately from HTTP Gateway to the health store, regardless of the fabric client settings that the HTTP Gateway Application is using.
     This is useful for critical reports that should be sent as soon as possible.
     Depending on timing and other conditions, sending the report may still fail, for example if the HTTP Gateway is closed or the message doesn't reach the Gateway.
     If Immediate is set to false, the report is sent based on the health client settings from the HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
     This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
     By default, reports are not sent immediately.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void reportApplicationHealth(String applicationId, HealthInformation healthInformation, Boolean immediate, Long timeout) {
        reportApplicationHealthWithServiceResponseAsync(applicationId, healthInformation, immediate, timeout).toBlocking().single().body();
    }

    /**
     * Sends a health report on the Service Fabric application.
     * Reports health state of the specified Service Fabric application. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway Application, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, get application health and check that the report appears in the HealthEvents section.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @param immediate A flag that indicates whether the report should be sent immediately.
     A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
     If Immediate is set to true, the report is sent immediately from HTTP Gateway to the health store, regardless of the fabric client settings that the HTTP Gateway Application is using.
     This is useful for critical reports that should be sent as soon as possible.
     Depending on timing and other conditions, sending the report may still fail, for example if the HTTP Gateway is closed or the message doesn't reach the Gateway.
     If Immediate is set to false, the report is sent based on the health client settings from the HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
     This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
     By default, reports are not sent immediately.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> reportApplicationHealthAsync(String applicationId, HealthInformation healthInformation, Boolean immediate, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(reportApplicationHealthWithServiceResponseAsync(applicationId, healthInformation, immediate, timeout), serviceCallback);
    }

    /**
     * Sends a health report on the Service Fabric application.
     * Reports health state of the specified Service Fabric application. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway Application, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, get application health and check that the report appears in the HealthEvents section.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @param immediate A flag that indicates whether the report should be sent immediately.
     A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
     If Immediate is set to true, the report is sent immediately from HTTP Gateway to the health store, regardless of the fabric client settings that the HTTP Gateway Application is using.
     This is useful for critical reports that should be sent as soon as possible.
     Depending on timing and other conditions, sending the report may still fail, for example if the HTTP Gateway is closed or the message doesn't reach the Gateway.
     If Immediate is set to false, the report is sent based on the health client settings from the HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
     This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
     By default, reports are not sent immediately.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> reportApplicationHealthAsync(String applicationId, HealthInformation healthInformation, Boolean immediate, Long timeout) {
        return reportApplicationHealthWithServiceResponseAsync(applicationId, healthInformation, immediate, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Sends a health report on the Service Fabric application.
     * Reports health state of the specified Service Fabric application. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway Application, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, get application health and check that the report appears in the HealthEvents section.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @param immediate A flag that indicates whether the report should be sent immediately.
     A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
     If Immediate is set to true, the report is sent immediately from HTTP Gateway to the health store, regardless of the fabric client settings that the HTTP Gateway Application is using.
     This is useful for critical reports that should be sent as soon as possible.
     Depending on timing and other conditions, sending the report may still fail, for example if the HTTP Gateway is closed or the message doesn't reach the Gateway.
     If Immediate is set to false, the report is sent based on the health client settings from the HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
     This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
     By default, reports are not sent immediately.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> reportApplicationHealthWithServiceResponseAsync(String applicationId, HealthInformation healthInformation, Boolean immediate, Long timeout) {
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        if (healthInformation == null) {
            throw new IllegalArgumentException("Parameter healthInformation is required and cannot be null.");
        }
        Validator.validate(healthInformation);
        final String apiVersion = "6.0";
        return service.reportApplicationHealth(applicationId, apiVersion, healthInformation, immediate, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = reportApplicationHealthDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> reportApplicationHealthDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Starts upgrading an application in the Service Fabric cluster.
     * Validates the supplied application upgrade parameters and starts upgrading the application if the parameters are valid.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param applicationUpgradeDescription Parameters for an application upgrade.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void startApplicationUpgrade(String applicationId, ApplicationUpgradeDescription applicationUpgradeDescription) {
        startApplicationUpgradeWithServiceResponseAsync(applicationId, applicationUpgradeDescription).toBlocking().single().body();
    }

    /**
     * Starts upgrading an application in the Service Fabric cluster.
     * Validates the supplied application upgrade parameters and starts upgrading the application if the parameters are valid.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param applicationUpgradeDescription Parameters for an application upgrade.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> startApplicationUpgradeAsync(String applicationId, ApplicationUpgradeDescription applicationUpgradeDescription, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(startApplicationUpgradeWithServiceResponseAsync(applicationId, applicationUpgradeDescription), serviceCallback);
    }

    /**
     * Starts upgrading an application in the Service Fabric cluster.
     * Validates the supplied application upgrade parameters and starts upgrading the application if the parameters are valid.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param applicationUpgradeDescription Parameters for an application upgrade.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> startApplicationUpgradeAsync(String applicationId, ApplicationUpgradeDescription applicationUpgradeDescription) {
        return startApplicationUpgradeWithServiceResponseAsync(applicationId, applicationUpgradeDescription).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Starts upgrading an application in the Service Fabric cluster.
     * Validates the supplied application upgrade parameters and starts upgrading the application if the parameters are valid.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param applicationUpgradeDescription Parameters for an application upgrade.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> startApplicationUpgradeWithServiceResponseAsync(String applicationId, ApplicationUpgradeDescription applicationUpgradeDescription) {
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        if (applicationUpgradeDescription == null) {
            throw new IllegalArgumentException("Parameter applicationUpgradeDescription is required and cannot be null.");
        }
        Validator.validate(applicationUpgradeDescription);
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.startApplicationUpgrade(applicationId, apiVersion, applicationUpgradeDescription, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = startApplicationUpgradeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Starts upgrading an application in the Service Fabric cluster.
     * Validates the supplied application upgrade parameters and starts upgrading the application if the parameters are valid.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param applicationUpgradeDescription Parameters for an application upgrade.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void startApplicationUpgrade(String applicationId, ApplicationUpgradeDescription applicationUpgradeDescription, Long timeout) {
        startApplicationUpgradeWithServiceResponseAsync(applicationId, applicationUpgradeDescription, timeout).toBlocking().single().body();
    }

    /**
     * Starts upgrading an application in the Service Fabric cluster.
     * Validates the supplied application upgrade parameters and starts upgrading the application if the parameters are valid.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param applicationUpgradeDescription Parameters for an application upgrade.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> startApplicationUpgradeAsync(String applicationId, ApplicationUpgradeDescription applicationUpgradeDescription, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(startApplicationUpgradeWithServiceResponseAsync(applicationId, applicationUpgradeDescription, timeout), serviceCallback);
    }

    /**
     * Starts upgrading an application in the Service Fabric cluster.
     * Validates the supplied application upgrade parameters and starts upgrading the application if the parameters are valid.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param applicationUpgradeDescription Parameters for an application upgrade.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> startApplicationUpgradeAsync(String applicationId, ApplicationUpgradeDescription applicationUpgradeDescription, Long timeout) {
        return startApplicationUpgradeWithServiceResponseAsync(applicationId, applicationUpgradeDescription, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Starts upgrading an application in the Service Fabric cluster.
     * Validates the supplied application upgrade parameters and starts upgrading the application if the parameters are valid.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param applicationUpgradeDescription Parameters for an application upgrade.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> startApplicationUpgradeWithServiceResponseAsync(String applicationId, ApplicationUpgradeDescription applicationUpgradeDescription, Long timeout) {
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        if (applicationUpgradeDescription == null) {
            throw new IllegalArgumentException("Parameter applicationUpgradeDescription is required and cannot be null.");
        }
        Validator.validate(applicationUpgradeDescription);
        final String apiVersion = "6.0";
        return service.startApplicationUpgrade(applicationId, apiVersion, applicationUpgradeDescription, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = startApplicationUpgradeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> startApplicationUpgradeDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets details for the latest upgrade performed on this application.
     * Returns information about the state of the latest application upgrade along with details to aid debugging application health issues.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ApplicationUpgradeProgressInfoInner object if successful.
     */
    public ApplicationUpgradeProgressInfoInner getApplicationUpgrade(String applicationId) {
        return getApplicationUpgradeWithServiceResponseAsync(applicationId).toBlocking().single().body();
    }

    /**
     * Gets details for the latest upgrade performed on this application.
     * Returns information about the state of the latest application upgrade along with details to aid debugging application health issues.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ApplicationUpgradeProgressInfoInner> getApplicationUpgradeAsync(String applicationId, final ServiceCallback<ApplicationUpgradeProgressInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getApplicationUpgradeWithServiceResponseAsync(applicationId), serviceCallback);
    }

    /**
     * Gets details for the latest upgrade performed on this application.
     * Returns information about the state of the latest application upgrade along with details to aid debugging application health issues.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationUpgradeProgressInfoInner object
     */
    public Observable<ApplicationUpgradeProgressInfoInner> getApplicationUpgradeAsync(String applicationId) {
        return getApplicationUpgradeWithServiceResponseAsync(applicationId).map(new Func1<ServiceResponse<ApplicationUpgradeProgressInfoInner>, ApplicationUpgradeProgressInfoInner>() {
            @Override
            public ApplicationUpgradeProgressInfoInner call(ServiceResponse<ApplicationUpgradeProgressInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets details for the latest upgrade performed on this application.
     * Returns information about the state of the latest application upgrade along with details to aid debugging application health issues.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationUpgradeProgressInfoInner object
     */
    public Observable<ServiceResponse<ApplicationUpgradeProgressInfoInner>> getApplicationUpgradeWithServiceResponseAsync(String applicationId) {
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.getApplicationUpgrade(applicationId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ApplicationUpgradeProgressInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<ApplicationUpgradeProgressInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ApplicationUpgradeProgressInfoInner> clientResponse = getApplicationUpgradeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets details for the latest upgrade performed on this application.
     * Returns information about the state of the latest application upgrade along with details to aid debugging application health issues.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ApplicationUpgradeProgressInfoInner object if successful.
     */
    public ApplicationUpgradeProgressInfoInner getApplicationUpgrade(String applicationId, Long timeout) {
        return getApplicationUpgradeWithServiceResponseAsync(applicationId, timeout).toBlocking().single().body();
    }

    /**
     * Gets details for the latest upgrade performed on this application.
     * Returns information about the state of the latest application upgrade along with details to aid debugging application health issues.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ApplicationUpgradeProgressInfoInner> getApplicationUpgradeAsync(String applicationId, Long timeout, final ServiceCallback<ApplicationUpgradeProgressInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getApplicationUpgradeWithServiceResponseAsync(applicationId, timeout), serviceCallback);
    }

    /**
     * Gets details for the latest upgrade performed on this application.
     * Returns information about the state of the latest application upgrade along with details to aid debugging application health issues.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationUpgradeProgressInfoInner object
     */
    public Observable<ApplicationUpgradeProgressInfoInner> getApplicationUpgradeAsync(String applicationId, Long timeout) {
        return getApplicationUpgradeWithServiceResponseAsync(applicationId, timeout).map(new Func1<ServiceResponse<ApplicationUpgradeProgressInfoInner>, ApplicationUpgradeProgressInfoInner>() {
            @Override
            public ApplicationUpgradeProgressInfoInner call(ServiceResponse<ApplicationUpgradeProgressInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets details for the latest upgrade performed on this application.
     * Returns information about the state of the latest application upgrade along with details to aid debugging application health issues.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationUpgradeProgressInfoInner object
     */
    public Observable<ServiceResponse<ApplicationUpgradeProgressInfoInner>> getApplicationUpgradeWithServiceResponseAsync(String applicationId, Long timeout) {
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.getApplicationUpgrade(applicationId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ApplicationUpgradeProgressInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<ApplicationUpgradeProgressInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ApplicationUpgradeProgressInfoInner> clientResponse = getApplicationUpgradeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ApplicationUpgradeProgressInfoInner> getApplicationUpgradeDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ApplicationUpgradeProgressInfoInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ApplicationUpgradeProgressInfoInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Updates an ongoing application upgrade in the Service Fabric cluster.
     * Updates the parameters of an ongoing application upgrade from the ones specified at the time of starting the application upgrade. This may be required to mitigate stuck application upgrades due to incorrect parameters or issues in the application to make progress.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param applicationUpgradeUpdateDescription Parameters for updating an existing application upgrade.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void updateApplicationUpgrade(String applicationId, ApplicationUpgradeUpdateDescription applicationUpgradeUpdateDescription) {
        updateApplicationUpgradeWithServiceResponseAsync(applicationId, applicationUpgradeUpdateDescription).toBlocking().single().body();
    }

    /**
     * Updates an ongoing application upgrade in the Service Fabric cluster.
     * Updates the parameters of an ongoing application upgrade from the ones specified at the time of starting the application upgrade. This may be required to mitigate stuck application upgrades due to incorrect parameters or issues in the application to make progress.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param applicationUpgradeUpdateDescription Parameters for updating an existing application upgrade.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> updateApplicationUpgradeAsync(String applicationId, ApplicationUpgradeUpdateDescription applicationUpgradeUpdateDescription, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(updateApplicationUpgradeWithServiceResponseAsync(applicationId, applicationUpgradeUpdateDescription), serviceCallback);
    }

    /**
     * Updates an ongoing application upgrade in the Service Fabric cluster.
     * Updates the parameters of an ongoing application upgrade from the ones specified at the time of starting the application upgrade. This may be required to mitigate stuck application upgrades due to incorrect parameters or issues in the application to make progress.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param applicationUpgradeUpdateDescription Parameters for updating an existing application upgrade.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> updateApplicationUpgradeAsync(String applicationId, ApplicationUpgradeUpdateDescription applicationUpgradeUpdateDescription) {
        return updateApplicationUpgradeWithServiceResponseAsync(applicationId, applicationUpgradeUpdateDescription).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates an ongoing application upgrade in the Service Fabric cluster.
     * Updates the parameters of an ongoing application upgrade from the ones specified at the time of starting the application upgrade. This may be required to mitigate stuck application upgrades due to incorrect parameters or issues in the application to make progress.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param applicationUpgradeUpdateDescription Parameters for updating an existing application upgrade.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> updateApplicationUpgradeWithServiceResponseAsync(String applicationId, ApplicationUpgradeUpdateDescription applicationUpgradeUpdateDescription) {
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        if (applicationUpgradeUpdateDescription == null) {
            throw new IllegalArgumentException("Parameter applicationUpgradeUpdateDescription is required and cannot be null.");
        }
        Validator.validate(applicationUpgradeUpdateDescription);
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.updateApplicationUpgrade(applicationId, apiVersion, applicationUpgradeUpdateDescription, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = updateApplicationUpgradeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Updates an ongoing application upgrade in the Service Fabric cluster.
     * Updates the parameters of an ongoing application upgrade from the ones specified at the time of starting the application upgrade. This may be required to mitigate stuck application upgrades due to incorrect parameters or issues in the application to make progress.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param applicationUpgradeUpdateDescription Parameters for updating an existing application upgrade.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void updateApplicationUpgrade(String applicationId, ApplicationUpgradeUpdateDescription applicationUpgradeUpdateDescription, Long timeout) {
        updateApplicationUpgradeWithServiceResponseAsync(applicationId, applicationUpgradeUpdateDescription, timeout).toBlocking().single().body();
    }

    /**
     * Updates an ongoing application upgrade in the Service Fabric cluster.
     * Updates the parameters of an ongoing application upgrade from the ones specified at the time of starting the application upgrade. This may be required to mitigate stuck application upgrades due to incorrect parameters or issues in the application to make progress.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param applicationUpgradeUpdateDescription Parameters for updating an existing application upgrade.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> updateApplicationUpgradeAsync(String applicationId, ApplicationUpgradeUpdateDescription applicationUpgradeUpdateDescription, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(updateApplicationUpgradeWithServiceResponseAsync(applicationId, applicationUpgradeUpdateDescription, timeout), serviceCallback);
    }

    /**
     * Updates an ongoing application upgrade in the Service Fabric cluster.
     * Updates the parameters of an ongoing application upgrade from the ones specified at the time of starting the application upgrade. This may be required to mitigate stuck application upgrades due to incorrect parameters or issues in the application to make progress.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param applicationUpgradeUpdateDescription Parameters for updating an existing application upgrade.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> updateApplicationUpgradeAsync(String applicationId, ApplicationUpgradeUpdateDescription applicationUpgradeUpdateDescription, Long timeout) {
        return updateApplicationUpgradeWithServiceResponseAsync(applicationId, applicationUpgradeUpdateDescription, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates an ongoing application upgrade in the Service Fabric cluster.
     * Updates the parameters of an ongoing application upgrade from the ones specified at the time of starting the application upgrade. This may be required to mitigate stuck application upgrades due to incorrect parameters or issues in the application to make progress.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param applicationUpgradeUpdateDescription Parameters for updating an existing application upgrade.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> updateApplicationUpgradeWithServiceResponseAsync(String applicationId, ApplicationUpgradeUpdateDescription applicationUpgradeUpdateDescription, Long timeout) {
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        if (applicationUpgradeUpdateDescription == null) {
            throw new IllegalArgumentException("Parameter applicationUpgradeUpdateDescription is required and cannot be null.");
        }
        Validator.validate(applicationUpgradeUpdateDescription);
        final String apiVersion = "6.0";
        return service.updateApplicationUpgrade(applicationId, apiVersion, applicationUpgradeUpdateDescription, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = updateApplicationUpgradeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> updateApplicationUpgradeDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Resumes upgrading an application in the Service Fabric cluster.
     * Resumes an unmonitored manual Service Fabric application upgrade. Service Fabric upgrades one upgrade domain at a time. For unmonitored manual upgrades, after Service Fabric finishes an upgrade domain, it waits for you to call this API before proceeding to the next upgrade domain.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param upgradeDomainName The name of the upgrade domain in which to resume the upgrade.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void resumeApplicationUpgrade(String applicationId, String upgradeDomainName) {
        resumeApplicationUpgradeWithServiceResponseAsync(applicationId, upgradeDomainName).toBlocking().single().body();
    }

    /**
     * Resumes upgrading an application in the Service Fabric cluster.
     * Resumes an unmonitored manual Service Fabric application upgrade. Service Fabric upgrades one upgrade domain at a time. For unmonitored manual upgrades, after Service Fabric finishes an upgrade domain, it waits for you to call this API before proceeding to the next upgrade domain.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param upgradeDomainName The name of the upgrade domain in which to resume the upgrade.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> resumeApplicationUpgradeAsync(String applicationId, String upgradeDomainName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(resumeApplicationUpgradeWithServiceResponseAsync(applicationId, upgradeDomainName), serviceCallback);
    }

    /**
     * Resumes upgrading an application in the Service Fabric cluster.
     * Resumes an unmonitored manual Service Fabric application upgrade. Service Fabric upgrades one upgrade domain at a time. For unmonitored manual upgrades, after Service Fabric finishes an upgrade domain, it waits for you to call this API before proceeding to the next upgrade domain.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param upgradeDomainName The name of the upgrade domain in which to resume the upgrade.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> resumeApplicationUpgradeAsync(String applicationId, String upgradeDomainName) {
        return resumeApplicationUpgradeWithServiceResponseAsync(applicationId, upgradeDomainName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Resumes upgrading an application in the Service Fabric cluster.
     * Resumes an unmonitored manual Service Fabric application upgrade. Service Fabric upgrades one upgrade domain at a time. For unmonitored manual upgrades, after Service Fabric finishes an upgrade domain, it waits for you to call this API before proceeding to the next upgrade domain.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param upgradeDomainName The name of the upgrade domain in which to resume the upgrade.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> resumeApplicationUpgradeWithServiceResponseAsync(String applicationId, String upgradeDomainName) {
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        if (upgradeDomainName == null) {
            throw new IllegalArgumentException("Parameter upgradeDomainName is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        ResumeApplicationUpgradeDescription resumeApplicationUpgradeDescription = new ResumeApplicationUpgradeDescription();
        resumeApplicationUpgradeDescription.withUpgradeDomainName(upgradeDomainName);
        return service.resumeApplicationUpgrade(applicationId, apiVersion, timeout, this.acceptLanguage(), resumeApplicationUpgradeDescription, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = resumeApplicationUpgradeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Resumes upgrading an application in the Service Fabric cluster.
     * Resumes an unmonitored manual Service Fabric application upgrade. Service Fabric upgrades one upgrade domain at a time. For unmonitored manual upgrades, after Service Fabric finishes an upgrade domain, it waits for you to call this API before proceeding to the next upgrade domain.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param upgradeDomainName The name of the upgrade domain in which to resume the upgrade.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void resumeApplicationUpgrade(String applicationId, String upgradeDomainName, Long timeout) {
        resumeApplicationUpgradeWithServiceResponseAsync(applicationId, upgradeDomainName, timeout).toBlocking().single().body();
    }

    /**
     * Resumes upgrading an application in the Service Fabric cluster.
     * Resumes an unmonitored manual Service Fabric application upgrade. Service Fabric upgrades one upgrade domain at a time. For unmonitored manual upgrades, after Service Fabric finishes an upgrade domain, it waits for you to call this API before proceeding to the next upgrade domain.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param upgradeDomainName The name of the upgrade domain in which to resume the upgrade.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> resumeApplicationUpgradeAsync(String applicationId, String upgradeDomainName, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(resumeApplicationUpgradeWithServiceResponseAsync(applicationId, upgradeDomainName, timeout), serviceCallback);
    }

    /**
     * Resumes upgrading an application in the Service Fabric cluster.
     * Resumes an unmonitored manual Service Fabric application upgrade. Service Fabric upgrades one upgrade domain at a time. For unmonitored manual upgrades, after Service Fabric finishes an upgrade domain, it waits for you to call this API before proceeding to the next upgrade domain.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param upgradeDomainName The name of the upgrade domain in which to resume the upgrade.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> resumeApplicationUpgradeAsync(String applicationId, String upgradeDomainName, Long timeout) {
        return resumeApplicationUpgradeWithServiceResponseAsync(applicationId, upgradeDomainName, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Resumes upgrading an application in the Service Fabric cluster.
     * Resumes an unmonitored manual Service Fabric application upgrade. Service Fabric upgrades one upgrade domain at a time. For unmonitored manual upgrades, after Service Fabric finishes an upgrade domain, it waits for you to call this API before proceeding to the next upgrade domain.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param upgradeDomainName The name of the upgrade domain in which to resume the upgrade.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> resumeApplicationUpgradeWithServiceResponseAsync(String applicationId, String upgradeDomainName, Long timeout) {
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        if (upgradeDomainName == null) {
            throw new IllegalArgumentException("Parameter upgradeDomainName is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        ResumeApplicationUpgradeDescription resumeApplicationUpgradeDescription = new ResumeApplicationUpgradeDescription();
        resumeApplicationUpgradeDescription.withUpgradeDomainName(upgradeDomainName);
        return service.resumeApplicationUpgrade(applicationId, apiVersion, timeout, this.acceptLanguage(), resumeApplicationUpgradeDescription, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = resumeApplicationUpgradeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> resumeApplicationUpgradeDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Starts rolling back the currently on-going upgrade of an application in the Service Fabric cluster.
     * Starts rolling back the current application upgrade to the previous version. This API can only be used to roll back the current in-progress upgrade that is rolling forward to new version. If the application is not currently being upgraded use StartApplicationUpgrade API to upgrade it to desired version, including rolling back to a previous version.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void rollbackApplicationUpgrade(String applicationId) {
        rollbackApplicationUpgradeWithServiceResponseAsync(applicationId).toBlocking().single().body();
    }

    /**
     * Starts rolling back the currently on-going upgrade of an application in the Service Fabric cluster.
     * Starts rolling back the current application upgrade to the previous version. This API can only be used to roll back the current in-progress upgrade that is rolling forward to new version. If the application is not currently being upgraded use StartApplicationUpgrade API to upgrade it to desired version, including rolling back to a previous version.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> rollbackApplicationUpgradeAsync(String applicationId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(rollbackApplicationUpgradeWithServiceResponseAsync(applicationId), serviceCallback);
    }

    /**
     * Starts rolling back the currently on-going upgrade of an application in the Service Fabric cluster.
     * Starts rolling back the current application upgrade to the previous version. This API can only be used to roll back the current in-progress upgrade that is rolling forward to new version. If the application is not currently being upgraded use StartApplicationUpgrade API to upgrade it to desired version, including rolling back to a previous version.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> rollbackApplicationUpgradeAsync(String applicationId) {
        return rollbackApplicationUpgradeWithServiceResponseAsync(applicationId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Starts rolling back the currently on-going upgrade of an application in the Service Fabric cluster.
     * Starts rolling back the current application upgrade to the previous version. This API can only be used to roll back the current in-progress upgrade that is rolling forward to new version. If the application is not currently being upgraded use StartApplicationUpgrade API to upgrade it to desired version, including rolling back to a previous version.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> rollbackApplicationUpgradeWithServiceResponseAsync(String applicationId) {
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.rollbackApplicationUpgrade(applicationId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = rollbackApplicationUpgradeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Starts rolling back the currently on-going upgrade of an application in the Service Fabric cluster.
     * Starts rolling back the current application upgrade to the previous version. This API can only be used to roll back the current in-progress upgrade that is rolling forward to new version. If the application is not currently being upgraded use StartApplicationUpgrade API to upgrade it to desired version, including rolling back to a previous version.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void rollbackApplicationUpgrade(String applicationId, Long timeout) {
        rollbackApplicationUpgradeWithServiceResponseAsync(applicationId, timeout).toBlocking().single().body();
    }

    /**
     * Starts rolling back the currently on-going upgrade of an application in the Service Fabric cluster.
     * Starts rolling back the current application upgrade to the previous version. This API can only be used to roll back the current in-progress upgrade that is rolling forward to new version. If the application is not currently being upgraded use StartApplicationUpgrade API to upgrade it to desired version, including rolling back to a previous version.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> rollbackApplicationUpgradeAsync(String applicationId, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(rollbackApplicationUpgradeWithServiceResponseAsync(applicationId, timeout), serviceCallback);
    }

    /**
     * Starts rolling back the currently on-going upgrade of an application in the Service Fabric cluster.
     * Starts rolling back the current application upgrade to the previous version. This API can only be used to roll back the current in-progress upgrade that is rolling forward to new version. If the application is not currently being upgraded use StartApplicationUpgrade API to upgrade it to desired version, including rolling back to a previous version.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> rollbackApplicationUpgradeAsync(String applicationId, Long timeout) {
        return rollbackApplicationUpgradeWithServiceResponseAsync(applicationId, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Starts rolling back the currently on-going upgrade of an application in the Service Fabric cluster.
     * Starts rolling back the current application upgrade to the previous version. This API can only be used to roll back the current in-progress upgrade that is rolling forward to new version. If the application is not currently being upgraded use StartApplicationUpgrade API to upgrade it to desired version, including rolling back to a previous version.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> rollbackApplicationUpgradeWithServiceResponseAsync(String applicationId, Long timeout) {
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.rollbackApplicationUpgrade(applicationId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = rollbackApplicationUpgradeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> rollbackApplicationUpgradeDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the list of applications deployed on a Service Fabric node.
     * Gets the list of applications deployed on a Service Fabric node. The results do not include information about deployed system applications unless explicitly queried for by ID. Results encompass deployed applications in active, activating, and downloading states. This query requires that the node name corresponds to a node on the cluster. The query fails if the provided node name does not point to any active Service Fabric nodes on the cluster.
     *
     * @param nodeName The name of the node.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedDeployedApplicationInfoListInner object if successful.
     */
    public PagedDeployedApplicationInfoListInner getDeployedApplicationInfoList(String nodeName) {
        return getDeployedApplicationInfoListWithServiceResponseAsync(nodeName).toBlocking().single().body();
    }

    /**
     * Gets the list of applications deployed on a Service Fabric node.
     * Gets the list of applications deployed on a Service Fabric node. The results do not include information about deployed system applications unless explicitly queried for by ID. Results encompass deployed applications in active, activating, and downloading states. This query requires that the node name corresponds to a node on the cluster. The query fails if the provided node name does not point to any active Service Fabric nodes on the cluster.
     *
     * @param nodeName The name of the node.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedDeployedApplicationInfoListInner> getDeployedApplicationInfoListAsync(String nodeName, final ServiceCallback<PagedDeployedApplicationInfoListInner> serviceCallback) {
        return ServiceFuture.fromResponse(getDeployedApplicationInfoListWithServiceResponseAsync(nodeName), serviceCallback);
    }

    /**
     * Gets the list of applications deployed on a Service Fabric node.
     * Gets the list of applications deployed on a Service Fabric node. The results do not include information about deployed system applications unless explicitly queried for by ID. Results encompass deployed applications in active, activating, and downloading states. This query requires that the node name corresponds to a node on the cluster. The query fails if the provided node name does not point to any active Service Fabric nodes on the cluster.
     *
     * @param nodeName The name of the node.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedDeployedApplicationInfoListInner object
     */
    public Observable<PagedDeployedApplicationInfoListInner> getDeployedApplicationInfoListAsync(String nodeName) {
        return getDeployedApplicationInfoListWithServiceResponseAsync(nodeName).map(new Func1<ServiceResponse<PagedDeployedApplicationInfoListInner>, PagedDeployedApplicationInfoListInner>() {
            @Override
            public PagedDeployedApplicationInfoListInner call(ServiceResponse<PagedDeployedApplicationInfoListInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the list of applications deployed on a Service Fabric node.
     * Gets the list of applications deployed on a Service Fabric node. The results do not include information about deployed system applications unless explicitly queried for by ID. Results encompass deployed applications in active, activating, and downloading states. This query requires that the node name corresponds to a node on the cluster. The query fails if the provided node name does not point to any active Service Fabric nodes on the cluster.
     *
     * @param nodeName The name of the node.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedDeployedApplicationInfoListInner object
     */
    public Observable<ServiceResponse<PagedDeployedApplicationInfoListInner>> getDeployedApplicationInfoListWithServiceResponseAsync(String nodeName) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        final String apiVersion = "6.1";
        final Long timeout = null;
        final Boolean includeHealthState = null;
        final String continuationToken = null;
        final Long maxResults = null;
        return service.getDeployedApplicationInfoList(nodeName, apiVersion, timeout, includeHealthState, continuationToken, maxResults, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedDeployedApplicationInfoListInner>>>() {
                @Override
                public Observable<ServiceResponse<PagedDeployedApplicationInfoListInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedDeployedApplicationInfoListInner> clientResponse = getDeployedApplicationInfoListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the list of applications deployed on a Service Fabric node.
     * Gets the list of applications deployed on a Service Fabric node. The results do not include information about deployed system applications unless explicitly queried for by ID. Results encompass deployed applications in active, activating, and downloading states. This query requires that the node name corresponds to a node on the cluster. The query fails if the provided node name does not point to any active Service Fabric nodes on the cluster.
     *
     * @param nodeName The name of the node.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param includeHealthState Include the health state of an entity.
     If this parameter is false or not specified, then the health state returned is "Unknown".
     When set to true, the query goes in parallel to the node and the health system service before the results are merged.
     As a result, the query is more expensive and may take a longer time.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedDeployedApplicationInfoListInner object if successful.
     */
    public PagedDeployedApplicationInfoListInner getDeployedApplicationInfoList(String nodeName, Long timeout, Boolean includeHealthState, String continuationToken, Long maxResults) {
        return getDeployedApplicationInfoListWithServiceResponseAsync(nodeName, timeout, includeHealthState, continuationToken, maxResults).toBlocking().single().body();
    }

    /**
     * Gets the list of applications deployed on a Service Fabric node.
     * Gets the list of applications deployed on a Service Fabric node. The results do not include information about deployed system applications unless explicitly queried for by ID. Results encompass deployed applications in active, activating, and downloading states. This query requires that the node name corresponds to a node on the cluster. The query fails if the provided node name does not point to any active Service Fabric nodes on the cluster.
     *
     * @param nodeName The name of the node.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param includeHealthState Include the health state of an entity.
     If this parameter is false or not specified, then the health state returned is "Unknown".
     When set to true, the query goes in parallel to the node and the health system service before the results are merged.
     As a result, the query is more expensive and may take a longer time.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedDeployedApplicationInfoListInner> getDeployedApplicationInfoListAsync(String nodeName, Long timeout, Boolean includeHealthState, String continuationToken, Long maxResults, final ServiceCallback<PagedDeployedApplicationInfoListInner> serviceCallback) {
        return ServiceFuture.fromResponse(getDeployedApplicationInfoListWithServiceResponseAsync(nodeName, timeout, includeHealthState, continuationToken, maxResults), serviceCallback);
    }

    /**
     * Gets the list of applications deployed on a Service Fabric node.
     * Gets the list of applications deployed on a Service Fabric node. The results do not include information about deployed system applications unless explicitly queried for by ID. Results encompass deployed applications in active, activating, and downloading states. This query requires that the node name corresponds to a node on the cluster. The query fails if the provided node name does not point to any active Service Fabric nodes on the cluster.
     *
     * @param nodeName The name of the node.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param includeHealthState Include the health state of an entity.
     If this parameter is false or not specified, then the health state returned is "Unknown".
     When set to true, the query goes in parallel to the node and the health system service before the results are merged.
     As a result, the query is more expensive and may take a longer time.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedDeployedApplicationInfoListInner object
     */
    public Observable<PagedDeployedApplicationInfoListInner> getDeployedApplicationInfoListAsync(String nodeName, Long timeout, Boolean includeHealthState, String continuationToken, Long maxResults) {
        return getDeployedApplicationInfoListWithServiceResponseAsync(nodeName, timeout, includeHealthState, continuationToken, maxResults).map(new Func1<ServiceResponse<PagedDeployedApplicationInfoListInner>, PagedDeployedApplicationInfoListInner>() {
            @Override
            public PagedDeployedApplicationInfoListInner call(ServiceResponse<PagedDeployedApplicationInfoListInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the list of applications deployed on a Service Fabric node.
     * Gets the list of applications deployed on a Service Fabric node. The results do not include information about deployed system applications unless explicitly queried for by ID. Results encompass deployed applications in active, activating, and downloading states. This query requires that the node name corresponds to a node on the cluster. The query fails if the provided node name does not point to any active Service Fabric nodes on the cluster.
     *
     * @param nodeName The name of the node.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param includeHealthState Include the health state of an entity.
     If this parameter is false or not specified, then the health state returned is "Unknown".
     When set to true, the query goes in parallel to the node and the health system service before the results are merged.
     As a result, the query is more expensive and may take a longer time.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedDeployedApplicationInfoListInner object
     */
    public Observable<ServiceResponse<PagedDeployedApplicationInfoListInner>> getDeployedApplicationInfoListWithServiceResponseAsync(String nodeName, Long timeout, Boolean includeHealthState, String continuationToken, Long maxResults) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        final String apiVersion = "6.1";
        return service.getDeployedApplicationInfoList(nodeName, apiVersion, timeout, includeHealthState, continuationToken, maxResults, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedDeployedApplicationInfoListInner>>>() {
                @Override
                public Observable<ServiceResponse<PagedDeployedApplicationInfoListInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedDeployedApplicationInfoListInner> clientResponse = getDeployedApplicationInfoListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PagedDeployedApplicationInfoListInner> getDeployedApplicationInfoListDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<PagedDeployedApplicationInfoListInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PagedDeployedApplicationInfoListInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the information about an application deployed on a Service Fabric node.
     * This query returns system application information if the application ID provided is for system application. Results encompass deployed applications in active, activating, and downloading states. This query requires that the node name corresponds to a node on the cluster. The query fails if the provided node name does not point to any active Service Fabric nodes on the cluster.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the DeployedApplicationInfoInner object if successful.
     */
    public DeployedApplicationInfoInner getDeployedApplicationInfo(String nodeName, String applicationId) {
        return getDeployedApplicationInfoWithServiceResponseAsync(nodeName, applicationId).toBlocking().single().body();
    }

    /**
     * Gets the information about an application deployed on a Service Fabric node.
     * This query returns system application information if the application ID provided is for system application. Results encompass deployed applications in active, activating, and downloading states. This query requires that the node name corresponds to a node on the cluster. The query fails if the provided node name does not point to any active Service Fabric nodes on the cluster.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<DeployedApplicationInfoInner> getDeployedApplicationInfoAsync(String nodeName, String applicationId, final ServiceCallback<DeployedApplicationInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getDeployedApplicationInfoWithServiceResponseAsync(nodeName, applicationId), serviceCallback);
    }

    /**
     * Gets the information about an application deployed on a Service Fabric node.
     * This query returns system application information if the application ID provided is for system application. Results encompass deployed applications in active, activating, and downloading states. This query requires that the node name corresponds to a node on the cluster. The query fails if the provided node name does not point to any active Service Fabric nodes on the cluster.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeployedApplicationInfoInner object
     */
    public Observable<DeployedApplicationInfoInner> getDeployedApplicationInfoAsync(String nodeName, String applicationId) {
        return getDeployedApplicationInfoWithServiceResponseAsync(nodeName, applicationId).map(new Func1<ServiceResponse<DeployedApplicationInfoInner>, DeployedApplicationInfoInner>() {
            @Override
            public DeployedApplicationInfoInner call(ServiceResponse<DeployedApplicationInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the information about an application deployed on a Service Fabric node.
     * This query returns system application information if the application ID provided is for system application. Results encompass deployed applications in active, activating, and downloading states. This query requires that the node name corresponds to a node on the cluster. The query fails if the provided node name does not point to any active Service Fabric nodes on the cluster.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeployedApplicationInfoInner object
     */
    public Observable<ServiceResponse<DeployedApplicationInfoInner>> getDeployedApplicationInfoWithServiceResponseAsync(String nodeName, String applicationId) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        final String apiVersion = "6.1";
        final Long timeout = null;
        final Boolean includeHealthState = null;
        return service.getDeployedApplicationInfo(nodeName, applicationId, apiVersion, timeout, includeHealthState, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeployedApplicationInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<DeployedApplicationInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeployedApplicationInfoInner> clientResponse = getDeployedApplicationInfoDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the information about an application deployed on a Service Fabric node.
     * This query returns system application information if the application ID provided is for system application. Results encompass deployed applications in active, activating, and downloading states. This query requires that the node name corresponds to a node on the cluster. The query fails if the provided node name does not point to any active Service Fabric nodes on the cluster.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param includeHealthState Include the health state of an entity.
     If this parameter is false or not specified, then the health state returned is "Unknown".
     When set to true, the query goes in parallel to the node and the health system service before the results are merged.
     As a result, the query is more expensive and may take a longer time.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the DeployedApplicationInfoInner object if successful.
     */
    public DeployedApplicationInfoInner getDeployedApplicationInfo(String nodeName, String applicationId, Long timeout, Boolean includeHealthState) {
        return getDeployedApplicationInfoWithServiceResponseAsync(nodeName, applicationId, timeout, includeHealthState).toBlocking().single().body();
    }

    /**
     * Gets the information about an application deployed on a Service Fabric node.
     * This query returns system application information if the application ID provided is for system application. Results encompass deployed applications in active, activating, and downloading states. This query requires that the node name corresponds to a node on the cluster. The query fails if the provided node name does not point to any active Service Fabric nodes on the cluster.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param includeHealthState Include the health state of an entity.
     If this parameter is false or not specified, then the health state returned is "Unknown".
     When set to true, the query goes in parallel to the node and the health system service before the results are merged.
     As a result, the query is more expensive and may take a longer time.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<DeployedApplicationInfoInner> getDeployedApplicationInfoAsync(String nodeName, String applicationId, Long timeout, Boolean includeHealthState, final ServiceCallback<DeployedApplicationInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getDeployedApplicationInfoWithServiceResponseAsync(nodeName, applicationId, timeout, includeHealthState), serviceCallback);
    }

    /**
     * Gets the information about an application deployed on a Service Fabric node.
     * This query returns system application information if the application ID provided is for system application. Results encompass deployed applications in active, activating, and downloading states. This query requires that the node name corresponds to a node on the cluster. The query fails if the provided node name does not point to any active Service Fabric nodes on the cluster.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param includeHealthState Include the health state of an entity.
     If this parameter is false or not specified, then the health state returned is "Unknown".
     When set to true, the query goes in parallel to the node and the health system service before the results are merged.
     As a result, the query is more expensive and may take a longer time.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeployedApplicationInfoInner object
     */
    public Observable<DeployedApplicationInfoInner> getDeployedApplicationInfoAsync(String nodeName, String applicationId, Long timeout, Boolean includeHealthState) {
        return getDeployedApplicationInfoWithServiceResponseAsync(nodeName, applicationId, timeout, includeHealthState).map(new Func1<ServiceResponse<DeployedApplicationInfoInner>, DeployedApplicationInfoInner>() {
            @Override
            public DeployedApplicationInfoInner call(ServiceResponse<DeployedApplicationInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the information about an application deployed on a Service Fabric node.
     * This query returns system application information if the application ID provided is for system application. Results encompass deployed applications in active, activating, and downloading states. This query requires that the node name corresponds to a node on the cluster. The query fails if the provided node name does not point to any active Service Fabric nodes on the cluster.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param includeHealthState Include the health state of an entity.
     If this parameter is false or not specified, then the health state returned is "Unknown".
     When set to true, the query goes in parallel to the node and the health system service before the results are merged.
     As a result, the query is more expensive and may take a longer time.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeployedApplicationInfoInner object
     */
    public Observable<ServiceResponse<DeployedApplicationInfoInner>> getDeployedApplicationInfoWithServiceResponseAsync(String nodeName, String applicationId, Long timeout, Boolean includeHealthState) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        final String apiVersion = "6.1";
        return service.getDeployedApplicationInfo(nodeName, applicationId, apiVersion, timeout, includeHealthState, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeployedApplicationInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<DeployedApplicationInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeployedApplicationInfoInner> clientResponse = getDeployedApplicationInfoDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DeployedApplicationInfoInner> getDeployedApplicationInfoDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<DeployedApplicationInfoInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<DeployedApplicationInfoInner>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the information about health of an application deployed on a Service Fabric node.
     * Gets the information about health of an application deployed on a Service Fabric node. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed application based on health state. Use DeployedServicePackagesHealthStateFilter to optionally filter for DeployedServicePackageHealth children based on health state.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the DeployedApplicationHealthInner object if successful.
     */
    public DeployedApplicationHealthInner getDeployedApplicationHealth(String nodeName, String applicationId) {
        return getDeployedApplicationHealthWithServiceResponseAsync(nodeName, applicationId).toBlocking().single().body();
    }

    /**
     * Gets the information about health of an application deployed on a Service Fabric node.
     * Gets the information about health of an application deployed on a Service Fabric node. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed application based on health state. Use DeployedServicePackagesHealthStateFilter to optionally filter for DeployedServicePackageHealth children based on health state.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<DeployedApplicationHealthInner> getDeployedApplicationHealthAsync(String nodeName, String applicationId, final ServiceCallback<DeployedApplicationHealthInner> serviceCallback) {
        return ServiceFuture.fromResponse(getDeployedApplicationHealthWithServiceResponseAsync(nodeName, applicationId), serviceCallback);
    }

    /**
     * Gets the information about health of an application deployed on a Service Fabric node.
     * Gets the information about health of an application deployed on a Service Fabric node. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed application based on health state. Use DeployedServicePackagesHealthStateFilter to optionally filter for DeployedServicePackageHealth children based on health state.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeployedApplicationHealthInner object
     */
    public Observable<DeployedApplicationHealthInner> getDeployedApplicationHealthAsync(String nodeName, String applicationId) {
        return getDeployedApplicationHealthWithServiceResponseAsync(nodeName, applicationId).map(new Func1<ServiceResponse<DeployedApplicationHealthInner>, DeployedApplicationHealthInner>() {
            @Override
            public DeployedApplicationHealthInner call(ServiceResponse<DeployedApplicationHealthInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the information about health of an application deployed on a Service Fabric node.
     * Gets the information about health of an application deployed on a Service Fabric node. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed application based on health state. Use DeployedServicePackagesHealthStateFilter to optionally filter for DeployedServicePackageHealth children based on health state.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeployedApplicationHealthInner object
     */
    public Observable<ServiceResponse<DeployedApplicationHealthInner>> getDeployedApplicationHealthWithServiceResponseAsync(String nodeName, String applicationId) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Integer eventsHealthStateFilter = null;
        final Integer deployedServicePackagesHealthStateFilter = null;
        final Boolean excludeHealthStatistics = null;
        final Long timeout = null;
        return service.getDeployedApplicationHealth(nodeName, applicationId, apiVersion, eventsHealthStateFilter, deployedServicePackagesHealthStateFilter, excludeHealthStatistics, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeployedApplicationHealthInner>>>() {
                @Override
                public Observable<ServiceResponse<DeployedApplicationHealthInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeployedApplicationHealthInner> clientResponse = getDeployedApplicationHealthDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the information about health of an application deployed on a Service Fabric node.
     * Gets the information about health of an application deployed on a Service Fabric node. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed application based on health state. Use DeployedServicePackagesHealthStateFilter to optionally filter for DeployedServicePackageHealth children based on health state.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param deployedServicePackagesHealthStateFilter Allows filtering of the deployed service package health state objects returned in the result of deployed application health query based on their health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only deployed service packages that match the filter are returned. All deployed service packages are used to evaluate the aggregated health state of the deployed application.
     If not specified, all entries are returned.
     The state values are flag-based enumeration, so the value can be a combination of these values, obtained using the bitwise 'OR' operator.
     For example, if the provided value is 6 then health state of service packages with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param excludeHealthStatistics Indicates whether the health statistics should be returned as part of the query result. False by default.
     The statistics show the number of children entities in health state Ok, Warning, and Error.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the DeployedApplicationHealthInner object if successful.
     */
    public DeployedApplicationHealthInner getDeployedApplicationHealth(String nodeName, String applicationId, Integer eventsHealthStateFilter, Integer deployedServicePackagesHealthStateFilter, Boolean excludeHealthStatistics, Long timeout) {
        return getDeployedApplicationHealthWithServiceResponseAsync(nodeName, applicationId, eventsHealthStateFilter, deployedServicePackagesHealthStateFilter, excludeHealthStatistics, timeout).toBlocking().single().body();
    }

    /**
     * Gets the information about health of an application deployed on a Service Fabric node.
     * Gets the information about health of an application deployed on a Service Fabric node. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed application based on health state. Use DeployedServicePackagesHealthStateFilter to optionally filter for DeployedServicePackageHealth children based on health state.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param deployedServicePackagesHealthStateFilter Allows filtering of the deployed service package health state objects returned in the result of deployed application health query based on their health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only deployed service packages that match the filter are returned. All deployed service packages are used to evaluate the aggregated health state of the deployed application.
     If not specified, all entries are returned.
     The state values are flag-based enumeration, so the value can be a combination of these values, obtained using the bitwise 'OR' operator.
     For example, if the provided value is 6 then health state of service packages with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param excludeHealthStatistics Indicates whether the health statistics should be returned as part of the query result. False by default.
     The statistics show the number of children entities in health state Ok, Warning, and Error.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<DeployedApplicationHealthInner> getDeployedApplicationHealthAsync(String nodeName, String applicationId, Integer eventsHealthStateFilter, Integer deployedServicePackagesHealthStateFilter, Boolean excludeHealthStatistics, Long timeout, final ServiceCallback<DeployedApplicationHealthInner> serviceCallback) {
        return ServiceFuture.fromResponse(getDeployedApplicationHealthWithServiceResponseAsync(nodeName, applicationId, eventsHealthStateFilter, deployedServicePackagesHealthStateFilter, excludeHealthStatistics, timeout), serviceCallback);
    }

    /**
     * Gets the information about health of an application deployed on a Service Fabric node.
     * Gets the information about health of an application deployed on a Service Fabric node. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed application based on health state. Use DeployedServicePackagesHealthStateFilter to optionally filter for DeployedServicePackageHealth children based on health state.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param deployedServicePackagesHealthStateFilter Allows filtering of the deployed service package health state objects returned in the result of deployed application health query based on their health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only deployed service packages that match the filter are returned. All deployed service packages are used to evaluate the aggregated health state of the deployed application.
     If not specified, all entries are returned.
     The state values are flag-based enumeration, so the value can be a combination of these values, obtained using the bitwise 'OR' operator.
     For example, if the provided value is 6 then health state of service packages with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param excludeHealthStatistics Indicates whether the health statistics should be returned as part of the query result. False by default.
     The statistics show the number of children entities in health state Ok, Warning, and Error.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeployedApplicationHealthInner object
     */
    public Observable<DeployedApplicationHealthInner> getDeployedApplicationHealthAsync(String nodeName, String applicationId, Integer eventsHealthStateFilter, Integer deployedServicePackagesHealthStateFilter, Boolean excludeHealthStatistics, Long timeout) {
        return getDeployedApplicationHealthWithServiceResponseAsync(nodeName, applicationId, eventsHealthStateFilter, deployedServicePackagesHealthStateFilter, excludeHealthStatistics, timeout).map(new Func1<ServiceResponse<DeployedApplicationHealthInner>, DeployedApplicationHealthInner>() {
            @Override
            public DeployedApplicationHealthInner call(ServiceResponse<DeployedApplicationHealthInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the information about health of an application deployed on a Service Fabric node.
     * Gets the information about health of an application deployed on a Service Fabric node. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed application based on health state. Use DeployedServicePackagesHealthStateFilter to optionally filter for DeployedServicePackageHealth children based on health state.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param deployedServicePackagesHealthStateFilter Allows filtering of the deployed service package health state objects returned in the result of deployed application health query based on their health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only deployed service packages that match the filter are returned. All deployed service packages are used to evaluate the aggregated health state of the deployed application.
     If not specified, all entries are returned.
     The state values are flag-based enumeration, so the value can be a combination of these values, obtained using the bitwise 'OR' operator.
     For example, if the provided value is 6 then health state of service packages with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param excludeHealthStatistics Indicates whether the health statistics should be returned as part of the query result. False by default.
     The statistics show the number of children entities in health state Ok, Warning, and Error.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeployedApplicationHealthInner object
     */
    public Observable<ServiceResponse<DeployedApplicationHealthInner>> getDeployedApplicationHealthWithServiceResponseAsync(String nodeName, String applicationId, Integer eventsHealthStateFilter, Integer deployedServicePackagesHealthStateFilter, Boolean excludeHealthStatistics, Long timeout) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.getDeployedApplicationHealth(nodeName, applicationId, apiVersion, eventsHealthStateFilter, deployedServicePackagesHealthStateFilter, excludeHealthStatistics, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeployedApplicationHealthInner>>>() {
                @Override
                public Observable<ServiceResponse<DeployedApplicationHealthInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeployedApplicationHealthInner> clientResponse = getDeployedApplicationHealthDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DeployedApplicationHealthInner> getDeployedApplicationHealthDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<DeployedApplicationHealthInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<DeployedApplicationHealthInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the information about health of an application deployed on a Service Fabric node. using the specified policy.
     * Gets the information about health of an application deployed on a Service Fabric node using the specified policy. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed application based on health state. Use DeployedServicePackagesHealthStateFilter to optionally filter for DeployedServicePackageHealth children based on health state. Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the deployed application.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the DeployedApplicationHealthInner object if successful.
     */
    public DeployedApplicationHealthInner getDeployedApplicationHealthUsingPolicy(String nodeName, String applicationId) {
        return getDeployedApplicationHealthUsingPolicyWithServiceResponseAsync(nodeName, applicationId).toBlocking().single().body();
    }

    /**
     * Gets the information about health of an application deployed on a Service Fabric node. using the specified policy.
     * Gets the information about health of an application deployed on a Service Fabric node using the specified policy. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed application based on health state. Use DeployedServicePackagesHealthStateFilter to optionally filter for DeployedServicePackageHealth children based on health state. Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the deployed application.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<DeployedApplicationHealthInner> getDeployedApplicationHealthUsingPolicyAsync(String nodeName, String applicationId, final ServiceCallback<DeployedApplicationHealthInner> serviceCallback) {
        return ServiceFuture.fromResponse(getDeployedApplicationHealthUsingPolicyWithServiceResponseAsync(nodeName, applicationId), serviceCallback);
    }

    /**
     * Gets the information about health of an application deployed on a Service Fabric node. using the specified policy.
     * Gets the information about health of an application deployed on a Service Fabric node using the specified policy. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed application based on health state. Use DeployedServicePackagesHealthStateFilter to optionally filter for DeployedServicePackageHealth children based on health state. Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the deployed application.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeployedApplicationHealthInner object
     */
    public Observable<DeployedApplicationHealthInner> getDeployedApplicationHealthUsingPolicyAsync(String nodeName, String applicationId) {
        return getDeployedApplicationHealthUsingPolicyWithServiceResponseAsync(nodeName, applicationId).map(new Func1<ServiceResponse<DeployedApplicationHealthInner>, DeployedApplicationHealthInner>() {
            @Override
            public DeployedApplicationHealthInner call(ServiceResponse<DeployedApplicationHealthInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the information about health of an application deployed on a Service Fabric node. using the specified policy.
     * Gets the information about health of an application deployed on a Service Fabric node using the specified policy. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed application based on health state. Use DeployedServicePackagesHealthStateFilter to optionally filter for DeployedServicePackageHealth children based on health state. Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the deployed application.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeployedApplicationHealthInner object
     */
    public Observable<ServiceResponse<DeployedApplicationHealthInner>> getDeployedApplicationHealthUsingPolicyWithServiceResponseAsync(String nodeName, String applicationId) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Integer eventsHealthStateFilter = null;
        final Integer deployedServicePackagesHealthStateFilter = null;
        final ApplicationHealthPolicy applicationHealthPolicy = null;
        final Boolean excludeHealthStatistics = null;
        final Long timeout = null;
        return service.getDeployedApplicationHealthUsingPolicy(nodeName, applicationId, apiVersion, eventsHealthStateFilter, deployedServicePackagesHealthStateFilter, applicationHealthPolicy, excludeHealthStatistics, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeployedApplicationHealthInner>>>() {
                @Override
                public Observable<ServiceResponse<DeployedApplicationHealthInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeployedApplicationHealthInner> clientResponse = getDeployedApplicationHealthUsingPolicyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the information about health of an application deployed on a Service Fabric node. using the specified policy.
     * Gets the information about health of an application deployed on a Service Fabric node using the specified policy. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed application based on health state. Use DeployedServicePackagesHealthStateFilter to optionally filter for DeployedServicePackageHealth children based on health state. Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the deployed application.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param deployedServicePackagesHealthStateFilter Allows filtering of the deployed service package health state objects returned in the result of deployed application health query based on their health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only deployed service packages that match the filter are returned. All deployed service packages are used to evaluate the aggregated health state of the deployed application.
     If not specified, all entries are returned.
     The state values are flag-based enumeration, so the value can be a combination of these values, obtained using the bitwise 'OR' operator.
     For example, if the provided value is 6 then health state of service packages with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param applicationHealthPolicy Describes the health policies used to evaluate the health of an application or one of its children.
     If not present, the health evaluation uses the health policy from application manifest or the default health policy.
     * @param excludeHealthStatistics Indicates whether the health statistics should be returned as part of the query result. False by default.
     The statistics show the number of children entities in health state Ok, Warning, and Error.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the DeployedApplicationHealthInner object if successful.
     */
    public DeployedApplicationHealthInner getDeployedApplicationHealthUsingPolicy(String nodeName, String applicationId, Integer eventsHealthStateFilter, Integer deployedServicePackagesHealthStateFilter, ApplicationHealthPolicy applicationHealthPolicy, Boolean excludeHealthStatistics, Long timeout) {
        return getDeployedApplicationHealthUsingPolicyWithServiceResponseAsync(nodeName, applicationId, eventsHealthStateFilter, deployedServicePackagesHealthStateFilter, applicationHealthPolicy, excludeHealthStatistics, timeout).toBlocking().single().body();
    }

    /**
     * Gets the information about health of an application deployed on a Service Fabric node. using the specified policy.
     * Gets the information about health of an application deployed on a Service Fabric node using the specified policy. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed application based on health state. Use DeployedServicePackagesHealthStateFilter to optionally filter for DeployedServicePackageHealth children based on health state. Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the deployed application.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param deployedServicePackagesHealthStateFilter Allows filtering of the deployed service package health state objects returned in the result of deployed application health query based on their health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only deployed service packages that match the filter are returned. All deployed service packages are used to evaluate the aggregated health state of the deployed application.
     If not specified, all entries are returned.
     The state values are flag-based enumeration, so the value can be a combination of these values, obtained using the bitwise 'OR' operator.
     For example, if the provided value is 6 then health state of service packages with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param applicationHealthPolicy Describes the health policies used to evaluate the health of an application or one of its children.
     If not present, the health evaluation uses the health policy from application manifest or the default health policy.
     * @param excludeHealthStatistics Indicates whether the health statistics should be returned as part of the query result. False by default.
     The statistics show the number of children entities in health state Ok, Warning, and Error.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<DeployedApplicationHealthInner> getDeployedApplicationHealthUsingPolicyAsync(String nodeName, String applicationId, Integer eventsHealthStateFilter, Integer deployedServicePackagesHealthStateFilter, ApplicationHealthPolicy applicationHealthPolicy, Boolean excludeHealthStatistics, Long timeout, final ServiceCallback<DeployedApplicationHealthInner> serviceCallback) {
        return ServiceFuture.fromResponse(getDeployedApplicationHealthUsingPolicyWithServiceResponseAsync(nodeName, applicationId, eventsHealthStateFilter, deployedServicePackagesHealthStateFilter, applicationHealthPolicy, excludeHealthStatistics, timeout), serviceCallback);
    }

    /**
     * Gets the information about health of an application deployed on a Service Fabric node. using the specified policy.
     * Gets the information about health of an application deployed on a Service Fabric node using the specified policy. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed application based on health state. Use DeployedServicePackagesHealthStateFilter to optionally filter for DeployedServicePackageHealth children based on health state. Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the deployed application.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param deployedServicePackagesHealthStateFilter Allows filtering of the deployed service package health state objects returned in the result of deployed application health query based on their health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only deployed service packages that match the filter are returned. All deployed service packages are used to evaluate the aggregated health state of the deployed application.
     If not specified, all entries are returned.
     The state values are flag-based enumeration, so the value can be a combination of these values, obtained using the bitwise 'OR' operator.
     For example, if the provided value is 6 then health state of service packages with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param applicationHealthPolicy Describes the health policies used to evaluate the health of an application or one of its children.
     If not present, the health evaluation uses the health policy from application manifest or the default health policy.
     * @param excludeHealthStatistics Indicates whether the health statistics should be returned as part of the query result. False by default.
     The statistics show the number of children entities in health state Ok, Warning, and Error.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeployedApplicationHealthInner object
     */
    public Observable<DeployedApplicationHealthInner> getDeployedApplicationHealthUsingPolicyAsync(String nodeName, String applicationId, Integer eventsHealthStateFilter, Integer deployedServicePackagesHealthStateFilter, ApplicationHealthPolicy applicationHealthPolicy, Boolean excludeHealthStatistics, Long timeout) {
        return getDeployedApplicationHealthUsingPolicyWithServiceResponseAsync(nodeName, applicationId, eventsHealthStateFilter, deployedServicePackagesHealthStateFilter, applicationHealthPolicy, excludeHealthStatistics, timeout).map(new Func1<ServiceResponse<DeployedApplicationHealthInner>, DeployedApplicationHealthInner>() {
            @Override
            public DeployedApplicationHealthInner call(ServiceResponse<DeployedApplicationHealthInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the information about health of an application deployed on a Service Fabric node. using the specified policy.
     * Gets the information about health of an application deployed on a Service Fabric node using the specified policy. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed application based on health state. Use DeployedServicePackagesHealthStateFilter to optionally filter for DeployedServicePackageHealth children based on health state. Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the deployed application.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param deployedServicePackagesHealthStateFilter Allows filtering of the deployed service package health state objects returned in the result of deployed application health query based on their health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only deployed service packages that match the filter are returned. All deployed service packages are used to evaluate the aggregated health state of the deployed application.
     If not specified, all entries are returned.
     The state values are flag-based enumeration, so the value can be a combination of these values, obtained using the bitwise 'OR' operator.
     For example, if the provided value is 6 then health state of service packages with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param applicationHealthPolicy Describes the health policies used to evaluate the health of an application or one of its children.
     If not present, the health evaluation uses the health policy from application manifest or the default health policy.
     * @param excludeHealthStatistics Indicates whether the health statistics should be returned as part of the query result. False by default.
     The statistics show the number of children entities in health state Ok, Warning, and Error.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeployedApplicationHealthInner object
     */
    public Observable<ServiceResponse<DeployedApplicationHealthInner>> getDeployedApplicationHealthUsingPolicyWithServiceResponseAsync(String nodeName, String applicationId, Integer eventsHealthStateFilter, Integer deployedServicePackagesHealthStateFilter, ApplicationHealthPolicy applicationHealthPolicy, Boolean excludeHealthStatistics, Long timeout) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        Validator.validate(applicationHealthPolicy);
        final String apiVersion = "6.0";
        return service.getDeployedApplicationHealthUsingPolicy(nodeName, applicationId, apiVersion, eventsHealthStateFilter, deployedServicePackagesHealthStateFilter, applicationHealthPolicy, excludeHealthStatistics, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeployedApplicationHealthInner>>>() {
                @Override
                public Observable<ServiceResponse<DeployedApplicationHealthInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeployedApplicationHealthInner> clientResponse = getDeployedApplicationHealthUsingPolicyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DeployedApplicationHealthInner> getDeployedApplicationHealthUsingPolicyDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<DeployedApplicationHealthInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<DeployedApplicationHealthInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Sends a health report on the Service Fabric application deployed on a Service Fabric node.
     * Reports health state of the application deployed on a Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway Service, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, get deployed application health and check that the report appears in the HealthEvents section.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void reportDeployedApplicationHealth(String nodeName, String applicationId, HealthInformation healthInformation) {
        reportDeployedApplicationHealthWithServiceResponseAsync(nodeName, applicationId, healthInformation).toBlocking().single().body();
    }

    /**
     * Sends a health report on the Service Fabric application deployed on a Service Fabric node.
     * Reports health state of the application deployed on a Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway Service, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, get deployed application health and check that the report appears in the HealthEvents section.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> reportDeployedApplicationHealthAsync(String nodeName, String applicationId, HealthInformation healthInformation, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(reportDeployedApplicationHealthWithServiceResponseAsync(nodeName, applicationId, healthInformation), serviceCallback);
    }

    /**
     * Sends a health report on the Service Fabric application deployed on a Service Fabric node.
     * Reports health state of the application deployed on a Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway Service, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, get deployed application health and check that the report appears in the HealthEvents section.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> reportDeployedApplicationHealthAsync(String nodeName, String applicationId, HealthInformation healthInformation) {
        return reportDeployedApplicationHealthWithServiceResponseAsync(nodeName, applicationId, healthInformation).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Sends a health report on the Service Fabric application deployed on a Service Fabric node.
     * Reports health state of the application deployed on a Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway Service, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, get deployed application health and check that the report appears in the HealthEvents section.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> reportDeployedApplicationHealthWithServiceResponseAsync(String nodeName, String applicationId, HealthInformation healthInformation) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        if (healthInformation == null) {
            throw new IllegalArgumentException("Parameter healthInformation is required and cannot be null.");
        }
        Validator.validate(healthInformation);
        final String apiVersion = "6.0";
        final Boolean immediate = null;
        final Long timeout = null;
        return service.reportDeployedApplicationHealth(nodeName, applicationId, apiVersion, healthInformation, immediate, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = reportDeployedApplicationHealthDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Sends a health report on the Service Fabric application deployed on a Service Fabric node.
     * Reports health state of the application deployed on a Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway Service, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, get deployed application health and check that the report appears in the HealthEvents section.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @param immediate A flag that indicates whether the report should be sent immediately.
     A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
     If Immediate is set to true, the report is sent immediately from HTTP Gateway to the health store, regardless of the fabric client settings that the HTTP Gateway Application is using.
     This is useful for critical reports that should be sent as soon as possible.
     Depending on timing and other conditions, sending the report may still fail, for example if the HTTP Gateway is closed or the message doesn't reach the Gateway.
     If Immediate is set to false, the report is sent based on the health client settings from the HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
     This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
     By default, reports are not sent immediately.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void reportDeployedApplicationHealth(String nodeName, String applicationId, HealthInformation healthInformation, Boolean immediate, Long timeout) {
        reportDeployedApplicationHealthWithServiceResponseAsync(nodeName, applicationId, healthInformation, immediate, timeout).toBlocking().single().body();
    }

    /**
     * Sends a health report on the Service Fabric application deployed on a Service Fabric node.
     * Reports health state of the application deployed on a Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway Service, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, get deployed application health and check that the report appears in the HealthEvents section.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @param immediate A flag that indicates whether the report should be sent immediately.
     A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
     If Immediate is set to true, the report is sent immediately from HTTP Gateway to the health store, regardless of the fabric client settings that the HTTP Gateway Application is using.
     This is useful for critical reports that should be sent as soon as possible.
     Depending on timing and other conditions, sending the report may still fail, for example if the HTTP Gateway is closed or the message doesn't reach the Gateway.
     If Immediate is set to false, the report is sent based on the health client settings from the HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
     This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
     By default, reports are not sent immediately.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> reportDeployedApplicationHealthAsync(String nodeName, String applicationId, HealthInformation healthInformation, Boolean immediate, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(reportDeployedApplicationHealthWithServiceResponseAsync(nodeName, applicationId, healthInformation, immediate, timeout), serviceCallback);
    }

    /**
     * Sends a health report on the Service Fabric application deployed on a Service Fabric node.
     * Reports health state of the application deployed on a Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway Service, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, get deployed application health and check that the report appears in the HealthEvents section.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @param immediate A flag that indicates whether the report should be sent immediately.
     A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
     If Immediate is set to true, the report is sent immediately from HTTP Gateway to the health store, regardless of the fabric client settings that the HTTP Gateway Application is using.
     This is useful for critical reports that should be sent as soon as possible.
     Depending on timing and other conditions, sending the report may still fail, for example if the HTTP Gateway is closed or the message doesn't reach the Gateway.
     If Immediate is set to false, the report is sent based on the health client settings from the HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
     This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
     By default, reports are not sent immediately.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> reportDeployedApplicationHealthAsync(String nodeName, String applicationId, HealthInformation healthInformation, Boolean immediate, Long timeout) {
        return reportDeployedApplicationHealthWithServiceResponseAsync(nodeName, applicationId, healthInformation, immediate, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Sends a health report on the Service Fabric application deployed on a Service Fabric node.
     * Reports health state of the application deployed on a Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway Service, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, get deployed application health and check that the report appears in the HealthEvents section.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @param immediate A flag that indicates whether the report should be sent immediately.
     A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
     If Immediate is set to true, the report is sent immediately from HTTP Gateway to the health store, regardless of the fabric client settings that the HTTP Gateway Application is using.
     This is useful for critical reports that should be sent as soon as possible.
     Depending on timing and other conditions, sending the report may still fail, for example if the HTTP Gateway is closed or the message doesn't reach the Gateway.
     If Immediate is set to false, the report is sent based on the health client settings from the HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
     This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
     By default, reports are not sent immediately.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> reportDeployedApplicationHealthWithServiceResponseAsync(String nodeName, String applicationId, HealthInformation healthInformation, Boolean immediate, Long timeout) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        if (healthInformation == null) {
            throw new IllegalArgumentException("Parameter healthInformation is required and cannot be null.");
        }
        Validator.validate(healthInformation);
        final String apiVersion = "6.0";
        return service.reportDeployedApplicationHealth(nodeName, applicationId, apiVersion, healthInformation, immediate, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = reportDeployedApplicationHealthDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> reportDeployedApplicationHealthDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the manifest describing an application type.
     * The response contains the application manifest XML as a string.
     *
     * @param applicationTypeName The name of the application type.
     * @param applicationTypeVersion The version of the application type.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ApplicationTypeManifestInner object if successful.
     */
    public ApplicationTypeManifestInner getApplicationManifest(String applicationTypeName, String applicationTypeVersion) {
        return getApplicationManifestWithServiceResponseAsync(applicationTypeName, applicationTypeVersion).toBlocking().single().body();
    }

    /**
     * Gets the manifest describing an application type.
     * The response contains the application manifest XML as a string.
     *
     * @param applicationTypeName The name of the application type.
     * @param applicationTypeVersion The version of the application type.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ApplicationTypeManifestInner> getApplicationManifestAsync(String applicationTypeName, String applicationTypeVersion, final ServiceCallback<ApplicationTypeManifestInner> serviceCallback) {
        return ServiceFuture.fromResponse(getApplicationManifestWithServiceResponseAsync(applicationTypeName, applicationTypeVersion), serviceCallback);
    }

    /**
     * Gets the manifest describing an application type.
     * The response contains the application manifest XML as a string.
     *
     * @param applicationTypeName The name of the application type.
     * @param applicationTypeVersion The version of the application type.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationTypeManifestInner object
     */
    public Observable<ApplicationTypeManifestInner> getApplicationManifestAsync(String applicationTypeName, String applicationTypeVersion) {
        return getApplicationManifestWithServiceResponseAsync(applicationTypeName, applicationTypeVersion).map(new Func1<ServiceResponse<ApplicationTypeManifestInner>, ApplicationTypeManifestInner>() {
            @Override
            public ApplicationTypeManifestInner call(ServiceResponse<ApplicationTypeManifestInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the manifest describing an application type.
     * The response contains the application manifest XML as a string.
     *
     * @param applicationTypeName The name of the application type.
     * @param applicationTypeVersion The version of the application type.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationTypeManifestInner object
     */
    public Observable<ServiceResponse<ApplicationTypeManifestInner>> getApplicationManifestWithServiceResponseAsync(String applicationTypeName, String applicationTypeVersion) {
        if (applicationTypeName == null) {
            throw new IllegalArgumentException("Parameter applicationTypeName is required and cannot be null.");
        }
        if (applicationTypeVersion == null) {
            throw new IllegalArgumentException("Parameter applicationTypeVersion is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.getApplicationManifest(applicationTypeName, apiVersion, applicationTypeVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ApplicationTypeManifestInner>>>() {
                @Override
                public Observable<ServiceResponse<ApplicationTypeManifestInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ApplicationTypeManifestInner> clientResponse = getApplicationManifestDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the manifest describing an application type.
     * The response contains the application manifest XML as a string.
     *
     * @param applicationTypeName The name of the application type.
     * @param applicationTypeVersion The version of the application type.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ApplicationTypeManifestInner object if successful.
     */
    public ApplicationTypeManifestInner getApplicationManifest(String applicationTypeName, String applicationTypeVersion, Long timeout) {
        return getApplicationManifestWithServiceResponseAsync(applicationTypeName, applicationTypeVersion, timeout).toBlocking().single().body();
    }

    /**
     * Gets the manifest describing an application type.
     * The response contains the application manifest XML as a string.
     *
     * @param applicationTypeName The name of the application type.
     * @param applicationTypeVersion The version of the application type.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ApplicationTypeManifestInner> getApplicationManifestAsync(String applicationTypeName, String applicationTypeVersion, Long timeout, final ServiceCallback<ApplicationTypeManifestInner> serviceCallback) {
        return ServiceFuture.fromResponse(getApplicationManifestWithServiceResponseAsync(applicationTypeName, applicationTypeVersion, timeout), serviceCallback);
    }

    /**
     * Gets the manifest describing an application type.
     * The response contains the application manifest XML as a string.
     *
     * @param applicationTypeName The name of the application type.
     * @param applicationTypeVersion The version of the application type.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationTypeManifestInner object
     */
    public Observable<ApplicationTypeManifestInner> getApplicationManifestAsync(String applicationTypeName, String applicationTypeVersion, Long timeout) {
        return getApplicationManifestWithServiceResponseAsync(applicationTypeName, applicationTypeVersion, timeout).map(new Func1<ServiceResponse<ApplicationTypeManifestInner>, ApplicationTypeManifestInner>() {
            @Override
            public ApplicationTypeManifestInner call(ServiceResponse<ApplicationTypeManifestInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the manifest describing an application type.
     * The response contains the application manifest XML as a string.
     *
     * @param applicationTypeName The name of the application type.
     * @param applicationTypeVersion The version of the application type.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationTypeManifestInner object
     */
    public Observable<ServiceResponse<ApplicationTypeManifestInner>> getApplicationManifestWithServiceResponseAsync(String applicationTypeName, String applicationTypeVersion, Long timeout) {
        if (applicationTypeName == null) {
            throw new IllegalArgumentException("Parameter applicationTypeName is required and cannot be null.");
        }
        if (applicationTypeVersion == null) {
            throw new IllegalArgumentException("Parameter applicationTypeVersion is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.getApplicationManifest(applicationTypeName, apiVersion, applicationTypeVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ApplicationTypeManifestInner>>>() {
                @Override
                public Observable<ServiceResponse<ApplicationTypeManifestInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ApplicationTypeManifestInner> clientResponse = getApplicationManifestDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ApplicationTypeManifestInner> getApplicationManifestDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ApplicationTypeManifestInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ApplicationTypeManifestInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the information about all services belonging to the application specified by the application ID.
     * Returns the information about all services belonging to the application specified by the application ID.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedServiceInfoListInner object if successful.
     */
    public PagedServiceInfoListInner getServiceInfoList(String applicationId) {
        return getServiceInfoListWithServiceResponseAsync(applicationId).toBlocking().single().body();
    }

    /**
     * Gets the information about all services belonging to the application specified by the application ID.
     * Returns the information about all services belonging to the application specified by the application ID.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedServiceInfoListInner> getServiceInfoListAsync(String applicationId, final ServiceCallback<PagedServiceInfoListInner> serviceCallback) {
        return ServiceFuture.fromResponse(getServiceInfoListWithServiceResponseAsync(applicationId), serviceCallback);
    }

    /**
     * Gets the information about all services belonging to the application specified by the application ID.
     * Returns the information about all services belonging to the application specified by the application ID.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedServiceInfoListInner object
     */
    public Observable<PagedServiceInfoListInner> getServiceInfoListAsync(String applicationId) {
        return getServiceInfoListWithServiceResponseAsync(applicationId).map(new Func1<ServiceResponse<PagedServiceInfoListInner>, PagedServiceInfoListInner>() {
            @Override
            public PagedServiceInfoListInner call(ServiceResponse<PagedServiceInfoListInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the information about all services belonging to the application specified by the application ID.
     * Returns the information about all services belonging to the application specified by the application ID.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedServiceInfoListInner object
     */
    public Observable<ServiceResponse<PagedServiceInfoListInner>> getServiceInfoListWithServiceResponseAsync(String applicationId) {
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final String serviceTypeName = null;
        final String continuationToken = null;
        final Long timeout = null;
        return service.getServiceInfoList(applicationId, serviceTypeName, apiVersion, continuationToken, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedServiceInfoListInner>>>() {
                @Override
                public Observable<ServiceResponse<PagedServiceInfoListInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedServiceInfoListInner> clientResponse = getServiceInfoListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the information about all services belonging to the application specified by the application ID.
     * Returns the information about all services belonging to the application specified by the application ID.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceTypeName The service type name used to filter the services to query for.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedServiceInfoListInner object if successful.
     */
    public PagedServiceInfoListInner getServiceInfoList(String applicationId, String serviceTypeName, String continuationToken, Long timeout) {
        return getServiceInfoListWithServiceResponseAsync(applicationId, serviceTypeName, continuationToken, timeout).toBlocking().single().body();
    }

    /**
     * Gets the information about all services belonging to the application specified by the application ID.
     * Returns the information about all services belonging to the application specified by the application ID.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceTypeName The service type name used to filter the services to query for.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedServiceInfoListInner> getServiceInfoListAsync(String applicationId, String serviceTypeName, String continuationToken, Long timeout, final ServiceCallback<PagedServiceInfoListInner> serviceCallback) {
        return ServiceFuture.fromResponse(getServiceInfoListWithServiceResponseAsync(applicationId, serviceTypeName, continuationToken, timeout), serviceCallback);
    }

    /**
     * Gets the information about all services belonging to the application specified by the application ID.
     * Returns the information about all services belonging to the application specified by the application ID.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceTypeName The service type name used to filter the services to query for.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedServiceInfoListInner object
     */
    public Observable<PagedServiceInfoListInner> getServiceInfoListAsync(String applicationId, String serviceTypeName, String continuationToken, Long timeout) {
        return getServiceInfoListWithServiceResponseAsync(applicationId, serviceTypeName, continuationToken, timeout).map(new Func1<ServiceResponse<PagedServiceInfoListInner>, PagedServiceInfoListInner>() {
            @Override
            public PagedServiceInfoListInner call(ServiceResponse<PagedServiceInfoListInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the information about all services belonging to the application specified by the application ID.
     * Returns the information about all services belonging to the application specified by the application ID.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceTypeName The service type name used to filter the services to query for.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedServiceInfoListInner object
     */
    public Observable<ServiceResponse<PagedServiceInfoListInner>> getServiceInfoListWithServiceResponseAsync(String applicationId, String serviceTypeName, String continuationToken, Long timeout) {
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.getServiceInfoList(applicationId, serviceTypeName, apiVersion, continuationToken, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedServiceInfoListInner>>>() {
                @Override
                public Observable<ServiceResponse<PagedServiceInfoListInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedServiceInfoListInner> clientResponse = getServiceInfoListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PagedServiceInfoListInner> getServiceInfoListDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<PagedServiceInfoListInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PagedServiceInfoListInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the information about the specific service belonging to the Service Fabric application.
     * Returns the information about the specified service belonging to the specified Service Fabric application.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ServiceInfoInner object if successful.
     */
    public ServiceInfoInner getServiceInfo(String applicationId, String serviceId) {
        return getServiceInfoWithServiceResponseAsync(applicationId, serviceId).toBlocking().single().body();
    }

    /**
     * Gets the information about the specific service belonging to the Service Fabric application.
     * Returns the information about the specified service belonging to the specified Service Fabric application.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ServiceInfoInner> getServiceInfoAsync(String applicationId, String serviceId, final ServiceCallback<ServiceInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getServiceInfoWithServiceResponseAsync(applicationId, serviceId), serviceCallback);
    }

    /**
     * Gets the information about the specific service belonging to the Service Fabric application.
     * Returns the information about the specified service belonging to the specified Service Fabric application.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServiceInfoInner object
     */
    public Observable<ServiceInfoInner> getServiceInfoAsync(String applicationId, String serviceId) {
        return getServiceInfoWithServiceResponseAsync(applicationId, serviceId).map(new Func1<ServiceResponse<ServiceInfoInner>, ServiceInfoInner>() {
            @Override
            public ServiceInfoInner call(ServiceResponse<ServiceInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the information about the specific service belonging to the Service Fabric application.
     * Returns the information about the specified service belonging to the specified Service Fabric application.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServiceInfoInner object
     */
    public Observable<ServiceResponse<ServiceInfoInner>> getServiceInfoWithServiceResponseAsync(String applicationId, String serviceId) {
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        if (serviceId == null) {
            throw new IllegalArgumentException("Parameter serviceId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.getServiceInfo(applicationId, serviceId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ServiceInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<ServiceInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ServiceInfoInner> clientResponse = getServiceInfoDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the information about the specific service belonging to the Service Fabric application.
     * Returns the information about the specified service belonging to the specified Service Fabric application.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ServiceInfoInner object if successful.
     */
    public ServiceInfoInner getServiceInfo(String applicationId, String serviceId, Long timeout) {
        return getServiceInfoWithServiceResponseAsync(applicationId, serviceId, timeout).toBlocking().single().body();
    }

    /**
     * Gets the information about the specific service belonging to the Service Fabric application.
     * Returns the information about the specified service belonging to the specified Service Fabric application.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ServiceInfoInner> getServiceInfoAsync(String applicationId, String serviceId, Long timeout, final ServiceCallback<ServiceInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getServiceInfoWithServiceResponseAsync(applicationId, serviceId, timeout), serviceCallback);
    }

    /**
     * Gets the information about the specific service belonging to the Service Fabric application.
     * Returns the information about the specified service belonging to the specified Service Fabric application.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServiceInfoInner object
     */
    public Observable<ServiceInfoInner> getServiceInfoAsync(String applicationId, String serviceId, Long timeout) {
        return getServiceInfoWithServiceResponseAsync(applicationId, serviceId, timeout).map(new Func1<ServiceResponse<ServiceInfoInner>, ServiceInfoInner>() {
            @Override
            public ServiceInfoInner call(ServiceResponse<ServiceInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the information about the specific service belonging to the Service Fabric application.
     * Returns the information about the specified service belonging to the specified Service Fabric application.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServiceInfoInner object
     */
    public Observable<ServiceResponse<ServiceInfoInner>> getServiceInfoWithServiceResponseAsync(String applicationId, String serviceId, Long timeout) {
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        if (serviceId == null) {
            throw new IllegalArgumentException("Parameter serviceId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.getServiceInfo(applicationId, serviceId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ServiceInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<ServiceInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ServiceInfoInner> clientResponse = getServiceInfoDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ServiceInfoInner> getServiceInfoDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ServiceInfoInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ServiceInfoInner>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the name of the Service Fabric application for a service.
     * Gets the name of the application for the specified service. A 404 FABRIC_E_SERVICE_DOES_NOT_EXIST error is returned if a service with the provided service ID does not exist.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ApplicationNameInfoInner object if successful.
     */
    public ApplicationNameInfoInner getApplicationNameInfo(String serviceId) {
        return getApplicationNameInfoWithServiceResponseAsync(serviceId).toBlocking().single().body();
    }

    /**
     * Gets the name of the Service Fabric application for a service.
     * Gets the name of the application for the specified service. A 404 FABRIC_E_SERVICE_DOES_NOT_EXIST error is returned if a service with the provided service ID does not exist.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ApplicationNameInfoInner> getApplicationNameInfoAsync(String serviceId, final ServiceCallback<ApplicationNameInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getApplicationNameInfoWithServiceResponseAsync(serviceId), serviceCallback);
    }

    /**
     * Gets the name of the Service Fabric application for a service.
     * Gets the name of the application for the specified service. A 404 FABRIC_E_SERVICE_DOES_NOT_EXIST error is returned if a service with the provided service ID does not exist.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationNameInfoInner object
     */
    public Observable<ApplicationNameInfoInner> getApplicationNameInfoAsync(String serviceId) {
        return getApplicationNameInfoWithServiceResponseAsync(serviceId).map(new Func1<ServiceResponse<ApplicationNameInfoInner>, ApplicationNameInfoInner>() {
            @Override
            public ApplicationNameInfoInner call(ServiceResponse<ApplicationNameInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the name of the Service Fabric application for a service.
     * Gets the name of the application for the specified service. A 404 FABRIC_E_SERVICE_DOES_NOT_EXIST error is returned if a service with the provided service ID does not exist.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationNameInfoInner object
     */
    public Observable<ServiceResponse<ApplicationNameInfoInner>> getApplicationNameInfoWithServiceResponseAsync(String serviceId) {
        if (serviceId == null) {
            throw new IllegalArgumentException("Parameter serviceId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.getApplicationNameInfo(serviceId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ApplicationNameInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<ApplicationNameInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ApplicationNameInfoInner> clientResponse = getApplicationNameInfoDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the name of the Service Fabric application for a service.
     * Gets the name of the application for the specified service. A 404 FABRIC_E_SERVICE_DOES_NOT_EXIST error is returned if a service with the provided service ID does not exist.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ApplicationNameInfoInner object if successful.
     */
    public ApplicationNameInfoInner getApplicationNameInfo(String serviceId, Long timeout) {
        return getApplicationNameInfoWithServiceResponseAsync(serviceId, timeout).toBlocking().single().body();
    }

    /**
     * Gets the name of the Service Fabric application for a service.
     * Gets the name of the application for the specified service. A 404 FABRIC_E_SERVICE_DOES_NOT_EXIST error is returned if a service with the provided service ID does not exist.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ApplicationNameInfoInner> getApplicationNameInfoAsync(String serviceId, Long timeout, final ServiceCallback<ApplicationNameInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getApplicationNameInfoWithServiceResponseAsync(serviceId, timeout), serviceCallback);
    }

    /**
     * Gets the name of the Service Fabric application for a service.
     * Gets the name of the application for the specified service. A 404 FABRIC_E_SERVICE_DOES_NOT_EXIST error is returned if a service with the provided service ID does not exist.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationNameInfoInner object
     */
    public Observable<ApplicationNameInfoInner> getApplicationNameInfoAsync(String serviceId, Long timeout) {
        return getApplicationNameInfoWithServiceResponseAsync(serviceId, timeout).map(new Func1<ServiceResponse<ApplicationNameInfoInner>, ApplicationNameInfoInner>() {
            @Override
            public ApplicationNameInfoInner call(ServiceResponse<ApplicationNameInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the name of the Service Fabric application for a service.
     * Gets the name of the application for the specified service. A 404 FABRIC_E_SERVICE_DOES_NOT_EXIST error is returned if a service with the provided service ID does not exist.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationNameInfoInner object
     */
    public Observable<ServiceResponse<ApplicationNameInfoInner>> getApplicationNameInfoWithServiceResponseAsync(String serviceId, Long timeout) {
        if (serviceId == null) {
            throw new IllegalArgumentException("Parameter serviceId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.getApplicationNameInfo(serviceId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ApplicationNameInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<ApplicationNameInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ApplicationNameInfoInner> clientResponse = getApplicationNameInfoDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ApplicationNameInfoInner> getApplicationNameInfoDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ApplicationNameInfoInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ApplicationNameInfoInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Creates the specified Service Fabric service.
     * This api allows creating a new Service Fabric stateless or stateful service under a specified Service Fabric application. The description for creating the service includes partitioning information and optional properties for placement and load balancing. Some of the properties can later be modified using `UpdateService` API.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceDescription The information necessary to create a service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void createService(String applicationId, ServiceDescriptionInner serviceDescription) {
        createServiceWithServiceResponseAsync(applicationId, serviceDescription).toBlocking().single().body();
    }

    /**
     * Creates the specified Service Fabric service.
     * This api allows creating a new Service Fabric stateless or stateful service under a specified Service Fabric application. The description for creating the service includes partitioning information and optional properties for placement and load balancing. Some of the properties can later be modified using `UpdateService` API.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceDescription The information necessary to create a service.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> createServiceAsync(String applicationId, ServiceDescriptionInner serviceDescription, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(createServiceWithServiceResponseAsync(applicationId, serviceDescription), serviceCallback);
    }

    /**
     * Creates the specified Service Fabric service.
     * This api allows creating a new Service Fabric stateless or stateful service under a specified Service Fabric application. The description for creating the service includes partitioning information and optional properties for placement and load balancing. Some of the properties can later be modified using `UpdateService` API.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceDescription The information necessary to create a service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> createServiceAsync(String applicationId, ServiceDescriptionInner serviceDescription) {
        return createServiceWithServiceResponseAsync(applicationId, serviceDescription).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates the specified Service Fabric service.
     * This api allows creating a new Service Fabric stateless or stateful service under a specified Service Fabric application. The description for creating the service includes partitioning information and optional properties for placement and load balancing. Some of the properties can later be modified using `UpdateService` API.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceDescription The information necessary to create a service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> createServiceWithServiceResponseAsync(String applicationId, ServiceDescriptionInner serviceDescription) {
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        if (serviceDescription == null) {
            throw new IllegalArgumentException("Parameter serviceDescription is required and cannot be null.");
        }
        Validator.validate(serviceDescription);
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.createService(applicationId, apiVersion, serviceDescription, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = createServiceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Creates the specified Service Fabric service.
     * This api allows creating a new Service Fabric stateless or stateful service under a specified Service Fabric application. The description for creating the service includes partitioning information and optional properties for placement and load balancing. Some of the properties can later be modified using `UpdateService` API.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceDescription The information necessary to create a service.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void createService(String applicationId, ServiceDescriptionInner serviceDescription, Long timeout) {
        createServiceWithServiceResponseAsync(applicationId, serviceDescription, timeout).toBlocking().single().body();
    }

    /**
     * Creates the specified Service Fabric service.
     * This api allows creating a new Service Fabric stateless or stateful service under a specified Service Fabric application. The description for creating the service includes partitioning information and optional properties for placement and load balancing. Some of the properties can later be modified using `UpdateService` API.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceDescription The information necessary to create a service.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> createServiceAsync(String applicationId, ServiceDescriptionInner serviceDescription, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(createServiceWithServiceResponseAsync(applicationId, serviceDescription, timeout), serviceCallback);
    }

    /**
     * Creates the specified Service Fabric service.
     * This api allows creating a new Service Fabric stateless or stateful service under a specified Service Fabric application. The description for creating the service includes partitioning information and optional properties for placement and load balancing. Some of the properties can later be modified using `UpdateService` API.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceDescription The information necessary to create a service.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> createServiceAsync(String applicationId, ServiceDescriptionInner serviceDescription, Long timeout) {
        return createServiceWithServiceResponseAsync(applicationId, serviceDescription, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates the specified Service Fabric service.
     * This api allows creating a new Service Fabric stateless or stateful service under a specified Service Fabric application. The description for creating the service includes partitioning information and optional properties for placement and load balancing. Some of the properties can later be modified using `UpdateService` API.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceDescription The information necessary to create a service.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> createServiceWithServiceResponseAsync(String applicationId, ServiceDescriptionInner serviceDescription, Long timeout) {
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        if (serviceDescription == null) {
            throw new IllegalArgumentException("Parameter serviceDescription is required and cannot be null.");
        }
        Validator.validate(serviceDescription);
        final String apiVersion = "6.0";
        return service.createService(applicationId, apiVersion, serviceDescription, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = createServiceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> createServiceDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Creates a Service Fabric service from the service template.
     * Creates a Service Fabric service from the service template defined in the application manifest. A service template contains the properties that will be same for the service instance of the same type. The API allows overriding the properties that are usually different for different services of the same service type.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceFromTemplateDescription Describes the service that needs to be created from the template defined in the application manifest.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void createServiceFromTemplate(String applicationId, ServiceFromTemplateDescription serviceFromTemplateDescription) {
        createServiceFromTemplateWithServiceResponseAsync(applicationId, serviceFromTemplateDescription).toBlocking().single().body();
    }

    /**
     * Creates a Service Fabric service from the service template.
     * Creates a Service Fabric service from the service template defined in the application manifest. A service template contains the properties that will be same for the service instance of the same type. The API allows overriding the properties that are usually different for different services of the same service type.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceFromTemplateDescription Describes the service that needs to be created from the template defined in the application manifest.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> createServiceFromTemplateAsync(String applicationId, ServiceFromTemplateDescription serviceFromTemplateDescription, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(createServiceFromTemplateWithServiceResponseAsync(applicationId, serviceFromTemplateDescription), serviceCallback);
    }

    /**
     * Creates a Service Fabric service from the service template.
     * Creates a Service Fabric service from the service template defined in the application manifest. A service template contains the properties that will be same for the service instance of the same type. The API allows overriding the properties that are usually different for different services of the same service type.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceFromTemplateDescription Describes the service that needs to be created from the template defined in the application manifest.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> createServiceFromTemplateAsync(String applicationId, ServiceFromTemplateDescription serviceFromTemplateDescription) {
        return createServiceFromTemplateWithServiceResponseAsync(applicationId, serviceFromTemplateDescription).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a Service Fabric service from the service template.
     * Creates a Service Fabric service from the service template defined in the application manifest. A service template contains the properties that will be same for the service instance of the same type. The API allows overriding the properties that are usually different for different services of the same service type.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceFromTemplateDescription Describes the service that needs to be created from the template defined in the application manifest.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> createServiceFromTemplateWithServiceResponseAsync(String applicationId, ServiceFromTemplateDescription serviceFromTemplateDescription) {
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        if (serviceFromTemplateDescription == null) {
            throw new IllegalArgumentException("Parameter serviceFromTemplateDescription is required and cannot be null.");
        }
        Validator.validate(serviceFromTemplateDescription);
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.createServiceFromTemplate(applicationId, apiVersion, serviceFromTemplateDescription, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = createServiceFromTemplateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Creates a Service Fabric service from the service template.
     * Creates a Service Fabric service from the service template defined in the application manifest. A service template contains the properties that will be same for the service instance of the same type. The API allows overriding the properties that are usually different for different services of the same service type.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceFromTemplateDescription Describes the service that needs to be created from the template defined in the application manifest.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void createServiceFromTemplate(String applicationId, ServiceFromTemplateDescription serviceFromTemplateDescription, Long timeout) {
        createServiceFromTemplateWithServiceResponseAsync(applicationId, serviceFromTemplateDescription, timeout).toBlocking().single().body();
    }

    /**
     * Creates a Service Fabric service from the service template.
     * Creates a Service Fabric service from the service template defined in the application manifest. A service template contains the properties that will be same for the service instance of the same type. The API allows overriding the properties that are usually different for different services of the same service type.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceFromTemplateDescription Describes the service that needs to be created from the template defined in the application manifest.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> createServiceFromTemplateAsync(String applicationId, ServiceFromTemplateDescription serviceFromTemplateDescription, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(createServiceFromTemplateWithServiceResponseAsync(applicationId, serviceFromTemplateDescription, timeout), serviceCallback);
    }

    /**
     * Creates a Service Fabric service from the service template.
     * Creates a Service Fabric service from the service template defined in the application manifest. A service template contains the properties that will be same for the service instance of the same type. The API allows overriding the properties that are usually different for different services of the same service type.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceFromTemplateDescription Describes the service that needs to be created from the template defined in the application manifest.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> createServiceFromTemplateAsync(String applicationId, ServiceFromTemplateDescription serviceFromTemplateDescription, Long timeout) {
        return createServiceFromTemplateWithServiceResponseAsync(applicationId, serviceFromTemplateDescription, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a Service Fabric service from the service template.
     * Creates a Service Fabric service from the service template defined in the application manifest. A service template contains the properties that will be same for the service instance of the same type. The API allows overriding the properties that are usually different for different services of the same service type.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceFromTemplateDescription Describes the service that needs to be created from the template defined in the application manifest.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> createServiceFromTemplateWithServiceResponseAsync(String applicationId, ServiceFromTemplateDescription serviceFromTemplateDescription, Long timeout) {
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        if (serviceFromTemplateDescription == null) {
            throw new IllegalArgumentException("Parameter serviceFromTemplateDescription is required and cannot be null.");
        }
        Validator.validate(serviceFromTemplateDescription);
        final String apiVersion = "6.0";
        return service.createServiceFromTemplate(applicationId, apiVersion, serviceFromTemplateDescription, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = createServiceFromTemplateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> createServiceFromTemplateDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Deletes an existing Service Fabric service.
     * A service must be created before it can be deleted. By default, Service Fabric will try to close service replicas in a graceful manner and then delete the service. However, if the service is having issues closing the replica gracefully, the delete operation may take a long time or get stuck. Use the optional ForceRemove flag to skip the graceful close sequence and forcefully delete the service.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteService(String serviceId) {
        deleteServiceWithServiceResponseAsync(serviceId).toBlocking().single().body();
    }

    /**
     * Deletes an existing Service Fabric service.
     * A service must be created before it can be deleted. By default, Service Fabric will try to close service replicas in a graceful manner and then delete the service. However, if the service is having issues closing the replica gracefully, the delete operation may take a long time or get stuck. Use the optional ForceRemove flag to skip the graceful close sequence and forcefully delete the service.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteServiceAsync(String serviceId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteServiceWithServiceResponseAsync(serviceId), serviceCallback);
    }

    /**
     * Deletes an existing Service Fabric service.
     * A service must be created before it can be deleted. By default, Service Fabric will try to close service replicas in a graceful manner and then delete the service. However, if the service is having issues closing the replica gracefully, the delete operation may take a long time or get stuck. Use the optional ForceRemove flag to skip the graceful close sequence and forcefully delete the service.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteServiceAsync(String serviceId) {
        return deleteServiceWithServiceResponseAsync(serviceId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes an existing Service Fabric service.
     * A service must be created before it can be deleted. By default, Service Fabric will try to close service replicas in a graceful manner and then delete the service. However, if the service is having issues closing the replica gracefully, the delete operation may take a long time or get stuck. Use the optional ForceRemove flag to skip the graceful close sequence and forcefully delete the service.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteServiceWithServiceResponseAsync(String serviceId) {
        if (serviceId == null) {
            throw new IllegalArgumentException("Parameter serviceId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Boolean forceRemove = null;
        final Long timeout = null;
        return service.deleteService(serviceId, apiVersion, forceRemove, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteServiceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Deletes an existing Service Fabric service.
     * A service must be created before it can be deleted. By default, Service Fabric will try to close service replicas in a graceful manner and then delete the service. However, if the service is having issues closing the replica gracefully, the delete operation may take a long time or get stuck. Use the optional ForceRemove flag to skip the graceful close sequence and forcefully delete the service.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param forceRemove Remove a Service Fabric application or service forcefully without going through the graceful shutdown sequence. This parameter can be used to forcefully delete an application or service for which delete is timing out due to issues in the service code that prevents graceful close of replicas.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteService(String serviceId, Boolean forceRemove, Long timeout) {
        deleteServiceWithServiceResponseAsync(serviceId, forceRemove, timeout).toBlocking().single().body();
    }

    /**
     * Deletes an existing Service Fabric service.
     * A service must be created before it can be deleted. By default, Service Fabric will try to close service replicas in a graceful manner and then delete the service. However, if the service is having issues closing the replica gracefully, the delete operation may take a long time or get stuck. Use the optional ForceRemove flag to skip the graceful close sequence and forcefully delete the service.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param forceRemove Remove a Service Fabric application or service forcefully without going through the graceful shutdown sequence. This parameter can be used to forcefully delete an application or service for which delete is timing out due to issues in the service code that prevents graceful close of replicas.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteServiceAsync(String serviceId, Boolean forceRemove, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteServiceWithServiceResponseAsync(serviceId, forceRemove, timeout), serviceCallback);
    }

    /**
     * Deletes an existing Service Fabric service.
     * A service must be created before it can be deleted. By default, Service Fabric will try to close service replicas in a graceful manner and then delete the service. However, if the service is having issues closing the replica gracefully, the delete operation may take a long time or get stuck. Use the optional ForceRemove flag to skip the graceful close sequence and forcefully delete the service.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param forceRemove Remove a Service Fabric application or service forcefully without going through the graceful shutdown sequence. This parameter can be used to forcefully delete an application or service for which delete is timing out due to issues in the service code that prevents graceful close of replicas.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteServiceAsync(String serviceId, Boolean forceRemove, Long timeout) {
        return deleteServiceWithServiceResponseAsync(serviceId, forceRemove, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes an existing Service Fabric service.
     * A service must be created before it can be deleted. By default, Service Fabric will try to close service replicas in a graceful manner and then delete the service. However, if the service is having issues closing the replica gracefully, the delete operation may take a long time or get stuck. Use the optional ForceRemove flag to skip the graceful close sequence and forcefully delete the service.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param forceRemove Remove a Service Fabric application or service forcefully without going through the graceful shutdown sequence. This parameter can be used to forcefully delete an application or service for which delete is timing out due to issues in the service code that prevents graceful close of replicas.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteServiceWithServiceResponseAsync(String serviceId, Boolean forceRemove, Long timeout) {
        if (serviceId == null) {
            throw new IllegalArgumentException("Parameter serviceId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.deleteService(serviceId, apiVersion, forceRemove, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteServiceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteServiceDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Updates a Service Fabric service using the specified update description.
     * This API allows updating properties of a running Service Fabric service. The set of properties that can be updated are a subset of the properties that were specified at the time of creating the service. The current set of properties can be obtained using `GetServiceDescription` API. Note that updating the properties of a running service is different than upgrading your application using `StartApplicationUpgrade` API. The upgrade is a long running background operation that involves moving the application from one version to another, one upgrade domain at a time, whereas update applies the new properties immediately to the service.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param serviceUpdateDescription The information necessary to update a service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void updateService(String serviceId, ServiceUpdateDescription serviceUpdateDescription) {
        updateServiceWithServiceResponseAsync(serviceId, serviceUpdateDescription).toBlocking().single().body();
    }

    /**
     * Updates a Service Fabric service using the specified update description.
     * This API allows updating properties of a running Service Fabric service. The set of properties that can be updated are a subset of the properties that were specified at the time of creating the service. The current set of properties can be obtained using `GetServiceDescription` API. Note that updating the properties of a running service is different than upgrading your application using `StartApplicationUpgrade` API. The upgrade is a long running background operation that involves moving the application from one version to another, one upgrade domain at a time, whereas update applies the new properties immediately to the service.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param serviceUpdateDescription The information necessary to update a service.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> updateServiceAsync(String serviceId, ServiceUpdateDescription serviceUpdateDescription, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(updateServiceWithServiceResponseAsync(serviceId, serviceUpdateDescription), serviceCallback);
    }

    /**
     * Updates a Service Fabric service using the specified update description.
     * This API allows updating properties of a running Service Fabric service. The set of properties that can be updated are a subset of the properties that were specified at the time of creating the service. The current set of properties can be obtained using `GetServiceDescription` API. Note that updating the properties of a running service is different than upgrading your application using `StartApplicationUpgrade` API. The upgrade is a long running background operation that involves moving the application from one version to another, one upgrade domain at a time, whereas update applies the new properties immediately to the service.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param serviceUpdateDescription The information necessary to update a service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> updateServiceAsync(String serviceId, ServiceUpdateDescription serviceUpdateDescription) {
        return updateServiceWithServiceResponseAsync(serviceId, serviceUpdateDescription).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates a Service Fabric service using the specified update description.
     * This API allows updating properties of a running Service Fabric service. The set of properties that can be updated are a subset of the properties that were specified at the time of creating the service. The current set of properties can be obtained using `GetServiceDescription` API. Note that updating the properties of a running service is different than upgrading your application using `StartApplicationUpgrade` API. The upgrade is a long running background operation that involves moving the application from one version to another, one upgrade domain at a time, whereas update applies the new properties immediately to the service.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param serviceUpdateDescription The information necessary to update a service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> updateServiceWithServiceResponseAsync(String serviceId, ServiceUpdateDescription serviceUpdateDescription) {
        if (serviceId == null) {
            throw new IllegalArgumentException("Parameter serviceId is required and cannot be null.");
        }
        if (serviceUpdateDescription == null) {
            throw new IllegalArgumentException("Parameter serviceUpdateDescription is required and cannot be null.");
        }
        Validator.validate(serviceUpdateDescription);
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.updateService(serviceId, apiVersion, serviceUpdateDescription, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = updateServiceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Updates a Service Fabric service using the specified update description.
     * This API allows updating properties of a running Service Fabric service. The set of properties that can be updated are a subset of the properties that were specified at the time of creating the service. The current set of properties can be obtained using `GetServiceDescription` API. Note that updating the properties of a running service is different than upgrading your application using `StartApplicationUpgrade` API. The upgrade is a long running background operation that involves moving the application from one version to another, one upgrade domain at a time, whereas update applies the new properties immediately to the service.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param serviceUpdateDescription The information necessary to update a service.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void updateService(String serviceId, ServiceUpdateDescription serviceUpdateDescription, Long timeout) {
        updateServiceWithServiceResponseAsync(serviceId, serviceUpdateDescription, timeout).toBlocking().single().body();
    }

    /**
     * Updates a Service Fabric service using the specified update description.
     * This API allows updating properties of a running Service Fabric service. The set of properties that can be updated are a subset of the properties that were specified at the time of creating the service. The current set of properties can be obtained using `GetServiceDescription` API. Note that updating the properties of a running service is different than upgrading your application using `StartApplicationUpgrade` API. The upgrade is a long running background operation that involves moving the application from one version to another, one upgrade domain at a time, whereas update applies the new properties immediately to the service.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param serviceUpdateDescription The information necessary to update a service.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> updateServiceAsync(String serviceId, ServiceUpdateDescription serviceUpdateDescription, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(updateServiceWithServiceResponseAsync(serviceId, serviceUpdateDescription, timeout), serviceCallback);
    }

    /**
     * Updates a Service Fabric service using the specified update description.
     * This API allows updating properties of a running Service Fabric service. The set of properties that can be updated are a subset of the properties that were specified at the time of creating the service. The current set of properties can be obtained using `GetServiceDescription` API. Note that updating the properties of a running service is different than upgrading your application using `StartApplicationUpgrade` API. The upgrade is a long running background operation that involves moving the application from one version to another, one upgrade domain at a time, whereas update applies the new properties immediately to the service.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param serviceUpdateDescription The information necessary to update a service.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> updateServiceAsync(String serviceId, ServiceUpdateDescription serviceUpdateDescription, Long timeout) {
        return updateServiceWithServiceResponseAsync(serviceId, serviceUpdateDescription, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates a Service Fabric service using the specified update description.
     * This API allows updating properties of a running Service Fabric service. The set of properties that can be updated are a subset of the properties that were specified at the time of creating the service. The current set of properties can be obtained using `GetServiceDescription` API. Note that updating the properties of a running service is different than upgrading your application using `StartApplicationUpgrade` API. The upgrade is a long running background operation that involves moving the application from one version to another, one upgrade domain at a time, whereas update applies the new properties immediately to the service.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param serviceUpdateDescription The information necessary to update a service.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> updateServiceWithServiceResponseAsync(String serviceId, ServiceUpdateDescription serviceUpdateDescription, Long timeout) {
        if (serviceId == null) {
            throw new IllegalArgumentException("Parameter serviceId is required and cannot be null.");
        }
        if (serviceUpdateDescription == null) {
            throw new IllegalArgumentException("Parameter serviceUpdateDescription is required and cannot be null.");
        }
        Validator.validate(serviceUpdateDescription);
        final String apiVersion = "6.0";
        return service.updateService(serviceId, apiVersion, serviceUpdateDescription, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = updateServiceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> updateServiceDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the description of an existing Service Fabric service.
     * Gets the description of an existing Service Fabric service. A service must be created before its description can be obtained.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ServiceDescriptionInner object if successful.
     */
    public ServiceDescriptionInner getServiceDescription(String serviceId) {
        return getServiceDescriptionWithServiceResponseAsync(serviceId).toBlocking().single().body();
    }

    /**
     * Gets the description of an existing Service Fabric service.
     * Gets the description of an existing Service Fabric service. A service must be created before its description can be obtained.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ServiceDescriptionInner> getServiceDescriptionAsync(String serviceId, final ServiceCallback<ServiceDescriptionInner> serviceCallback) {
        return ServiceFuture.fromResponse(getServiceDescriptionWithServiceResponseAsync(serviceId), serviceCallback);
    }

    /**
     * Gets the description of an existing Service Fabric service.
     * Gets the description of an existing Service Fabric service. A service must be created before its description can be obtained.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServiceDescriptionInner object
     */
    public Observable<ServiceDescriptionInner> getServiceDescriptionAsync(String serviceId) {
        return getServiceDescriptionWithServiceResponseAsync(serviceId).map(new Func1<ServiceResponse<ServiceDescriptionInner>, ServiceDescriptionInner>() {
            @Override
            public ServiceDescriptionInner call(ServiceResponse<ServiceDescriptionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the description of an existing Service Fabric service.
     * Gets the description of an existing Service Fabric service. A service must be created before its description can be obtained.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServiceDescriptionInner object
     */
    public Observable<ServiceResponse<ServiceDescriptionInner>> getServiceDescriptionWithServiceResponseAsync(String serviceId) {
        if (serviceId == null) {
            throw new IllegalArgumentException("Parameter serviceId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.getServiceDescription(serviceId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ServiceDescriptionInner>>>() {
                @Override
                public Observable<ServiceResponse<ServiceDescriptionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ServiceDescriptionInner> clientResponse = getServiceDescriptionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the description of an existing Service Fabric service.
     * Gets the description of an existing Service Fabric service. A service must be created before its description can be obtained.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ServiceDescriptionInner object if successful.
     */
    public ServiceDescriptionInner getServiceDescription(String serviceId, Long timeout) {
        return getServiceDescriptionWithServiceResponseAsync(serviceId, timeout).toBlocking().single().body();
    }

    /**
     * Gets the description of an existing Service Fabric service.
     * Gets the description of an existing Service Fabric service. A service must be created before its description can be obtained.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ServiceDescriptionInner> getServiceDescriptionAsync(String serviceId, Long timeout, final ServiceCallback<ServiceDescriptionInner> serviceCallback) {
        return ServiceFuture.fromResponse(getServiceDescriptionWithServiceResponseAsync(serviceId, timeout), serviceCallback);
    }

    /**
     * Gets the description of an existing Service Fabric service.
     * Gets the description of an existing Service Fabric service. A service must be created before its description can be obtained.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServiceDescriptionInner object
     */
    public Observable<ServiceDescriptionInner> getServiceDescriptionAsync(String serviceId, Long timeout) {
        return getServiceDescriptionWithServiceResponseAsync(serviceId, timeout).map(new Func1<ServiceResponse<ServiceDescriptionInner>, ServiceDescriptionInner>() {
            @Override
            public ServiceDescriptionInner call(ServiceResponse<ServiceDescriptionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the description of an existing Service Fabric service.
     * Gets the description of an existing Service Fabric service. A service must be created before its description can be obtained.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServiceDescriptionInner object
     */
    public Observable<ServiceResponse<ServiceDescriptionInner>> getServiceDescriptionWithServiceResponseAsync(String serviceId, Long timeout) {
        if (serviceId == null) {
            throw new IllegalArgumentException("Parameter serviceId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.getServiceDescription(serviceId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ServiceDescriptionInner>>>() {
                @Override
                public Observable<ServiceResponse<ServiceDescriptionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ServiceDescriptionInner> clientResponse = getServiceDescriptionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ServiceDescriptionInner> getServiceDescriptionDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ServiceDescriptionInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ServiceDescriptionInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the health of the specified Service Fabric service.
     * Gets the health information of the specified service.
     Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.
     Use PartitionsHealthStateFilter to filter the collection of partitions returned.
     If you specify a service that does not exist in the health store, this request returns an error.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ServiceHealthInner object if successful.
     */
    public ServiceHealthInner getServiceHealth(String serviceId) {
        return getServiceHealthWithServiceResponseAsync(serviceId).toBlocking().single().body();
    }

    /**
     * Gets the health of the specified Service Fabric service.
     * Gets the health information of the specified service.
     Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.
     Use PartitionsHealthStateFilter to filter the collection of partitions returned.
     If you specify a service that does not exist in the health store, this request returns an error.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ServiceHealthInner> getServiceHealthAsync(String serviceId, final ServiceCallback<ServiceHealthInner> serviceCallback) {
        return ServiceFuture.fromResponse(getServiceHealthWithServiceResponseAsync(serviceId), serviceCallback);
    }

    /**
     * Gets the health of the specified Service Fabric service.
     * Gets the health information of the specified service.
     Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.
     Use PartitionsHealthStateFilter to filter the collection of partitions returned.
     If you specify a service that does not exist in the health store, this request returns an error.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServiceHealthInner object
     */
    public Observable<ServiceHealthInner> getServiceHealthAsync(String serviceId) {
        return getServiceHealthWithServiceResponseAsync(serviceId).map(new Func1<ServiceResponse<ServiceHealthInner>, ServiceHealthInner>() {
            @Override
            public ServiceHealthInner call(ServiceResponse<ServiceHealthInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the health of the specified Service Fabric service.
     * Gets the health information of the specified service.
     Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.
     Use PartitionsHealthStateFilter to filter the collection of partitions returned.
     If you specify a service that does not exist in the health store, this request returns an error.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServiceHealthInner object
     */
    public Observable<ServiceResponse<ServiceHealthInner>> getServiceHealthWithServiceResponseAsync(String serviceId) {
        if (serviceId == null) {
            throw new IllegalArgumentException("Parameter serviceId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Integer eventsHealthStateFilter = null;
        final Integer partitionsHealthStateFilter = null;
        final Boolean excludeHealthStatistics = null;
        final Long timeout = null;
        return service.getServiceHealth(serviceId, apiVersion, eventsHealthStateFilter, partitionsHealthStateFilter, excludeHealthStatistics, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ServiceHealthInner>>>() {
                @Override
                public Observable<ServiceResponse<ServiceHealthInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ServiceHealthInner> clientResponse = getServiceHealthDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the health of the specified Service Fabric service.
     * Gets the health information of the specified service.
     Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.
     Use PartitionsHealthStateFilter to filter the collection of partitions returned.
     If you specify a service that does not exist in the health store, this request returns an error.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param partitionsHealthStateFilter Allows filtering of the partitions health state objects returned in the result of service health query based on their health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only partitions that match the filter are returned. All partitions are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these value
     obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of partitions with HealthState value of OK (2) and Warning (4) will be returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param excludeHealthStatistics Indicates whether the health statistics should be returned as part of the query result. False by default.
     The statistics show the number of children entities in health state Ok, Warning, and Error.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ServiceHealthInner object if successful.
     */
    public ServiceHealthInner getServiceHealth(String serviceId, Integer eventsHealthStateFilter, Integer partitionsHealthStateFilter, Boolean excludeHealthStatistics, Long timeout) {
        return getServiceHealthWithServiceResponseAsync(serviceId, eventsHealthStateFilter, partitionsHealthStateFilter, excludeHealthStatistics, timeout).toBlocking().single().body();
    }

    /**
     * Gets the health of the specified Service Fabric service.
     * Gets the health information of the specified service.
     Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.
     Use PartitionsHealthStateFilter to filter the collection of partitions returned.
     If you specify a service that does not exist in the health store, this request returns an error.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param partitionsHealthStateFilter Allows filtering of the partitions health state objects returned in the result of service health query based on their health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only partitions that match the filter are returned. All partitions are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these value
     obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of partitions with HealthState value of OK (2) and Warning (4) will be returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param excludeHealthStatistics Indicates whether the health statistics should be returned as part of the query result. False by default.
     The statistics show the number of children entities in health state Ok, Warning, and Error.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ServiceHealthInner> getServiceHealthAsync(String serviceId, Integer eventsHealthStateFilter, Integer partitionsHealthStateFilter, Boolean excludeHealthStatistics, Long timeout, final ServiceCallback<ServiceHealthInner> serviceCallback) {
        return ServiceFuture.fromResponse(getServiceHealthWithServiceResponseAsync(serviceId, eventsHealthStateFilter, partitionsHealthStateFilter, excludeHealthStatistics, timeout), serviceCallback);
    }

    /**
     * Gets the health of the specified Service Fabric service.
     * Gets the health information of the specified service.
     Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.
     Use PartitionsHealthStateFilter to filter the collection of partitions returned.
     If you specify a service that does not exist in the health store, this request returns an error.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param partitionsHealthStateFilter Allows filtering of the partitions health state objects returned in the result of service health query based on their health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only partitions that match the filter are returned. All partitions are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these value
     obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of partitions with HealthState value of OK (2) and Warning (4) will be returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param excludeHealthStatistics Indicates whether the health statistics should be returned as part of the query result. False by default.
     The statistics show the number of children entities in health state Ok, Warning, and Error.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServiceHealthInner object
     */
    public Observable<ServiceHealthInner> getServiceHealthAsync(String serviceId, Integer eventsHealthStateFilter, Integer partitionsHealthStateFilter, Boolean excludeHealthStatistics, Long timeout) {
        return getServiceHealthWithServiceResponseAsync(serviceId, eventsHealthStateFilter, partitionsHealthStateFilter, excludeHealthStatistics, timeout).map(new Func1<ServiceResponse<ServiceHealthInner>, ServiceHealthInner>() {
            @Override
            public ServiceHealthInner call(ServiceResponse<ServiceHealthInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the health of the specified Service Fabric service.
     * Gets the health information of the specified service.
     Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.
     Use PartitionsHealthStateFilter to filter the collection of partitions returned.
     If you specify a service that does not exist in the health store, this request returns an error.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param partitionsHealthStateFilter Allows filtering of the partitions health state objects returned in the result of service health query based on their health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only partitions that match the filter are returned. All partitions are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these value
     obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of partitions with HealthState value of OK (2) and Warning (4) will be returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param excludeHealthStatistics Indicates whether the health statistics should be returned as part of the query result. False by default.
     The statistics show the number of children entities in health state Ok, Warning, and Error.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServiceHealthInner object
     */
    public Observable<ServiceResponse<ServiceHealthInner>> getServiceHealthWithServiceResponseAsync(String serviceId, Integer eventsHealthStateFilter, Integer partitionsHealthStateFilter, Boolean excludeHealthStatistics, Long timeout) {
        if (serviceId == null) {
            throw new IllegalArgumentException("Parameter serviceId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.getServiceHealth(serviceId, apiVersion, eventsHealthStateFilter, partitionsHealthStateFilter, excludeHealthStatistics, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ServiceHealthInner>>>() {
                @Override
                public Observable<ServiceResponse<ServiceHealthInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ServiceHealthInner> clientResponse = getServiceHealthDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ServiceHealthInner> getServiceHealthDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ServiceHealthInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ServiceHealthInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the health of the specified Service Fabric service, by using the specified health policy.
     * Gets the health information of the specified service.
     If the application health policy is specified, the health evaluation uses it to get the aggregated health state.
     If the policy is not specified, the health evaluation uses the application health policy defined in the application manifest, or the default health policy, if no policy is defined in the manifest.
     Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.
     Use PartitionsHealthStateFilter to filter the collection of partitions returned.
     If you specify a service that does not exist in the health store, this request returns an error.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ServiceHealthInner object if successful.
     */
    public ServiceHealthInner getServiceHealthUsingPolicy(String serviceId) {
        return getServiceHealthUsingPolicyWithServiceResponseAsync(serviceId).toBlocking().single().body();
    }

    /**
     * Gets the health of the specified Service Fabric service, by using the specified health policy.
     * Gets the health information of the specified service.
     If the application health policy is specified, the health evaluation uses it to get the aggregated health state.
     If the policy is not specified, the health evaluation uses the application health policy defined in the application manifest, or the default health policy, if no policy is defined in the manifest.
     Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.
     Use PartitionsHealthStateFilter to filter the collection of partitions returned.
     If you specify a service that does not exist in the health store, this request returns an error.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ServiceHealthInner> getServiceHealthUsingPolicyAsync(String serviceId, final ServiceCallback<ServiceHealthInner> serviceCallback) {
        return ServiceFuture.fromResponse(getServiceHealthUsingPolicyWithServiceResponseAsync(serviceId), serviceCallback);
    }

    /**
     * Gets the health of the specified Service Fabric service, by using the specified health policy.
     * Gets the health information of the specified service.
     If the application health policy is specified, the health evaluation uses it to get the aggregated health state.
     If the policy is not specified, the health evaluation uses the application health policy defined in the application manifest, or the default health policy, if no policy is defined in the manifest.
     Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.
     Use PartitionsHealthStateFilter to filter the collection of partitions returned.
     If you specify a service that does not exist in the health store, this request returns an error.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServiceHealthInner object
     */
    public Observable<ServiceHealthInner> getServiceHealthUsingPolicyAsync(String serviceId) {
        return getServiceHealthUsingPolicyWithServiceResponseAsync(serviceId).map(new Func1<ServiceResponse<ServiceHealthInner>, ServiceHealthInner>() {
            @Override
            public ServiceHealthInner call(ServiceResponse<ServiceHealthInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the health of the specified Service Fabric service, by using the specified health policy.
     * Gets the health information of the specified service.
     If the application health policy is specified, the health evaluation uses it to get the aggregated health state.
     If the policy is not specified, the health evaluation uses the application health policy defined in the application manifest, or the default health policy, if no policy is defined in the manifest.
     Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.
     Use PartitionsHealthStateFilter to filter the collection of partitions returned.
     If you specify a service that does not exist in the health store, this request returns an error.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServiceHealthInner object
     */
    public Observable<ServiceResponse<ServiceHealthInner>> getServiceHealthUsingPolicyWithServiceResponseAsync(String serviceId) {
        if (serviceId == null) {
            throw new IllegalArgumentException("Parameter serviceId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Integer eventsHealthStateFilter = null;
        final Integer partitionsHealthStateFilter = null;
        final ApplicationHealthPolicy applicationHealthPolicy = null;
        final Boolean excludeHealthStatistics = null;
        final Long timeout = null;
        return service.getServiceHealthUsingPolicy(serviceId, apiVersion, eventsHealthStateFilter, partitionsHealthStateFilter, applicationHealthPolicy, excludeHealthStatistics, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ServiceHealthInner>>>() {
                @Override
                public Observable<ServiceResponse<ServiceHealthInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ServiceHealthInner> clientResponse = getServiceHealthUsingPolicyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the health of the specified Service Fabric service, by using the specified health policy.
     * Gets the health information of the specified service.
     If the application health policy is specified, the health evaluation uses it to get the aggregated health state.
     If the policy is not specified, the health evaluation uses the application health policy defined in the application manifest, or the default health policy, if no policy is defined in the manifest.
     Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.
     Use PartitionsHealthStateFilter to filter the collection of partitions returned.
     If you specify a service that does not exist in the health store, this request returns an error.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param partitionsHealthStateFilter Allows filtering of the partitions health state objects returned in the result of service health query based on their health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only partitions that match the filter are returned. All partitions are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these value
     obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of partitions with HealthState value of OK (2) and Warning (4) will be returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param applicationHealthPolicy Describes the health policies used to evaluate the health of an application or one of its children.
     If not present, the health evaluation uses the health policy from application manifest or the default health policy.
     * @param excludeHealthStatistics Indicates whether the health statistics should be returned as part of the query result. False by default.
     The statistics show the number of children entities in health state Ok, Warning, and Error.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ServiceHealthInner object if successful.
     */
    public ServiceHealthInner getServiceHealthUsingPolicy(String serviceId, Integer eventsHealthStateFilter, Integer partitionsHealthStateFilter, ApplicationHealthPolicy applicationHealthPolicy, Boolean excludeHealthStatistics, Long timeout) {
        return getServiceHealthUsingPolicyWithServiceResponseAsync(serviceId, eventsHealthStateFilter, partitionsHealthStateFilter, applicationHealthPolicy, excludeHealthStatistics, timeout).toBlocking().single().body();
    }

    /**
     * Gets the health of the specified Service Fabric service, by using the specified health policy.
     * Gets the health information of the specified service.
     If the application health policy is specified, the health evaluation uses it to get the aggregated health state.
     If the policy is not specified, the health evaluation uses the application health policy defined in the application manifest, or the default health policy, if no policy is defined in the manifest.
     Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.
     Use PartitionsHealthStateFilter to filter the collection of partitions returned.
     If you specify a service that does not exist in the health store, this request returns an error.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param partitionsHealthStateFilter Allows filtering of the partitions health state objects returned in the result of service health query based on their health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only partitions that match the filter are returned. All partitions are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these value
     obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of partitions with HealthState value of OK (2) and Warning (4) will be returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param applicationHealthPolicy Describes the health policies used to evaluate the health of an application or one of its children.
     If not present, the health evaluation uses the health policy from application manifest or the default health policy.
     * @param excludeHealthStatistics Indicates whether the health statistics should be returned as part of the query result. False by default.
     The statistics show the number of children entities in health state Ok, Warning, and Error.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ServiceHealthInner> getServiceHealthUsingPolicyAsync(String serviceId, Integer eventsHealthStateFilter, Integer partitionsHealthStateFilter, ApplicationHealthPolicy applicationHealthPolicy, Boolean excludeHealthStatistics, Long timeout, final ServiceCallback<ServiceHealthInner> serviceCallback) {
        return ServiceFuture.fromResponse(getServiceHealthUsingPolicyWithServiceResponseAsync(serviceId, eventsHealthStateFilter, partitionsHealthStateFilter, applicationHealthPolicy, excludeHealthStatistics, timeout), serviceCallback);
    }

    /**
     * Gets the health of the specified Service Fabric service, by using the specified health policy.
     * Gets the health information of the specified service.
     If the application health policy is specified, the health evaluation uses it to get the aggregated health state.
     If the policy is not specified, the health evaluation uses the application health policy defined in the application manifest, or the default health policy, if no policy is defined in the manifest.
     Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.
     Use PartitionsHealthStateFilter to filter the collection of partitions returned.
     If you specify a service that does not exist in the health store, this request returns an error.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param partitionsHealthStateFilter Allows filtering of the partitions health state objects returned in the result of service health query based on their health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only partitions that match the filter are returned. All partitions are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these value
     obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of partitions with HealthState value of OK (2) and Warning (4) will be returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param applicationHealthPolicy Describes the health policies used to evaluate the health of an application or one of its children.
     If not present, the health evaluation uses the health policy from application manifest or the default health policy.
     * @param excludeHealthStatistics Indicates whether the health statistics should be returned as part of the query result. False by default.
     The statistics show the number of children entities in health state Ok, Warning, and Error.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServiceHealthInner object
     */
    public Observable<ServiceHealthInner> getServiceHealthUsingPolicyAsync(String serviceId, Integer eventsHealthStateFilter, Integer partitionsHealthStateFilter, ApplicationHealthPolicy applicationHealthPolicy, Boolean excludeHealthStatistics, Long timeout) {
        return getServiceHealthUsingPolicyWithServiceResponseAsync(serviceId, eventsHealthStateFilter, partitionsHealthStateFilter, applicationHealthPolicy, excludeHealthStatistics, timeout).map(new Func1<ServiceResponse<ServiceHealthInner>, ServiceHealthInner>() {
            @Override
            public ServiceHealthInner call(ServiceResponse<ServiceHealthInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the health of the specified Service Fabric service, by using the specified health policy.
     * Gets the health information of the specified service.
     If the application health policy is specified, the health evaluation uses it to get the aggregated health state.
     If the policy is not specified, the health evaluation uses the application health policy defined in the application manifest, or the default health policy, if no policy is defined in the manifest.
     Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.
     Use PartitionsHealthStateFilter to filter the collection of partitions returned.
     If you specify a service that does not exist in the health store, this request returns an error.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param partitionsHealthStateFilter Allows filtering of the partitions health state objects returned in the result of service health query based on their health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only partitions that match the filter are returned. All partitions are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these value
     obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of partitions with HealthState value of OK (2) and Warning (4) will be returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param applicationHealthPolicy Describes the health policies used to evaluate the health of an application or one of its children.
     If not present, the health evaluation uses the health policy from application manifest or the default health policy.
     * @param excludeHealthStatistics Indicates whether the health statistics should be returned as part of the query result. False by default.
     The statistics show the number of children entities in health state Ok, Warning, and Error.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServiceHealthInner object
     */
    public Observable<ServiceResponse<ServiceHealthInner>> getServiceHealthUsingPolicyWithServiceResponseAsync(String serviceId, Integer eventsHealthStateFilter, Integer partitionsHealthStateFilter, ApplicationHealthPolicy applicationHealthPolicy, Boolean excludeHealthStatistics, Long timeout) {
        if (serviceId == null) {
            throw new IllegalArgumentException("Parameter serviceId is required and cannot be null.");
        }
        Validator.validate(applicationHealthPolicy);
        final String apiVersion = "6.0";
        return service.getServiceHealthUsingPolicy(serviceId, apiVersion, eventsHealthStateFilter, partitionsHealthStateFilter, applicationHealthPolicy, excludeHealthStatistics, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ServiceHealthInner>>>() {
                @Override
                public Observable<ServiceResponse<ServiceHealthInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ServiceHealthInner> clientResponse = getServiceHealthUsingPolicyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ServiceHealthInner> getServiceHealthUsingPolicyDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ServiceHealthInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ServiceHealthInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Sends a health report on the Service Fabric service.
     * Reports health state of the specified Service Fabric service. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway Service, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, run GetServiceHealth and check that the report appears in the HealthEvents section.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void reportServiceHealth(String serviceId, HealthInformation healthInformation) {
        reportServiceHealthWithServiceResponseAsync(serviceId, healthInformation).toBlocking().single().body();
    }

    /**
     * Sends a health report on the Service Fabric service.
     * Reports health state of the specified Service Fabric service. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway Service, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, run GetServiceHealth and check that the report appears in the HealthEvents section.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> reportServiceHealthAsync(String serviceId, HealthInformation healthInformation, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(reportServiceHealthWithServiceResponseAsync(serviceId, healthInformation), serviceCallback);
    }

    /**
     * Sends a health report on the Service Fabric service.
     * Reports health state of the specified Service Fabric service. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway Service, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, run GetServiceHealth and check that the report appears in the HealthEvents section.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> reportServiceHealthAsync(String serviceId, HealthInformation healthInformation) {
        return reportServiceHealthWithServiceResponseAsync(serviceId, healthInformation).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Sends a health report on the Service Fabric service.
     * Reports health state of the specified Service Fabric service. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway Service, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, run GetServiceHealth and check that the report appears in the HealthEvents section.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> reportServiceHealthWithServiceResponseAsync(String serviceId, HealthInformation healthInformation) {
        if (serviceId == null) {
            throw new IllegalArgumentException("Parameter serviceId is required and cannot be null.");
        }
        if (healthInformation == null) {
            throw new IllegalArgumentException("Parameter healthInformation is required and cannot be null.");
        }
        Validator.validate(healthInformation);
        final String apiVersion = "6.0";
        final Boolean immediate = null;
        final Long timeout = null;
        return service.reportServiceHealth(serviceId, apiVersion, healthInformation, immediate, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = reportServiceHealthDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Sends a health report on the Service Fabric service.
     * Reports health state of the specified Service Fabric service. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway Service, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, run GetServiceHealth and check that the report appears in the HealthEvents section.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @param immediate A flag that indicates whether the report should be sent immediately.
     A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
     If Immediate is set to true, the report is sent immediately from HTTP Gateway to the health store, regardless of the fabric client settings that the HTTP Gateway Application is using.
     This is useful for critical reports that should be sent as soon as possible.
     Depending on timing and other conditions, sending the report may still fail, for example if the HTTP Gateway is closed or the message doesn't reach the Gateway.
     If Immediate is set to false, the report is sent based on the health client settings from the HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
     This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
     By default, reports are not sent immediately.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void reportServiceHealth(String serviceId, HealthInformation healthInformation, Boolean immediate, Long timeout) {
        reportServiceHealthWithServiceResponseAsync(serviceId, healthInformation, immediate, timeout).toBlocking().single().body();
    }

    /**
     * Sends a health report on the Service Fabric service.
     * Reports health state of the specified Service Fabric service. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway Service, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, run GetServiceHealth and check that the report appears in the HealthEvents section.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @param immediate A flag that indicates whether the report should be sent immediately.
     A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
     If Immediate is set to true, the report is sent immediately from HTTP Gateway to the health store, regardless of the fabric client settings that the HTTP Gateway Application is using.
     This is useful for critical reports that should be sent as soon as possible.
     Depending on timing and other conditions, sending the report may still fail, for example if the HTTP Gateway is closed or the message doesn't reach the Gateway.
     If Immediate is set to false, the report is sent based on the health client settings from the HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
     This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
     By default, reports are not sent immediately.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> reportServiceHealthAsync(String serviceId, HealthInformation healthInformation, Boolean immediate, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(reportServiceHealthWithServiceResponseAsync(serviceId, healthInformation, immediate, timeout), serviceCallback);
    }

    /**
     * Sends a health report on the Service Fabric service.
     * Reports health state of the specified Service Fabric service. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway Service, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, run GetServiceHealth and check that the report appears in the HealthEvents section.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @param immediate A flag that indicates whether the report should be sent immediately.
     A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
     If Immediate is set to true, the report is sent immediately from HTTP Gateway to the health store, regardless of the fabric client settings that the HTTP Gateway Application is using.
     This is useful for critical reports that should be sent as soon as possible.
     Depending on timing and other conditions, sending the report may still fail, for example if the HTTP Gateway is closed or the message doesn't reach the Gateway.
     If Immediate is set to false, the report is sent based on the health client settings from the HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
     This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
     By default, reports are not sent immediately.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> reportServiceHealthAsync(String serviceId, HealthInformation healthInformation, Boolean immediate, Long timeout) {
        return reportServiceHealthWithServiceResponseAsync(serviceId, healthInformation, immediate, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Sends a health report on the Service Fabric service.
     * Reports health state of the specified Service Fabric service. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway Service, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, run GetServiceHealth and check that the report appears in the HealthEvents section.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @param immediate A flag that indicates whether the report should be sent immediately.
     A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
     If Immediate is set to true, the report is sent immediately from HTTP Gateway to the health store, regardless of the fabric client settings that the HTTP Gateway Application is using.
     This is useful for critical reports that should be sent as soon as possible.
     Depending on timing and other conditions, sending the report may still fail, for example if the HTTP Gateway is closed or the message doesn't reach the Gateway.
     If Immediate is set to false, the report is sent based on the health client settings from the HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
     This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
     By default, reports are not sent immediately.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> reportServiceHealthWithServiceResponseAsync(String serviceId, HealthInformation healthInformation, Boolean immediate, Long timeout) {
        if (serviceId == null) {
            throw new IllegalArgumentException("Parameter serviceId is required and cannot be null.");
        }
        if (healthInformation == null) {
            throw new IllegalArgumentException("Parameter healthInformation is required and cannot be null.");
        }
        Validator.validate(healthInformation);
        final String apiVersion = "6.0";
        return service.reportServiceHealth(serviceId, apiVersion, healthInformation, immediate, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = reportServiceHealthDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> reportServiceHealthDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Resolve a Service Fabric partition.
     * Resolve a Service Fabric service partition to get the endpoints of the service replicas.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ResolvedServicePartitionInner object if successful.
     */
    public ResolvedServicePartitionInner resolveService(String serviceId) {
        return resolveServiceWithServiceResponseAsync(serviceId).toBlocking().single().body();
    }

    /**
     * Resolve a Service Fabric partition.
     * Resolve a Service Fabric service partition to get the endpoints of the service replicas.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ResolvedServicePartitionInner> resolveServiceAsync(String serviceId, final ServiceCallback<ResolvedServicePartitionInner> serviceCallback) {
        return ServiceFuture.fromResponse(resolveServiceWithServiceResponseAsync(serviceId), serviceCallback);
    }

    /**
     * Resolve a Service Fabric partition.
     * Resolve a Service Fabric service partition to get the endpoints of the service replicas.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ResolvedServicePartitionInner object
     */
    public Observable<ResolvedServicePartitionInner> resolveServiceAsync(String serviceId) {
        return resolveServiceWithServiceResponseAsync(serviceId).map(new Func1<ServiceResponse<ResolvedServicePartitionInner>, ResolvedServicePartitionInner>() {
            @Override
            public ResolvedServicePartitionInner call(ServiceResponse<ResolvedServicePartitionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Resolve a Service Fabric partition.
     * Resolve a Service Fabric service partition to get the endpoints of the service replicas.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ResolvedServicePartitionInner object
     */
    public Observable<ServiceResponse<ResolvedServicePartitionInner>> resolveServiceWithServiceResponseAsync(String serviceId) {
        if (serviceId == null) {
            throw new IllegalArgumentException("Parameter serviceId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Integer partitionKeyType = null;
        final String partitionKeyValue = null;
        final String previousRspVersion = null;
        final Long timeout = null;
        return service.resolveService(serviceId, apiVersion, partitionKeyType, partitionKeyValue, previousRspVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ResolvedServicePartitionInner>>>() {
                @Override
                public Observable<ServiceResponse<ResolvedServicePartitionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ResolvedServicePartitionInner> clientResponse = resolveServiceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Resolve a Service Fabric partition.
     * Resolve a Service Fabric service partition to get the endpoints of the service replicas.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionKeyType Key type for the partition. This parameter is required if the partition scheme for the service is Int64Range or Named. The possible values are following.
     - None (1) - Indicates that the PartitionKeyValue parameter is not specified. This is valid for the partitions with partitioning scheme as Singleton. This is the default value. The value is 1.
     - Int64Range (2) - Indicates that the PartitionKeyValue parameter is an int64 partition key. This is valid for the partitions with partitioning scheme as Int64Range. The value is 2.
     - Named (3) - Indicates that the PartitionKeyValue parameter is a name of the partition. This is valid for the partitions with partitioning scheme as Named. The value is 3.
     * @param partitionKeyValue Partition key. This is required if the partition scheme for the service is Int64Range or Named.
     * @param previousRspVersion The value in the Version field of the response that was received previously. This is required if the user knows that the result that was gotten previously is stale.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ResolvedServicePartitionInner object if successful.
     */
    public ResolvedServicePartitionInner resolveService(String serviceId, Integer partitionKeyType, String partitionKeyValue, String previousRspVersion, Long timeout) {
        return resolveServiceWithServiceResponseAsync(serviceId, partitionKeyType, partitionKeyValue, previousRspVersion, timeout).toBlocking().single().body();
    }

    /**
     * Resolve a Service Fabric partition.
     * Resolve a Service Fabric service partition to get the endpoints of the service replicas.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionKeyType Key type for the partition. This parameter is required if the partition scheme for the service is Int64Range or Named. The possible values are following.
     - None (1) - Indicates that the PartitionKeyValue parameter is not specified. This is valid for the partitions with partitioning scheme as Singleton. This is the default value. The value is 1.
     - Int64Range (2) - Indicates that the PartitionKeyValue parameter is an int64 partition key. This is valid for the partitions with partitioning scheme as Int64Range. The value is 2.
     - Named (3) - Indicates that the PartitionKeyValue parameter is a name of the partition. This is valid for the partitions with partitioning scheme as Named. The value is 3.
     * @param partitionKeyValue Partition key. This is required if the partition scheme for the service is Int64Range or Named.
     * @param previousRspVersion The value in the Version field of the response that was received previously. This is required if the user knows that the result that was gotten previously is stale.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ResolvedServicePartitionInner> resolveServiceAsync(String serviceId, Integer partitionKeyType, String partitionKeyValue, String previousRspVersion, Long timeout, final ServiceCallback<ResolvedServicePartitionInner> serviceCallback) {
        return ServiceFuture.fromResponse(resolveServiceWithServiceResponseAsync(serviceId, partitionKeyType, partitionKeyValue, previousRspVersion, timeout), serviceCallback);
    }

    /**
     * Resolve a Service Fabric partition.
     * Resolve a Service Fabric service partition to get the endpoints of the service replicas.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionKeyType Key type for the partition. This parameter is required if the partition scheme for the service is Int64Range or Named. The possible values are following.
     - None (1) - Indicates that the PartitionKeyValue parameter is not specified. This is valid for the partitions with partitioning scheme as Singleton. This is the default value. The value is 1.
     - Int64Range (2) - Indicates that the PartitionKeyValue parameter is an int64 partition key. This is valid for the partitions with partitioning scheme as Int64Range. The value is 2.
     - Named (3) - Indicates that the PartitionKeyValue parameter is a name of the partition. This is valid for the partitions with partitioning scheme as Named. The value is 3.
     * @param partitionKeyValue Partition key. This is required if the partition scheme for the service is Int64Range or Named.
     * @param previousRspVersion The value in the Version field of the response that was received previously. This is required if the user knows that the result that was gotten previously is stale.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ResolvedServicePartitionInner object
     */
    public Observable<ResolvedServicePartitionInner> resolveServiceAsync(String serviceId, Integer partitionKeyType, String partitionKeyValue, String previousRspVersion, Long timeout) {
        return resolveServiceWithServiceResponseAsync(serviceId, partitionKeyType, partitionKeyValue, previousRspVersion, timeout).map(new Func1<ServiceResponse<ResolvedServicePartitionInner>, ResolvedServicePartitionInner>() {
            @Override
            public ResolvedServicePartitionInner call(ServiceResponse<ResolvedServicePartitionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Resolve a Service Fabric partition.
     * Resolve a Service Fabric service partition to get the endpoints of the service replicas.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionKeyType Key type for the partition. This parameter is required if the partition scheme for the service is Int64Range or Named. The possible values are following.
     - None (1) - Indicates that the PartitionKeyValue parameter is not specified. This is valid for the partitions with partitioning scheme as Singleton. This is the default value. The value is 1.
     - Int64Range (2) - Indicates that the PartitionKeyValue parameter is an int64 partition key. This is valid for the partitions with partitioning scheme as Int64Range. The value is 2.
     - Named (3) - Indicates that the PartitionKeyValue parameter is a name of the partition. This is valid for the partitions with partitioning scheme as Named. The value is 3.
     * @param partitionKeyValue Partition key. This is required if the partition scheme for the service is Int64Range or Named.
     * @param previousRspVersion The value in the Version field of the response that was received previously. This is required if the user knows that the result that was gotten previously is stale.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ResolvedServicePartitionInner object
     */
    public Observable<ServiceResponse<ResolvedServicePartitionInner>> resolveServiceWithServiceResponseAsync(String serviceId, Integer partitionKeyType, String partitionKeyValue, String previousRspVersion, Long timeout) {
        if (serviceId == null) {
            throw new IllegalArgumentException("Parameter serviceId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.resolveService(serviceId, apiVersion, partitionKeyType, partitionKeyValue, previousRspVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ResolvedServicePartitionInner>>>() {
                @Override
                public Observable<ServiceResponse<ResolvedServicePartitionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ResolvedServicePartitionInner> clientResponse = resolveServiceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ResolvedServicePartitionInner> resolveServiceDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ResolvedServicePartitionInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ResolvedServicePartitionInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the list of partitions of a Service Fabric service.
     * The response includes the partition ID, partitioning scheme information, keys supported by the partition, status, health, and other details about the partition.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedServicePartitionInfoListInner object if successful.
     */
    public PagedServicePartitionInfoListInner getPartitionInfoList(String serviceId) {
        return getPartitionInfoListWithServiceResponseAsync(serviceId).toBlocking().single().body();
    }

    /**
     * Gets the list of partitions of a Service Fabric service.
     * The response includes the partition ID, partitioning scheme information, keys supported by the partition, status, health, and other details about the partition.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedServicePartitionInfoListInner> getPartitionInfoListAsync(String serviceId, final ServiceCallback<PagedServicePartitionInfoListInner> serviceCallback) {
        return ServiceFuture.fromResponse(getPartitionInfoListWithServiceResponseAsync(serviceId), serviceCallback);
    }

    /**
     * Gets the list of partitions of a Service Fabric service.
     * The response includes the partition ID, partitioning scheme information, keys supported by the partition, status, health, and other details about the partition.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedServicePartitionInfoListInner object
     */
    public Observable<PagedServicePartitionInfoListInner> getPartitionInfoListAsync(String serviceId) {
        return getPartitionInfoListWithServiceResponseAsync(serviceId).map(new Func1<ServiceResponse<PagedServicePartitionInfoListInner>, PagedServicePartitionInfoListInner>() {
            @Override
            public PagedServicePartitionInfoListInner call(ServiceResponse<PagedServicePartitionInfoListInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the list of partitions of a Service Fabric service.
     * The response includes the partition ID, partitioning scheme information, keys supported by the partition, status, health, and other details about the partition.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedServicePartitionInfoListInner object
     */
    public Observable<ServiceResponse<PagedServicePartitionInfoListInner>> getPartitionInfoListWithServiceResponseAsync(String serviceId) {
        if (serviceId == null) {
            throw new IllegalArgumentException("Parameter serviceId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final String continuationToken = null;
        final Long timeout = null;
        return service.getPartitionInfoList(serviceId, apiVersion, continuationToken, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedServicePartitionInfoListInner>>>() {
                @Override
                public Observable<ServiceResponse<PagedServicePartitionInfoListInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedServicePartitionInfoListInner> clientResponse = getPartitionInfoListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the list of partitions of a Service Fabric service.
     * The response includes the partition ID, partitioning scheme information, keys supported by the partition, status, health, and other details about the partition.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedServicePartitionInfoListInner object if successful.
     */
    public PagedServicePartitionInfoListInner getPartitionInfoList(String serviceId, String continuationToken, Long timeout) {
        return getPartitionInfoListWithServiceResponseAsync(serviceId, continuationToken, timeout).toBlocking().single().body();
    }

    /**
     * Gets the list of partitions of a Service Fabric service.
     * The response includes the partition ID, partitioning scheme information, keys supported by the partition, status, health, and other details about the partition.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedServicePartitionInfoListInner> getPartitionInfoListAsync(String serviceId, String continuationToken, Long timeout, final ServiceCallback<PagedServicePartitionInfoListInner> serviceCallback) {
        return ServiceFuture.fromResponse(getPartitionInfoListWithServiceResponseAsync(serviceId, continuationToken, timeout), serviceCallback);
    }

    /**
     * Gets the list of partitions of a Service Fabric service.
     * The response includes the partition ID, partitioning scheme information, keys supported by the partition, status, health, and other details about the partition.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedServicePartitionInfoListInner object
     */
    public Observable<PagedServicePartitionInfoListInner> getPartitionInfoListAsync(String serviceId, String continuationToken, Long timeout) {
        return getPartitionInfoListWithServiceResponseAsync(serviceId, continuationToken, timeout).map(new Func1<ServiceResponse<PagedServicePartitionInfoListInner>, PagedServicePartitionInfoListInner>() {
            @Override
            public PagedServicePartitionInfoListInner call(ServiceResponse<PagedServicePartitionInfoListInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the list of partitions of a Service Fabric service.
     * The response includes the partition ID, partitioning scheme information, keys supported by the partition, status, health, and other details about the partition.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedServicePartitionInfoListInner object
     */
    public Observable<ServiceResponse<PagedServicePartitionInfoListInner>> getPartitionInfoListWithServiceResponseAsync(String serviceId, String continuationToken, Long timeout) {
        if (serviceId == null) {
            throw new IllegalArgumentException("Parameter serviceId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.getPartitionInfoList(serviceId, apiVersion, continuationToken, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedServicePartitionInfoListInner>>>() {
                @Override
                public Observable<ServiceResponse<PagedServicePartitionInfoListInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedServicePartitionInfoListInner> clientResponse = getPartitionInfoListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PagedServicePartitionInfoListInner> getPartitionInfoListDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<PagedServicePartitionInfoListInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PagedServicePartitionInfoListInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the information about a Service Fabric partition.
     * Gets the information about the specified partition. The response includes the partition ID, partitioning scheme information, keys supported by the partition, status, health, and other details about the partition.
     *
     * @param partitionId The identity of the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ServicePartitionInfoInner object if successful.
     */
    public ServicePartitionInfoInner getPartitionInfo(UUID partitionId) {
        return getPartitionInfoWithServiceResponseAsync(partitionId).toBlocking().single().body();
    }

    /**
     * Gets the information about a Service Fabric partition.
     * Gets the information about the specified partition. The response includes the partition ID, partitioning scheme information, keys supported by the partition, status, health, and other details about the partition.
     *
     * @param partitionId The identity of the partition.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ServicePartitionInfoInner> getPartitionInfoAsync(UUID partitionId, final ServiceCallback<ServicePartitionInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getPartitionInfoWithServiceResponseAsync(partitionId), serviceCallback);
    }

    /**
     * Gets the information about a Service Fabric partition.
     * Gets the information about the specified partition. The response includes the partition ID, partitioning scheme information, keys supported by the partition, status, health, and other details about the partition.
     *
     * @param partitionId The identity of the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServicePartitionInfoInner object
     */
    public Observable<ServicePartitionInfoInner> getPartitionInfoAsync(UUID partitionId) {
        return getPartitionInfoWithServiceResponseAsync(partitionId).map(new Func1<ServiceResponse<ServicePartitionInfoInner>, ServicePartitionInfoInner>() {
            @Override
            public ServicePartitionInfoInner call(ServiceResponse<ServicePartitionInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the information about a Service Fabric partition.
     * Gets the information about the specified partition. The response includes the partition ID, partitioning scheme information, keys supported by the partition, status, health, and other details about the partition.
     *
     * @param partitionId The identity of the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServicePartitionInfoInner object
     */
    public Observable<ServiceResponse<ServicePartitionInfoInner>> getPartitionInfoWithServiceResponseAsync(UUID partitionId) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.getPartitionInfo(partitionId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ServicePartitionInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<ServicePartitionInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ServicePartitionInfoInner> clientResponse = getPartitionInfoDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the information about a Service Fabric partition.
     * Gets the information about the specified partition. The response includes the partition ID, partitioning scheme information, keys supported by the partition, status, health, and other details about the partition.
     *
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ServicePartitionInfoInner object if successful.
     */
    public ServicePartitionInfoInner getPartitionInfo(UUID partitionId, Long timeout) {
        return getPartitionInfoWithServiceResponseAsync(partitionId, timeout).toBlocking().single().body();
    }

    /**
     * Gets the information about a Service Fabric partition.
     * Gets the information about the specified partition. The response includes the partition ID, partitioning scheme information, keys supported by the partition, status, health, and other details about the partition.
     *
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ServicePartitionInfoInner> getPartitionInfoAsync(UUID partitionId, Long timeout, final ServiceCallback<ServicePartitionInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getPartitionInfoWithServiceResponseAsync(partitionId, timeout), serviceCallback);
    }

    /**
     * Gets the information about a Service Fabric partition.
     * Gets the information about the specified partition. The response includes the partition ID, partitioning scheme information, keys supported by the partition, status, health, and other details about the partition.
     *
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServicePartitionInfoInner object
     */
    public Observable<ServicePartitionInfoInner> getPartitionInfoAsync(UUID partitionId, Long timeout) {
        return getPartitionInfoWithServiceResponseAsync(partitionId, timeout).map(new Func1<ServiceResponse<ServicePartitionInfoInner>, ServicePartitionInfoInner>() {
            @Override
            public ServicePartitionInfoInner call(ServiceResponse<ServicePartitionInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the information about a Service Fabric partition.
     * Gets the information about the specified partition. The response includes the partition ID, partitioning scheme information, keys supported by the partition, status, health, and other details about the partition.
     *
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServicePartitionInfoInner object
     */
    public Observable<ServiceResponse<ServicePartitionInfoInner>> getPartitionInfoWithServiceResponseAsync(UUID partitionId, Long timeout) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.getPartitionInfo(partitionId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ServicePartitionInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<ServicePartitionInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ServicePartitionInfoInner> clientResponse = getPartitionInfoDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ServicePartitionInfoInner> getPartitionInfoDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ServicePartitionInfoInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ServicePartitionInfoInner>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the name of the Service Fabric service for a partition.
     * Gets name of the service for the specified partition. A 404 error is returned if the partition ID does not exist in the cluster.
     *
     * @param partitionId The identity of the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ServiceNameInfoInner object if successful.
     */
    public ServiceNameInfoInner getServiceNameInfo(UUID partitionId) {
        return getServiceNameInfoWithServiceResponseAsync(partitionId).toBlocking().single().body();
    }

    /**
     * Gets the name of the Service Fabric service for a partition.
     * Gets name of the service for the specified partition. A 404 error is returned if the partition ID does not exist in the cluster.
     *
     * @param partitionId The identity of the partition.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ServiceNameInfoInner> getServiceNameInfoAsync(UUID partitionId, final ServiceCallback<ServiceNameInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getServiceNameInfoWithServiceResponseAsync(partitionId), serviceCallback);
    }

    /**
     * Gets the name of the Service Fabric service for a partition.
     * Gets name of the service for the specified partition. A 404 error is returned if the partition ID does not exist in the cluster.
     *
     * @param partitionId The identity of the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServiceNameInfoInner object
     */
    public Observable<ServiceNameInfoInner> getServiceNameInfoAsync(UUID partitionId) {
        return getServiceNameInfoWithServiceResponseAsync(partitionId).map(new Func1<ServiceResponse<ServiceNameInfoInner>, ServiceNameInfoInner>() {
            @Override
            public ServiceNameInfoInner call(ServiceResponse<ServiceNameInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the name of the Service Fabric service for a partition.
     * Gets name of the service for the specified partition. A 404 error is returned if the partition ID does not exist in the cluster.
     *
     * @param partitionId The identity of the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServiceNameInfoInner object
     */
    public Observable<ServiceResponse<ServiceNameInfoInner>> getServiceNameInfoWithServiceResponseAsync(UUID partitionId) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.getServiceNameInfo(partitionId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ServiceNameInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<ServiceNameInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ServiceNameInfoInner> clientResponse = getServiceNameInfoDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the name of the Service Fabric service for a partition.
     * Gets name of the service for the specified partition. A 404 error is returned if the partition ID does not exist in the cluster.
     *
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ServiceNameInfoInner object if successful.
     */
    public ServiceNameInfoInner getServiceNameInfo(UUID partitionId, Long timeout) {
        return getServiceNameInfoWithServiceResponseAsync(partitionId, timeout).toBlocking().single().body();
    }

    /**
     * Gets the name of the Service Fabric service for a partition.
     * Gets name of the service for the specified partition. A 404 error is returned if the partition ID does not exist in the cluster.
     *
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ServiceNameInfoInner> getServiceNameInfoAsync(UUID partitionId, Long timeout, final ServiceCallback<ServiceNameInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getServiceNameInfoWithServiceResponseAsync(partitionId, timeout), serviceCallback);
    }

    /**
     * Gets the name of the Service Fabric service for a partition.
     * Gets name of the service for the specified partition. A 404 error is returned if the partition ID does not exist in the cluster.
     *
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServiceNameInfoInner object
     */
    public Observable<ServiceNameInfoInner> getServiceNameInfoAsync(UUID partitionId, Long timeout) {
        return getServiceNameInfoWithServiceResponseAsync(partitionId, timeout).map(new Func1<ServiceResponse<ServiceNameInfoInner>, ServiceNameInfoInner>() {
            @Override
            public ServiceNameInfoInner call(ServiceResponse<ServiceNameInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the name of the Service Fabric service for a partition.
     * Gets name of the service for the specified partition. A 404 error is returned if the partition ID does not exist in the cluster.
     *
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServiceNameInfoInner object
     */
    public Observable<ServiceResponse<ServiceNameInfoInner>> getServiceNameInfoWithServiceResponseAsync(UUID partitionId, Long timeout) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.getServiceNameInfo(partitionId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ServiceNameInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<ServiceNameInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ServiceNameInfoInner> clientResponse = getServiceNameInfoDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ServiceNameInfoInner> getServiceNameInfoDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ServiceNameInfoInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ServiceNameInfoInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the health of the specified Service Fabric partition.
     * Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.
     Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState objects on the partition.
     If you specify a partition that does not exist in the health store, this request returns an error.
     *
     * @param partitionId The identity of the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PartitionHealthInner object if successful.
     */
    public PartitionHealthInner getPartitionHealth(UUID partitionId) {
        return getPartitionHealthWithServiceResponseAsync(partitionId).toBlocking().single().body();
    }

    /**
     * Gets the health of the specified Service Fabric partition.
     * Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.
     Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState objects on the partition.
     If you specify a partition that does not exist in the health store, this request returns an error.
     *
     * @param partitionId The identity of the partition.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PartitionHealthInner> getPartitionHealthAsync(UUID partitionId, final ServiceCallback<PartitionHealthInner> serviceCallback) {
        return ServiceFuture.fromResponse(getPartitionHealthWithServiceResponseAsync(partitionId), serviceCallback);
    }

    /**
     * Gets the health of the specified Service Fabric partition.
     * Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.
     Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState objects on the partition.
     If you specify a partition that does not exist in the health store, this request returns an error.
     *
     * @param partitionId The identity of the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PartitionHealthInner object
     */
    public Observable<PartitionHealthInner> getPartitionHealthAsync(UUID partitionId) {
        return getPartitionHealthWithServiceResponseAsync(partitionId).map(new Func1<ServiceResponse<PartitionHealthInner>, PartitionHealthInner>() {
            @Override
            public PartitionHealthInner call(ServiceResponse<PartitionHealthInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the health of the specified Service Fabric partition.
     * Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.
     Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState objects on the partition.
     If you specify a partition that does not exist in the health store, this request returns an error.
     *
     * @param partitionId The identity of the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PartitionHealthInner object
     */
    public Observable<ServiceResponse<PartitionHealthInner>> getPartitionHealthWithServiceResponseAsync(UUID partitionId) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Integer eventsHealthStateFilter = null;
        final Integer replicasHealthStateFilter = null;
        final Boolean excludeHealthStatistics = null;
        final Long timeout = null;
        return service.getPartitionHealth(partitionId, apiVersion, eventsHealthStateFilter, replicasHealthStateFilter, excludeHealthStatistics, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PartitionHealthInner>>>() {
                @Override
                public Observable<ServiceResponse<PartitionHealthInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PartitionHealthInner> clientResponse = getPartitionHealthDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the health of the specified Service Fabric partition.
     * Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.
     Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState objects on the partition.
     If you specify a partition that does not exist in the health store, this request returns an error.
     *
     * @param partitionId The identity of the partition.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param replicasHealthStateFilter Allows filtering the collection of ReplicaHealthState objects on the partition. The value can be obtained from members or bitwise operations on members of HealthStateFilter. Only replicas that match the filter will be returned. All replicas will be used to evaluate the aggregated health state. If not specified, all entries will be returned.The state values are flag-based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) will be returned. The possible values for this parameter include integer value of one of the following health states.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param excludeHealthStatistics Indicates whether the health statistics should be returned as part of the query result. False by default.
     The statistics show the number of children entities in health state Ok, Warning, and Error.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PartitionHealthInner object if successful.
     */
    public PartitionHealthInner getPartitionHealth(UUID partitionId, Integer eventsHealthStateFilter, Integer replicasHealthStateFilter, Boolean excludeHealthStatistics, Long timeout) {
        return getPartitionHealthWithServiceResponseAsync(partitionId, eventsHealthStateFilter, replicasHealthStateFilter, excludeHealthStatistics, timeout).toBlocking().single().body();
    }

    /**
     * Gets the health of the specified Service Fabric partition.
     * Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.
     Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState objects on the partition.
     If you specify a partition that does not exist in the health store, this request returns an error.
     *
     * @param partitionId The identity of the partition.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param replicasHealthStateFilter Allows filtering the collection of ReplicaHealthState objects on the partition. The value can be obtained from members or bitwise operations on members of HealthStateFilter. Only replicas that match the filter will be returned. All replicas will be used to evaluate the aggregated health state. If not specified, all entries will be returned.The state values are flag-based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) will be returned. The possible values for this parameter include integer value of one of the following health states.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param excludeHealthStatistics Indicates whether the health statistics should be returned as part of the query result. False by default.
     The statistics show the number of children entities in health state Ok, Warning, and Error.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PartitionHealthInner> getPartitionHealthAsync(UUID partitionId, Integer eventsHealthStateFilter, Integer replicasHealthStateFilter, Boolean excludeHealthStatistics, Long timeout, final ServiceCallback<PartitionHealthInner> serviceCallback) {
        return ServiceFuture.fromResponse(getPartitionHealthWithServiceResponseAsync(partitionId, eventsHealthStateFilter, replicasHealthStateFilter, excludeHealthStatistics, timeout), serviceCallback);
    }

    /**
     * Gets the health of the specified Service Fabric partition.
     * Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.
     Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState objects on the partition.
     If you specify a partition that does not exist in the health store, this request returns an error.
     *
     * @param partitionId The identity of the partition.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param replicasHealthStateFilter Allows filtering the collection of ReplicaHealthState objects on the partition. The value can be obtained from members or bitwise operations on members of HealthStateFilter. Only replicas that match the filter will be returned. All replicas will be used to evaluate the aggregated health state. If not specified, all entries will be returned.The state values are flag-based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) will be returned. The possible values for this parameter include integer value of one of the following health states.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param excludeHealthStatistics Indicates whether the health statistics should be returned as part of the query result. False by default.
     The statistics show the number of children entities in health state Ok, Warning, and Error.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PartitionHealthInner object
     */
    public Observable<PartitionHealthInner> getPartitionHealthAsync(UUID partitionId, Integer eventsHealthStateFilter, Integer replicasHealthStateFilter, Boolean excludeHealthStatistics, Long timeout) {
        return getPartitionHealthWithServiceResponseAsync(partitionId, eventsHealthStateFilter, replicasHealthStateFilter, excludeHealthStatistics, timeout).map(new Func1<ServiceResponse<PartitionHealthInner>, PartitionHealthInner>() {
            @Override
            public PartitionHealthInner call(ServiceResponse<PartitionHealthInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the health of the specified Service Fabric partition.
     * Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.
     Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState objects on the partition.
     If you specify a partition that does not exist in the health store, this request returns an error.
     *
     * @param partitionId The identity of the partition.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param replicasHealthStateFilter Allows filtering the collection of ReplicaHealthState objects on the partition. The value can be obtained from members or bitwise operations on members of HealthStateFilter. Only replicas that match the filter will be returned. All replicas will be used to evaluate the aggregated health state. If not specified, all entries will be returned.The state values are flag-based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) will be returned. The possible values for this parameter include integer value of one of the following health states.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param excludeHealthStatistics Indicates whether the health statistics should be returned as part of the query result. False by default.
     The statistics show the number of children entities in health state Ok, Warning, and Error.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PartitionHealthInner object
     */
    public Observable<ServiceResponse<PartitionHealthInner>> getPartitionHealthWithServiceResponseAsync(UUID partitionId, Integer eventsHealthStateFilter, Integer replicasHealthStateFilter, Boolean excludeHealthStatistics, Long timeout) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.getPartitionHealth(partitionId, apiVersion, eventsHealthStateFilter, replicasHealthStateFilter, excludeHealthStatistics, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PartitionHealthInner>>>() {
                @Override
                public Observable<ServiceResponse<PartitionHealthInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PartitionHealthInner> clientResponse = getPartitionHealthDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PartitionHealthInner> getPartitionHealthDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<PartitionHealthInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PartitionHealthInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the health of the specified Service Fabric partition, by using the specified health policy.
     * Gets the health information of the specified partition.
     If the application health policy is specified, the health evaluation uses it to get the aggregated health state.
     If the policy is not specified, the health evaluation uses the application health policy defined in the application manifest, or the default health policy, if no policy is defined in the manifest.
     Use EventsHealthStateFilter to filter the collection of health events reported on the partition based on the health state.
     Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState objects on the partition. Use ApplicationHealthPolicy in the POST body to override the health policies used to evaluate the health.
     If you specify a partition that does not exist in the health store, this request returns an error.
     *
     * @param partitionId The identity of the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PartitionHealthInner object if successful.
     */
    public PartitionHealthInner getPartitionHealthUsingPolicy(UUID partitionId) {
        return getPartitionHealthUsingPolicyWithServiceResponseAsync(partitionId).toBlocking().single().body();
    }

    /**
     * Gets the health of the specified Service Fabric partition, by using the specified health policy.
     * Gets the health information of the specified partition.
     If the application health policy is specified, the health evaluation uses it to get the aggregated health state.
     If the policy is not specified, the health evaluation uses the application health policy defined in the application manifest, or the default health policy, if no policy is defined in the manifest.
     Use EventsHealthStateFilter to filter the collection of health events reported on the partition based on the health state.
     Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState objects on the partition. Use ApplicationHealthPolicy in the POST body to override the health policies used to evaluate the health.
     If you specify a partition that does not exist in the health store, this request returns an error.
     *
     * @param partitionId The identity of the partition.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PartitionHealthInner> getPartitionHealthUsingPolicyAsync(UUID partitionId, final ServiceCallback<PartitionHealthInner> serviceCallback) {
        return ServiceFuture.fromResponse(getPartitionHealthUsingPolicyWithServiceResponseAsync(partitionId), serviceCallback);
    }

    /**
     * Gets the health of the specified Service Fabric partition, by using the specified health policy.
     * Gets the health information of the specified partition.
     If the application health policy is specified, the health evaluation uses it to get the aggregated health state.
     If the policy is not specified, the health evaluation uses the application health policy defined in the application manifest, or the default health policy, if no policy is defined in the manifest.
     Use EventsHealthStateFilter to filter the collection of health events reported on the partition based on the health state.
     Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState objects on the partition. Use ApplicationHealthPolicy in the POST body to override the health policies used to evaluate the health.
     If you specify a partition that does not exist in the health store, this request returns an error.
     *
     * @param partitionId The identity of the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PartitionHealthInner object
     */
    public Observable<PartitionHealthInner> getPartitionHealthUsingPolicyAsync(UUID partitionId) {
        return getPartitionHealthUsingPolicyWithServiceResponseAsync(partitionId).map(new Func1<ServiceResponse<PartitionHealthInner>, PartitionHealthInner>() {
            @Override
            public PartitionHealthInner call(ServiceResponse<PartitionHealthInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the health of the specified Service Fabric partition, by using the specified health policy.
     * Gets the health information of the specified partition.
     If the application health policy is specified, the health evaluation uses it to get the aggregated health state.
     If the policy is not specified, the health evaluation uses the application health policy defined in the application manifest, or the default health policy, if no policy is defined in the manifest.
     Use EventsHealthStateFilter to filter the collection of health events reported on the partition based on the health state.
     Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState objects on the partition. Use ApplicationHealthPolicy in the POST body to override the health policies used to evaluate the health.
     If you specify a partition that does not exist in the health store, this request returns an error.
     *
     * @param partitionId The identity of the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PartitionHealthInner object
     */
    public Observable<ServiceResponse<PartitionHealthInner>> getPartitionHealthUsingPolicyWithServiceResponseAsync(UUID partitionId) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Integer eventsHealthStateFilter = null;
        final Integer replicasHealthStateFilter = null;
        final ApplicationHealthPolicy applicationHealthPolicy = null;
        final Boolean excludeHealthStatistics = null;
        final Long timeout = null;
        return service.getPartitionHealthUsingPolicy(partitionId, apiVersion, eventsHealthStateFilter, replicasHealthStateFilter, applicationHealthPolicy, excludeHealthStatistics, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PartitionHealthInner>>>() {
                @Override
                public Observable<ServiceResponse<PartitionHealthInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PartitionHealthInner> clientResponse = getPartitionHealthUsingPolicyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the health of the specified Service Fabric partition, by using the specified health policy.
     * Gets the health information of the specified partition.
     If the application health policy is specified, the health evaluation uses it to get the aggregated health state.
     If the policy is not specified, the health evaluation uses the application health policy defined in the application manifest, or the default health policy, if no policy is defined in the manifest.
     Use EventsHealthStateFilter to filter the collection of health events reported on the partition based on the health state.
     Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState objects on the partition. Use ApplicationHealthPolicy in the POST body to override the health policies used to evaluate the health.
     If you specify a partition that does not exist in the health store, this request returns an error.
     *
     * @param partitionId The identity of the partition.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param replicasHealthStateFilter Allows filtering the collection of ReplicaHealthState objects on the partition. The value can be obtained from members or bitwise operations on members of HealthStateFilter. Only replicas that match the filter will be returned. All replicas will be used to evaluate the aggregated health state. If not specified, all entries will be returned.The state values are flag-based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) will be returned. The possible values for this parameter include integer value of one of the following health states.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param applicationHealthPolicy Describes the health policies used to evaluate the health of an application or one of its children.
     If not present, the health evaluation uses the health policy from application manifest or the default health policy.
     * @param excludeHealthStatistics Indicates whether the health statistics should be returned as part of the query result. False by default.
     The statistics show the number of children entities in health state Ok, Warning, and Error.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PartitionHealthInner object if successful.
     */
    public PartitionHealthInner getPartitionHealthUsingPolicy(UUID partitionId, Integer eventsHealthStateFilter, Integer replicasHealthStateFilter, ApplicationHealthPolicy applicationHealthPolicy, Boolean excludeHealthStatistics, Long timeout) {
        return getPartitionHealthUsingPolicyWithServiceResponseAsync(partitionId, eventsHealthStateFilter, replicasHealthStateFilter, applicationHealthPolicy, excludeHealthStatistics, timeout).toBlocking().single().body();
    }

    /**
     * Gets the health of the specified Service Fabric partition, by using the specified health policy.
     * Gets the health information of the specified partition.
     If the application health policy is specified, the health evaluation uses it to get the aggregated health state.
     If the policy is not specified, the health evaluation uses the application health policy defined in the application manifest, or the default health policy, if no policy is defined in the manifest.
     Use EventsHealthStateFilter to filter the collection of health events reported on the partition based on the health state.
     Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState objects on the partition. Use ApplicationHealthPolicy in the POST body to override the health policies used to evaluate the health.
     If you specify a partition that does not exist in the health store, this request returns an error.
     *
     * @param partitionId The identity of the partition.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param replicasHealthStateFilter Allows filtering the collection of ReplicaHealthState objects on the partition. The value can be obtained from members or bitwise operations on members of HealthStateFilter. Only replicas that match the filter will be returned. All replicas will be used to evaluate the aggregated health state. If not specified, all entries will be returned.The state values are flag-based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) will be returned. The possible values for this parameter include integer value of one of the following health states.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param applicationHealthPolicy Describes the health policies used to evaluate the health of an application or one of its children.
     If not present, the health evaluation uses the health policy from application manifest or the default health policy.
     * @param excludeHealthStatistics Indicates whether the health statistics should be returned as part of the query result. False by default.
     The statistics show the number of children entities in health state Ok, Warning, and Error.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PartitionHealthInner> getPartitionHealthUsingPolicyAsync(UUID partitionId, Integer eventsHealthStateFilter, Integer replicasHealthStateFilter, ApplicationHealthPolicy applicationHealthPolicy, Boolean excludeHealthStatistics, Long timeout, final ServiceCallback<PartitionHealthInner> serviceCallback) {
        return ServiceFuture.fromResponse(getPartitionHealthUsingPolicyWithServiceResponseAsync(partitionId, eventsHealthStateFilter, replicasHealthStateFilter, applicationHealthPolicy, excludeHealthStatistics, timeout), serviceCallback);
    }

    /**
     * Gets the health of the specified Service Fabric partition, by using the specified health policy.
     * Gets the health information of the specified partition.
     If the application health policy is specified, the health evaluation uses it to get the aggregated health state.
     If the policy is not specified, the health evaluation uses the application health policy defined in the application manifest, or the default health policy, if no policy is defined in the manifest.
     Use EventsHealthStateFilter to filter the collection of health events reported on the partition based on the health state.
     Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState objects on the partition. Use ApplicationHealthPolicy in the POST body to override the health policies used to evaluate the health.
     If you specify a partition that does not exist in the health store, this request returns an error.
     *
     * @param partitionId The identity of the partition.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param replicasHealthStateFilter Allows filtering the collection of ReplicaHealthState objects on the partition. The value can be obtained from members or bitwise operations on members of HealthStateFilter. Only replicas that match the filter will be returned. All replicas will be used to evaluate the aggregated health state. If not specified, all entries will be returned.The state values are flag-based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) will be returned. The possible values for this parameter include integer value of one of the following health states.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param applicationHealthPolicy Describes the health policies used to evaluate the health of an application or one of its children.
     If not present, the health evaluation uses the health policy from application manifest or the default health policy.
     * @param excludeHealthStatistics Indicates whether the health statistics should be returned as part of the query result. False by default.
     The statistics show the number of children entities in health state Ok, Warning, and Error.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PartitionHealthInner object
     */
    public Observable<PartitionHealthInner> getPartitionHealthUsingPolicyAsync(UUID partitionId, Integer eventsHealthStateFilter, Integer replicasHealthStateFilter, ApplicationHealthPolicy applicationHealthPolicy, Boolean excludeHealthStatistics, Long timeout) {
        return getPartitionHealthUsingPolicyWithServiceResponseAsync(partitionId, eventsHealthStateFilter, replicasHealthStateFilter, applicationHealthPolicy, excludeHealthStatistics, timeout).map(new Func1<ServiceResponse<PartitionHealthInner>, PartitionHealthInner>() {
            @Override
            public PartitionHealthInner call(ServiceResponse<PartitionHealthInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the health of the specified Service Fabric partition, by using the specified health policy.
     * Gets the health information of the specified partition.
     If the application health policy is specified, the health evaluation uses it to get the aggregated health state.
     If the policy is not specified, the health evaluation uses the application health policy defined in the application manifest, or the default health policy, if no policy is defined in the manifest.
     Use EventsHealthStateFilter to filter the collection of health events reported on the partition based on the health state.
     Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState objects on the partition. Use ApplicationHealthPolicy in the POST body to override the health policies used to evaluate the health.
     If you specify a partition that does not exist in the health store, this request returns an error.
     *
     * @param partitionId The identity of the partition.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param replicasHealthStateFilter Allows filtering the collection of ReplicaHealthState objects on the partition. The value can be obtained from members or bitwise operations on members of HealthStateFilter. Only replicas that match the filter will be returned. All replicas will be used to evaluate the aggregated health state. If not specified, all entries will be returned.The state values are flag-based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) will be returned. The possible values for this parameter include integer value of one of the following health states.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param applicationHealthPolicy Describes the health policies used to evaluate the health of an application or one of its children.
     If not present, the health evaluation uses the health policy from application manifest or the default health policy.
     * @param excludeHealthStatistics Indicates whether the health statistics should be returned as part of the query result. False by default.
     The statistics show the number of children entities in health state Ok, Warning, and Error.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PartitionHealthInner object
     */
    public Observable<ServiceResponse<PartitionHealthInner>> getPartitionHealthUsingPolicyWithServiceResponseAsync(UUID partitionId, Integer eventsHealthStateFilter, Integer replicasHealthStateFilter, ApplicationHealthPolicy applicationHealthPolicy, Boolean excludeHealthStatistics, Long timeout) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        Validator.validate(applicationHealthPolicy);
        final String apiVersion = "6.0";
        return service.getPartitionHealthUsingPolicy(partitionId, apiVersion, eventsHealthStateFilter, replicasHealthStateFilter, applicationHealthPolicy, excludeHealthStatistics, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PartitionHealthInner>>>() {
                @Override
                public Observable<ServiceResponse<PartitionHealthInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PartitionHealthInner> clientResponse = getPartitionHealthUsingPolicyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PartitionHealthInner> getPartitionHealthUsingPolicyDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<PartitionHealthInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PartitionHealthInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Sends a health report on the Service Fabric partition.
     * Reports health state of the specified Service Fabric partition. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway Partition, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, run GetPartitionHealth and check that the report appears in the HealthEvents section.
     *
     * @param partitionId The identity of the partition.
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void reportPartitionHealth(UUID partitionId, HealthInformation healthInformation) {
        reportPartitionHealthWithServiceResponseAsync(partitionId, healthInformation).toBlocking().single().body();
    }

    /**
     * Sends a health report on the Service Fabric partition.
     * Reports health state of the specified Service Fabric partition. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway Partition, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, run GetPartitionHealth and check that the report appears in the HealthEvents section.
     *
     * @param partitionId The identity of the partition.
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> reportPartitionHealthAsync(UUID partitionId, HealthInformation healthInformation, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(reportPartitionHealthWithServiceResponseAsync(partitionId, healthInformation), serviceCallback);
    }

    /**
     * Sends a health report on the Service Fabric partition.
     * Reports health state of the specified Service Fabric partition. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway Partition, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, run GetPartitionHealth and check that the report appears in the HealthEvents section.
     *
     * @param partitionId The identity of the partition.
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> reportPartitionHealthAsync(UUID partitionId, HealthInformation healthInformation) {
        return reportPartitionHealthWithServiceResponseAsync(partitionId, healthInformation).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Sends a health report on the Service Fabric partition.
     * Reports health state of the specified Service Fabric partition. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway Partition, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, run GetPartitionHealth and check that the report appears in the HealthEvents section.
     *
     * @param partitionId The identity of the partition.
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> reportPartitionHealthWithServiceResponseAsync(UUID partitionId, HealthInformation healthInformation) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        if (healthInformation == null) {
            throw new IllegalArgumentException("Parameter healthInformation is required and cannot be null.");
        }
        Validator.validate(healthInformation);
        final String apiVersion = "6.0";
        final Boolean immediate = null;
        final Long timeout = null;
        return service.reportPartitionHealth(partitionId, apiVersion, healthInformation, immediate, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = reportPartitionHealthDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Sends a health report on the Service Fabric partition.
     * Reports health state of the specified Service Fabric partition. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway Partition, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, run GetPartitionHealth and check that the report appears in the HealthEvents section.
     *
     * @param partitionId The identity of the partition.
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @param immediate A flag that indicates whether the report should be sent immediately.
     A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
     If Immediate is set to true, the report is sent immediately from HTTP Gateway to the health store, regardless of the fabric client settings that the HTTP Gateway Application is using.
     This is useful for critical reports that should be sent as soon as possible.
     Depending on timing and other conditions, sending the report may still fail, for example if the HTTP Gateway is closed or the message doesn't reach the Gateway.
     If Immediate is set to false, the report is sent based on the health client settings from the HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
     This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
     By default, reports are not sent immediately.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void reportPartitionHealth(UUID partitionId, HealthInformation healthInformation, Boolean immediate, Long timeout) {
        reportPartitionHealthWithServiceResponseAsync(partitionId, healthInformation, immediate, timeout).toBlocking().single().body();
    }

    /**
     * Sends a health report on the Service Fabric partition.
     * Reports health state of the specified Service Fabric partition. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway Partition, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, run GetPartitionHealth and check that the report appears in the HealthEvents section.
     *
     * @param partitionId The identity of the partition.
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @param immediate A flag that indicates whether the report should be sent immediately.
     A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
     If Immediate is set to true, the report is sent immediately from HTTP Gateway to the health store, regardless of the fabric client settings that the HTTP Gateway Application is using.
     This is useful for critical reports that should be sent as soon as possible.
     Depending on timing and other conditions, sending the report may still fail, for example if the HTTP Gateway is closed or the message doesn't reach the Gateway.
     If Immediate is set to false, the report is sent based on the health client settings from the HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
     This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
     By default, reports are not sent immediately.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> reportPartitionHealthAsync(UUID partitionId, HealthInformation healthInformation, Boolean immediate, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(reportPartitionHealthWithServiceResponseAsync(partitionId, healthInformation, immediate, timeout), serviceCallback);
    }

    /**
     * Sends a health report on the Service Fabric partition.
     * Reports health state of the specified Service Fabric partition. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway Partition, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, run GetPartitionHealth and check that the report appears in the HealthEvents section.
     *
     * @param partitionId The identity of the partition.
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @param immediate A flag that indicates whether the report should be sent immediately.
     A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
     If Immediate is set to true, the report is sent immediately from HTTP Gateway to the health store, regardless of the fabric client settings that the HTTP Gateway Application is using.
     This is useful for critical reports that should be sent as soon as possible.
     Depending on timing and other conditions, sending the report may still fail, for example if the HTTP Gateway is closed or the message doesn't reach the Gateway.
     If Immediate is set to false, the report is sent based on the health client settings from the HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
     This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
     By default, reports are not sent immediately.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> reportPartitionHealthAsync(UUID partitionId, HealthInformation healthInformation, Boolean immediate, Long timeout) {
        return reportPartitionHealthWithServiceResponseAsync(partitionId, healthInformation, immediate, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Sends a health report on the Service Fabric partition.
     * Reports health state of the specified Service Fabric partition. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway Partition, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, run GetPartitionHealth and check that the report appears in the HealthEvents section.
     *
     * @param partitionId The identity of the partition.
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @param immediate A flag that indicates whether the report should be sent immediately.
     A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
     If Immediate is set to true, the report is sent immediately from HTTP Gateway to the health store, regardless of the fabric client settings that the HTTP Gateway Application is using.
     This is useful for critical reports that should be sent as soon as possible.
     Depending on timing and other conditions, sending the report may still fail, for example if the HTTP Gateway is closed or the message doesn't reach the Gateway.
     If Immediate is set to false, the report is sent based on the health client settings from the HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
     This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
     By default, reports are not sent immediately.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> reportPartitionHealthWithServiceResponseAsync(UUID partitionId, HealthInformation healthInformation, Boolean immediate, Long timeout) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        if (healthInformation == null) {
            throw new IllegalArgumentException("Parameter healthInformation is required and cannot be null.");
        }
        Validator.validate(healthInformation);
        final String apiVersion = "6.0";
        return service.reportPartitionHealth(partitionId, apiVersion, healthInformation, immediate, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = reportPartitionHealthDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> reportPartitionHealthDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the load information of the specified Service Fabric partition.
     * Returns information about the load of a specified partition.
     The response includes a list of load reports for a Service Fabric partition.
     Each report includes the load metric name, value, and last reported time in UTC.
     *
     * @param partitionId The identity of the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PartitionLoadInformationInner object if successful.
     */
    public PartitionLoadInformationInner getPartitionLoadInformation(UUID partitionId) {
        return getPartitionLoadInformationWithServiceResponseAsync(partitionId).toBlocking().single().body();
    }

    /**
     * Gets the load information of the specified Service Fabric partition.
     * Returns information about the load of a specified partition.
     The response includes a list of load reports for a Service Fabric partition.
     Each report includes the load metric name, value, and last reported time in UTC.
     *
     * @param partitionId The identity of the partition.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PartitionLoadInformationInner> getPartitionLoadInformationAsync(UUID partitionId, final ServiceCallback<PartitionLoadInformationInner> serviceCallback) {
        return ServiceFuture.fromResponse(getPartitionLoadInformationWithServiceResponseAsync(partitionId), serviceCallback);
    }

    /**
     * Gets the load information of the specified Service Fabric partition.
     * Returns information about the load of a specified partition.
     The response includes a list of load reports for a Service Fabric partition.
     Each report includes the load metric name, value, and last reported time in UTC.
     *
     * @param partitionId The identity of the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PartitionLoadInformationInner object
     */
    public Observable<PartitionLoadInformationInner> getPartitionLoadInformationAsync(UUID partitionId) {
        return getPartitionLoadInformationWithServiceResponseAsync(partitionId).map(new Func1<ServiceResponse<PartitionLoadInformationInner>, PartitionLoadInformationInner>() {
            @Override
            public PartitionLoadInformationInner call(ServiceResponse<PartitionLoadInformationInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the load information of the specified Service Fabric partition.
     * Returns information about the load of a specified partition.
     The response includes a list of load reports for a Service Fabric partition.
     Each report includes the load metric name, value, and last reported time in UTC.
     *
     * @param partitionId The identity of the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PartitionLoadInformationInner object
     */
    public Observable<ServiceResponse<PartitionLoadInformationInner>> getPartitionLoadInformationWithServiceResponseAsync(UUID partitionId) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.getPartitionLoadInformation(partitionId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PartitionLoadInformationInner>>>() {
                @Override
                public Observable<ServiceResponse<PartitionLoadInformationInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PartitionLoadInformationInner> clientResponse = getPartitionLoadInformationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the load information of the specified Service Fabric partition.
     * Returns information about the load of a specified partition.
     The response includes a list of load reports for a Service Fabric partition.
     Each report includes the load metric name, value, and last reported time in UTC.
     *
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PartitionLoadInformationInner object if successful.
     */
    public PartitionLoadInformationInner getPartitionLoadInformation(UUID partitionId, Long timeout) {
        return getPartitionLoadInformationWithServiceResponseAsync(partitionId, timeout).toBlocking().single().body();
    }

    /**
     * Gets the load information of the specified Service Fabric partition.
     * Returns information about the load of a specified partition.
     The response includes a list of load reports for a Service Fabric partition.
     Each report includes the load metric name, value, and last reported time in UTC.
     *
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PartitionLoadInformationInner> getPartitionLoadInformationAsync(UUID partitionId, Long timeout, final ServiceCallback<PartitionLoadInformationInner> serviceCallback) {
        return ServiceFuture.fromResponse(getPartitionLoadInformationWithServiceResponseAsync(partitionId, timeout), serviceCallback);
    }

    /**
     * Gets the load information of the specified Service Fabric partition.
     * Returns information about the load of a specified partition.
     The response includes a list of load reports for a Service Fabric partition.
     Each report includes the load metric name, value, and last reported time in UTC.
     *
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PartitionLoadInformationInner object
     */
    public Observable<PartitionLoadInformationInner> getPartitionLoadInformationAsync(UUID partitionId, Long timeout) {
        return getPartitionLoadInformationWithServiceResponseAsync(partitionId, timeout).map(new Func1<ServiceResponse<PartitionLoadInformationInner>, PartitionLoadInformationInner>() {
            @Override
            public PartitionLoadInformationInner call(ServiceResponse<PartitionLoadInformationInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the load information of the specified Service Fabric partition.
     * Returns information about the load of a specified partition.
     The response includes a list of load reports for a Service Fabric partition.
     Each report includes the load metric name, value, and last reported time in UTC.
     *
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PartitionLoadInformationInner object
     */
    public Observable<ServiceResponse<PartitionLoadInformationInner>> getPartitionLoadInformationWithServiceResponseAsync(UUID partitionId, Long timeout) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.getPartitionLoadInformation(partitionId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PartitionLoadInformationInner>>>() {
                @Override
                public Observable<ServiceResponse<PartitionLoadInformationInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PartitionLoadInformationInner> clientResponse = getPartitionLoadInformationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PartitionLoadInformationInner> getPartitionLoadInformationDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<PartitionLoadInformationInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PartitionLoadInformationInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Resets the current load of a Service Fabric partition.
     * Resets the current load of a Service Fabric partition to the default load for the service.
     *
     * @param partitionId The identity of the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void resetPartitionLoad(UUID partitionId) {
        resetPartitionLoadWithServiceResponseAsync(partitionId).toBlocking().single().body();
    }

    /**
     * Resets the current load of a Service Fabric partition.
     * Resets the current load of a Service Fabric partition to the default load for the service.
     *
     * @param partitionId The identity of the partition.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> resetPartitionLoadAsync(UUID partitionId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(resetPartitionLoadWithServiceResponseAsync(partitionId), serviceCallback);
    }

    /**
     * Resets the current load of a Service Fabric partition.
     * Resets the current load of a Service Fabric partition to the default load for the service.
     *
     * @param partitionId The identity of the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> resetPartitionLoadAsync(UUID partitionId) {
        return resetPartitionLoadWithServiceResponseAsync(partitionId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Resets the current load of a Service Fabric partition.
     * Resets the current load of a Service Fabric partition to the default load for the service.
     *
     * @param partitionId The identity of the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> resetPartitionLoadWithServiceResponseAsync(UUID partitionId) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.resetPartitionLoad(partitionId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = resetPartitionLoadDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Resets the current load of a Service Fabric partition.
     * Resets the current load of a Service Fabric partition to the default load for the service.
     *
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void resetPartitionLoad(UUID partitionId, Long timeout) {
        resetPartitionLoadWithServiceResponseAsync(partitionId, timeout).toBlocking().single().body();
    }

    /**
     * Resets the current load of a Service Fabric partition.
     * Resets the current load of a Service Fabric partition to the default load for the service.
     *
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> resetPartitionLoadAsync(UUID partitionId, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(resetPartitionLoadWithServiceResponseAsync(partitionId, timeout), serviceCallback);
    }

    /**
     * Resets the current load of a Service Fabric partition.
     * Resets the current load of a Service Fabric partition to the default load for the service.
     *
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> resetPartitionLoadAsync(UUID partitionId, Long timeout) {
        return resetPartitionLoadWithServiceResponseAsync(partitionId, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Resets the current load of a Service Fabric partition.
     * Resets the current load of a Service Fabric partition to the default load for the service.
     *
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> resetPartitionLoadWithServiceResponseAsync(UUID partitionId, Long timeout) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.resetPartitionLoad(partitionId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = resetPartitionLoadDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> resetPartitionLoadDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Indicates to the Service Fabric cluster that it should attempt to recover a specific partition that is currently stuck in quorum loss.
     * This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
     *
     * @param partitionId The identity of the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void recoverPartition(UUID partitionId) {
        recoverPartitionWithServiceResponseAsync(partitionId).toBlocking().single().body();
    }

    /**
     * Indicates to the Service Fabric cluster that it should attempt to recover a specific partition that is currently stuck in quorum loss.
     * This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
     *
     * @param partitionId The identity of the partition.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> recoverPartitionAsync(UUID partitionId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(recoverPartitionWithServiceResponseAsync(partitionId), serviceCallback);
    }

    /**
     * Indicates to the Service Fabric cluster that it should attempt to recover a specific partition that is currently stuck in quorum loss.
     * This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
     *
     * @param partitionId The identity of the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> recoverPartitionAsync(UUID partitionId) {
        return recoverPartitionWithServiceResponseAsync(partitionId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Indicates to the Service Fabric cluster that it should attempt to recover a specific partition that is currently stuck in quorum loss.
     * This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
     *
     * @param partitionId The identity of the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> recoverPartitionWithServiceResponseAsync(UUID partitionId) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.recoverPartition(partitionId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = recoverPartitionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Indicates to the Service Fabric cluster that it should attempt to recover a specific partition that is currently stuck in quorum loss.
     * This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
     *
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void recoverPartition(UUID partitionId, Long timeout) {
        recoverPartitionWithServiceResponseAsync(partitionId, timeout).toBlocking().single().body();
    }

    /**
     * Indicates to the Service Fabric cluster that it should attempt to recover a specific partition that is currently stuck in quorum loss.
     * This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
     *
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> recoverPartitionAsync(UUID partitionId, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(recoverPartitionWithServiceResponseAsync(partitionId, timeout), serviceCallback);
    }

    /**
     * Indicates to the Service Fabric cluster that it should attempt to recover a specific partition that is currently stuck in quorum loss.
     * This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
     *
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> recoverPartitionAsync(UUID partitionId, Long timeout) {
        return recoverPartitionWithServiceResponseAsync(partitionId, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Indicates to the Service Fabric cluster that it should attempt to recover a specific partition that is currently stuck in quorum loss.
     * This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
     *
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> recoverPartitionWithServiceResponseAsync(UUID partitionId, Long timeout) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.recoverPartition(partitionId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = recoverPartitionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> recoverPartitionDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Indicates to the Service Fabric cluster that it should attempt to recover the specified service that is currently stuck in quorum loss.
     * Indicates to the Service Fabric cluster that it should attempt to recover the specified service that is currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void recoverServicePartitions(String serviceId) {
        recoverServicePartitionsWithServiceResponseAsync(serviceId).toBlocking().single().body();
    }

    /**
     * Indicates to the Service Fabric cluster that it should attempt to recover the specified service that is currently stuck in quorum loss.
     * Indicates to the Service Fabric cluster that it should attempt to recover the specified service that is currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> recoverServicePartitionsAsync(String serviceId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(recoverServicePartitionsWithServiceResponseAsync(serviceId), serviceCallback);
    }

    /**
     * Indicates to the Service Fabric cluster that it should attempt to recover the specified service that is currently stuck in quorum loss.
     * Indicates to the Service Fabric cluster that it should attempt to recover the specified service that is currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> recoverServicePartitionsAsync(String serviceId) {
        return recoverServicePartitionsWithServiceResponseAsync(serviceId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Indicates to the Service Fabric cluster that it should attempt to recover the specified service that is currently stuck in quorum loss.
     * Indicates to the Service Fabric cluster that it should attempt to recover the specified service that is currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> recoverServicePartitionsWithServiceResponseAsync(String serviceId) {
        if (serviceId == null) {
            throw new IllegalArgumentException("Parameter serviceId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.recoverServicePartitions(serviceId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = recoverServicePartitionsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Indicates to the Service Fabric cluster that it should attempt to recover the specified service that is currently stuck in quorum loss.
     * Indicates to the Service Fabric cluster that it should attempt to recover the specified service that is currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void recoverServicePartitions(String serviceId, Long timeout) {
        recoverServicePartitionsWithServiceResponseAsync(serviceId, timeout).toBlocking().single().body();
    }

    /**
     * Indicates to the Service Fabric cluster that it should attempt to recover the specified service that is currently stuck in quorum loss.
     * Indicates to the Service Fabric cluster that it should attempt to recover the specified service that is currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> recoverServicePartitionsAsync(String serviceId, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(recoverServicePartitionsWithServiceResponseAsync(serviceId, timeout), serviceCallback);
    }

    /**
     * Indicates to the Service Fabric cluster that it should attempt to recover the specified service that is currently stuck in quorum loss.
     * Indicates to the Service Fabric cluster that it should attempt to recover the specified service that is currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> recoverServicePartitionsAsync(String serviceId, Long timeout) {
        return recoverServicePartitionsWithServiceResponseAsync(serviceId, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Indicates to the Service Fabric cluster that it should attempt to recover the specified service that is currently stuck in quorum loss.
     * Indicates to the Service Fabric cluster that it should attempt to recover the specified service that is currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> recoverServicePartitionsWithServiceResponseAsync(String serviceId, Long timeout) {
        if (serviceId == null) {
            throw new IllegalArgumentException("Parameter serviceId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.recoverServicePartitions(serviceId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = recoverServicePartitionsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> recoverServicePartitionsDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Indicates to the Service Fabric cluster that it should attempt to recover the system services that are currently stuck in quorum loss.
     * Indicates to the Service Fabric cluster that it should attempt to recover the system services that are currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void recoverSystemPartitions() {
        recoverSystemPartitionsWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Indicates to the Service Fabric cluster that it should attempt to recover the system services that are currently stuck in quorum loss.
     * Indicates to the Service Fabric cluster that it should attempt to recover the system services that are currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> recoverSystemPartitionsAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(recoverSystemPartitionsWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Indicates to the Service Fabric cluster that it should attempt to recover the system services that are currently stuck in quorum loss.
     * Indicates to the Service Fabric cluster that it should attempt to recover the system services that are currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> recoverSystemPartitionsAsync() {
        return recoverSystemPartitionsWithServiceResponseAsync().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Indicates to the Service Fabric cluster that it should attempt to recover the system services that are currently stuck in quorum loss.
     * Indicates to the Service Fabric cluster that it should attempt to recover the system services that are currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> recoverSystemPartitionsWithServiceResponseAsync() {
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.recoverSystemPartitions(apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = recoverSystemPartitionsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Indicates to the Service Fabric cluster that it should attempt to recover the system services that are currently stuck in quorum loss.
     * Indicates to the Service Fabric cluster that it should attempt to recover the system services that are currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void recoverSystemPartitions(Long timeout) {
        recoverSystemPartitionsWithServiceResponseAsync(timeout).toBlocking().single().body();
    }

    /**
     * Indicates to the Service Fabric cluster that it should attempt to recover the system services that are currently stuck in quorum loss.
     * Indicates to the Service Fabric cluster that it should attempt to recover the system services that are currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> recoverSystemPartitionsAsync(Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(recoverSystemPartitionsWithServiceResponseAsync(timeout), serviceCallback);
    }

    /**
     * Indicates to the Service Fabric cluster that it should attempt to recover the system services that are currently stuck in quorum loss.
     * Indicates to the Service Fabric cluster that it should attempt to recover the system services that are currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> recoverSystemPartitionsAsync(Long timeout) {
        return recoverSystemPartitionsWithServiceResponseAsync(timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Indicates to the Service Fabric cluster that it should attempt to recover the system services that are currently stuck in quorum loss.
     * Indicates to the Service Fabric cluster that it should attempt to recover the system services that are currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> recoverSystemPartitionsWithServiceResponseAsync(Long timeout) {
        final String apiVersion = "6.0";
        return service.recoverSystemPartitions(apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = recoverSystemPartitionsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> recoverSystemPartitionsDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Indicates to the Service Fabric cluster that it should attempt to recover any services (including system services) which are currently stuck in quorum loss.
     * This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void recoverAllPartitions() {
        recoverAllPartitionsWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Indicates to the Service Fabric cluster that it should attempt to recover any services (including system services) which are currently stuck in quorum loss.
     * This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> recoverAllPartitionsAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(recoverAllPartitionsWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Indicates to the Service Fabric cluster that it should attempt to recover any services (including system services) which are currently stuck in quorum loss.
     * This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> recoverAllPartitionsAsync() {
        return recoverAllPartitionsWithServiceResponseAsync().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Indicates to the Service Fabric cluster that it should attempt to recover any services (including system services) which are currently stuck in quorum loss.
     * This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> recoverAllPartitionsWithServiceResponseAsync() {
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.recoverAllPartitions(apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = recoverAllPartitionsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Indicates to the Service Fabric cluster that it should attempt to recover any services (including system services) which are currently stuck in quorum loss.
     * This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void recoverAllPartitions(Long timeout) {
        recoverAllPartitionsWithServiceResponseAsync(timeout).toBlocking().single().body();
    }

    /**
     * Indicates to the Service Fabric cluster that it should attempt to recover any services (including system services) which are currently stuck in quorum loss.
     * This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> recoverAllPartitionsAsync(Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(recoverAllPartitionsWithServiceResponseAsync(timeout), serviceCallback);
    }

    /**
     * Indicates to the Service Fabric cluster that it should attempt to recover any services (including system services) which are currently stuck in quorum loss.
     * This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> recoverAllPartitionsAsync(Long timeout) {
        return recoverAllPartitionsWithServiceResponseAsync(timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Indicates to the Service Fabric cluster that it should attempt to recover any services (including system services) which are currently stuck in quorum loss.
     * This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> recoverAllPartitionsWithServiceResponseAsync(Long timeout) {
        final String apiVersion = "6.0";
        return service.recoverAllPartitions(apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = recoverAllPartitionsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> recoverAllPartitionsDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Creates a new repair task.
     * For clusters that have the Repair Manager Service configured,
     this API provides a way to create repair tasks that run automatically or manually.
     For repair tasks that run automatically, an appropriate repair executor
     must be running for each repair action to run automatically.
     These are currently only available in specially-configured Azure Cloud Services.
     To create a manual repair task, provide the set of impacted node names and the
     expected impact. When the state of the created repair task changes to approved,
     you can safely perform repair actions on those nodes.
     This API supports the Service Fabric platform; it is not meant to be used directly from your code.
     *
     * @param repairTask Describes the repair task to be created or updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RepairTaskUpdateInfoInner object if successful.
     */
    public RepairTaskUpdateInfoInner createRepairTask(RepairTaskInner repairTask) {
        return createRepairTaskWithServiceResponseAsync(repairTask).toBlocking().single().body();
    }

    /**
     * Creates a new repair task.
     * For clusters that have the Repair Manager Service configured,
     this API provides a way to create repair tasks that run automatically or manually.
     For repair tasks that run automatically, an appropriate repair executor
     must be running for each repair action to run automatically.
     These are currently only available in specially-configured Azure Cloud Services.
     To create a manual repair task, provide the set of impacted node names and the
     expected impact. When the state of the created repair task changes to approved,
     you can safely perform repair actions on those nodes.
     This API supports the Service Fabric platform; it is not meant to be used directly from your code.
     *
     * @param repairTask Describes the repair task to be created or updated.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RepairTaskUpdateInfoInner> createRepairTaskAsync(RepairTaskInner repairTask, final ServiceCallback<RepairTaskUpdateInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(createRepairTaskWithServiceResponseAsync(repairTask), serviceCallback);
    }

    /**
     * Creates a new repair task.
     * For clusters that have the Repair Manager Service configured,
     this API provides a way to create repair tasks that run automatically or manually.
     For repair tasks that run automatically, an appropriate repair executor
     must be running for each repair action to run automatically.
     These are currently only available in specially-configured Azure Cloud Services.
     To create a manual repair task, provide the set of impacted node names and the
     expected impact. When the state of the created repair task changes to approved,
     you can safely perform repair actions on those nodes.
     This API supports the Service Fabric platform; it is not meant to be used directly from your code.
     *
     * @param repairTask Describes the repair task to be created or updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RepairTaskUpdateInfoInner object
     */
    public Observable<RepairTaskUpdateInfoInner> createRepairTaskAsync(RepairTaskInner repairTask) {
        return createRepairTaskWithServiceResponseAsync(repairTask).map(new Func1<ServiceResponse<RepairTaskUpdateInfoInner>, RepairTaskUpdateInfoInner>() {
            @Override
            public RepairTaskUpdateInfoInner call(ServiceResponse<RepairTaskUpdateInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new repair task.
     * For clusters that have the Repair Manager Service configured,
     this API provides a way to create repair tasks that run automatically or manually.
     For repair tasks that run automatically, an appropriate repair executor
     must be running for each repair action to run automatically.
     These are currently only available in specially-configured Azure Cloud Services.
     To create a manual repair task, provide the set of impacted node names and the
     expected impact. When the state of the created repair task changes to approved,
     you can safely perform repair actions on those nodes.
     This API supports the Service Fabric platform; it is not meant to be used directly from your code.
     *
     * @param repairTask Describes the repair task to be created or updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RepairTaskUpdateInfoInner object
     */
    public Observable<ServiceResponse<RepairTaskUpdateInfoInner>> createRepairTaskWithServiceResponseAsync(RepairTaskInner repairTask) {
        if (repairTask == null) {
            throw new IllegalArgumentException("Parameter repairTask is required and cannot be null.");
        }
        Validator.validate(repairTask);
        final String apiVersion = "6.0";
        return service.createRepairTask(apiVersion, repairTask, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RepairTaskUpdateInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<RepairTaskUpdateInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RepairTaskUpdateInfoInner> clientResponse = createRepairTaskDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RepairTaskUpdateInfoInner> createRepairTaskDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<RepairTaskUpdateInfoInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<RepairTaskUpdateInfoInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Requests the cancellation of the given repair task.
     * This API supports the Service Fabric platform; it is not meant to be used directly from your code.
     *
     * @param repairTaskCancelDescription Describes the repair task to be cancelled.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RepairTaskUpdateInfoInner object if successful.
     */
    public RepairTaskUpdateInfoInner cancelRepairTask(RepairTaskCancelDescription repairTaskCancelDescription) {
        return cancelRepairTaskWithServiceResponseAsync(repairTaskCancelDescription).toBlocking().single().body();
    }

    /**
     * Requests the cancellation of the given repair task.
     * This API supports the Service Fabric platform; it is not meant to be used directly from your code.
     *
     * @param repairTaskCancelDescription Describes the repair task to be cancelled.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RepairTaskUpdateInfoInner> cancelRepairTaskAsync(RepairTaskCancelDescription repairTaskCancelDescription, final ServiceCallback<RepairTaskUpdateInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(cancelRepairTaskWithServiceResponseAsync(repairTaskCancelDescription), serviceCallback);
    }

    /**
     * Requests the cancellation of the given repair task.
     * This API supports the Service Fabric platform; it is not meant to be used directly from your code.
     *
     * @param repairTaskCancelDescription Describes the repair task to be cancelled.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RepairTaskUpdateInfoInner object
     */
    public Observable<RepairTaskUpdateInfoInner> cancelRepairTaskAsync(RepairTaskCancelDescription repairTaskCancelDescription) {
        return cancelRepairTaskWithServiceResponseAsync(repairTaskCancelDescription).map(new Func1<ServiceResponse<RepairTaskUpdateInfoInner>, RepairTaskUpdateInfoInner>() {
            @Override
            public RepairTaskUpdateInfoInner call(ServiceResponse<RepairTaskUpdateInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Requests the cancellation of the given repair task.
     * This API supports the Service Fabric platform; it is not meant to be used directly from your code.
     *
     * @param repairTaskCancelDescription Describes the repair task to be cancelled.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RepairTaskUpdateInfoInner object
     */
    public Observable<ServiceResponse<RepairTaskUpdateInfoInner>> cancelRepairTaskWithServiceResponseAsync(RepairTaskCancelDescription repairTaskCancelDescription) {
        if (repairTaskCancelDescription == null) {
            throw new IllegalArgumentException("Parameter repairTaskCancelDescription is required and cannot be null.");
        }
        Validator.validate(repairTaskCancelDescription);
        final String apiVersion = "6.0";
        return service.cancelRepairTask(apiVersion, repairTaskCancelDescription, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RepairTaskUpdateInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<RepairTaskUpdateInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RepairTaskUpdateInfoInner> clientResponse = cancelRepairTaskDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RepairTaskUpdateInfoInner> cancelRepairTaskDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<RepairTaskUpdateInfoInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<RepairTaskUpdateInfoInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Deletes a completed repair task.
     * This API supports the Service Fabric platform; it is not meant to be used directly from your code.
     *
     * @param repairTaskDeleteDescription Describes the repair task to be deleted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteRepairTask(RepairTaskDeleteDescription repairTaskDeleteDescription) {
        deleteRepairTaskWithServiceResponseAsync(repairTaskDeleteDescription).toBlocking().single().body();
    }

    /**
     * Deletes a completed repair task.
     * This API supports the Service Fabric platform; it is not meant to be used directly from your code.
     *
     * @param repairTaskDeleteDescription Describes the repair task to be deleted.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteRepairTaskAsync(RepairTaskDeleteDescription repairTaskDeleteDescription, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteRepairTaskWithServiceResponseAsync(repairTaskDeleteDescription), serviceCallback);
    }

    /**
     * Deletes a completed repair task.
     * This API supports the Service Fabric platform; it is not meant to be used directly from your code.
     *
     * @param repairTaskDeleteDescription Describes the repair task to be deleted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteRepairTaskAsync(RepairTaskDeleteDescription repairTaskDeleteDescription) {
        return deleteRepairTaskWithServiceResponseAsync(repairTaskDeleteDescription).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a completed repair task.
     * This API supports the Service Fabric platform; it is not meant to be used directly from your code.
     *
     * @param repairTaskDeleteDescription Describes the repair task to be deleted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteRepairTaskWithServiceResponseAsync(RepairTaskDeleteDescription repairTaskDeleteDescription) {
        if (repairTaskDeleteDescription == null) {
            throw new IllegalArgumentException("Parameter repairTaskDeleteDescription is required and cannot be null.");
        }
        Validator.validate(repairTaskDeleteDescription);
        final String apiVersion = "6.0";
        return service.deleteRepairTask(apiVersion, repairTaskDeleteDescription, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteRepairTaskDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteRepairTaskDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets a list of repair tasks matching the given filters.
     * This API supports the Service Fabric platform; it is not meant to be used directly from your code.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;RepairTaskInner&gt; object if successful.
     */
    public List<RepairTaskInner> getRepairTaskList() {
        return getRepairTaskListWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets a list of repair tasks matching the given filters.
     * This API supports the Service Fabric platform; it is not meant to be used directly from your code.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<RepairTaskInner>> getRepairTaskListAsync(final ServiceCallback<List<RepairTaskInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getRepairTaskListWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets a list of repair tasks matching the given filters.
     * This API supports the Service Fabric platform; it is not meant to be used directly from your code.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RepairTaskInner&gt; object
     */
    public Observable<List<RepairTaskInner>> getRepairTaskListAsync() {
        return getRepairTaskListWithServiceResponseAsync().map(new Func1<ServiceResponse<List<RepairTaskInner>>, List<RepairTaskInner>>() {
            @Override
            public List<RepairTaskInner> call(ServiceResponse<List<RepairTaskInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of repair tasks matching the given filters.
     * This API supports the Service Fabric platform; it is not meant to be used directly from your code.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RepairTaskInner&gt; object
     */
    public Observable<ServiceResponse<List<RepairTaskInner>>> getRepairTaskListWithServiceResponseAsync() {
        final String apiVersion = "6.0";
        final String taskIdFilter = null;
        final Integer stateFilter = null;
        final String executorFilter = null;
        return service.getRepairTaskList(apiVersion, taskIdFilter, stateFilter, executorFilter, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<RepairTaskInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<RepairTaskInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<RepairTaskInner>> clientResponse = getRepairTaskListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets a list of repair tasks matching the given filters.
     * This API supports the Service Fabric platform; it is not meant to be used directly from your code.
     *
     * @param taskIdFilter The repair task ID prefix to be matched.
     * @param stateFilter A bitwise-OR of the following values, specifying which task states should be included in the result list.
     - 1 - Created
     - 2 - Claimed
     - 4 - Preparing
     - 8 - Approved
     - 16 - Executing
     - 32 - Restoring
     - 64 - Completed
     * @param executorFilter The name of the repair executor whose claimed tasks should be included in the list.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;RepairTaskInner&gt; object if successful.
     */
    public List<RepairTaskInner> getRepairTaskList(String taskIdFilter, Integer stateFilter, String executorFilter) {
        return getRepairTaskListWithServiceResponseAsync(taskIdFilter, stateFilter, executorFilter).toBlocking().single().body();
    }

    /**
     * Gets a list of repair tasks matching the given filters.
     * This API supports the Service Fabric platform; it is not meant to be used directly from your code.
     *
     * @param taskIdFilter The repair task ID prefix to be matched.
     * @param stateFilter A bitwise-OR of the following values, specifying which task states should be included in the result list.
     - 1 - Created
     - 2 - Claimed
     - 4 - Preparing
     - 8 - Approved
     - 16 - Executing
     - 32 - Restoring
     - 64 - Completed
     * @param executorFilter The name of the repair executor whose claimed tasks should be included in the list.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<RepairTaskInner>> getRepairTaskListAsync(String taskIdFilter, Integer stateFilter, String executorFilter, final ServiceCallback<List<RepairTaskInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getRepairTaskListWithServiceResponseAsync(taskIdFilter, stateFilter, executorFilter), serviceCallback);
    }

    /**
     * Gets a list of repair tasks matching the given filters.
     * This API supports the Service Fabric platform; it is not meant to be used directly from your code.
     *
     * @param taskIdFilter The repair task ID prefix to be matched.
     * @param stateFilter A bitwise-OR of the following values, specifying which task states should be included in the result list.
     - 1 - Created
     - 2 - Claimed
     - 4 - Preparing
     - 8 - Approved
     - 16 - Executing
     - 32 - Restoring
     - 64 - Completed
     * @param executorFilter The name of the repair executor whose claimed tasks should be included in the list.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RepairTaskInner&gt; object
     */
    public Observable<List<RepairTaskInner>> getRepairTaskListAsync(String taskIdFilter, Integer stateFilter, String executorFilter) {
        return getRepairTaskListWithServiceResponseAsync(taskIdFilter, stateFilter, executorFilter).map(new Func1<ServiceResponse<List<RepairTaskInner>>, List<RepairTaskInner>>() {
            @Override
            public List<RepairTaskInner> call(ServiceResponse<List<RepairTaskInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of repair tasks matching the given filters.
     * This API supports the Service Fabric platform; it is not meant to be used directly from your code.
     *
     * @param taskIdFilter The repair task ID prefix to be matched.
     * @param stateFilter A bitwise-OR of the following values, specifying which task states should be included in the result list.
     - 1 - Created
     - 2 - Claimed
     - 4 - Preparing
     - 8 - Approved
     - 16 - Executing
     - 32 - Restoring
     - 64 - Completed
     * @param executorFilter The name of the repair executor whose claimed tasks should be included in the list.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RepairTaskInner&gt; object
     */
    public Observable<ServiceResponse<List<RepairTaskInner>>> getRepairTaskListWithServiceResponseAsync(String taskIdFilter, Integer stateFilter, String executorFilter) {
        final String apiVersion = "6.0";
        return service.getRepairTaskList(apiVersion, taskIdFilter, stateFilter, executorFilter, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<RepairTaskInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<RepairTaskInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<RepairTaskInner>> clientResponse = getRepairTaskListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<RepairTaskInner>> getRepairTaskListDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException {
        return this.restClient().responseBuilderFactory().<List<RepairTaskInner>, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<RepairTaskInner>>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Forces the approval of the given repair task.
     * This API supports the Service Fabric platform; it is not meant to be used directly from your code.
     *
     * @param repairTaskApproveDescription Describes the repair task to be approved.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RepairTaskUpdateInfoInner object if successful.
     */
    public RepairTaskUpdateInfoInner forceApproveRepairTask(RepairTaskApproveDescription repairTaskApproveDescription) {
        return forceApproveRepairTaskWithServiceResponseAsync(repairTaskApproveDescription).toBlocking().single().body();
    }

    /**
     * Forces the approval of the given repair task.
     * This API supports the Service Fabric platform; it is not meant to be used directly from your code.
     *
     * @param repairTaskApproveDescription Describes the repair task to be approved.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RepairTaskUpdateInfoInner> forceApproveRepairTaskAsync(RepairTaskApproveDescription repairTaskApproveDescription, final ServiceCallback<RepairTaskUpdateInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(forceApproveRepairTaskWithServiceResponseAsync(repairTaskApproveDescription), serviceCallback);
    }

    /**
     * Forces the approval of the given repair task.
     * This API supports the Service Fabric platform; it is not meant to be used directly from your code.
     *
     * @param repairTaskApproveDescription Describes the repair task to be approved.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RepairTaskUpdateInfoInner object
     */
    public Observable<RepairTaskUpdateInfoInner> forceApproveRepairTaskAsync(RepairTaskApproveDescription repairTaskApproveDescription) {
        return forceApproveRepairTaskWithServiceResponseAsync(repairTaskApproveDescription).map(new Func1<ServiceResponse<RepairTaskUpdateInfoInner>, RepairTaskUpdateInfoInner>() {
            @Override
            public RepairTaskUpdateInfoInner call(ServiceResponse<RepairTaskUpdateInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Forces the approval of the given repair task.
     * This API supports the Service Fabric platform; it is not meant to be used directly from your code.
     *
     * @param repairTaskApproveDescription Describes the repair task to be approved.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RepairTaskUpdateInfoInner object
     */
    public Observable<ServiceResponse<RepairTaskUpdateInfoInner>> forceApproveRepairTaskWithServiceResponseAsync(RepairTaskApproveDescription repairTaskApproveDescription) {
        if (repairTaskApproveDescription == null) {
            throw new IllegalArgumentException("Parameter repairTaskApproveDescription is required and cannot be null.");
        }
        Validator.validate(repairTaskApproveDescription);
        final String apiVersion = "6.0";
        return service.forceApproveRepairTask(apiVersion, repairTaskApproveDescription, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RepairTaskUpdateInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<RepairTaskUpdateInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RepairTaskUpdateInfoInner> clientResponse = forceApproveRepairTaskDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RepairTaskUpdateInfoInner> forceApproveRepairTaskDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<RepairTaskUpdateInfoInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<RepairTaskUpdateInfoInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Updates the health policy of the given repair task.
     * This API supports the Service Fabric platform; it is not meant to be used directly from your code.
     *
     * @param repairTaskUpdateHealthPolicyDescription Describes the repair task healthy policy to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RepairTaskUpdateInfoInner object if successful.
     */
    public RepairTaskUpdateInfoInner updateRepairTaskHealthPolicy(RepairTaskUpdateHealthPolicyDescription repairTaskUpdateHealthPolicyDescription) {
        return updateRepairTaskHealthPolicyWithServiceResponseAsync(repairTaskUpdateHealthPolicyDescription).toBlocking().single().body();
    }

    /**
     * Updates the health policy of the given repair task.
     * This API supports the Service Fabric platform; it is not meant to be used directly from your code.
     *
     * @param repairTaskUpdateHealthPolicyDescription Describes the repair task healthy policy to be updated.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RepairTaskUpdateInfoInner> updateRepairTaskHealthPolicyAsync(RepairTaskUpdateHealthPolicyDescription repairTaskUpdateHealthPolicyDescription, final ServiceCallback<RepairTaskUpdateInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateRepairTaskHealthPolicyWithServiceResponseAsync(repairTaskUpdateHealthPolicyDescription), serviceCallback);
    }

    /**
     * Updates the health policy of the given repair task.
     * This API supports the Service Fabric platform; it is not meant to be used directly from your code.
     *
     * @param repairTaskUpdateHealthPolicyDescription Describes the repair task healthy policy to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RepairTaskUpdateInfoInner object
     */
    public Observable<RepairTaskUpdateInfoInner> updateRepairTaskHealthPolicyAsync(RepairTaskUpdateHealthPolicyDescription repairTaskUpdateHealthPolicyDescription) {
        return updateRepairTaskHealthPolicyWithServiceResponseAsync(repairTaskUpdateHealthPolicyDescription).map(new Func1<ServiceResponse<RepairTaskUpdateInfoInner>, RepairTaskUpdateInfoInner>() {
            @Override
            public RepairTaskUpdateInfoInner call(ServiceResponse<RepairTaskUpdateInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the health policy of the given repair task.
     * This API supports the Service Fabric platform; it is not meant to be used directly from your code.
     *
     * @param repairTaskUpdateHealthPolicyDescription Describes the repair task healthy policy to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RepairTaskUpdateInfoInner object
     */
    public Observable<ServiceResponse<RepairTaskUpdateInfoInner>> updateRepairTaskHealthPolicyWithServiceResponseAsync(RepairTaskUpdateHealthPolicyDescription repairTaskUpdateHealthPolicyDescription) {
        if (repairTaskUpdateHealthPolicyDescription == null) {
            throw new IllegalArgumentException("Parameter repairTaskUpdateHealthPolicyDescription is required and cannot be null.");
        }
        Validator.validate(repairTaskUpdateHealthPolicyDescription);
        final String apiVersion = "6.0";
        return service.updateRepairTaskHealthPolicy(apiVersion, repairTaskUpdateHealthPolicyDescription, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RepairTaskUpdateInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<RepairTaskUpdateInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RepairTaskUpdateInfoInner> clientResponse = updateRepairTaskHealthPolicyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RepairTaskUpdateInfoInner> updateRepairTaskHealthPolicyDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<RepairTaskUpdateInfoInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<RepairTaskUpdateInfoInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Updates the execution state of a repair task.
     * This API supports the Service Fabric platform; it is not meant to be used directly from your code.
     *
     * @param repairTask Describes the repair task to be created or updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RepairTaskUpdateInfoInner object if successful.
     */
    public RepairTaskUpdateInfoInner updateRepairExecutionState(RepairTaskInner repairTask) {
        return updateRepairExecutionStateWithServiceResponseAsync(repairTask).toBlocking().single().body();
    }

    /**
     * Updates the execution state of a repair task.
     * This API supports the Service Fabric platform; it is not meant to be used directly from your code.
     *
     * @param repairTask Describes the repair task to be created or updated.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RepairTaskUpdateInfoInner> updateRepairExecutionStateAsync(RepairTaskInner repairTask, final ServiceCallback<RepairTaskUpdateInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateRepairExecutionStateWithServiceResponseAsync(repairTask), serviceCallback);
    }

    /**
     * Updates the execution state of a repair task.
     * This API supports the Service Fabric platform; it is not meant to be used directly from your code.
     *
     * @param repairTask Describes the repair task to be created or updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RepairTaskUpdateInfoInner object
     */
    public Observable<RepairTaskUpdateInfoInner> updateRepairExecutionStateAsync(RepairTaskInner repairTask) {
        return updateRepairExecutionStateWithServiceResponseAsync(repairTask).map(new Func1<ServiceResponse<RepairTaskUpdateInfoInner>, RepairTaskUpdateInfoInner>() {
            @Override
            public RepairTaskUpdateInfoInner call(ServiceResponse<RepairTaskUpdateInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the execution state of a repair task.
     * This API supports the Service Fabric platform; it is not meant to be used directly from your code.
     *
     * @param repairTask Describes the repair task to be created or updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RepairTaskUpdateInfoInner object
     */
    public Observable<ServiceResponse<RepairTaskUpdateInfoInner>> updateRepairExecutionStateWithServiceResponseAsync(RepairTaskInner repairTask) {
        if (repairTask == null) {
            throw new IllegalArgumentException("Parameter repairTask is required and cannot be null.");
        }
        Validator.validate(repairTask);
        final String apiVersion = "6.0";
        return service.updateRepairExecutionState(apiVersion, repairTask, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RepairTaskUpdateInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<RepairTaskUpdateInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RepairTaskUpdateInfoInner> clientResponse = updateRepairExecutionStateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RepairTaskUpdateInfoInner> updateRepairExecutionStateDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<RepairTaskUpdateInfoInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<RepairTaskUpdateInfoInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the information about replicas of a Service Fabric service partition.
     * The GetReplicas endpoint returns information about the replicas of the specified partition. The response includes the ID, role, status, health, node name, uptime, and other details about the replica.
     *
     * @param partitionId The identity of the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedReplicaInfoListInner object if successful.
     */
    public PagedReplicaInfoListInner getReplicaInfoList(UUID partitionId) {
        return getReplicaInfoListWithServiceResponseAsync(partitionId).toBlocking().single().body();
    }

    /**
     * Gets the information about replicas of a Service Fabric service partition.
     * The GetReplicas endpoint returns information about the replicas of the specified partition. The response includes the ID, role, status, health, node name, uptime, and other details about the replica.
     *
     * @param partitionId The identity of the partition.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedReplicaInfoListInner> getReplicaInfoListAsync(UUID partitionId, final ServiceCallback<PagedReplicaInfoListInner> serviceCallback) {
        return ServiceFuture.fromResponse(getReplicaInfoListWithServiceResponseAsync(partitionId), serviceCallback);
    }

    /**
     * Gets the information about replicas of a Service Fabric service partition.
     * The GetReplicas endpoint returns information about the replicas of the specified partition. The response includes the ID, role, status, health, node name, uptime, and other details about the replica.
     *
     * @param partitionId The identity of the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedReplicaInfoListInner object
     */
    public Observable<PagedReplicaInfoListInner> getReplicaInfoListAsync(UUID partitionId) {
        return getReplicaInfoListWithServiceResponseAsync(partitionId).map(new Func1<ServiceResponse<PagedReplicaInfoListInner>, PagedReplicaInfoListInner>() {
            @Override
            public PagedReplicaInfoListInner call(ServiceResponse<PagedReplicaInfoListInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the information about replicas of a Service Fabric service partition.
     * The GetReplicas endpoint returns information about the replicas of the specified partition. The response includes the ID, role, status, health, node name, uptime, and other details about the replica.
     *
     * @param partitionId The identity of the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedReplicaInfoListInner object
     */
    public Observable<ServiceResponse<PagedReplicaInfoListInner>> getReplicaInfoListWithServiceResponseAsync(UUID partitionId) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final String continuationToken = null;
        final Long timeout = null;
        return service.getReplicaInfoList(partitionId, apiVersion, continuationToken, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedReplicaInfoListInner>>>() {
                @Override
                public Observable<ServiceResponse<PagedReplicaInfoListInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedReplicaInfoListInner> clientResponse = getReplicaInfoListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the information about replicas of a Service Fabric service partition.
     * The GetReplicas endpoint returns information about the replicas of the specified partition. The response includes the ID, role, status, health, node name, uptime, and other details about the replica.
     *
     * @param partitionId The identity of the partition.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedReplicaInfoListInner object if successful.
     */
    public PagedReplicaInfoListInner getReplicaInfoList(UUID partitionId, String continuationToken, Long timeout) {
        return getReplicaInfoListWithServiceResponseAsync(partitionId, continuationToken, timeout).toBlocking().single().body();
    }

    /**
     * Gets the information about replicas of a Service Fabric service partition.
     * The GetReplicas endpoint returns information about the replicas of the specified partition. The response includes the ID, role, status, health, node name, uptime, and other details about the replica.
     *
     * @param partitionId The identity of the partition.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedReplicaInfoListInner> getReplicaInfoListAsync(UUID partitionId, String continuationToken, Long timeout, final ServiceCallback<PagedReplicaInfoListInner> serviceCallback) {
        return ServiceFuture.fromResponse(getReplicaInfoListWithServiceResponseAsync(partitionId, continuationToken, timeout), serviceCallback);
    }

    /**
     * Gets the information about replicas of a Service Fabric service partition.
     * The GetReplicas endpoint returns information about the replicas of the specified partition. The response includes the ID, role, status, health, node name, uptime, and other details about the replica.
     *
     * @param partitionId The identity of the partition.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedReplicaInfoListInner object
     */
    public Observable<PagedReplicaInfoListInner> getReplicaInfoListAsync(UUID partitionId, String continuationToken, Long timeout) {
        return getReplicaInfoListWithServiceResponseAsync(partitionId, continuationToken, timeout).map(new Func1<ServiceResponse<PagedReplicaInfoListInner>, PagedReplicaInfoListInner>() {
            @Override
            public PagedReplicaInfoListInner call(ServiceResponse<PagedReplicaInfoListInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the information about replicas of a Service Fabric service partition.
     * The GetReplicas endpoint returns information about the replicas of the specified partition. The response includes the ID, role, status, health, node name, uptime, and other details about the replica.
     *
     * @param partitionId The identity of the partition.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedReplicaInfoListInner object
     */
    public Observable<ServiceResponse<PagedReplicaInfoListInner>> getReplicaInfoListWithServiceResponseAsync(UUID partitionId, String continuationToken, Long timeout) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.getReplicaInfoList(partitionId, apiVersion, continuationToken, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedReplicaInfoListInner>>>() {
                @Override
                public Observable<ServiceResponse<PagedReplicaInfoListInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedReplicaInfoListInner> clientResponse = getReplicaInfoListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PagedReplicaInfoListInner> getReplicaInfoListDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<PagedReplicaInfoListInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PagedReplicaInfoListInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the information about a replica of a Service Fabric partition.
     * The response includes the ID, role, status, health, node name, uptime, and other details about the replica.
     *
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ReplicaInfoInner object if successful.
     */
    public ReplicaInfoInner getReplicaInfo(UUID partitionId, String replicaId) {
        return getReplicaInfoWithServiceResponseAsync(partitionId, replicaId).toBlocking().single().body();
    }

    /**
     * Gets the information about a replica of a Service Fabric partition.
     * The response includes the ID, role, status, health, node name, uptime, and other details about the replica.
     *
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ReplicaInfoInner> getReplicaInfoAsync(UUID partitionId, String replicaId, final ServiceCallback<ReplicaInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getReplicaInfoWithServiceResponseAsync(partitionId, replicaId), serviceCallback);
    }

    /**
     * Gets the information about a replica of a Service Fabric partition.
     * The response includes the ID, role, status, health, node name, uptime, and other details about the replica.
     *
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ReplicaInfoInner object
     */
    public Observable<ReplicaInfoInner> getReplicaInfoAsync(UUID partitionId, String replicaId) {
        return getReplicaInfoWithServiceResponseAsync(partitionId, replicaId).map(new Func1<ServiceResponse<ReplicaInfoInner>, ReplicaInfoInner>() {
            @Override
            public ReplicaInfoInner call(ServiceResponse<ReplicaInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the information about a replica of a Service Fabric partition.
     * The response includes the ID, role, status, health, node name, uptime, and other details about the replica.
     *
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ReplicaInfoInner object
     */
    public Observable<ServiceResponse<ReplicaInfoInner>> getReplicaInfoWithServiceResponseAsync(UUID partitionId, String replicaId) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        if (replicaId == null) {
            throw new IllegalArgumentException("Parameter replicaId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.getReplicaInfo(partitionId, replicaId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ReplicaInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<ReplicaInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ReplicaInfoInner> clientResponse = getReplicaInfoDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the information about a replica of a Service Fabric partition.
     * The response includes the ID, role, status, health, node name, uptime, and other details about the replica.
     *
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ReplicaInfoInner object if successful.
     */
    public ReplicaInfoInner getReplicaInfo(UUID partitionId, String replicaId, Long timeout) {
        return getReplicaInfoWithServiceResponseAsync(partitionId, replicaId, timeout).toBlocking().single().body();
    }

    /**
     * Gets the information about a replica of a Service Fabric partition.
     * The response includes the ID, role, status, health, node name, uptime, and other details about the replica.
     *
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ReplicaInfoInner> getReplicaInfoAsync(UUID partitionId, String replicaId, Long timeout, final ServiceCallback<ReplicaInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getReplicaInfoWithServiceResponseAsync(partitionId, replicaId, timeout), serviceCallback);
    }

    /**
     * Gets the information about a replica of a Service Fabric partition.
     * The response includes the ID, role, status, health, node name, uptime, and other details about the replica.
     *
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ReplicaInfoInner object
     */
    public Observable<ReplicaInfoInner> getReplicaInfoAsync(UUID partitionId, String replicaId, Long timeout) {
        return getReplicaInfoWithServiceResponseAsync(partitionId, replicaId, timeout).map(new Func1<ServiceResponse<ReplicaInfoInner>, ReplicaInfoInner>() {
            @Override
            public ReplicaInfoInner call(ServiceResponse<ReplicaInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the information about a replica of a Service Fabric partition.
     * The response includes the ID, role, status, health, node name, uptime, and other details about the replica.
     *
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ReplicaInfoInner object
     */
    public Observable<ServiceResponse<ReplicaInfoInner>> getReplicaInfoWithServiceResponseAsync(UUID partitionId, String replicaId, Long timeout) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        if (replicaId == null) {
            throw new IllegalArgumentException("Parameter replicaId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.getReplicaInfo(partitionId, replicaId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ReplicaInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<ReplicaInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ReplicaInfoInner> clientResponse = getReplicaInfoDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ReplicaInfoInner> getReplicaInfoDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ReplicaInfoInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ReplicaInfoInner>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the health of a Service Fabric stateful service replica or stateless service instance.
     * Gets the health of a Service Fabric replica.
     Use EventsHealthStateFilter to filter the collection of health events reported on the replica based on the health state.
     *
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ReplicaHealthInner object if successful.
     */
    public ReplicaHealthInner getReplicaHealth(UUID partitionId, String replicaId) {
        return getReplicaHealthWithServiceResponseAsync(partitionId, replicaId).toBlocking().single().body();
    }

    /**
     * Gets the health of a Service Fabric stateful service replica or stateless service instance.
     * Gets the health of a Service Fabric replica.
     Use EventsHealthStateFilter to filter the collection of health events reported on the replica based on the health state.
     *
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ReplicaHealthInner> getReplicaHealthAsync(UUID partitionId, String replicaId, final ServiceCallback<ReplicaHealthInner> serviceCallback) {
        return ServiceFuture.fromResponse(getReplicaHealthWithServiceResponseAsync(partitionId, replicaId), serviceCallback);
    }

    /**
     * Gets the health of a Service Fabric stateful service replica or stateless service instance.
     * Gets the health of a Service Fabric replica.
     Use EventsHealthStateFilter to filter the collection of health events reported on the replica based on the health state.
     *
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ReplicaHealthInner object
     */
    public Observable<ReplicaHealthInner> getReplicaHealthAsync(UUID partitionId, String replicaId) {
        return getReplicaHealthWithServiceResponseAsync(partitionId, replicaId).map(new Func1<ServiceResponse<ReplicaHealthInner>, ReplicaHealthInner>() {
            @Override
            public ReplicaHealthInner call(ServiceResponse<ReplicaHealthInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the health of a Service Fabric stateful service replica or stateless service instance.
     * Gets the health of a Service Fabric replica.
     Use EventsHealthStateFilter to filter the collection of health events reported on the replica based on the health state.
     *
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ReplicaHealthInner object
     */
    public Observable<ServiceResponse<ReplicaHealthInner>> getReplicaHealthWithServiceResponseAsync(UUID partitionId, String replicaId) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        if (replicaId == null) {
            throw new IllegalArgumentException("Parameter replicaId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Integer eventsHealthStateFilter = null;
        final Long timeout = null;
        return service.getReplicaHealth(partitionId, replicaId, apiVersion, eventsHealthStateFilter, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ReplicaHealthInner>>>() {
                @Override
                public Observable<ServiceResponse<ReplicaHealthInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ReplicaHealthInner> clientResponse = getReplicaHealthDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the health of a Service Fabric stateful service replica or stateless service instance.
     * Gets the health of a Service Fabric replica.
     Use EventsHealthStateFilter to filter the collection of health events reported on the replica based on the health state.
     *
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ReplicaHealthInner object if successful.
     */
    public ReplicaHealthInner getReplicaHealth(UUID partitionId, String replicaId, Integer eventsHealthStateFilter, Long timeout) {
        return getReplicaHealthWithServiceResponseAsync(partitionId, replicaId, eventsHealthStateFilter, timeout).toBlocking().single().body();
    }

    /**
     * Gets the health of a Service Fabric stateful service replica or stateless service instance.
     * Gets the health of a Service Fabric replica.
     Use EventsHealthStateFilter to filter the collection of health events reported on the replica based on the health state.
     *
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ReplicaHealthInner> getReplicaHealthAsync(UUID partitionId, String replicaId, Integer eventsHealthStateFilter, Long timeout, final ServiceCallback<ReplicaHealthInner> serviceCallback) {
        return ServiceFuture.fromResponse(getReplicaHealthWithServiceResponseAsync(partitionId, replicaId, eventsHealthStateFilter, timeout), serviceCallback);
    }

    /**
     * Gets the health of a Service Fabric stateful service replica or stateless service instance.
     * Gets the health of a Service Fabric replica.
     Use EventsHealthStateFilter to filter the collection of health events reported on the replica based on the health state.
     *
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ReplicaHealthInner object
     */
    public Observable<ReplicaHealthInner> getReplicaHealthAsync(UUID partitionId, String replicaId, Integer eventsHealthStateFilter, Long timeout) {
        return getReplicaHealthWithServiceResponseAsync(partitionId, replicaId, eventsHealthStateFilter, timeout).map(new Func1<ServiceResponse<ReplicaHealthInner>, ReplicaHealthInner>() {
            @Override
            public ReplicaHealthInner call(ServiceResponse<ReplicaHealthInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the health of a Service Fabric stateful service replica or stateless service instance.
     * Gets the health of a Service Fabric replica.
     Use EventsHealthStateFilter to filter the collection of health events reported on the replica based on the health state.
     *
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ReplicaHealthInner object
     */
    public Observable<ServiceResponse<ReplicaHealthInner>> getReplicaHealthWithServiceResponseAsync(UUID partitionId, String replicaId, Integer eventsHealthStateFilter, Long timeout) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        if (replicaId == null) {
            throw new IllegalArgumentException("Parameter replicaId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.getReplicaHealth(partitionId, replicaId, apiVersion, eventsHealthStateFilter, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ReplicaHealthInner>>>() {
                @Override
                public Observable<ServiceResponse<ReplicaHealthInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ReplicaHealthInner> clientResponse = getReplicaHealthDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ReplicaHealthInner> getReplicaHealthDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ReplicaHealthInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ReplicaHealthInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the health of a Service Fabric stateful service replica or stateless service instance using the specified policy.
     * Gets the health of a Service Fabric stateful service replica or stateless service instance.
     Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.
     Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the replica.
     *
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ReplicaHealthInner object if successful.
     */
    public ReplicaHealthInner getReplicaHealthUsingPolicy(UUID partitionId, String replicaId) {
        return getReplicaHealthUsingPolicyWithServiceResponseAsync(partitionId, replicaId).toBlocking().single().body();
    }

    /**
     * Gets the health of a Service Fabric stateful service replica or stateless service instance using the specified policy.
     * Gets the health of a Service Fabric stateful service replica or stateless service instance.
     Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.
     Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the replica.
     *
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ReplicaHealthInner> getReplicaHealthUsingPolicyAsync(UUID partitionId, String replicaId, final ServiceCallback<ReplicaHealthInner> serviceCallback) {
        return ServiceFuture.fromResponse(getReplicaHealthUsingPolicyWithServiceResponseAsync(partitionId, replicaId), serviceCallback);
    }

    /**
     * Gets the health of a Service Fabric stateful service replica or stateless service instance using the specified policy.
     * Gets the health of a Service Fabric stateful service replica or stateless service instance.
     Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.
     Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the replica.
     *
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ReplicaHealthInner object
     */
    public Observable<ReplicaHealthInner> getReplicaHealthUsingPolicyAsync(UUID partitionId, String replicaId) {
        return getReplicaHealthUsingPolicyWithServiceResponseAsync(partitionId, replicaId).map(new Func1<ServiceResponse<ReplicaHealthInner>, ReplicaHealthInner>() {
            @Override
            public ReplicaHealthInner call(ServiceResponse<ReplicaHealthInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the health of a Service Fabric stateful service replica or stateless service instance using the specified policy.
     * Gets the health of a Service Fabric stateful service replica or stateless service instance.
     Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.
     Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the replica.
     *
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ReplicaHealthInner object
     */
    public Observable<ServiceResponse<ReplicaHealthInner>> getReplicaHealthUsingPolicyWithServiceResponseAsync(UUID partitionId, String replicaId) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        if (replicaId == null) {
            throw new IllegalArgumentException("Parameter replicaId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Integer eventsHealthStateFilter = null;
        final ApplicationHealthPolicy applicationHealthPolicy = null;
        final Long timeout = null;
        return service.getReplicaHealthUsingPolicy(partitionId, replicaId, apiVersion, eventsHealthStateFilter, applicationHealthPolicy, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ReplicaHealthInner>>>() {
                @Override
                public Observable<ServiceResponse<ReplicaHealthInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ReplicaHealthInner> clientResponse = getReplicaHealthUsingPolicyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the health of a Service Fabric stateful service replica or stateless service instance using the specified policy.
     * Gets the health of a Service Fabric stateful service replica or stateless service instance.
     Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.
     Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the replica.
     *
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param applicationHealthPolicy Describes the health policies used to evaluate the health of an application or one of its children.
     If not present, the health evaluation uses the health policy from application manifest or the default health policy.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ReplicaHealthInner object if successful.
     */
    public ReplicaHealthInner getReplicaHealthUsingPolicy(UUID partitionId, String replicaId, Integer eventsHealthStateFilter, ApplicationHealthPolicy applicationHealthPolicy, Long timeout) {
        return getReplicaHealthUsingPolicyWithServiceResponseAsync(partitionId, replicaId, eventsHealthStateFilter, applicationHealthPolicy, timeout).toBlocking().single().body();
    }

    /**
     * Gets the health of a Service Fabric stateful service replica or stateless service instance using the specified policy.
     * Gets the health of a Service Fabric stateful service replica or stateless service instance.
     Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.
     Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the replica.
     *
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param applicationHealthPolicy Describes the health policies used to evaluate the health of an application or one of its children.
     If not present, the health evaluation uses the health policy from application manifest or the default health policy.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ReplicaHealthInner> getReplicaHealthUsingPolicyAsync(UUID partitionId, String replicaId, Integer eventsHealthStateFilter, ApplicationHealthPolicy applicationHealthPolicy, Long timeout, final ServiceCallback<ReplicaHealthInner> serviceCallback) {
        return ServiceFuture.fromResponse(getReplicaHealthUsingPolicyWithServiceResponseAsync(partitionId, replicaId, eventsHealthStateFilter, applicationHealthPolicy, timeout), serviceCallback);
    }

    /**
     * Gets the health of a Service Fabric stateful service replica or stateless service instance using the specified policy.
     * Gets the health of a Service Fabric stateful service replica or stateless service instance.
     Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.
     Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the replica.
     *
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param applicationHealthPolicy Describes the health policies used to evaluate the health of an application or one of its children.
     If not present, the health evaluation uses the health policy from application manifest or the default health policy.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ReplicaHealthInner object
     */
    public Observable<ReplicaHealthInner> getReplicaHealthUsingPolicyAsync(UUID partitionId, String replicaId, Integer eventsHealthStateFilter, ApplicationHealthPolicy applicationHealthPolicy, Long timeout) {
        return getReplicaHealthUsingPolicyWithServiceResponseAsync(partitionId, replicaId, eventsHealthStateFilter, applicationHealthPolicy, timeout).map(new Func1<ServiceResponse<ReplicaHealthInner>, ReplicaHealthInner>() {
            @Override
            public ReplicaHealthInner call(ServiceResponse<ReplicaHealthInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the health of a Service Fabric stateful service replica or stateless service instance using the specified policy.
     * Gets the health of a Service Fabric stateful service replica or stateless service instance.
     Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.
     Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the replica.
     *
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param applicationHealthPolicy Describes the health policies used to evaluate the health of an application or one of its children.
     If not present, the health evaluation uses the health policy from application manifest or the default health policy.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ReplicaHealthInner object
     */
    public Observable<ServiceResponse<ReplicaHealthInner>> getReplicaHealthUsingPolicyWithServiceResponseAsync(UUID partitionId, String replicaId, Integer eventsHealthStateFilter, ApplicationHealthPolicy applicationHealthPolicy, Long timeout) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        if (replicaId == null) {
            throw new IllegalArgumentException("Parameter replicaId is required and cannot be null.");
        }
        Validator.validate(applicationHealthPolicy);
        final String apiVersion = "6.0";
        return service.getReplicaHealthUsingPolicy(partitionId, replicaId, apiVersion, eventsHealthStateFilter, applicationHealthPolicy, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ReplicaHealthInner>>>() {
                @Override
                public Observable<ServiceResponse<ReplicaHealthInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ReplicaHealthInner> clientResponse = getReplicaHealthUsingPolicyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ReplicaHealthInner> getReplicaHealthUsingPolicyDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ReplicaHealthInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ReplicaHealthInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Sends a health report on the Service Fabric replica.
     * Reports health state of the specified Service Fabric replica. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway Replica, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, run GetReplicaHealth and check that the report appears in the HealthEvents section.
     *
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @param replicaHealthReportServiceKind The kind of service replica (Stateless or Stateful) for which the health is being reported. Following are the possible values. Possible values include: 'Stateless', 'Stateful'
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void reportReplicaHealth(UUID partitionId, String replicaId, ReplicaHealthReportServiceKind replicaHealthReportServiceKind, HealthInformation healthInformation) {
        reportReplicaHealthWithServiceResponseAsync(partitionId, replicaId, replicaHealthReportServiceKind, healthInformation).toBlocking().single().body();
    }

    /**
     * Sends a health report on the Service Fabric replica.
     * Reports health state of the specified Service Fabric replica. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway Replica, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, run GetReplicaHealth and check that the report appears in the HealthEvents section.
     *
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @param replicaHealthReportServiceKind The kind of service replica (Stateless or Stateful) for which the health is being reported. Following are the possible values. Possible values include: 'Stateless', 'Stateful'
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> reportReplicaHealthAsync(UUID partitionId, String replicaId, ReplicaHealthReportServiceKind replicaHealthReportServiceKind, HealthInformation healthInformation, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(reportReplicaHealthWithServiceResponseAsync(partitionId, replicaId, replicaHealthReportServiceKind, healthInformation), serviceCallback);
    }

    /**
     * Sends a health report on the Service Fabric replica.
     * Reports health state of the specified Service Fabric replica. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway Replica, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, run GetReplicaHealth and check that the report appears in the HealthEvents section.
     *
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @param replicaHealthReportServiceKind The kind of service replica (Stateless or Stateful) for which the health is being reported. Following are the possible values. Possible values include: 'Stateless', 'Stateful'
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> reportReplicaHealthAsync(UUID partitionId, String replicaId, ReplicaHealthReportServiceKind replicaHealthReportServiceKind, HealthInformation healthInformation) {
        return reportReplicaHealthWithServiceResponseAsync(partitionId, replicaId, replicaHealthReportServiceKind, healthInformation).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Sends a health report on the Service Fabric replica.
     * Reports health state of the specified Service Fabric replica. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway Replica, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, run GetReplicaHealth and check that the report appears in the HealthEvents section.
     *
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @param replicaHealthReportServiceKind The kind of service replica (Stateless or Stateful) for which the health is being reported. Following are the possible values. Possible values include: 'Stateless', 'Stateful'
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> reportReplicaHealthWithServiceResponseAsync(UUID partitionId, String replicaId, ReplicaHealthReportServiceKind replicaHealthReportServiceKind, HealthInformation healthInformation) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        if (replicaId == null) {
            throw new IllegalArgumentException("Parameter replicaId is required and cannot be null.");
        }
        if (replicaHealthReportServiceKind == null) {
            throw new IllegalArgumentException("Parameter replicaHealthReportServiceKind is required and cannot be null.");
        }
        if (healthInformation == null) {
            throw new IllegalArgumentException("Parameter healthInformation is required and cannot be null.");
        }
        Validator.validate(healthInformation);
        final String apiVersion = "6.0";
        final Boolean immediate = null;
        final Long timeout = null;
        return service.reportReplicaHealth(partitionId, replicaId, apiVersion, replicaHealthReportServiceKind, healthInformation, immediate, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = reportReplicaHealthDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Sends a health report on the Service Fabric replica.
     * Reports health state of the specified Service Fabric replica. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway Replica, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, run GetReplicaHealth and check that the report appears in the HealthEvents section.
     *
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @param replicaHealthReportServiceKind The kind of service replica (Stateless or Stateful) for which the health is being reported. Following are the possible values. Possible values include: 'Stateless', 'Stateful'
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @param immediate A flag that indicates whether the report should be sent immediately.
     A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
     If Immediate is set to true, the report is sent immediately from HTTP Gateway to the health store, regardless of the fabric client settings that the HTTP Gateway Application is using.
     This is useful for critical reports that should be sent as soon as possible.
     Depending on timing and other conditions, sending the report may still fail, for example if the HTTP Gateway is closed or the message doesn't reach the Gateway.
     If Immediate is set to false, the report is sent based on the health client settings from the HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
     This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
     By default, reports are not sent immediately.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void reportReplicaHealth(UUID partitionId, String replicaId, ReplicaHealthReportServiceKind replicaHealthReportServiceKind, HealthInformation healthInformation, Boolean immediate, Long timeout) {
        reportReplicaHealthWithServiceResponseAsync(partitionId, replicaId, replicaHealthReportServiceKind, healthInformation, immediate, timeout).toBlocking().single().body();
    }

    /**
     * Sends a health report on the Service Fabric replica.
     * Reports health state of the specified Service Fabric replica. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway Replica, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, run GetReplicaHealth and check that the report appears in the HealthEvents section.
     *
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @param replicaHealthReportServiceKind The kind of service replica (Stateless or Stateful) for which the health is being reported. Following are the possible values. Possible values include: 'Stateless', 'Stateful'
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @param immediate A flag that indicates whether the report should be sent immediately.
     A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
     If Immediate is set to true, the report is sent immediately from HTTP Gateway to the health store, regardless of the fabric client settings that the HTTP Gateway Application is using.
     This is useful for critical reports that should be sent as soon as possible.
     Depending on timing and other conditions, sending the report may still fail, for example if the HTTP Gateway is closed or the message doesn't reach the Gateway.
     If Immediate is set to false, the report is sent based on the health client settings from the HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
     This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
     By default, reports are not sent immediately.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> reportReplicaHealthAsync(UUID partitionId, String replicaId, ReplicaHealthReportServiceKind replicaHealthReportServiceKind, HealthInformation healthInformation, Boolean immediate, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(reportReplicaHealthWithServiceResponseAsync(partitionId, replicaId, replicaHealthReportServiceKind, healthInformation, immediate, timeout), serviceCallback);
    }

    /**
     * Sends a health report on the Service Fabric replica.
     * Reports health state of the specified Service Fabric replica. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway Replica, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, run GetReplicaHealth and check that the report appears in the HealthEvents section.
     *
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @param replicaHealthReportServiceKind The kind of service replica (Stateless or Stateful) for which the health is being reported. Following are the possible values. Possible values include: 'Stateless', 'Stateful'
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @param immediate A flag that indicates whether the report should be sent immediately.
     A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
     If Immediate is set to true, the report is sent immediately from HTTP Gateway to the health store, regardless of the fabric client settings that the HTTP Gateway Application is using.
     This is useful for critical reports that should be sent as soon as possible.
     Depending on timing and other conditions, sending the report may still fail, for example if the HTTP Gateway is closed or the message doesn't reach the Gateway.
     If Immediate is set to false, the report is sent based on the health client settings from the HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
     This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
     By default, reports are not sent immediately.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> reportReplicaHealthAsync(UUID partitionId, String replicaId, ReplicaHealthReportServiceKind replicaHealthReportServiceKind, HealthInformation healthInformation, Boolean immediate, Long timeout) {
        return reportReplicaHealthWithServiceResponseAsync(partitionId, replicaId, replicaHealthReportServiceKind, healthInformation, immediate, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Sends a health report on the Service Fabric replica.
     * Reports health state of the specified Service Fabric replica. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway Replica, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, run GetReplicaHealth and check that the report appears in the HealthEvents section.
     *
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @param replicaHealthReportServiceKind The kind of service replica (Stateless or Stateful) for which the health is being reported. Following are the possible values. Possible values include: 'Stateless', 'Stateful'
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @param immediate A flag that indicates whether the report should be sent immediately.
     A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
     If Immediate is set to true, the report is sent immediately from HTTP Gateway to the health store, regardless of the fabric client settings that the HTTP Gateway Application is using.
     This is useful for critical reports that should be sent as soon as possible.
     Depending on timing and other conditions, sending the report may still fail, for example if the HTTP Gateway is closed or the message doesn't reach the Gateway.
     If Immediate is set to false, the report is sent based on the health client settings from the HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
     This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
     By default, reports are not sent immediately.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> reportReplicaHealthWithServiceResponseAsync(UUID partitionId, String replicaId, ReplicaHealthReportServiceKind replicaHealthReportServiceKind, HealthInformation healthInformation, Boolean immediate, Long timeout) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        if (replicaId == null) {
            throw new IllegalArgumentException("Parameter replicaId is required and cannot be null.");
        }
        if (replicaHealthReportServiceKind == null) {
            throw new IllegalArgumentException("Parameter replicaHealthReportServiceKind is required and cannot be null.");
        }
        if (healthInformation == null) {
            throw new IllegalArgumentException("Parameter healthInformation is required and cannot be null.");
        }
        Validator.validate(healthInformation);
        final String apiVersion = "6.0";
        return service.reportReplicaHealth(partitionId, replicaId, apiVersion, replicaHealthReportServiceKind, healthInformation, immediate, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = reportReplicaHealthDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> reportReplicaHealthDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the list of replicas deployed on a Service Fabric node.
     * Gets the list containing the information about replicas deployed on a Service Fabric node. The information include partition ID, replica ID, status of the replica, name of the service, name of the service type, and other information. Use PartitionId or ServiceManifestName query parameters to return information about the deployed replicas matching the specified values for those parameters.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;DeployedServiceReplicaInfoInner&gt; object if successful.
     */
    public List<DeployedServiceReplicaInfoInner> getDeployedServiceReplicaInfoList(String nodeName, String applicationId) {
        return getDeployedServiceReplicaInfoListWithServiceResponseAsync(nodeName, applicationId).toBlocking().single().body();
    }

    /**
     * Gets the list of replicas deployed on a Service Fabric node.
     * Gets the list containing the information about replicas deployed on a Service Fabric node. The information include partition ID, replica ID, status of the replica, name of the service, name of the service type, and other information. Use PartitionId or ServiceManifestName query parameters to return information about the deployed replicas matching the specified values for those parameters.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<DeployedServiceReplicaInfoInner>> getDeployedServiceReplicaInfoListAsync(String nodeName, String applicationId, final ServiceCallback<List<DeployedServiceReplicaInfoInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getDeployedServiceReplicaInfoListWithServiceResponseAsync(nodeName, applicationId), serviceCallback);
    }

    /**
     * Gets the list of replicas deployed on a Service Fabric node.
     * Gets the list containing the information about replicas deployed on a Service Fabric node. The information include partition ID, replica ID, status of the replica, name of the service, name of the service type, and other information. Use PartitionId or ServiceManifestName query parameters to return information about the deployed replicas matching the specified values for those parameters.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;DeployedServiceReplicaInfoInner&gt; object
     */
    public Observable<List<DeployedServiceReplicaInfoInner>> getDeployedServiceReplicaInfoListAsync(String nodeName, String applicationId) {
        return getDeployedServiceReplicaInfoListWithServiceResponseAsync(nodeName, applicationId).map(new Func1<ServiceResponse<List<DeployedServiceReplicaInfoInner>>, List<DeployedServiceReplicaInfoInner>>() {
            @Override
            public List<DeployedServiceReplicaInfoInner> call(ServiceResponse<List<DeployedServiceReplicaInfoInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the list of replicas deployed on a Service Fabric node.
     * Gets the list containing the information about replicas deployed on a Service Fabric node. The information include partition ID, replica ID, status of the replica, name of the service, name of the service type, and other information. Use PartitionId or ServiceManifestName query parameters to return information about the deployed replicas matching the specified values for those parameters.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;DeployedServiceReplicaInfoInner&gt; object
     */
    public Observable<ServiceResponse<List<DeployedServiceReplicaInfoInner>>> getDeployedServiceReplicaInfoListWithServiceResponseAsync(String nodeName, String applicationId) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final UUID partitionId = null;
        final String serviceManifestName = null;
        final Long timeout = null;
        return service.getDeployedServiceReplicaInfoList(nodeName, applicationId, apiVersion, partitionId, serviceManifestName, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<DeployedServiceReplicaInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<DeployedServiceReplicaInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<DeployedServiceReplicaInfoInner>> clientResponse = getDeployedServiceReplicaInfoListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the list of replicas deployed on a Service Fabric node.
     * Gets the list containing the information about replicas deployed on a Service Fabric node. The information include partition ID, replica ID, status of the replica, name of the service, name of the service type, and other information. Use PartitionId or ServiceManifestName query parameters to return information about the deployed replicas matching the specified values for those parameters.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param serviceManifestName The name of a service manifest registered as part of an application type in a Service Fabric cluster.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;DeployedServiceReplicaInfoInner&gt; object if successful.
     */
    public List<DeployedServiceReplicaInfoInner> getDeployedServiceReplicaInfoList(String nodeName, String applicationId, UUID partitionId, String serviceManifestName, Long timeout) {
        return getDeployedServiceReplicaInfoListWithServiceResponseAsync(nodeName, applicationId, partitionId, serviceManifestName, timeout).toBlocking().single().body();
    }

    /**
     * Gets the list of replicas deployed on a Service Fabric node.
     * Gets the list containing the information about replicas deployed on a Service Fabric node. The information include partition ID, replica ID, status of the replica, name of the service, name of the service type, and other information. Use PartitionId or ServiceManifestName query parameters to return information about the deployed replicas matching the specified values for those parameters.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param serviceManifestName The name of a service manifest registered as part of an application type in a Service Fabric cluster.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<DeployedServiceReplicaInfoInner>> getDeployedServiceReplicaInfoListAsync(String nodeName, String applicationId, UUID partitionId, String serviceManifestName, Long timeout, final ServiceCallback<List<DeployedServiceReplicaInfoInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getDeployedServiceReplicaInfoListWithServiceResponseAsync(nodeName, applicationId, partitionId, serviceManifestName, timeout), serviceCallback);
    }

    /**
     * Gets the list of replicas deployed on a Service Fabric node.
     * Gets the list containing the information about replicas deployed on a Service Fabric node. The information include partition ID, replica ID, status of the replica, name of the service, name of the service type, and other information. Use PartitionId or ServiceManifestName query parameters to return information about the deployed replicas matching the specified values for those parameters.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param serviceManifestName The name of a service manifest registered as part of an application type in a Service Fabric cluster.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;DeployedServiceReplicaInfoInner&gt; object
     */
    public Observable<List<DeployedServiceReplicaInfoInner>> getDeployedServiceReplicaInfoListAsync(String nodeName, String applicationId, UUID partitionId, String serviceManifestName, Long timeout) {
        return getDeployedServiceReplicaInfoListWithServiceResponseAsync(nodeName, applicationId, partitionId, serviceManifestName, timeout).map(new Func1<ServiceResponse<List<DeployedServiceReplicaInfoInner>>, List<DeployedServiceReplicaInfoInner>>() {
            @Override
            public List<DeployedServiceReplicaInfoInner> call(ServiceResponse<List<DeployedServiceReplicaInfoInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the list of replicas deployed on a Service Fabric node.
     * Gets the list containing the information about replicas deployed on a Service Fabric node. The information include partition ID, replica ID, status of the replica, name of the service, name of the service type, and other information. Use PartitionId or ServiceManifestName query parameters to return information about the deployed replicas matching the specified values for those parameters.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param serviceManifestName The name of a service manifest registered as part of an application type in a Service Fabric cluster.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;DeployedServiceReplicaInfoInner&gt; object
     */
    public Observable<ServiceResponse<List<DeployedServiceReplicaInfoInner>>> getDeployedServiceReplicaInfoListWithServiceResponseAsync(String nodeName, String applicationId, UUID partitionId, String serviceManifestName, Long timeout) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.getDeployedServiceReplicaInfoList(nodeName, applicationId, apiVersion, partitionId, serviceManifestName, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<DeployedServiceReplicaInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<DeployedServiceReplicaInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<DeployedServiceReplicaInfoInner>> clientResponse = getDeployedServiceReplicaInfoListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<DeployedServiceReplicaInfoInner>> getDeployedServiceReplicaInfoListDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<DeployedServiceReplicaInfoInner>, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<DeployedServiceReplicaInfoInner>>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the details of replica deployed on a Service Fabric node.
     * Gets the details of the replica deployed on a Service Fabric node. The information includes service kind, service name, current service operation, current service operation start date time, partition ID, replica/instance ID, reported load, and other information.
     *
     * @param nodeName The name of the node.
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the DeployedServiceReplicaDetailInfoInner object if successful.
     */
    public DeployedServiceReplicaDetailInfoInner getDeployedServiceReplicaDetailInfo(String nodeName, UUID partitionId, String replicaId) {
        return getDeployedServiceReplicaDetailInfoWithServiceResponseAsync(nodeName, partitionId, replicaId).toBlocking().single().body();
    }

    /**
     * Gets the details of replica deployed on a Service Fabric node.
     * Gets the details of the replica deployed on a Service Fabric node. The information includes service kind, service name, current service operation, current service operation start date time, partition ID, replica/instance ID, reported load, and other information.
     *
     * @param nodeName The name of the node.
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<DeployedServiceReplicaDetailInfoInner> getDeployedServiceReplicaDetailInfoAsync(String nodeName, UUID partitionId, String replicaId, final ServiceCallback<DeployedServiceReplicaDetailInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getDeployedServiceReplicaDetailInfoWithServiceResponseAsync(nodeName, partitionId, replicaId), serviceCallback);
    }

    /**
     * Gets the details of replica deployed on a Service Fabric node.
     * Gets the details of the replica deployed on a Service Fabric node. The information includes service kind, service name, current service operation, current service operation start date time, partition ID, replica/instance ID, reported load, and other information.
     *
     * @param nodeName The name of the node.
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeployedServiceReplicaDetailInfoInner object
     */
    public Observable<DeployedServiceReplicaDetailInfoInner> getDeployedServiceReplicaDetailInfoAsync(String nodeName, UUID partitionId, String replicaId) {
        return getDeployedServiceReplicaDetailInfoWithServiceResponseAsync(nodeName, partitionId, replicaId).map(new Func1<ServiceResponse<DeployedServiceReplicaDetailInfoInner>, DeployedServiceReplicaDetailInfoInner>() {
            @Override
            public DeployedServiceReplicaDetailInfoInner call(ServiceResponse<DeployedServiceReplicaDetailInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the details of replica deployed on a Service Fabric node.
     * Gets the details of the replica deployed on a Service Fabric node. The information includes service kind, service name, current service operation, current service operation start date time, partition ID, replica/instance ID, reported load, and other information.
     *
     * @param nodeName The name of the node.
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeployedServiceReplicaDetailInfoInner object
     */
    public Observable<ServiceResponse<DeployedServiceReplicaDetailInfoInner>> getDeployedServiceReplicaDetailInfoWithServiceResponseAsync(String nodeName, UUID partitionId, String replicaId) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        if (replicaId == null) {
            throw new IllegalArgumentException("Parameter replicaId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.getDeployedServiceReplicaDetailInfo(nodeName, partitionId, replicaId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeployedServiceReplicaDetailInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<DeployedServiceReplicaDetailInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeployedServiceReplicaDetailInfoInner> clientResponse = getDeployedServiceReplicaDetailInfoDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the details of replica deployed on a Service Fabric node.
     * Gets the details of the replica deployed on a Service Fabric node. The information includes service kind, service name, current service operation, current service operation start date time, partition ID, replica/instance ID, reported load, and other information.
     *
     * @param nodeName The name of the node.
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the DeployedServiceReplicaDetailInfoInner object if successful.
     */
    public DeployedServiceReplicaDetailInfoInner getDeployedServiceReplicaDetailInfo(String nodeName, UUID partitionId, String replicaId, Long timeout) {
        return getDeployedServiceReplicaDetailInfoWithServiceResponseAsync(nodeName, partitionId, replicaId, timeout).toBlocking().single().body();
    }

    /**
     * Gets the details of replica deployed on a Service Fabric node.
     * Gets the details of the replica deployed on a Service Fabric node. The information includes service kind, service name, current service operation, current service operation start date time, partition ID, replica/instance ID, reported load, and other information.
     *
     * @param nodeName The name of the node.
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<DeployedServiceReplicaDetailInfoInner> getDeployedServiceReplicaDetailInfoAsync(String nodeName, UUID partitionId, String replicaId, Long timeout, final ServiceCallback<DeployedServiceReplicaDetailInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getDeployedServiceReplicaDetailInfoWithServiceResponseAsync(nodeName, partitionId, replicaId, timeout), serviceCallback);
    }

    /**
     * Gets the details of replica deployed on a Service Fabric node.
     * Gets the details of the replica deployed on a Service Fabric node. The information includes service kind, service name, current service operation, current service operation start date time, partition ID, replica/instance ID, reported load, and other information.
     *
     * @param nodeName The name of the node.
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeployedServiceReplicaDetailInfoInner object
     */
    public Observable<DeployedServiceReplicaDetailInfoInner> getDeployedServiceReplicaDetailInfoAsync(String nodeName, UUID partitionId, String replicaId, Long timeout) {
        return getDeployedServiceReplicaDetailInfoWithServiceResponseAsync(nodeName, partitionId, replicaId, timeout).map(new Func1<ServiceResponse<DeployedServiceReplicaDetailInfoInner>, DeployedServiceReplicaDetailInfoInner>() {
            @Override
            public DeployedServiceReplicaDetailInfoInner call(ServiceResponse<DeployedServiceReplicaDetailInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the details of replica deployed on a Service Fabric node.
     * Gets the details of the replica deployed on a Service Fabric node. The information includes service kind, service name, current service operation, current service operation start date time, partition ID, replica/instance ID, reported load, and other information.
     *
     * @param nodeName The name of the node.
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeployedServiceReplicaDetailInfoInner object
     */
    public Observable<ServiceResponse<DeployedServiceReplicaDetailInfoInner>> getDeployedServiceReplicaDetailInfoWithServiceResponseAsync(String nodeName, UUID partitionId, String replicaId, Long timeout) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        if (replicaId == null) {
            throw new IllegalArgumentException("Parameter replicaId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.getDeployedServiceReplicaDetailInfo(nodeName, partitionId, replicaId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeployedServiceReplicaDetailInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<DeployedServiceReplicaDetailInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeployedServiceReplicaDetailInfoInner> clientResponse = getDeployedServiceReplicaDetailInfoDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DeployedServiceReplicaDetailInfoInner> getDeployedServiceReplicaDetailInfoDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<DeployedServiceReplicaDetailInfoInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<DeployedServiceReplicaDetailInfoInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the details of replica deployed on a Service Fabric node.
     * Gets the details of the replica deployed on a Service Fabric node. The information includes service kind, service name, current service operation, current service operation start date time, partition ID, replica/instance ID, reported load, and other information.
     *
     * @param nodeName The name of the node.
     * @param partitionId The identity of the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the DeployedServiceReplicaDetailInfoInner object if successful.
     */
    public DeployedServiceReplicaDetailInfoInner getDeployedServiceReplicaDetailInfoByPartitionId(String nodeName, UUID partitionId) {
        return getDeployedServiceReplicaDetailInfoByPartitionIdWithServiceResponseAsync(nodeName, partitionId).toBlocking().single().body();
    }

    /**
     * Gets the details of replica deployed on a Service Fabric node.
     * Gets the details of the replica deployed on a Service Fabric node. The information includes service kind, service name, current service operation, current service operation start date time, partition ID, replica/instance ID, reported load, and other information.
     *
     * @param nodeName The name of the node.
     * @param partitionId The identity of the partition.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<DeployedServiceReplicaDetailInfoInner> getDeployedServiceReplicaDetailInfoByPartitionIdAsync(String nodeName, UUID partitionId, final ServiceCallback<DeployedServiceReplicaDetailInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getDeployedServiceReplicaDetailInfoByPartitionIdWithServiceResponseAsync(nodeName, partitionId), serviceCallback);
    }

    /**
     * Gets the details of replica deployed on a Service Fabric node.
     * Gets the details of the replica deployed on a Service Fabric node. The information includes service kind, service name, current service operation, current service operation start date time, partition ID, replica/instance ID, reported load, and other information.
     *
     * @param nodeName The name of the node.
     * @param partitionId The identity of the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeployedServiceReplicaDetailInfoInner object
     */
    public Observable<DeployedServiceReplicaDetailInfoInner> getDeployedServiceReplicaDetailInfoByPartitionIdAsync(String nodeName, UUID partitionId) {
        return getDeployedServiceReplicaDetailInfoByPartitionIdWithServiceResponseAsync(nodeName, partitionId).map(new Func1<ServiceResponse<DeployedServiceReplicaDetailInfoInner>, DeployedServiceReplicaDetailInfoInner>() {
            @Override
            public DeployedServiceReplicaDetailInfoInner call(ServiceResponse<DeployedServiceReplicaDetailInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the details of replica deployed on a Service Fabric node.
     * Gets the details of the replica deployed on a Service Fabric node. The information includes service kind, service name, current service operation, current service operation start date time, partition ID, replica/instance ID, reported load, and other information.
     *
     * @param nodeName The name of the node.
     * @param partitionId The identity of the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeployedServiceReplicaDetailInfoInner object
     */
    public Observable<ServiceResponse<DeployedServiceReplicaDetailInfoInner>> getDeployedServiceReplicaDetailInfoByPartitionIdWithServiceResponseAsync(String nodeName, UUID partitionId) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.getDeployedServiceReplicaDetailInfoByPartitionId(nodeName, partitionId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeployedServiceReplicaDetailInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<DeployedServiceReplicaDetailInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeployedServiceReplicaDetailInfoInner> clientResponse = getDeployedServiceReplicaDetailInfoByPartitionIdDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the details of replica deployed on a Service Fabric node.
     * Gets the details of the replica deployed on a Service Fabric node. The information includes service kind, service name, current service operation, current service operation start date time, partition ID, replica/instance ID, reported load, and other information.
     *
     * @param nodeName The name of the node.
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the DeployedServiceReplicaDetailInfoInner object if successful.
     */
    public DeployedServiceReplicaDetailInfoInner getDeployedServiceReplicaDetailInfoByPartitionId(String nodeName, UUID partitionId, Long timeout) {
        return getDeployedServiceReplicaDetailInfoByPartitionIdWithServiceResponseAsync(nodeName, partitionId, timeout).toBlocking().single().body();
    }

    /**
     * Gets the details of replica deployed on a Service Fabric node.
     * Gets the details of the replica deployed on a Service Fabric node. The information includes service kind, service name, current service operation, current service operation start date time, partition ID, replica/instance ID, reported load, and other information.
     *
     * @param nodeName The name of the node.
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<DeployedServiceReplicaDetailInfoInner> getDeployedServiceReplicaDetailInfoByPartitionIdAsync(String nodeName, UUID partitionId, Long timeout, final ServiceCallback<DeployedServiceReplicaDetailInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getDeployedServiceReplicaDetailInfoByPartitionIdWithServiceResponseAsync(nodeName, partitionId, timeout), serviceCallback);
    }

    /**
     * Gets the details of replica deployed on a Service Fabric node.
     * Gets the details of the replica deployed on a Service Fabric node. The information includes service kind, service name, current service operation, current service operation start date time, partition ID, replica/instance ID, reported load, and other information.
     *
     * @param nodeName The name of the node.
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeployedServiceReplicaDetailInfoInner object
     */
    public Observable<DeployedServiceReplicaDetailInfoInner> getDeployedServiceReplicaDetailInfoByPartitionIdAsync(String nodeName, UUID partitionId, Long timeout) {
        return getDeployedServiceReplicaDetailInfoByPartitionIdWithServiceResponseAsync(nodeName, partitionId, timeout).map(new Func1<ServiceResponse<DeployedServiceReplicaDetailInfoInner>, DeployedServiceReplicaDetailInfoInner>() {
            @Override
            public DeployedServiceReplicaDetailInfoInner call(ServiceResponse<DeployedServiceReplicaDetailInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the details of replica deployed on a Service Fabric node.
     * Gets the details of the replica deployed on a Service Fabric node. The information includes service kind, service name, current service operation, current service operation start date time, partition ID, replica/instance ID, reported load, and other information.
     *
     * @param nodeName The name of the node.
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeployedServiceReplicaDetailInfoInner object
     */
    public Observable<ServiceResponse<DeployedServiceReplicaDetailInfoInner>> getDeployedServiceReplicaDetailInfoByPartitionIdWithServiceResponseAsync(String nodeName, UUID partitionId, Long timeout) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.getDeployedServiceReplicaDetailInfoByPartitionId(nodeName, partitionId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeployedServiceReplicaDetailInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<DeployedServiceReplicaDetailInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeployedServiceReplicaDetailInfoInner> clientResponse = getDeployedServiceReplicaDetailInfoByPartitionIdDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DeployedServiceReplicaDetailInfoInner> getDeployedServiceReplicaDetailInfoByPartitionIdDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<DeployedServiceReplicaDetailInfoInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<DeployedServiceReplicaDetailInfoInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Restarts a service replica of a persisted service running on a node.
     * Restarts a service replica of a persisted service running on a node. Warning - There are no safety checks performed when this API is used. Incorrect use of this API can lead to availability loss for stateful services.
     *
     * @param nodeName The name of the node.
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void restartReplica(String nodeName, UUID partitionId, String replicaId) {
        restartReplicaWithServiceResponseAsync(nodeName, partitionId, replicaId).toBlocking().single().body();
    }

    /**
     * Restarts a service replica of a persisted service running on a node.
     * Restarts a service replica of a persisted service running on a node. Warning - There are no safety checks performed when this API is used. Incorrect use of this API can lead to availability loss for stateful services.
     *
     * @param nodeName The name of the node.
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> restartReplicaAsync(String nodeName, UUID partitionId, String replicaId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(restartReplicaWithServiceResponseAsync(nodeName, partitionId, replicaId), serviceCallback);
    }

    /**
     * Restarts a service replica of a persisted service running on a node.
     * Restarts a service replica of a persisted service running on a node. Warning - There are no safety checks performed when this API is used. Incorrect use of this API can lead to availability loss for stateful services.
     *
     * @param nodeName The name of the node.
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> restartReplicaAsync(String nodeName, UUID partitionId, String replicaId) {
        return restartReplicaWithServiceResponseAsync(nodeName, partitionId, replicaId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Restarts a service replica of a persisted service running on a node.
     * Restarts a service replica of a persisted service running on a node. Warning - There are no safety checks performed when this API is used. Incorrect use of this API can lead to availability loss for stateful services.
     *
     * @param nodeName The name of the node.
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> restartReplicaWithServiceResponseAsync(String nodeName, UUID partitionId, String replicaId) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        if (replicaId == null) {
            throw new IllegalArgumentException("Parameter replicaId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.restartReplica(nodeName, partitionId, replicaId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = restartReplicaDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Restarts a service replica of a persisted service running on a node.
     * Restarts a service replica of a persisted service running on a node. Warning - There are no safety checks performed when this API is used. Incorrect use of this API can lead to availability loss for stateful services.
     *
     * @param nodeName The name of the node.
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void restartReplica(String nodeName, UUID partitionId, String replicaId, Long timeout) {
        restartReplicaWithServiceResponseAsync(nodeName, partitionId, replicaId, timeout).toBlocking().single().body();
    }

    /**
     * Restarts a service replica of a persisted service running on a node.
     * Restarts a service replica of a persisted service running on a node. Warning - There are no safety checks performed when this API is used. Incorrect use of this API can lead to availability loss for stateful services.
     *
     * @param nodeName The name of the node.
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> restartReplicaAsync(String nodeName, UUID partitionId, String replicaId, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(restartReplicaWithServiceResponseAsync(nodeName, partitionId, replicaId, timeout), serviceCallback);
    }

    /**
     * Restarts a service replica of a persisted service running on a node.
     * Restarts a service replica of a persisted service running on a node. Warning - There are no safety checks performed when this API is used. Incorrect use of this API can lead to availability loss for stateful services.
     *
     * @param nodeName The name of the node.
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> restartReplicaAsync(String nodeName, UUID partitionId, String replicaId, Long timeout) {
        return restartReplicaWithServiceResponseAsync(nodeName, partitionId, replicaId, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Restarts a service replica of a persisted service running on a node.
     * Restarts a service replica of a persisted service running on a node. Warning - There are no safety checks performed when this API is used. Incorrect use of this API can lead to availability loss for stateful services.
     *
     * @param nodeName The name of the node.
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> restartReplicaWithServiceResponseAsync(String nodeName, UUID partitionId, String replicaId, Long timeout) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        if (replicaId == null) {
            throw new IllegalArgumentException("Parameter replicaId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.restartReplica(nodeName, partitionId, replicaId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = restartReplicaDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> restartReplicaDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Removes a service replica running on a node.
     * This API simulates a Service Fabric replica failure by removing a replica from a Service Fabric cluster. The removal closes the replica, transitions the replica to the role None, and then removes all of the state information of the replica from the cluster. This API tests the replica state removal path, and simulates the report fault permanent path through client APIs. Warning - There are no safety checks performed when this API is used. Incorrect use of this API can lead to data loss for stateful services. In addition, the forceRemove flag impacts all other replicas hosted in the same process.
     *
     * @param nodeName The name of the node.
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void removeReplica(String nodeName, UUID partitionId, String replicaId) {
        removeReplicaWithServiceResponseAsync(nodeName, partitionId, replicaId).toBlocking().single().body();
    }

    /**
     * Removes a service replica running on a node.
     * This API simulates a Service Fabric replica failure by removing a replica from a Service Fabric cluster. The removal closes the replica, transitions the replica to the role None, and then removes all of the state information of the replica from the cluster. This API tests the replica state removal path, and simulates the report fault permanent path through client APIs. Warning - There are no safety checks performed when this API is used. Incorrect use of this API can lead to data loss for stateful services. In addition, the forceRemove flag impacts all other replicas hosted in the same process.
     *
     * @param nodeName The name of the node.
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> removeReplicaAsync(String nodeName, UUID partitionId, String replicaId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(removeReplicaWithServiceResponseAsync(nodeName, partitionId, replicaId), serviceCallback);
    }

    /**
     * Removes a service replica running on a node.
     * This API simulates a Service Fabric replica failure by removing a replica from a Service Fabric cluster. The removal closes the replica, transitions the replica to the role None, and then removes all of the state information of the replica from the cluster. This API tests the replica state removal path, and simulates the report fault permanent path through client APIs. Warning - There are no safety checks performed when this API is used. Incorrect use of this API can lead to data loss for stateful services. In addition, the forceRemove flag impacts all other replicas hosted in the same process.
     *
     * @param nodeName The name of the node.
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> removeReplicaAsync(String nodeName, UUID partitionId, String replicaId) {
        return removeReplicaWithServiceResponseAsync(nodeName, partitionId, replicaId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Removes a service replica running on a node.
     * This API simulates a Service Fabric replica failure by removing a replica from a Service Fabric cluster. The removal closes the replica, transitions the replica to the role None, and then removes all of the state information of the replica from the cluster. This API tests the replica state removal path, and simulates the report fault permanent path through client APIs. Warning - There are no safety checks performed when this API is used. Incorrect use of this API can lead to data loss for stateful services. In addition, the forceRemove flag impacts all other replicas hosted in the same process.
     *
     * @param nodeName The name of the node.
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> removeReplicaWithServiceResponseAsync(String nodeName, UUID partitionId, String replicaId) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        if (replicaId == null) {
            throw new IllegalArgumentException("Parameter replicaId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Boolean forceRemove = null;
        final Long timeout = null;
        return service.removeReplica(nodeName, partitionId, replicaId, apiVersion, forceRemove, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = removeReplicaDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Removes a service replica running on a node.
     * This API simulates a Service Fabric replica failure by removing a replica from a Service Fabric cluster. The removal closes the replica, transitions the replica to the role None, and then removes all of the state information of the replica from the cluster. This API tests the replica state removal path, and simulates the report fault permanent path through client APIs. Warning - There are no safety checks performed when this API is used. Incorrect use of this API can lead to data loss for stateful services. In addition, the forceRemove flag impacts all other replicas hosted in the same process.
     *
     * @param nodeName The name of the node.
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @param forceRemove Remove a Service Fabric application or service forcefully without going through the graceful shutdown sequence. This parameter can be used to forcefully delete an application or service for which delete is timing out due to issues in the service code that prevents graceful close of replicas.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void removeReplica(String nodeName, UUID partitionId, String replicaId, Boolean forceRemove, Long timeout) {
        removeReplicaWithServiceResponseAsync(nodeName, partitionId, replicaId, forceRemove, timeout).toBlocking().single().body();
    }

    /**
     * Removes a service replica running on a node.
     * This API simulates a Service Fabric replica failure by removing a replica from a Service Fabric cluster. The removal closes the replica, transitions the replica to the role None, and then removes all of the state information of the replica from the cluster. This API tests the replica state removal path, and simulates the report fault permanent path through client APIs. Warning - There are no safety checks performed when this API is used. Incorrect use of this API can lead to data loss for stateful services. In addition, the forceRemove flag impacts all other replicas hosted in the same process.
     *
     * @param nodeName The name of the node.
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @param forceRemove Remove a Service Fabric application or service forcefully without going through the graceful shutdown sequence. This parameter can be used to forcefully delete an application or service for which delete is timing out due to issues in the service code that prevents graceful close of replicas.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> removeReplicaAsync(String nodeName, UUID partitionId, String replicaId, Boolean forceRemove, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(removeReplicaWithServiceResponseAsync(nodeName, partitionId, replicaId, forceRemove, timeout), serviceCallback);
    }

    /**
     * Removes a service replica running on a node.
     * This API simulates a Service Fabric replica failure by removing a replica from a Service Fabric cluster. The removal closes the replica, transitions the replica to the role None, and then removes all of the state information of the replica from the cluster. This API tests the replica state removal path, and simulates the report fault permanent path through client APIs. Warning - There are no safety checks performed when this API is used. Incorrect use of this API can lead to data loss for stateful services. In addition, the forceRemove flag impacts all other replicas hosted in the same process.
     *
     * @param nodeName The name of the node.
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @param forceRemove Remove a Service Fabric application or service forcefully without going through the graceful shutdown sequence. This parameter can be used to forcefully delete an application or service for which delete is timing out due to issues in the service code that prevents graceful close of replicas.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> removeReplicaAsync(String nodeName, UUID partitionId, String replicaId, Boolean forceRemove, Long timeout) {
        return removeReplicaWithServiceResponseAsync(nodeName, partitionId, replicaId, forceRemove, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Removes a service replica running on a node.
     * This API simulates a Service Fabric replica failure by removing a replica from a Service Fabric cluster. The removal closes the replica, transitions the replica to the role None, and then removes all of the state information of the replica from the cluster. This API tests the replica state removal path, and simulates the report fault permanent path through client APIs. Warning - There are no safety checks performed when this API is used. Incorrect use of this API can lead to data loss for stateful services. In addition, the forceRemove flag impacts all other replicas hosted in the same process.
     *
     * @param nodeName The name of the node.
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @param forceRemove Remove a Service Fabric application or service forcefully without going through the graceful shutdown sequence. This parameter can be used to forcefully delete an application or service for which delete is timing out due to issues in the service code that prevents graceful close of replicas.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> removeReplicaWithServiceResponseAsync(String nodeName, UUID partitionId, String replicaId, Boolean forceRemove, Long timeout) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        if (replicaId == null) {
            throw new IllegalArgumentException("Parameter replicaId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.removeReplica(nodeName, partitionId, replicaId, apiVersion, forceRemove, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = removeReplicaDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> removeReplicaDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the list of service packages deployed on a Service Fabric node.
     * Returns the information about the service packages deployed on a Service Fabric node for the given application.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;DeployedServicePackageInfoInner&gt; object if successful.
     */
    public List<DeployedServicePackageInfoInner> getDeployedServicePackageInfoList(String nodeName, String applicationId) {
        return getDeployedServicePackageInfoListWithServiceResponseAsync(nodeName, applicationId).toBlocking().single().body();
    }

    /**
     * Gets the list of service packages deployed on a Service Fabric node.
     * Returns the information about the service packages deployed on a Service Fabric node for the given application.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<DeployedServicePackageInfoInner>> getDeployedServicePackageInfoListAsync(String nodeName, String applicationId, final ServiceCallback<List<DeployedServicePackageInfoInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getDeployedServicePackageInfoListWithServiceResponseAsync(nodeName, applicationId), serviceCallback);
    }

    /**
     * Gets the list of service packages deployed on a Service Fabric node.
     * Returns the information about the service packages deployed on a Service Fabric node for the given application.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;DeployedServicePackageInfoInner&gt; object
     */
    public Observable<List<DeployedServicePackageInfoInner>> getDeployedServicePackageInfoListAsync(String nodeName, String applicationId) {
        return getDeployedServicePackageInfoListWithServiceResponseAsync(nodeName, applicationId).map(new Func1<ServiceResponse<List<DeployedServicePackageInfoInner>>, List<DeployedServicePackageInfoInner>>() {
            @Override
            public List<DeployedServicePackageInfoInner> call(ServiceResponse<List<DeployedServicePackageInfoInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the list of service packages deployed on a Service Fabric node.
     * Returns the information about the service packages deployed on a Service Fabric node for the given application.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;DeployedServicePackageInfoInner&gt; object
     */
    public Observable<ServiceResponse<List<DeployedServicePackageInfoInner>>> getDeployedServicePackageInfoListWithServiceResponseAsync(String nodeName, String applicationId) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.getDeployedServicePackageInfoList(nodeName, applicationId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<DeployedServicePackageInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<DeployedServicePackageInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<DeployedServicePackageInfoInner>> clientResponse = getDeployedServicePackageInfoListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the list of service packages deployed on a Service Fabric node.
     * Returns the information about the service packages deployed on a Service Fabric node for the given application.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;DeployedServicePackageInfoInner&gt; object if successful.
     */
    public List<DeployedServicePackageInfoInner> getDeployedServicePackageInfoList(String nodeName, String applicationId, Long timeout) {
        return getDeployedServicePackageInfoListWithServiceResponseAsync(nodeName, applicationId, timeout).toBlocking().single().body();
    }

    /**
     * Gets the list of service packages deployed on a Service Fabric node.
     * Returns the information about the service packages deployed on a Service Fabric node for the given application.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<DeployedServicePackageInfoInner>> getDeployedServicePackageInfoListAsync(String nodeName, String applicationId, Long timeout, final ServiceCallback<List<DeployedServicePackageInfoInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getDeployedServicePackageInfoListWithServiceResponseAsync(nodeName, applicationId, timeout), serviceCallback);
    }

    /**
     * Gets the list of service packages deployed on a Service Fabric node.
     * Returns the information about the service packages deployed on a Service Fabric node for the given application.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;DeployedServicePackageInfoInner&gt; object
     */
    public Observable<List<DeployedServicePackageInfoInner>> getDeployedServicePackageInfoListAsync(String nodeName, String applicationId, Long timeout) {
        return getDeployedServicePackageInfoListWithServiceResponseAsync(nodeName, applicationId, timeout).map(new Func1<ServiceResponse<List<DeployedServicePackageInfoInner>>, List<DeployedServicePackageInfoInner>>() {
            @Override
            public List<DeployedServicePackageInfoInner> call(ServiceResponse<List<DeployedServicePackageInfoInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the list of service packages deployed on a Service Fabric node.
     * Returns the information about the service packages deployed on a Service Fabric node for the given application.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;DeployedServicePackageInfoInner&gt; object
     */
    public Observable<ServiceResponse<List<DeployedServicePackageInfoInner>>> getDeployedServicePackageInfoListWithServiceResponseAsync(String nodeName, String applicationId, Long timeout) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.getDeployedServicePackageInfoList(nodeName, applicationId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<DeployedServicePackageInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<DeployedServicePackageInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<DeployedServicePackageInfoInner>> clientResponse = getDeployedServicePackageInfoListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<DeployedServicePackageInfoInner>> getDeployedServicePackageInfoListDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<DeployedServicePackageInfoInner>, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<DeployedServicePackageInfoInner>>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the list of service packages deployed on a Service Fabric node matching exactly the specified name.
     * Returns the information about the service packages deployed on a Service Fabric node for the given application. These results are of service packages whose name match exactly the service package name specified as the parameter.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param servicePackageName The name of the service package.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;DeployedServicePackageInfoInner&gt; object if successful.
     */
    public List<DeployedServicePackageInfoInner> getDeployedServicePackageInfoListByName(String nodeName, String applicationId, String servicePackageName) {
        return getDeployedServicePackageInfoListByNameWithServiceResponseAsync(nodeName, applicationId, servicePackageName).toBlocking().single().body();
    }

    /**
     * Gets the list of service packages deployed on a Service Fabric node matching exactly the specified name.
     * Returns the information about the service packages deployed on a Service Fabric node for the given application. These results are of service packages whose name match exactly the service package name specified as the parameter.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param servicePackageName The name of the service package.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<DeployedServicePackageInfoInner>> getDeployedServicePackageInfoListByNameAsync(String nodeName, String applicationId, String servicePackageName, final ServiceCallback<List<DeployedServicePackageInfoInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getDeployedServicePackageInfoListByNameWithServiceResponseAsync(nodeName, applicationId, servicePackageName), serviceCallback);
    }

    /**
     * Gets the list of service packages deployed on a Service Fabric node matching exactly the specified name.
     * Returns the information about the service packages deployed on a Service Fabric node for the given application. These results are of service packages whose name match exactly the service package name specified as the parameter.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param servicePackageName The name of the service package.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;DeployedServicePackageInfoInner&gt; object
     */
    public Observable<List<DeployedServicePackageInfoInner>> getDeployedServicePackageInfoListByNameAsync(String nodeName, String applicationId, String servicePackageName) {
        return getDeployedServicePackageInfoListByNameWithServiceResponseAsync(nodeName, applicationId, servicePackageName).map(new Func1<ServiceResponse<List<DeployedServicePackageInfoInner>>, List<DeployedServicePackageInfoInner>>() {
            @Override
            public List<DeployedServicePackageInfoInner> call(ServiceResponse<List<DeployedServicePackageInfoInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the list of service packages deployed on a Service Fabric node matching exactly the specified name.
     * Returns the information about the service packages deployed on a Service Fabric node for the given application. These results are of service packages whose name match exactly the service package name specified as the parameter.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param servicePackageName The name of the service package.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;DeployedServicePackageInfoInner&gt; object
     */
    public Observable<ServiceResponse<List<DeployedServicePackageInfoInner>>> getDeployedServicePackageInfoListByNameWithServiceResponseAsync(String nodeName, String applicationId, String servicePackageName) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        if (servicePackageName == null) {
            throw new IllegalArgumentException("Parameter servicePackageName is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.getDeployedServicePackageInfoListByName(nodeName, applicationId, servicePackageName, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<DeployedServicePackageInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<DeployedServicePackageInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<DeployedServicePackageInfoInner>> clientResponse = getDeployedServicePackageInfoListByNameDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the list of service packages deployed on a Service Fabric node matching exactly the specified name.
     * Returns the information about the service packages deployed on a Service Fabric node for the given application. These results are of service packages whose name match exactly the service package name specified as the parameter.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param servicePackageName The name of the service package.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;DeployedServicePackageInfoInner&gt; object if successful.
     */
    public List<DeployedServicePackageInfoInner> getDeployedServicePackageInfoListByName(String nodeName, String applicationId, String servicePackageName, Long timeout) {
        return getDeployedServicePackageInfoListByNameWithServiceResponseAsync(nodeName, applicationId, servicePackageName, timeout).toBlocking().single().body();
    }

    /**
     * Gets the list of service packages deployed on a Service Fabric node matching exactly the specified name.
     * Returns the information about the service packages deployed on a Service Fabric node for the given application. These results are of service packages whose name match exactly the service package name specified as the parameter.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param servicePackageName The name of the service package.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<DeployedServicePackageInfoInner>> getDeployedServicePackageInfoListByNameAsync(String nodeName, String applicationId, String servicePackageName, Long timeout, final ServiceCallback<List<DeployedServicePackageInfoInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getDeployedServicePackageInfoListByNameWithServiceResponseAsync(nodeName, applicationId, servicePackageName, timeout), serviceCallback);
    }

    /**
     * Gets the list of service packages deployed on a Service Fabric node matching exactly the specified name.
     * Returns the information about the service packages deployed on a Service Fabric node for the given application. These results are of service packages whose name match exactly the service package name specified as the parameter.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param servicePackageName The name of the service package.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;DeployedServicePackageInfoInner&gt; object
     */
    public Observable<List<DeployedServicePackageInfoInner>> getDeployedServicePackageInfoListByNameAsync(String nodeName, String applicationId, String servicePackageName, Long timeout) {
        return getDeployedServicePackageInfoListByNameWithServiceResponseAsync(nodeName, applicationId, servicePackageName, timeout).map(new Func1<ServiceResponse<List<DeployedServicePackageInfoInner>>, List<DeployedServicePackageInfoInner>>() {
            @Override
            public List<DeployedServicePackageInfoInner> call(ServiceResponse<List<DeployedServicePackageInfoInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the list of service packages deployed on a Service Fabric node matching exactly the specified name.
     * Returns the information about the service packages deployed on a Service Fabric node for the given application. These results are of service packages whose name match exactly the service package name specified as the parameter.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param servicePackageName The name of the service package.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;DeployedServicePackageInfoInner&gt; object
     */
    public Observable<ServiceResponse<List<DeployedServicePackageInfoInner>>> getDeployedServicePackageInfoListByNameWithServiceResponseAsync(String nodeName, String applicationId, String servicePackageName, Long timeout) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        if (servicePackageName == null) {
            throw new IllegalArgumentException("Parameter servicePackageName is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.getDeployedServicePackageInfoListByName(nodeName, applicationId, servicePackageName, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<DeployedServicePackageInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<DeployedServicePackageInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<DeployedServicePackageInfoInner>> clientResponse = getDeployedServicePackageInfoListByNameDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<DeployedServicePackageInfoInner>> getDeployedServicePackageInfoListByNameDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<DeployedServicePackageInfoInner>, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<DeployedServicePackageInfoInner>>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the information about health of a service package for a specific application deployed for a Service Fabric node and application.
     * Gets the information about health of a service package for a specific application deployed on a Service Fabric node. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed service package based on health state.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param servicePackageName The name of the service package.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the DeployedServicePackageHealthInner object if successful.
     */
    public DeployedServicePackageHealthInner getDeployedServicePackageHealth(String nodeName, String applicationId, String servicePackageName) {
        return getDeployedServicePackageHealthWithServiceResponseAsync(nodeName, applicationId, servicePackageName).toBlocking().single().body();
    }

    /**
     * Gets the information about health of a service package for a specific application deployed for a Service Fabric node and application.
     * Gets the information about health of a service package for a specific application deployed on a Service Fabric node. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed service package based on health state.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param servicePackageName The name of the service package.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<DeployedServicePackageHealthInner> getDeployedServicePackageHealthAsync(String nodeName, String applicationId, String servicePackageName, final ServiceCallback<DeployedServicePackageHealthInner> serviceCallback) {
        return ServiceFuture.fromResponse(getDeployedServicePackageHealthWithServiceResponseAsync(nodeName, applicationId, servicePackageName), serviceCallback);
    }

    /**
     * Gets the information about health of a service package for a specific application deployed for a Service Fabric node and application.
     * Gets the information about health of a service package for a specific application deployed on a Service Fabric node. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed service package based on health state.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param servicePackageName The name of the service package.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeployedServicePackageHealthInner object
     */
    public Observable<DeployedServicePackageHealthInner> getDeployedServicePackageHealthAsync(String nodeName, String applicationId, String servicePackageName) {
        return getDeployedServicePackageHealthWithServiceResponseAsync(nodeName, applicationId, servicePackageName).map(new Func1<ServiceResponse<DeployedServicePackageHealthInner>, DeployedServicePackageHealthInner>() {
            @Override
            public DeployedServicePackageHealthInner call(ServiceResponse<DeployedServicePackageHealthInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the information about health of a service package for a specific application deployed for a Service Fabric node and application.
     * Gets the information about health of a service package for a specific application deployed on a Service Fabric node. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed service package based on health state.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param servicePackageName The name of the service package.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeployedServicePackageHealthInner object
     */
    public Observable<ServiceResponse<DeployedServicePackageHealthInner>> getDeployedServicePackageHealthWithServiceResponseAsync(String nodeName, String applicationId, String servicePackageName) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        if (servicePackageName == null) {
            throw new IllegalArgumentException("Parameter servicePackageName is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Integer eventsHealthStateFilter = null;
        final Long timeout = null;
        return service.getDeployedServicePackageHealth(nodeName, applicationId, servicePackageName, apiVersion, eventsHealthStateFilter, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeployedServicePackageHealthInner>>>() {
                @Override
                public Observable<ServiceResponse<DeployedServicePackageHealthInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeployedServicePackageHealthInner> clientResponse = getDeployedServicePackageHealthDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the information about health of a service package for a specific application deployed for a Service Fabric node and application.
     * Gets the information about health of a service package for a specific application deployed on a Service Fabric node. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed service package based on health state.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param servicePackageName The name of the service package.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the DeployedServicePackageHealthInner object if successful.
     */
    public DeployedServicePackageHealthInner getDeployedServicePackageHealth(String nodeName, String applicationId, String servicePackageName, Integer eventsHealthStateFilter, Long timeout) {
        return getDeployedServicePackageHealthWithServiceResponseAsync(nodeName, applicationId, servicePackageName, eventsHealthStateFilter, timeout).toBlocking().single().body();
    }

    /**
     * Gets the information about health of a service package for a specific application deployed for a Service Fabric node and application.
     * Gets the information about health of a service package for a specific application deployed on a Service Fabric node. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed service package based on health state.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param servicePackageName The name of the service package.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<DeployedServicePackageHealthInner> getDeployedServicePackageHealthAsync(String nodeName, String applicationId, String servicePackageName, Integer eventsHealthStateFilter, Long timeout, final ServiceCallback<DeployedServicePackageHealthInner> serviceCallback) {
        return ServiceFuture.fromResponse(getDeployedServicePackageHealthWithServiceResponseAsync(nodeName, applicationId, servicePackageName, eventsHealthStateFilter, timeout), serviceCallback);
    }

    /**
     * Gets the information about health of a service package for a specific application deployed for a Service Fabric node and application.
     * Gets the information about health of a service package for a specific application deployed on a Service Fabric node. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed service package based on health state.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param servicePackageName The name of the service package.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeployedServicePackageHealthInner object
     */
    public Observable<DeployedServicePackageHealthInner> getDeployedServicePackageHealthAsync(String nodeName, String applicationId, String servicePackageName, Integer eventsHealthStateFilter, Long timeout) {
        return getDeployedServicePackageHealthWithServiceResponseAsync(nodeName, applicationId, servicePackageName, eventsHealthStateFilter, timeout).map(new Func1<ServiceResponse<DeployedServicePackageHealthInner>, DeployedServicePackageHealthInner>() {
            @Override
            public DeployedServicePackageHealthInner call(ServiceResponse<DeployedServicePackageHealthInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the information about health of a service package for a specific application deployed for a Service Fabric node and application.
     * Gets the information about health of a service package for a specific application deployed on a Service Fabric node. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed service package based on health state.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param servicePackageName The name of the service package.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeployedServicePackageHealthInner object
     */
    public Observable<ServiceResponse<DeployedServicePackageHealthInner>> getDeployedServicePackageHealthWithServiceResponseAsync(String nodeName, String applicationId, String servicePackageName, Integer eventsHealthStateFilter, Long timeout) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        if (servicePackageName == null) {
            throw new IllegalArgumentException("Parameter servicePackageName is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.getDeployedServicePackageHealth(nodeName, applicationId, servicePackageName, apiVersion, eventsHealthStateFilter, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeployedServicePackageHealthInner>>>() {
                @Override
                public Observable<ServiceResponse<DeployedServicePackageHealthInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeployedServicePackageHealthInner> clientResponse = getDeployedServicePackageHealthDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DeployedServicePackageHealthInner> getDeployedServicePackageHealthDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<DeployedServicePackageHealthInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<DeployedServicePackageHealthInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the information about health of service package for a specific application deployed on a Service Fabric node using the specified policy.
     * Gets the information about health of a service package for a specific application deployed on a Service Fabric node. using the specified policy. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed service package based on health state. Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the deployed service package.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param servicePackageName The name of the service package.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the DeployedServicePackageHealthInner object if successful.
     */
    public DeployedServicePackageHealthInner getDeployedServicePackageHealthUsingPolicy(String nodeName, String applicationId, String servicePackageName) {
        return getDeployedServicePackageHealthUsingPolicyWithServiceResponseAsync(nodeName, applicationId, servicePackageName).toBlocking().single().body();
    }

    /**
     * Gets the information about health of service package for a specific application deployed on a Service Fabric node using the specified policy.
     * Gets the information about health of a service package for a specific application deployed on a Service Fabric node. using the specified policy. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed service package based on health state. Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the deployed service package.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param servicePackageName The name of the service package.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<DeployedServicePackageHealthInner> getDeployedServicePackageHealthUsingPolicyAsync(String nodeName, String applicationId, String servicePackageName, final ServiceCallback<DeployedServicePackageHealthInner> serviceCallback) {
        return ServiceFuture.fromResponse(getDeployedServicePackageHealthUsingPolicyWithServiceResponseAsync(nodeName, applicationId, servicePackageName), serviceCallback);
    }

    /**
     * Gets the information about health of service package for a specific application deployed on a Service Fabric node using the specified policy.
     * Gets the information about health of a service package for a specific application deployed on a Service Fabric node. using the specified policy. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed service package based on health state. Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the deployed service package.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param servicePackageName The name of the service package.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeployedServicePackageHealthInner object
     */
    public Observable<DeployedServicePackageHealthInner> getDeployedServicePackageHealthUsingPolicyAsync(String nodeName, String applicationId, String servicePackageName) {
        return getDeployedServicePackageHealthUsingPolicyWithServiceResponseAsync(nodeName, applicationId, servicePackageName).map(new Func1<ServiceResponse<DeployedServicePackageHealthInner>, DeployedServicePackageHealthInner>() {
            @Override
            public DeployedServicePackageHealthInner call(ServiceResponse<DeployedServicePackageHealthInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the information about health of service package for a specific application deployed on a Service Fabric node using the specified policy.
     * Gets the information about health of a service package for a specific application deployed on a Service Fabric node. using the specified policy. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed service package based on health state. Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the deployed service package.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param servicePackageName The name of the service package.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeployedServicePackageHealthInner object
     */
    public Observable<ServiceResponse<DeployedServicePackageHealthInner>> getDeployedServicePackageHealthUsingPolicyWithServiceResponseAsync(String nodeName, String applicationId, String servicePackageName) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        if (servicePackageName == null) {
            throw new IllegalArgumentException("Parameter servicePackageName is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Integer eventsHealthStateFilter = null;
        final ApplicationHealthPolicy applicationHealthPolicy = null;
        final Long timeout = null;
        return service.getDeployedServicePackageHealthUsingPolicy(nodeName, applicationId, servicePackageName, apiVersion, eventsHealthStateFilter, applicationHealthPolicy, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeployedServicePackageHealthInner>>>() {
                @Override
                public Observable<ServiceResponse<DeployedServicePackageHealthInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeployedServicePackageHealthInner> clientResponse = getDeployedServicePackageHealthUsingPolicyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the information about health of service package for a specific application deployed on a Service Fabric node using the specified policy.
     * Gets the information about health of a service package for a specific application deployed on a Service Fabric node. using the specified policy. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed service package based on health state. Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the deployed service package.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param servicePackageName The name of the service package.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param applicationHealthPolicy Describes the health policies used to evaluate the health of an application or one of its children.
     If not present, the health evaluation uses the health policy from application manifest or the default health policy.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the DeployedServicePackageHealthInner object if successful.
     */
    public DeployedServicePackageHealthInner getDeployedServicePackageHealthUsingPolicy(String nodeName, String applicationId, String servicePackageName, Integer eventsHealthStateFilter, ApplicationHealthPolicy applicationHealthPolicy, Long timeout) {
        return getDeployedServicePackageHealthUsingPolicyWithServiceResponseAsync(nodeName, applicationId, servicePackageName, eventsHealthStateFilter, applicationHealthPolicy, timeout).toBlocking().single().body();
    }

    /**
     * Gets the information about health of service package for a specific application deployed on a Service Fabric node using the specified policy.
     * Gets the information about health of a service package for a specific application deployed on a Service Fabric node. using the specified policy. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed service package based on health state. Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the deployed service package.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param servicePackageName The name of the service package.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param applicationHealthPolicy Describes the health policies used to evaluate the health of an application or one of its children.
     If not present, the health evaluation uses the health policy from application manifest or the default health policy.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<DeployedServicePackageHealthInner> getDeployedServicePackageHealthUsingPolicyAsync(String nodeName, String applicationId, String servicePackageName, Integer eventsHealthStateFilter, ApplicationHealthPolicy applicationHealthPolicy, Long timeout, final ServiceCallback<DeployedServicePackageHealthInner> serviceCallback) {
        return ServiceFuture.fromResponse(getDeployedServicePackageHealthUsingPolicyWithServiceResponseAsync(nodeName, applicationId, servicePackageName, eventsHealthStateFilter, applicationHealthPolicy, timeout), serviceCallback);
    }

    /**
     * Gets the information about health of service package for a specific application deployed on a Service Fabric node using the specified policy.
     * Gets the information about health of a service package for a specific application deployed on a Service Fabric node. using the specified policy. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed service package based on health state. Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the deployed service package.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param servicePackageName The name of the service package.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param applicationHealthPolicy Describes the health policies used to evaluate the health of an application or one of its children.
     If not present, the health evaluation uses the health policy from application manifest or the default health policy.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeployedServicePackageHealthInner object
     */
    public Observable<DeployedServicePackageHealthInner> getDeployedServicePackageHealthUsingPolicyAsync(String nodeName, String applicationId, String servicePackageName, Integer eventsHealthStateFilter, ApplicationHealthPolicy applicationHealthPolicy, Long timeout) {
        return getDeployedServicePackageHealthUsingPolicyWithServiceResponseAsync(nodeName, applicationId, servicePackageName, eventsHealthStateFilter, applicationHealthPolicy, timeout).map(new Func1<ServiceResponse<DeployedServicePackageHealthInner>, DeployedServicePackageHealthInner>() {
            @Override
            public DeployedServicePackageHealthInner call(ServiceResponse<DeployedServicePackageHealthInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the information about health of service package for a specific application deployed on a Service Fabric node using the specified policy.
     * Gets the information about health of a service package for a specific application deployed on a Service Fabric node. using the specified policy. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed service package based on health state. Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the deployed service package.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param servicePackageName The name of the service package.
     * @param eventsHealthStateFilter Allows filtering the collection of HealthEvent objects returned based on health state.
     The possible values for this parameter include integer value of one of the following health states.
     Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
     If not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
     - Default - Default value. Matches any HealthState. The value is zero.
     - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
     - Ok - Filter that matches input with HealthState value Ok. The value is 2.
     - Warning - Filter that matches input with HealthState value Warning. The value is 4.
     - Error - Filter that matches input with HealthState value Error. The value is 8.
     - All - Filter that matches input with any HealthState value. The value is 65535.
     * @param applicationHealthPolicy Describes the health policies used to evaluate the health of an application or one of its children.
     If not present, the health evaluation uses the health policy from application manifest or the default health policy.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeployedServicePackageHealthInner object
     */
    public Observable<ServiceResponse<DeployedServicePackageHealthInner>> getDeployedServicePackageHealthUsingPolicyWithServiceResponseAsync(String nodeName, String applicationId, String servicePackageName, Integer eventsHealthStateFilter, ApplicationHealthPolicy applicationHealthPolicy, Long timeout) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        if (servicePackageName == null) {
            throw new IllegalArgumentException("Parameter servicePackageName is required and cannot be null.");
        }
        Validator.validate(applicationHealthPolicy);
        final String apiVersion = "6.0";
        return service.getDeployedServicePackageHealthUsingPolicy(nodeName, applicationId, servicePackageName, apiVersion, eventsHealthStateFilter, applicationHealthPolicy, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeployedServicePackageHealthInner>>>() {
                @Override
                public Observable<ServiceResponse<DeployedServicePackageHealthInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeployedServicePackageHealthInner> clientResponse = getDeployedServicePackageHealthUsingPolicyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DeployedServicePackageHealthInner> getDeployedServicePackageHealthUsingPolicyDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<DeployedServicePackageHealthInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<DeployedServicePackageHealthInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Sends a health report on the Service Fabric deployed service package.
     * Reports health state of the service package of the application deployed on a Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway Service, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, get deployed service package health and check that the report appears in the HealthEvents section.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param servicePackageName The name of the service package.
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void reportDeployedServicePackageHealth(String nodeName, String applicationId, String servicePackageName, HealthInformation healthInformation) {
        reportDeployedServicePackageHealthWithServiceResponseAsync(nodeName, applicationId, servicePackageName, healthInformation).toBlocking().single().body();
    }

    /**
     * Sends a health report on the Service Fabric deployed service package.
     * Reports health state of the service package of the application deployed on a Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway Service, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, get deployed service package health and check that the report appears in the HealthEvents section.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param servicePackageName The name of the service package.
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> reportDeployedServicePackageHealthAsync(String nodeName, String applicationId, String servicePackageName, HealthInformation healthInformation, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(reportDeployedServicePackageHealthWithServiceResponseAsync(nodeName, applicationId, servicePackageName, healthInformation), serviceCallback);
    }

    /**
     * Sends a health report on the Service Fabric deployed service package.
     * Reports health state of the service package of the application deployed on a Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway Service, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, get deployed service package health and check that the report appears in the HealthEvents section.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param servicePackageName The name of the service package.
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> reportDeployedServicePackageHealthAsync(String nodeName, String applicationId, String servicePackageName, HealthInformation healthInformation) {
        return reportDeployedServicePackageHealthWithServiceResponseAsync(nodeName, applicationId, servicePackageName, healthInformation).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Sends a health report on the Service Fabric deployed service package.
     * Reports health state of the service package of the application deployed on a Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway Service, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, get deployed service package health and check that the report appears in the HealthEvents section.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param servicePackageName The name of the service package.
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> reportDeployedServicePackageHealthWithServiceResponseAsync(String nodeName, String applicationId, String servicePackageName, HealthInformation healthInformation) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        if (servicePackageName == null) {
            throw new IllegalArgumentException("Parameter servicePackageName is required and cannot be null.");
        }
        if (healthInformation == null) {
            throw new IllegalArgumentException("Parameter healthInformation is required and cannot be null.");
        }
        Validator.validate(healthInformation);
        final String apiVersion = "6.0";
        final Boolean immediate = null;
        final Long timeout = null;
        return service.reportDeployedServicePackageHealth(nodeName, applicationId, servicePackageName, apiVersion, healthInformation, immediate, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = reportDeployedServicePackageHealthDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Sends a health report on the Service Fabric deployed service package.
     * Reports health state of the service package of the application deployed on a Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway Service, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, get deployed service package health and check that the report appears in the HealthEvents section.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param servicePackageName The name of the service package.
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @param immediate A flag that indicates whether the report should be sent immediately.
     A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
     If Immediate is set to true, the report is sent immediately from HTTP Gateway to the health store, regardless of the fabric client settings that the HTTP Gateway Application is using.
     This is useful for critical reports that should be sent as soon as possible.
     Depending on timing and other conditions, sending the report may still fail, for example if the HTTP Gateway is closed or the message doesn't reach the Gateway.
     If Immediate is set to false, the report is sent based on the health client settings from the HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
     This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
     By default, reports are not sent immediately.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void reportDeployedServicePackageHealth(String nodeName, String applicationId, String servicePackageName, HealthInformation healthInformation, Boolean immediate, Long timeout) {
        reportDeployedServicePackageHealthWithServiceResponseAsync(nodeName, applicationId, servicePackageName, healthInformation, immediate, timeout).toBlocking().single().body();
    }

    /**
     * Sends a health report on the Service Fabric deployed service package.
     * Reports health state of the service package of the application deployed on a Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway Service, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, get deployed service package health and check that the report appears in the HealthEvents section.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param servicePackageName The name of the service package.
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @param immediate A flag that indicates whether the report should be sent immediately.
     A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
     If Immediate is set to true, the report is sent immediately from HTTP Gateway to the health store, regardless of the fabric client settings that the HTTP Gateway Application is using.
     This is useful for critical reports that should be sent as soon as possible.
     Depending on timing and other conditions, sending the report may still fail, for example if the HTTP Gateway is closed or the message doesn't reach the Gateway.
     If Immediate is set to false, the report is sent based on the health client settings from the HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
     This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
     By default, reports are not sent immediately.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> reportDeployedServicePackageHealthAsync(String nodeName, String applicationId, String servicePackageName, HealthInformation healthInformation, Boolean immediate, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(reportDeployedServicePackageHealthWithServiceResponseAsync(nodeName, applicationId, servicePackageName, healthInformation, immediate, timeout), serviceCallback);
    }

    /**
     * Sends a health report on the Service Fabric deployed service package.
     * Reports health state of the service package of the application deployed on a Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway Service, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, get deployed service package health and check that the report appears in the HealthEvents section.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param servicePackageName The name of the service package.
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @param immediate A flag that indicates whether the report should be sent immediately.
     A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
     If Immediate is set to true, the report is sent immediately from HTTP Gateway to the health store, regardless of the fabric client settings that the HTTP Gateway Application is using.
     This is useful for critical reports that should be sent as soon as possible.
     Depending on timing and other conditions, sending the report may still fail, for example if the HTTP Gateway is closed or the message doesn't reach the Gateway.
     If Immediate is set to false, the report is sent based on the health client settings from the HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
     This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
     By default, reports are not sent immediately.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> reportDeployedServicePackageHealthAsync(String nodeName, String applicationId, String servicePackageName, HealthInformation healthInformation, Boolean immediate, Long timeout) {
        return reportDeployedServicePackageHealthWithServiceResponseAsync(nodeName, applicationId, servicePackageName, healthInformation, immediate, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Sends a health report on the Service Fabric deployed service package.
     * Reports health state of the service package of the application deployed on a Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.
     The report is sent to a Service Fabric gateway Service, which forwards to the health store.
     The report may be accepted by the gateway, but rejected by the health store after extra validation.
     For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
     To see whether the report was applied in the health store, get deployed service package health and check that the report appears in the HealthEvents section.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param servicePackageName The name of the service package.
     * @param healthInformation Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
     * @param immediate A flag that indicates whether the report should be sent immediately.
     A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
     If Immediate is set to true, the report is sent immediately from HTTP Gateway to the health store, regardless of the fabric client settings that the HTTP Gateway Application is using.
     This is useful for critical reports that should be sent as soon as possible.
     Depending on timing and other conditions, sending the report may still fail, for example if the HTTP Gateway is closed or the message doesn't reach the Gateway.
     If Immediate is set to false, the report is sent based on the health client settings from the HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
     This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
     By default, reports are not sent immediately.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> reportDeployedServicePackageHealthWithServiceResponseAsync(String nodeName, String applicationId, String servicePackageName, HealthInformation healthInformation, Boolean immediate, Long timeout) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        if (servicePackageName == null) {
            throw new IllegalArgumentException("Parameter servicePackageName is required and cannot be null.");
        }
        if (healthInformation == null) {
            throw new IllegalArgumentException("Parameter healthInformation is required and cannot be null.");
        }
        Validator.validate(healthInformation);
        final String apiVersion = "6.0";
        return service.reportDeployedServicePackageHealth(nodeName, applicationId, servicePackageName, apiVersion, healthInformation, immediate, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = reportDeployedServicePackageHealthDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> reportDeployedServicePackageHealthDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Downloads all of the code packages associated with specified service manifest on the specified node.
     * This API provides a way to download code packages including the container images on a specific node outside of the normal application deployment and upgrade path. This is useful for the large code packages and container images to be present on the node before the actual application deployment and upgrade, thus significantly reducing the total time required for the deployment or upgrade.
     *
     * @param nodeName The name of the node.
     * @param deployServicePackageToNodeDescription Describes information for deploying a service package to a Service Fabric node.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deployServicePackageToNode(String nodeName, DeployServicePackageToNodeDescription deployServicePackageToNodeDescription) {
        deployServicePackageToNodeWithServiceResponseAsync(nodeName, deployServicePackageToNodeDescription).toBlocking().single().body();
    }

    /**
     * Downloads all of the code packages associated with specified service manifest on the specified node.
     * This API provides a way to download code packages including the container images on a specific node outside of the normal application deployment and upgrade path. This is useful for the large code packages and container images to be present on the node before the actual application deployment and upgrade, thus significantly reducing the total time required for the deployment or upgrade.
     *
     * @param nodeName The name of the node.
     * @param deployServicePackageToNodeDescription Describes information for deploying a service package to a Service Fabric node.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deployServicePackageToNodeAsync(String nodeName, DeployServicePackageToNodeDescription deployServicePackageToNodeDescription, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deployServicePackageToNodeWithServiceResponseAsync(nodeName, deployServicePackageToNodeDescription), serviceCallback);
    }

    /**
     * Downloads all of the code packages associated with specified service manifest on the specified node.
     * This API provides a way to download code packages including the container images on a specific node outside of the normal application deployment and upgrade path. This is useful for the large code packages and container images to be present on the node before the actual application deployment and upgrade, thus significantly reducing the total time required for the deployment or upgrade.
     *
     * @param nodeName The name of the node.
     * @param deployServicePackageToNodeDescription Describes information for deploying a service package to a Service Fabric node.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deployServicePackageToNodeAsync(String nodeName, DeployServicePackageToNodeDescription deployServicePackageToNodeDescription) {
        return deployServicePackageToNodeWithServiceResponseAsync(nodeName, deployServicePackageToNodeDescription).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Downloads all of the code packages associated with specified service manifest on the specified node.
     * This API provides a way to download code packages including the container images on a specific node outside of the normal application deployment and upgrade path. This is useful for the large code packages and container images to be present on the node before the actual application deployment and upgrade, thus significantly reducing the total time required for the deployment or upgrade.
     *
     * @param nodeName The name of the node.
     * @param deployServicePackageToNodeDescription Describes information for deploying a service package to a Service Fabric node.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deployServicePackageToNodeWithServiceResponseAsync(String nodeName, DeployServicePackageToNodeDescription deployServicePackageToNodeDescription) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (deployServicePackageToNodeDescription == null) {
            throw new IllegalArgumentException("Parameter deployServicePackageToNodeDescription is required and cannot be null.");
        }
        Validator.validate(deployServicePackageToNodeDescription);
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.deployServicePackageToNode(nodeName, apiVersion, deployServicePackageToNodeDescription, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deployServicePackageToNodeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Downloads all of the code packages associated with specified service manifest on the specified node.
     * This API provides a way to download code packages including the container images on a specific node outside of the normal application deployment and upgrade path. This is useful for the large code packages and container images to be present on the node before the actual application deployment and upgrade, thus significantly reducing the total time required for the deployment or upgrade.
     *
     * @param nodeName The name of the node.
     * @param deployServicePackageToNodeDescription Describes information for deploying a service package to a Service Fabric node.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deployServicePackageToNode(String nodeName, DeployServicePackageToNodeDescription deployServicePackageToNodeDescription, Long timeout) {
        deployServicePackageToNodeWithServiceResponseAsync(nodeName, deployServicePackageToNodeDescription, timeout).toBlocking().single().body();
    }

    /**
     * Downloads all of the code packages associated with specified service manifest on the specified node.
     * This API provides a way to download code packages including the container images on a specific node outside of the normal application deployment and upgrade path. This is useful for the large code packages and container images to be present on the node before the actual application deployment and upgrade, thus significantly reducing the total time required for the deployment or upgrade.
     *
     * @param nodeName The name of the node.
     * @param deployServicePackageToNodeDescription Describes information for deploying a service package to a Service Fabric node.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deployServicePackageToNodeAsync(String nodeName, DeployServicePackageToNodeDescription deployServicePackageToNodeDescription, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deployServicePackageToNodeWithServiceResponseAsync(nodeName, deployServicePackageToNodeDescription, timeout), serviceCallback);
    }

    /**
     * Downloads all of the code packages associated with specified service manifest on the specified node.
     * This API provides a way to download code packages including the container images on a specific node outside of the normal application deployment and upgrade path. This is useful for the large code packages and container images to be present on the node before the actual application deployment and upgrade, thus significantly reducing the total time required for the deployment or upgrade.
     *
     * @param nodeName The name of the node.
     * @param deployServicePackageToNodeDescription Describes information for deploying a service package to a Service Fabric node.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deployServicePackageToNodeAsync(String nodeName, DeployServicePackageToNodeDescription deployServicePackageToNodeDescription, Long timeout) {
        return deployServicePackageToNodeWithServiceResponseAsync(nodeName, deployServicePackageToNodeDescription, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Downloads all of the code packages associated with specified service manifest on the specified node.
     * This API provides a way to download code packages including the container images on a specific node outside of the normal application deployment and upgrade path. This is useful for the large code packages and container images to be present on the node before the actual application deployment and upgrade, thus significantly reducing the total time required for the deployment or upgrade.
     *
     * @param nodeName The name of the node.
     * @param deployServicePackageToNodeDescription Describes information for deploying a service package to a Service Fabric node.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deployServicePackageToNodeWithServiceResponseAsync(String nodeName, DeployServicePackageToNodeDescription deployServicePackageToNodeDescription, Long timeout) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (deployServicePackageToNodeDescription == null) {
            throw new IllegalArgumentException("Parameter deployServicePackageToNodeDescription is required and cannot be null.");
        }
        Validator.validate(deployServicePackageToNodeDescription);
        final String apiVersion = "6.0";
        return service.deployServicePackageToNode(nodeName, apiVersion, deployServicePackageToNodeDescription, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deployServicePackageToNodeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deployServicePackageToNodeDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the list of code packages deployed on a Service Fabric node.
     * Gets the list of code packages deployed on a Service Fabric node for the given application.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;DeployedCodePackageInfoInner&gt; object if successful.
     */
    public List<DeployedCodePackageInfoInner> getDeployedCodePackageInfoList(String nodeName, String applicationId) {
        return getDeployedCodePackageInfoListWithServiceResponseAsync(nodeName, applicationId).toBlocking().single().body();
    }

    /**
     * Gets the list of code packages deployed on a Service Fabric node.
     * Gets the list of code packages deployed on a Service Fabric node for the given application.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<DeployedCodePackageInfoInner>> getDeployedCodePackageInfoListAsync(String nodeName, String applicationId, final ServiceCallback<List<DeployedCodePackageInfoInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getDeployedCodePackageInfoListWithServiceResponseAsync(nodeName, applicationId), serviceCallback);
    }

    /**
     * Gets the list of code packages deployed on a Service Fabric node.
     * Gets the list of code packages deployed on a Service Fabric node for the given application.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;DeployedCodePackageInfoInner&gt; object
     */
    public Observable<List<DeployedCodePackageInfoInner>> getDeployedCodePackageInfoListAsync(String nodeName, String applicationId) {
        return getDeployedCodePackageInfoListWithServiceResponseAsync(nodeName, applicationId).map(new Func1<ServiceResponse<List<DeployedCodePackageInfoInner>>, List<DeployedCodePackageInfoInner>>() {
            @Override
            public List<DeployedCodePackageInfoInner> call(ServiceResponse<List<DeployedCodePackageInfoInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the list of code packages deployed on a Service Fabric node.
     * Gets the list of code packages deployed on a Service Fabric node for the given application.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;DeployedCodePackageInfoInner&gt; object
     */
    public Observable<ServiceResponse<List<DeployedCodePackageInfoInner>>> getDeployedCodePackageInfoListWithServiceResponseAsync(String nodeName, String applicationId) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final String serviceManifestName = null;
        final String codePackageName = null;
        final Long timeout = null;
        return service.getDeployedCodePackageInfoList(nodeName, applicationId, apiVersion, serviceManifestName, codePackageName, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<DeployedCodePackageInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<DeployedCodePackageInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<DeployedCodePackageInfoInner>> clientResponse = getDeployedCodePackageInfoListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the list of code packages deployed on a Service Fabric node.
     * Gets the list of code packages deployed on a Service Fabric node for the given application.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceManifestName The name of a service manifest registered as part of an application type in a Service Fabric cluster.
     * @param codePackageName The name of code package specified in service manifest registered as part of an application type in a Service Fabric cluster.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;DeployedCodePackageInfoInner&gt; object if successful.
     */
    public List<DeployedCodePackageInfoInner> getDeployedCodePackageInfoList(String nodeName, String applicationId, String serviceManifestName, String codePackageName, Long timeout) {
        return getDeployedCodePackageInfoListWithServiceResponseAsync(nodeName, applicationId, serviceManifestName, codePackageName, timeout).toBlocking().single().body();
    }

    /**
     * Gets the list of code packages deployed on a Service Fabric node.
     * Gets the list of code packages deployed on a Service Fabric node for the given application.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceManifestName The name of a service manifest registered as part of an application type in a Service Fabric cluster.
     * @param codePackageName The name of code package specified in service manifest registered as part of an application type in a Service Fabric cluster.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<DeployedCodePackageInfoInner>> getDeployedCodePackageInfoListAsync(String nodeName, String applicationId, String serviceManifestName, String codePackageName, Long timeout, final ServiceCallback<List<DeployedCodePackageInfoInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getDeployedCodePackageInfoListWithServiceResponseAsync(nodeName, applicationId, serviceManifestName, codePackageName, timeout), serviceCallback);
    }

    /**
     * Gets the list of code packages deployed on a Service Fabric node.
     * Gets the list of code packages deployed on a Service Fabric node for the given application.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceManifestName The name of a service manifest registered as part of an application type in a Service Fabric cluster.
     * @param codePackageName The name of code package specified in service manifest registered as part of an application type in a Service Fabric cluster.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;DeployedCodePackageInfoInner&gt; object
     */
    public Observable<List<DeployedCodePackageInfoInner>> getDeployedCodePackageInfoListAsync(String nodeName, String applicationId, String serviceManifestName, String codePackageName, Long timeout) {
        return getDeployedCodePackageInfoListWithServiceResponseAsync(nodeName, applicationId, serviceManifestName, codePackageName, timeout).map(new Func1<ServiceResponse<List<DeployedCodePackageInfoInner>>, List<DeployedCodePackageInfoInner>>() {
            @Override
            public List<DeployedCodePackageInfoInner> call(ServiceResponse<List<DeployedCodePackageInfoInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the list of code packages deployed on a Service Fabric node.
     * Gets the list of code packages deployed on a Service Fabric node for the given application.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceManifestName The name of a service manifest registered as part of an application type in a Service Fabric cluster.
     * @param codePackageName The name of code package specified in service manifest registered as part of an application type in a Service Fabric cluster.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;DeployedCodePackageInfoInner&gt; object
     */
    public Observable<ServiceResponse<List<DeployedCodePackageInfoInner>>> getDeployedCodePackageInfoListWithServiceResponseAsync(String nodeName, String applicationId, String serviceManifestName, String codePackageName, Long timeout) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.getDeployedCodePackageInfoList(nodeName, applicationId, apiVersion, serviceManifestName, codePackageName, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<DeployedCodePackageInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<DeployedCodePackageInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<DeployedCodePackageInfoInner>> clientResponse = getDeployedCodePackageInfoListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<DeployedCodePackageInfoInner>> getDeployedCodePackageInfoListDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<DeployedCodePackageInfoInner>, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<DeployedCodePackageInfoInner>>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Restarts a code package deployed on a Service Fabric node in a cluster.
     * Restarts a code package deployed on a Service Fabric node in a cluster. This aborts the code package process, which will restart all the user service replicas hosted in that process.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param restartDeployedCodePackageDescription Describes the deployed code package on Service Fabric node to restart.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void restartDeployedCodePackage(String nodeName, String applicationId, RestartDeployedCodePackageDescription restartDeployedCodePackageDescription) {
        restartDeployedCodePackageWithServiceResponseAsync(nodeName, applicationId, restartDeployedCodePackageDescription).toBlocking().single().body();
    }

    /**
     * Restarts a code package deployed on a Service Fabric node in a cluster.
     * Restarts a code package deployed on a Service Fabric node in a cluster. This aborts the code package process, which will restart all the user service replicas hosted in that process.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param restartDeployedCodePackageDescription Describes the deployed code package on Service Fabric node to restart.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> restartDeployedCodePackageAsync(String nodeName, String applicationId, RestartDeployedCodePackageDescription restartDeployedCodePackageDescription, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(restartDeployedCodePackageWithServiceResponseAsync(nodeName, applicationId, restartDeployedCodePackageDescription), serviceCallback);
    }

    /**
     * Restarts a code package deployed on a Service Fabric node in a cluster.
     * Restarts a code package deployed on a Service Fabric node in a cluster. This aborts the code package process, which will restart all the user service replicas hosted in that process.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param restartDeployedCodePackageDescription Describes the deployed code package on Service Fabric node to restart.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> restartDeployedCodePackageAsync(String nodeName, String applicationId, RestartDeployedCodePackageDescription restartDeployedCodePackageDescription) {
        return restartDeployedCodePackageWithServiceResponseAsync(nodeName, applicationId, restartDeployedCodePackageDescription).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Restarts a code package deployed on a Service Fabric node in a cluster.
     * Restarts a code package deployed on a Service Fabric node in a cluster. This aborts the code package process, which will restart all the user service replicas hosted in that process.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param restartDeployedCodePackageDescription Describes the deployed code package on Service Fabric node to restart.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> restartDeployedCodePackageWithServiceResponseAsync(String nodeName, String applicationId, RestartDeployedCodePackageDescription restartDeployedCodePackageDescription) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        if (restartDeployedCodePackageDescription == null) {
            throw new IllegalArgumentException("Parameter restartDeployedCodePackageDescription is required and cannot be null.");
        }
        Validator.validate(restartDeployedCodePackageDescription);
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.restartDeployedCodePackage(nodeName, applicationId, apiVersion, restartDeployedCodePackageDescription, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = restartDeployedCodePackageDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Restarts a code package deployed on a Service Fabric node in a cluster.
     * Restarts a code package deployed on a Service Fabric node in a cluster. This aborts the code package process, which will restart all the user service replicas hosted in that process.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param restartDeployedCodePackageDescription Describes the deployed code package on Service Fabric node to restart.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void restartDeployedCodePackage(String nodeName, String applicationId, RestartDeployedCodePackageDescription restartDeployedCodePackageDescription, Long timeout) {
        restartDeployedCodePackageWithServiceResponseAsync(nodeName, applicationId, restartDeployedCodePackageDescription, timeout).toBlocking().single().body();
    }

    /**
     * Restarts a code package deployed on a Service Fabric node in a cluster.
     * Restarts a code package deployed on a Service Fabric node in a cluster. This aborts the code package process, which will restart all the user service replicas hosted in that process.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param restartDeployedCodePackageDescription Describes the deployed code package on Service Fabric node to restart.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> restartDeployedCodePackageAsync(String nodeName, String applicationId, RestartDeployedCodePackageDescription restartDeployedCodePackageDescription, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(restartDeployedCodePackageWithServiceResponseAsync(nodeName, applicationId, restartDeployedCodePackageDescription, timeout), serviceCallback);
    }

    /**
     * Restarts a code package deployed on a Service Fabric node in a cluster.
     * Restarts a code package deployed on a Service Fabric node in a cluster. This aborts the code package process, which will restart all the user service replicas hosted in that process.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param restartDeployedCodePackageDescription Describes the deployed code package on Service Fabric node to restart.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> restartDeployedCodePackageAsync(String nodeName, String applicationId, RestartDeployedCodePackageDescription restartDeployedCodePackageDescription, Long timeout) {
        return restartDeployedCodePackageWithServiceResponseAsync(nodeName, applicationId, restartDeployedCodePackageDescription, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Restarts a code package deployed on a Service Fabric node in a cluster.
     * Restarts a code package deployed on a Service Fabric node in a cluster. This aborts the code package process, which will restart all the user service replicas hosted in that process.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param restartDeployedCodePackageDescription Describes the deployed code package on Service Fabric node to restart.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> restartDeployedCodePackageWithServiceResponseAsync(String nodeName, String applicationId, RestartDeployedCodePackageDescription restartDeployedCodePackageDescription, Long timeout) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        if (restartDeployedCodePackageDescription == null) {
            throw new IllegalArgumentException("Parameter restartDeployedCodePackageDescription is required and cannot be null.");
        }
        Validator.validate(restartDeployedCodePackageDescription);
        final String apiVersion = "6.0";
        return service.restartDeployedCodePackage(nodeName, applicationId, apiVersion, restartDeployedCodePackageDescription, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = restartDeployedCodePackageDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> restartDeployedCodePackageDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the container logs for container deployed on a Service Fabric node.
     * Gets the container logs for container deployed on a Service Fabric node for the given code package.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceManifestName The name of a service manifest registered as part of an application type in a Service Fabric cluster.
     * @param codePackageName The name of code package specified in service manifest registered as part of an application type in a Service Fabric cluster.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ContainerLogsInner object if successful.
     */
    public ContainerLogsInner getContainerLogsDeployedOnNode(String nodeName, String applicationId, String serviceManifestName, String codePackageName) {
        return getContainerLogsDeployedOnNodeWithServiceResponseAsync(nodeName, applicationId, serviceManifestName, codePackageName).toBlocking().single().body();
    }

    /**
     * Gets the container logs for container deployed on a Service Fabric node.
     * Gets the container logs for container deployed on a Service Fabric node for the given code package.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceManifestName The name of a service manifest registered as part of an application type in a Service Fabric cluster.
     * @param codePackageName The name of code package specified in service manifest registered as part of an application type in a Service Fabric cluster.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ContainerLogsInner> getContainerLogsDeployedOnNodeAsync(String nodeName, String applicationId, String serviceManifestName, String codePackageName, final ServiceCallback<ContainerLogsInner> serviceCallback) {
        return ServiceFuture.fromResponse(getContainerLogsDeployedOnNodeWithServiceResponseAsync(nodeName, applicationId, serviceManifestName, codePackageName), serviceCallback);
    }

    /**
     * Gets the container logs for container deployed on a Service Fabric node.
     * Gets the container logs for container deployed on a Service Fabric node for the given code package.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceManifestName The name of a service manifest registered as part of an application type in a Service Fabric cluster.
     * @param codePackageName The name of code package specified in service manifest registered as part of an application type in a Service Fabric cluster.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ContainerLogsInner object
     */
    public Observable<ContainerLogsInner> getContainerLogsDeployedOnNodeAsync(String nodeName, String applicationId, String serviceManifestName, String codePackageName) {
        return getContainerLogsDeployedOnNodeWithServiceResponseAsync(nodeName, applicationId, serviceManifestName, codePackageName).map(new Func1<ServiceResponse<ContainerLogsInner>, ContainerLogsInner>() {
            @Override
            public ContainerLogsInner call(ServiceResponse<ContainerLogsInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the container logs for container deployed on a Service Fabric node.
     * Gets the container logs for container deployed on a Service Fabric node for the given code package.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceManifestName The name of a service manifest registered as part of an application type in a Service Fabric cluster.
     * @param codePackageName The name of code package specified in service manifest registered as part of an application type in a Service Fabric cluster.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ContainerLogsInner object
     */
    public Observable<ServiceResponse<ContainerLogsInner>> getContainerLogsDeployedOnNodeWithServiceResponseAsync(String nodeName, String applicationId, String serviceManifestName, String codePackageName) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        if (serviceManifestName == null) {
            throw new IllegalArgumentException("Parameter serviceManifestName is required and cannot be null.");
        }
        if (codePackageName == null) {
            throw new IllegalArgumentException("Parameter codePackageName is required and cannot be null.");
        }
        final String apiVersion = "6.2";
        final String tail = null;
        final Boolean previous = null;
        final Long timeout = null;
        return service.getContainerLogsDeployedOnNode(nodeName, applicationId, apiVersion, serviceManifestName, codePackageName, tail, previous, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ContainerLogsInner>>>() {
                @Override
                public Observable<ServiceResponse<ContainerLogsInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ContainerLogsInner> clientResponse = getContainerLogsDeployedOnNodeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the container logs for container deployed on a Service Fabric node.
     * Gets the container logs for container deployed on a Service Fabric node for the given code package.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceManifestName The name of a service manifest registered as part of an application type in a Service Fabric cluster.
     * @param codePackageName The name of code package specified in service manifest registered as part of an application type in a Service Fabric cluster.
     * @param tail Number of lines to show from the end of the logs. Default is 100. 'all' to show the complete logs.
     * @param previous Specifies whether to get container logs from exited/dead containers of the code package instance.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ContainerLogsInner object if successful.
     */
    public ContainerLogsInner getContainerLogsDeployedOnNode(String nodeName, String applicationId, String serviceManifestName, String codePackageName, String tail, Boolean previous, Long timeout) {
        return getContainerLogsDeployedOnNodeWithServiceResponseAsync(nodeName, applicationId, serviceManifestName, codePackageName, tail, previous, timeout).toBlocking().single().body();
    }

    /**
     * Gets the container logs for container deployed on a Service Fabric node.
     * Gets the container logs for container deployed on a Service Fabric node for the given code package.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceManifestName The name of a service manifest registered as part of an application type in a Service Fabric cluster.
     * @param codePackageName The name of code package specified in service manifest registered as part of an application type in a Service Fabric cluster.
     * @param tail Number of lines to show from the end of the logs. Default is 100. 'all' to show the complete logs.
     * @param previous Specifies whether to get container logs from exited/dead containers of the code package instance.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ContainerLogsInner> getContainerLogsDeployedOnNodeAsync(String nodeName, String applicationId, String serviceManifestName, String codePackageName, String tail, Boolean previous, Long timeout, final ServiceCallback<ContainerLogsInner> serviceCallback) {
        return ServiceFuture.fromResponse(getContainerLogsDeployedOnNodeWithServiceResponseAsync(nodeName, applicationId, serviceManifestName, codePackageName, tail, previous, timeout), serviceCallback);
    }

    /**
     * Gets the container logs for container deployed on a Service Fabric node.
     * Gets the container logs for container deployed on a Service Fabric node for the given code package.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceManifestName The name of a service manifest registered as part of an application type in a Service Fabric cluster.
     * @param codePackageName The name of code package specified in service manifest registered as part of an application type in a Service Fabric cluster.
     * @param tail Number of lines to show from the end of the logs. Default is 100. 'all' to show the complete logs.
     * @param previous Specifies whether to get container logs from exited/dead containers of the code package instance.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ContainerLogsInner object
     */
    public Observable<ContainerLogsInner> getContainerLogsDeployedOnNodeAsync(String nodeName, String applicationId, String serviceManifestName, String codePackageName, String tail, Boolean previous, Long timeout) {
        return getContainerLogsDeployedOnNodeWithServiceResponseAsync(nodeName, applicationId, serviceManifestName, codePackageName, tail, previous, timeout).map(new Func1<ServiceResponse<ContainerLogsInner>, ContainerLogsInner>() {
            @Override
            public ContainerLogsInner call(ServiceResponse<ContainerLogsInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the container logs for container deployed on a Service Fabric node.
     * Gets the container logs for container deployed on a Service Fabric node for the given code package.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceManifestName The name of a service manifest registered as part of an application type in a Service Fabric cluster.
     * @param codePackageName The name of code package specified in service manifest registered as part of an application type in a Service Fabric cluster.
     * @param tail Number of lines to show from the end of the logs. Default is 100. 'all' to show the complete logs.
     * @param previous Specifies whether to get container logs from exited/dead containers of the code package instance.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ContainerLogsInner object
     */
    public Observable<ServiceResponse<ContainerLogsInner>> getContainerLogsDeployedOnNodeWithServiceResponseAsync(String nodeName, String applicationId, String serviceManifestName, String codePackageName, String tail, Boolean previous, Long timeout) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        if (serviceManifestName == null) {
            throw new IllegalArgumentException("Parameter serviceManifestName is required and cannot be null.");
        }
        if (codePackageName == null) {
            throw new IllegalArgumentException("Parameter codePackageName is required and cannot be null.");
        }
        final String apiVersion = "6.2";
        return service.getContainerLogsDeployedOnNode(nodeName, applicationId, apiVersion, serviceManifestName, codePackageName, tail, previous, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ContainerLogsInner>>>() {
                @Override
                public Observable<ServiceResponse<ContainerLogsInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ContainerLogsInner> clientResponse = getContainerLogsDeployedOnNodeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ContainerLogsInner> getContainerLogsDeployedOnNodeDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ContainerLogsInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ContainerLogsInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Invoke container API on a container deployed on a Service Fabric node.
     * Invoke container API on a container deployed on a Service Fabric node for the given code package.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceManifestName The name of a service manifest registered as part of an application type in a Service Fabric cluster.
     * @param codePackageName The name of code package specified in service manifest registered as part of an application type in a Service Fabric cluster.
     * @param codePackageInstanceId ID that uniquely identifies a code package instance deployed on a service fabric node.
     * @param containerApiRequestBody Parameters for making container API call
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ContainerApiResponseInner object if successful.
     */
    public ContainerApiResponseInner invokeContainerApi(String nodeName, String applicationId, String serviceManifestName, String codePackageName, String codePackageInstanceId, ContainerApiRequestBody containerApiRequestBody) {
        return invokeContainerApiWithServiceResponseAsync(nodeName, applicationId, serviceManifestName, codePackageName, codePackageInstanceId, containerApiRequestBody).toBlocking().single().body();
    }

    /**
     * Invoke container API on a container deployed on a Service Fabric node.
     * Invoke container API on a container deployed on a Service Fabric node for the given code package.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceManifestName The name of a service manifest registered as part of an application type in a Service Fabric cluster.
     * @param codePackageName The name of code package specified in service manifest registered as part of an application type in a Service Fabric cluster.
     * @param codePackageInstanceId ID that uniquely identifies a code package instance deployed on a service fabric node.
     * @param containerApiRequestBody Parameters for making container API call
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ContainerApiResponseInner> invokeContainerApiAsync(String nodeName, String applicationId, String serviceManifestName, String codePackageName, String codePackageInstanceId, ContainerApiRequestBody containerApiRequestBody, final ServiceCallback<ContainerApiResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(invokeContainerApiWithServiceResponseAsync(nodeName, applicationId, serviceManifestName, codePackageName, codePackageInstanceId, containerApiRequestBody), serviceCallback);
    }

    /**
     * Invoke container API on a container deployed on a Service Fabric node.
     * Invoke container API on a container deployed on a Service Fabric node for the given code package.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceManifestName The name of a service manifest registered as part of an application type in a Service Fabric cluster.
     * @param codePackageName The name of code package specified in service manifest registered as part of an application type in a Service Fabric cluster.
     * @param codePackageInstanceId ID that uniquely identifies a code package instance deployed on a service fabric node.
     * @param containerApiRequestBody Parameters for making container API call
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ContainerApiResponseInner object
     */
    public Observable<ContainerApiResponseInner> invokeContainerApiAsync(String nodeName, String applicationId, String serviceManifestName, String codePackageName, String codePackageInstanceId, ContainerApiRequestBody containerApiRequestBody) {
        return invokeContainerApiWithServiceResponseAsync(nodeName, applicationId, serviceManifestName, codePackageName, codePackageInstanceId, containerApiRequestBody).map(new Func1<ServiceResponse<ContainerApiResponseInner>, ContainerApiResponseInner>() {
            @Override
            public ContainerApiResponseInner call(ServiceResponse<ContainerApiResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Invoke container API on a container deployed on a Service Fabric node.
     * Invoke container API on a container deployed on a Service Fabric node for the given code package.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceManifestName The name of a service manifest registered as part of an application type in a Service Fabric cluster.
     * @param codePackageName The name of code package specified in service manifest registered as part of an application type in a Service Fabric cluster.
     * @param codePackageInstanceId ID that uniquely identifies a code package instance deployed on a service fabric node.
     * @param containerApiRequestBody Parameters for making container API call
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ContainerApiResponseInner object
     */
    public Observable<ServiceResponse<ContainerApiResponseInner>> invokeContainerApiWithServiceResponseAsync(String nodeName, String applicationId, String serviceManifestName, String codePackageName, String codePackageInstanceId, ContainerApiRequestBody containerApiRequestBody) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        if (serviceManifestName == null) {
            throw new IllegalArgumentException("Parameter serviceManifestName is required and cannot be null.");
        }
        if (codePackageName == null) {
            throw new IllegalArgumentException("Parameter codePackageName is required and cannot be null.");
        }
        if (codePackageInstanceId == null) {
            throw new IllegalArgumentException("Parameter codePackageInstanceId is required and cannot be null.");
        }
        if (containerApiRequestBody == null) {
            throw new IllegalArgumentException("Parameter containerApiRequestBody is required and cannot be null.");
        }
        Validator.validate(containerApiRequestBody);
        final String apiVersion = "6.2";
        final Long timeout = null;
        return service.invokeContainerApi(nodeName, applicationId, apiVersion, serviceManifestName, codePackageName, codePackageInstanceId, timeout, containerApiRequestBody, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ContainerApiResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<ContainerApiResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ContainerApiResponseInner> clientResponse = invokeContainerApiDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Invoke container API on a container deployed on a Service Fabric node.
     * Invoke container API on a container deployed on a Service Fabric node for the given code package.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceManifestName The name of a service manifest registered as part of an application type in a Service Fabric cluster.
     * @param codePackageName The name of code package specified in service manifest registered as part of an application type in a Service Fabric cluster.
     * @param codePackageInstanceId ID that uniquely identifies a code package instance deployed on a service fabric node.
     * @param containerApiRequestBody Parameters for making container API call
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ContainerApiResponseInner object if successful.
     */
    public ContainerApiResponseInner invokeContainerApi(String nodeName, String applicationId, String serviceManifestName, String codePackageName, String codePackageInstanceId, ContainerApiRequestBody containerApiRequestBody, Long timeout) {
        return invokeContainerApiWithServiceResponseAsync(nodeName, applicationId, serviceManifestName, codePackageName, codePackageInstanceId, containerApiRequestBody, timeout).toBlocking().single().body();
    }

    /**
     * Invoke container API on a container deployed on a Service Fabric node.
     * Invoke container API on a container deployed on a Service Fabric node for the given code package.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceManifestName The name of a service manifest registered as part of an application type in a Service Fabric cluster.
     * @param codePackageName The name of code package specified in service manifest registered as part of an application type in a Service Fabric cluster.
     * @param codePackageInstanceId ID that uniquely identifies a code package instance deployed on a service fabric node.
     * @param containerApiRequestBody Parameters for making container API call
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ContainerApiResponseInner> invokeContainerApiAsync(String nodeName, String applicationId, String serviceManifestName, String codePackageName, String codePackageInstanceId, ContainerApiRequestBody containerApiRequestBody, Long timeout, final ServiceCallback<ContainerApiResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(invokeContainerApiWithServiceResponseAsync(nodeName, applicationId, serviceManifestName, codePackageName, codePackageInstanceId, containerApiRequestBody, timeout), serviceCallback);
    }

    /**
     * Invoke container API on a container deployed on a Service Fabric node.
     * Invoke container API on a container deployed on a Service Fabric node for the given code package.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceManifestName The name of a service manifest registered as part of an application type in a Service Fabric cluster.
     * @param codePackageName The name of code package specified in service manifest registered as part of an application type in a Service Fabric cluster.
     * @param codePackageInstanceId ID that uniquely identifies a code package instance deployed on a service fabric node.
     * @param containerApiRequestBody Parameters for making container API call
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ContainerApiResponseInner object
     */
    public Observable<ContainerApiResponseInner> invokeContainerApiAsync(String nodeName, String applicationId, String serviceManifestName, String codePackageName, String codePackageInstanceId, ContainerApiRequestBody containerApiRequestBody, Long timeout) {
        return invokeContainerApiWithServiceResponseAsync(nodeName, applicationId, serviceManifestName, codePackageName, codePackageInstanceId, containerApiRequestBody, timeout).map(new Func1<ServiceResponse<ContainerApiResponseInner>, ContainerApiResponseInner>() {
            @Override
            public ContainerApiResponseInner call(ServiceResponse<ContainerApiResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Invoke container API on a container deployed on a Service Fabric node.
     * Invoke container API on a container deployed on a Service Fabric node for the given code package.
     *
     * @param nodeName The name of the node.
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceManifestName The name of a service manifest registered as part of an application type in a Service Fabric cluster.
     * @param codePackageName The name of code package specified in service manifest registered as part of an application type in a Service Fabric cluster.
     * @param codePackageInstanceId ID that uniquely identifies a code package instance deployed on a service fabric node.
     * @param containerApiRequestBody Parameters for making container API call
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ContainerApiResponseInner object
     */
    public Observable<ServiceResponse<ContainerApiResponseInner>> invokeContainerApiWithServiceResponseAsync(String nodeName, String applicationId, String serviceManifestName, String codePackageName, String codePackageInstanceId, ContainerApiRequestBody containerApiRequestBody, Long timeout) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        if (serviceManifestName == null) {
            throw new IllegalArgumentException("Parameter serviceManifestName is required and cannot be null.");
        }
        if (codePackageName == null) {
            throw new IllegalArgumentException("Parameter codePackageName is required and cannot be null.");
        }
        if (codePackageInstanceId == null) {
            throw new IllegalArgumentException("Parameter codePackageInstanceId is required and cannot be null.");
        }
        if (containerApiRequestBody == null) {
            throw new IllegalArgumentException("Parameter containerApiRequestBody is required and cannot be null.");
        }
        Validator.validate(containerApiRequestBody);
        final String apiVersion = "6.2";
        return service.invokeContainerApi(nodeName, applicationId, apiVersion, serviceManifestName, codePackageName, codePackageInstanceId, timeout, containerApiRequestBody, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ContainerApiResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<ContainerApiResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ContainerApiResponseInner> clientResponse = invokeContainerApiDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ContainerApiResponseInner> invokeContainerApiDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ContainerApiResponseInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ContainerApiResponseInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Creates a Service Fabric compose deployment.
     * Compose is a file format that describes multi-container applications. This API allows deploying container based applications defined in compose format in a Service Fabric cluster. Once the deployment is created, its status can be tracked via the `GetComposeDeploymentStatus` API.
     *
     * @param createComposeDeploymentDescription Describes the compose deployment that needs to be created.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void createComposeDeployment(CreateComposeDeploymentDescription createComposeDeploymentDescription) {
        createComposeDeploymentWithServiceResponseAsync(createComposeDeploymentDescription).toBlocking().single().body();
    }

    /**
     * Creates a Service Fabric compose deployment.
     * Compose is a file format that describes multi-container applications. This API allows deploying container based applications defined in compose format in a Service Fabric cluster. Once the deployment is created, its status can be tracked via the `GetComposeDeploymentStatus` API.
     *
     * @param createComposeDeploymentDescription Describes the compose deployment that needs to be created.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> createComposeDeploymentAsync(CreateComposeDeploymentDescription createComposeDeploymentDescription, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(createComposeDeploymentWithServiceResponseAsync(createComposeDeploymentDescription), serviceCallback);
    }

    /**
     * Creates a Service Fabric compose deployment.
     * Compose is a file format that describes multi-container applications. This API allows deploying container based applications defined in compose format in a Service Fabric cluster. Once the deployment is created, its status can be tracked via the `GetComposeDeploymentStatus` API.
     *
     * @param createComposeDeploymentDescription Describes the compose deployment that needs to be created.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> createComposeDeploymentAsync(CreateComposeDeploymentDescription createComposeDeploymentDescription) {
        return createComposeDeploymentWithServiceResponseAsync(createComposeDeploymentDescription).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a Service Fabric compose deployment.
     * Compose is a file format that describes multi-container applications. This API allows deploying container based applications defined in compose format in a Service Fabric cluster. Once the deployment is created, its status can be tracked via the `GetComposeDeploymentStatus` API.
     *
     * @param createComposeDeploymentDescription Describes the compose deployment that needs to be created.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> createComposeDeploymentWithServiceResponseAsync(CreateComposeDeploymentDescription createComposeDeploymentDescription) {
        if (createComposeDeploymentDescription == null) {
            throw new IllegalArgumentException("Parameter createComposeDeploymentDescription is required and cannot be null.");
        }
        Validator.validate(createComposeDeploymentDescription);
        final String apiVersion = "6.0-preview";
        final Long timeout = null;
        return service.createComposeDeployment(apiVersion, createComposeDeploymentDescription, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = createComposeDeploymentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Creates a Service Fabric compose deployment.
     * Compose is a file format that describes multi-container applications. This API allows deploying container based applications defined in compose format in a Service Fabric cluster. Once the deployment is created, its status can be tracked via the `GetComposeDeploymentStatus` API.
     *
     * @param createComposeDeploymentDescription Describes the compose deployment that needs to be created.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void createComposeDeployment(CreateComposeDeploymentDescription createComposeDeploymentDescription, Long timeout) {
        createComposeDeploymentWithServiceResponseAsync(createComposeDeploymentDescription, timeout).toBlocking().single().body();
    }

    /**
     * Creates a Service Fabric compose deployment.
     * Compose is a file format that describes multi-container applications. This API allows deploying container based applications defined in compose format in a Service Fabric cluster. Once the deployment is created, its status can be tracked via the `GetComposeDeploymentStatus` API.
     *
     * @param createComposeDeploymentDescription Describes the compose deployment that needs to be created.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> createComposeDeploymentAsync(CreateComposeDeploymentDescription createComposeDeploymentDescription, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(createComposeDeploymentWithServiceResponseAsync(createComposeDeploymentDescription, timeout), serviceCallback);
    }

    /**
     * Creates a Service Fabric compose deployment.
     * Compose is a file format that describes multi-container applications. This API allows deploying container based applications defined in compose format in a Service Fabric cluster. Once the deployment is created, its status can be tracked via the `GetComposeDeploymentStatus` API.
     *
     * @param createComposeDeploymentDescription Describes the compose deployment that needs to be created.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> createComposeDeploymentAsync(CreateComposeDeploymentDescription createComposeDeploymentDescription, Long timeout) {
        return createComposeDeploymentWithServiceResponseAsync(createComposeDeploymentDescription, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a Service Fabric compose deployment.
     * Compose is a file format that describes multi-container applications. This API allows deploying container based applications defined in compose format in a Service Fabric cluster. Once the deployment is created, its status can be tracked via the `GetComposeDeploymentStatus` API.
     *
     * @param createComposeDeploymentDescription Describes the compose deployment that needs to be created.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> createComposeDeploymentWithServiceResponseAsync(CreateComposeDeploymentDescription createComposeDeploymentDescription, Long timeout) {
        if (createComposeDeploymentDescription == null) {
            throw new IllegalArgumentException("Parameter createComposeDeploymentDescription is required and cannot be null.");
        }
        Validator.validate(createComposeDeploymentDescription);
        final String apiVersion = "6.0-preview";
        return service.createComposeDeployment(apiVersion, createComposeDeploymentDescription, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = createComposeDeploymentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> createComposeDeploymentDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets information about a Service Fabric compose deployment.
     * Returns the status of the compose deployment that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, status, and other details about the deployment.
     *
     * @param deploymentName The identity of the deployment.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ComposeDeploymentStatusInfoInner object if successful.
     */
    public ComposeDeploymentStatusInfoInner getComposeDeploymentStatus(String deploymentName) {
        return getComposeDeploymentStatusWithServiceResponseAsync(deploymentName).toBlocking().single().body();
    }

    /**
     * Gets information about a Service Fabric compose deployment.
     * Returns the status of the compose deployment that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, status, and other details about the deployment.
     *
     * @param deploymentName The identity of the deployment.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ComposeDeploymentStatusInfoInner> getComposeDeploymentStatusAsync(String deploymentName, final ServiceCallback<ComposeDeploymentStatusInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getComposeDeploymentStatusWithServiceResponseAsync(deploymentName), serviceCallback);
    }

    /**
     * Gets information about a Service Fabric compose deployment.
     * Returns the status of the compose deployment that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, status, and other details about the deployment.
     *
     * @param deploymentName The identity of the deployment.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ComposeDeploymentStatusInfoInner object
     */
    public Observable<ComposeDeploymentStatusInfoInner> getComposeDeploymentStatusAsync(String deploymentName) {
        return getComposeDeploymentStatusWithServiceResponseAsync(deploymentName).map(new Func1<ServiceResponse<ComposeDeploymentStatusInfoInner>, ComposeDeploymentStatusInfoInner>() {
            @Override
            public ComposeDeploymentStatusInfoInner call(ServiceResponse<ComposeDeploymentStatusInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets information about a Service Fabric compose deployment.
     * Returns the status of the compose deployment that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, status, and other details about the deployment.
     *
     * @param deploymentName The identity of the deployment.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ComposeDeploymentStatusInfoInner object
     */
    public Observable<ServiceResponse<ComposeDeploymentStatusInfoInner>> getComposeDeploymentStatusWithServiceResponseAsync(String deploymentName) {
        if (deploymentName == null) {
            throw new IllegalArgumentException("Parameter deploymentName is required and cannot be null.");
        }
        final String apiVersion = "6.0-preview";
        final Long timeout = null;
        return service.getComposeDeploymentStatus(deploymentName, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ComposeDeploymentStatusInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<ComposeDeploymentStatusInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ComposeDeploymentStatusInfoInner> clientResponse = getComposeDeploymentStatusDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets information about a Service Fabric compose deployment.
     * Returns the status of the compose deployment that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, status, and other details about the deployment.
     *
     * @param deploymentName The identity of the deployment.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ComposeDeploymentStatusInfoInner object if successful.
     */
    public ComposeDeploymentStatusInfoInner getComposeDeploymentStatus(String deploymentName, Long timeout) {
        return getComposeDeploymentStatusWithServiceResponseAsync(deploymentName, timeout).toBlocking().single().body();
    }

    /**
     * Gets information about a Service Fabric compose deployment.
     * Returns the status of the compose deployment that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, status, and other details about the deployment.
     *
     * @param deploymentName The identity of the deployment.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ComposeDeploymentStatusInfoInner> getComposeDeploymentStatusAsync(String deploymentName, Long timeout, final ServiceCallback<ComposeDeploymentStatusInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getComposeDeploymentStatusWithServiceResponseAsync(deploymentName, timeout), serviceCallback);
    }

    /**
     * Gets information about a Service Fabric compose deployment.
     * Returns the status of the compose deployment that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, status, and other details about the deployment.
     *
     * @param deploymentName The identity of the deployment.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ComposeDeploymentStatusInfoInner object
     */
    public Observable<ComposeDeploymentStatusInfoInner> getComposeDeploymentStatusAsync(String deploymentName, Long timeout) {
        return getComposeDeploymentStatusWithServiceResponseAsync(deploymentName, timeout).map(new Func1<ServiceResponse<ComposeDeploymentStatusInfoInner>, ComposeDeploymentStatusInfoInner>() {
            @Override
            public ComposeDeploymentStatusInfoInner call(ServiceResponse<ComposeDeploymentStatusInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets information about a Service Fabric compose deployment.
     * Returns the status of the compose deployment that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, status, and other details about the deployment.
     *
     * @param deploymentName The identity of the deployment.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ComposeDeploymentStatusInfoInner object
     */
    public Observable<ServiceResponse<ComposeDeploymentStatusInfoInner>> getComposeDeploymentStatusWithServiceResponseAsync(String deploymentName, Long timeout) {
        if (deploymentName == null) {
            throw new IllegalArgumentException("Parameter deploymentName is required and cannot be null.");
        }
        final String apiVersion = "6.0-preview";
        return service.getComposeDeploymentStatus(deploymentName, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ComposeDeploymentStatusInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<ComposeDeploymentStatusInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ComposeDeploymentStatusInfoInner> clientResponse = getComposeDeploymentStatusDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ComposeDeploymentStatusInfoInner> getComposeDeploymentStatusDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ComposeDeploymentStatusInfoInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ComposeDeploymentStatusInfoInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the list of compose deployments created in the Service Fabric cluster.
     * Gets the status about the compose deployments that were created or in the process of being created in the Service Fabric cluster. The response includes the name, status, and other details about the compose deployments. If the list of deployments do not fit in a page, one page of results is returned as well as a continuation token, which can be used to get the next page.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedComposeDeploymentStatusInfoListInner object if successful.
     */
    public PagedComposeDeploymentStatusInfoListInner getComposeDeploymentStatusList() {
        return getComposeDeploymentStatusListWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets the list of compose deployments created in the Service Fabric cluster.
     * Gets the status about the compose deployments that were created or in the process of being created in the Service Fabric cluster. The response includes the name, status, and other details about the compose deployments. If the list of deployments do not fit in a page, one page of results is returned as well as a continuation token, which can be used to get the next page.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedComposeDeploymentStatusInfoListInner> getComposeDeploymentStatusListAsync(final ServiceCallback<PagedComposeDeploymentStatusInfoListInner> serviceCallback) {
        return ServiceFuture.fromResponse(getComposeDeploymentStatusListWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets the list of compose deployments created in the Service Fabric cluster.
     * Gets the status about the compose deployments that were created or in the process of being created in the Service Fabric cluster. The response includes the name, status, and other details about the compose deployments. If the list of deployments do not fit in a page, one page of results is returned as well as a continuation token, which can be used to get the next page.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedComposeDeploymentStatusInfoListInner object
     */
    public Observable<PagedComposeDeploymentStatusInfoListInner> getComposeDeploymentStatusListAsync() {
        return getComposeDeploymentStatusListWithServiceResponseAsync().map(new Func1<ServiceResponse<PagedComposeDeploymentStatusInfoListInner>, PagedComposeDeploymentStatusInfoListInner>() {
            @Override
            public PagedComposeDeploymentStatusInfoListInner call(ServiceResponse<PagedComposeDeploymentStatusInfoListInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the list of compose deployments created in the Service Fabric cluster.
     * Gets the status about the compose deployments that were created or in the process of being created in the Service Fabric cluster. The response includes the name, status, and other details about the compose deployments. If the list of deployments do not fit in a page, one page of results is returned as well as a continuation token, which can be used to get the next page.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedComposeDeploymentStatusInfoListInner object
     */
    public Observable<ServiceResponse<PagedComposeDeploymentStatusInfoListInner>> getComposeDeploymentStatusListWithServiceResponseAsync() {
        final String apiVersion = "6.0-preview";
        final String continuationToken = null;
        final Long maxResults = null;
        final Long timeout = null;
        return service.getComposeDeploymentStatusList(apiVersion, continuationToken, maxResults, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedComposeDeploymentStatusInfoListInner>>>() {
                @Override
                public Observable<ServiceResponse<PagedComposeDeploymentStatusInfoListInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedComposeDeploymentStatusInfoListInner> clientResponse = getComposeDeploymentStatusListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the list of compose deployments created in the Service Fabric cluster.
     * Gets the status about the compose deployments that were created or in the process of being created in the Service Fabric cluster. The response includes the name, status, and other details about the compose deployments. If the list of deployments do not fit in a page, one page of results is returned as well as a continuation token, which can be used to get the next page.
     *
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedComposeDeploymentStatusInfoListInner object if successful.
     */
    public PagedComposeDeploymentStatusInfoListInner getComposeDeploymentStatusList(String continuationToken, Long maxResults, Long timeout) {
        return getComposeDeploymentStatusListWithServiceResponseAsync(continuationToken, maxResults, timeout).toBlocking().single().body();
    }

    /**
     * Gets the list of compose deployments created in the Service Fabric cluster.
     * Gets the status about the compose deployments that were created or in the process of being created in the Service Fabric cluster. The response includes the name, status, and other details about the compose deployments. If the list of deployments do not fit in a page, one page of results is returned as well as a continuation token, which can be used to get the next page.
     *
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedComposeDeploymentStatusInfoListInner> getComposeDeploymentStatusListAsync(String continuationToken, Long maxResults, Long timeout, final ServiceCallback<PagedComposeDeploymentStatusInfoListInner> serviceCallback) {
        return ServiceFuture.fromResponse(getComposeDeploymentStatusListWithServiceResponseAsync(continuationToken, maxResults, timeout), serviceCallback);
    }

    /**
     * Gets the list of compose deployments created in the Service Fabric cluster.
     * Gets the status about the compose deployments that were created or in the process of being created in the Service Fabric cluster. The response includes the name, status, and other details about the compose deployments. If the list of deployments do not fit in a page, one page of results is returned as well as a continuation token, which can be used to get the next page.
     *
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedComposeDeploymentStatusInfoListInner object
     */
    public Observable<PagedComposeDeploymentStatusInfoListInner> getComposeDeploymentStatusListAsync(String continuationToken, Long maxResults, Long timeout) {
        return getComposeDeploymentStatusListWithServiceResponseAsync(continuationToken, maxResults, timeout).map(new Func1<ServiceResponse<PagedComposeDeploymentStatusInfoListInner>, PagedComposeDeploymentStatusInfoListInner>() {
            @Override
            public PagedComposeDeploymentStatusInfoListInner call(ServiceResponse<PagedComposeDeploymentStatusInfoListInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the list of compose deployments created in the Service Fabric cluster.
     * Gets the status about the compose deployments that were created or in the process of being created in the Service Fabric cluster. The response includes the name, status, and other details about the compose deployments. If the list of deployments do not fit in a page, one page of results is returned as well as a continuation token, which can be used to get the next page.
     *
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedComposeDeploymentStatusInfoListInner object
     */
    public Observable<ServiceResponse<PagedComposeDeploymentStatusInfoListInner>> getComposeDeploymentStatusListWithServiceResponseAsync(String continuationToken, Long maxResults, Long timeout) {
        final String apiVersion = "6.0-preview";
        return service.getComposeDeploymentStatusList(apiVersion, continuationToken, maxResults, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedComposeDeploymentStatusInfoListInner>>>() {
                @Override
                public Observable<ServiceResponse<PagedComposeDeploymentStatusInfoListInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedComposeDeploymentStatusInfoListInner> clientResponse = getComposeDeploymentStatusListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PagedComposeDeploymentStatusInfoListInner> getComposeDeploymentStatusListDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException {
        return this.restClient().responseBuilderFactory().<PagedComposeDeploymentStatusInfoListInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PagedComposeDeploymentStatusInfoListInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets details for the latest upgrade performed on this Service Fabric compose deployment.
     * Returns the information about the state of the compose deployment upgrade along with details to aid debugging application health issues.
     *
     * @param deploymentName The identity of the deployment.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ComposeDeploymentUpgradeProgressInfoInner object if successful.
     */
    public ComposeDeploymentUpgradeProgressInfoInner getComposeDeploymentUpgradeProgress(String deploymentName) {
        return getComposeDeploymentUpgradeProgressWithServiceResponseAsync(deploymentName).toBlocking().single().body();
    }

    /**
     * Gets details for the latest upgrade performed on this Service Fabric compose deployment.
     * Returns the information about the state of the compose deployment upgrade along with details to aid debugging application health issues.
     *
     * @param deploymentName The identity of the deployment.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ComposeDeploymentUpgradeProgressInfoInner> getComposeDeploymentUpgradeProgressAsync(String deploymentName, final ServiceCallback<ComposeDeploymentUpgradeProgressInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getComposeDeploymentUpgradeProgressWithServiceResponseAsync(deploymentName), serviceCallback);
    }

    /**
     * Gets details for the latest upgrade performed on this Service Fabric compose deployment.
     * Returns the information about the state of the compose deployment upgrade along with details to aid debugging application health issues.
     *
     * @param deploymentName The identity of the deployment.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ComposeDeploymentUpgradeProgressInfoInner object
     */
    public Observable<ComposeDeploymentUpgradeProgressInfoInner> getComposeDeploymentUpgradeProgressAsync(String deploymentName) {
        return getComposeDeploymentUpgradeProgressWithServiceResponseAsync(deploymentName).map(new Func1<ServiceResponse<ComposeDeploymentUpgradeProgressInfoInner>, ComposeDeploymentUpgradeProgressInfoInner>() {
            @Override
            public ComposeDeploymentUpgradeProgressInfoInner call(ServiceResponse<ComposeDeploymentUpgradeProgressInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets details for the latest upgrade performed on this Service Fabric compose deployment.
     * Returns the information about the state of the compose deployment upgrade along with details to aid debugging application health issues.
     *
     * @param deploymentName The identity of the deployment.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ComposeDeploymentUpgradeProgressInfoInner object
     */
    public Observable<ServiceResponse<ComposeDeploymentUpgradeProgressInfoInner>> getComposeDeploymentUpgradeProgressWithServiceResponseAsync(String deploymentName) {
        if (deploymentName == null) {
            throw new IllegalArgumentException("Parameter deploymentName is required and cannot be null.");
        }
        final String apiVersion = "6.0-preview";
        final Long timeout = null;
        return service.getComposeDeploymentUpgradeProgress(deploymentName, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ComposeDeploymentUpgradeProgressInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<ComposeDeploymentUpgradeProgressInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ComposeDeploymentUpgradeProgressInfoInner> clientResponse = getComposeDeploymentUpgradeProgressDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets details for the latest upgrade performed on this Service Fabric compose deployment.
     * Returns the information about the state of the compose deployment upgrade along with details to aid debugging application health issues.
     *
     * @param deploymentName The identity of the deployment.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ComposeDeploymentUpgradeProgressInfoInner object if successful.
     */
    public ComposeDeploymentUpgradeProgressInfoInner getComposeDeploymentUpgradeProgress(String deploymentName, Long timeout) {
        return getComposeDeploymentUpgradeProgressWithServiceResponseAsync(deploymentName, timeout).toBlocking().single().body();
    }

    /**
     * Gets details for the latest upgrade performed on this Service Fabric compose deployment.
     * Returns the information about the state of the compose deployment upgrade along with details to aid debugging application health issues.
     *
     * @param deploymentName The identity of the deployment.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ComposeDeploymentUpgradeProgressInfoInner> getComposeDeploymentUpgradeProgressAsync(String deploymentName, Long timeout, final ServiceCallback<ComposeDeploymentUpgradeProgressInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getComposeDeploymentUpgradeProgressWithServiceResponseAsync(deploymentName, timeout), serviceCallback);
    }

    /**
     * Gets details for the latest upgrade performed on this Service Fabric compose deployment.
     * Returns the information about the state of the compose deployment upgrade along with details to aid debugging application health issues.
     *
     * @param deploymentName The identity of the deployment.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ComposeDeploymentUpgradeProgressInfoInner object
     */
    public Observable<ComposeDeploymentUpgradeProgressInfoInner> getComposeDeploymentUpgradeProgressAsync(String deploymentName, Long timeout) {
        return getComposeDeploymentUpgradeProgressWithServiceResponseAsync(deploymentName, timeout).map(new Func1<ServiceResponse<ComposeDeploymentUpgradeProgressInfoInner>, ComposeDeploymentUpgradeProgressInfoInner>() {
            @Override
            public ComposeDeploymentUpgradeProgressInfoInner call(ServiceResponse<ComposeDeploymentUpgradeProgressInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets details for the latest upgrade performed on this Service Fabric compose deployment.
     * Returns the information about the state of the compose deployment upgrade along with details to aid debugging application health issues.
     *
     * @param deploymentName The identity of the deployment.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ComposeDeploymentUpgradeProgressInfoInner object
     */
    public Observable<ServiceResponse<ComposeDeploymentUpgradeProgressInfoInner>> getComposeDeploymentUpgradeProgressWithServiceResponseAsync(String deploymentName, Long timeout) {
        if (deploymentName == null) {
            throw new IllegalArgumentException("Parameter deploymentName is required and cannot be null.");
        }
        final String apiVersion = "6.0-preview";
        return service.getComposeDeploymentUpgradeProgress(deploymentName, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ComposeDeploymentUpgradeProgressInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<ComposeDeploymentUpgradeProgressInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ComposeDeploymentUpgradeProgressInfoInner> clientResponse = getComposeDeploymentUpgradeProgressDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ComposeDeploymentUpgradeProgressInfoInner> getComposeDeploymentUpgradeProgressDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ComposeDeploymentUpgradeProgressInfoInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ComposeDeploymentUpgradeProgressInfoInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Deletes an existing Service Fabric compose deployment from cluster.
     * Deletes an existing Service Fabric compose deployment.
     *
     * @param deploymentName The identity of the deployment.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void removeComposeDeployment(String deploymentName) {
        removeComposeDeploymentWithServiceResponseAsync(deploymentName).toBlocking().single().body();
    }

    /**
     * Deletes an existing Service Fabric compose deployment from cluster.
     * Deletes an existing Service Fabric compose deployment.
     *
     * @param deploymentName The identity of the deployment.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> removeComposeDeploymentAsync(String deploymentName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(removeComposeDeploymentWithServiceResponseAsync(deploymentName), serviceCallback);
    }

    /**
     * Deletes an existing Service Fabric compose deployment from cluster.
     * Deletes an existing Service Fabric compose deployment.
     *
     * @param deploymentName The identity of the deployment.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> removeComposeDeploymentAsync(String deploymentName) {
        return removeComposeDeploymentWithServiceResponseAsync(deploymentName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes an existing Service Fabric compose deployment from cluster.
     * Deletes an existing Service Fabric compose deployment.
     *
     * @param deploymentName The identity of the deployment.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> removeComposeDeploymentWithServiceResponseAsync(String deploymentName) {
        if (deploymentName == null) {
            throw new IllegalArgumentException("Parameter deploymentName is required and cannot be null.");
        }
        final String apiVersion = "6.0-preview";
        final Long timeout = null;
        return service.removeComposeDeployment(deploymentName, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = removeComposeDeploymentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Deletes an existing Service Fabric compose deployment from cluster.
     * Deletes an existing Service Fabric compose deployment.
     *
     * @param deploymentName The identity of the deployment.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void removeComposeDeployment(String deploymentName, Long timeout) {
        removeComposeDeploymentWithServiceResponseAsync(deploymentName, timeout).toBlocking().single().body();
    }

    /**
     * Deletes an existing Service Fabric compose deployment from cluster.
     * Deletes an existing Service Fabric compose deployment.
     *
     * @param deploymentName The identity of the deployment.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> removeComposeDeploymentAsync(String deploymentName, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(removeComposeDeploymentWithServiceResponseAsync(deploymentName, timeout), serviceCallback);
    }

    /**
     * Deletes an existing Service Fabric compose deployment from cluster.
     * Deletes an existing Service Fabric compose deployment.
     *
     * @param deploymentName The identity of the deployment.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> removeComposeDeploymentAsync(String deploymentName, Long timeout) {
        return removeComposeDeploymentWithServiceResponseAsync(deploymentName, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes an existing Service Fabric compose deployment from cluster.
     * Deletes an existing Service Fabric compose deployment.
     *
     * @param deploymentName The identity of the deployment.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> removeComposeDeploymentWithServiceResponseAsync(String deploymentName, Long timeout) {
        if (deploymentName == null) {
            throw new IllegalArgumentException("Parameter deploymentName is required and cannot be null.");
        }
        final String apiVersion = "6.0-preview";
        return service.removeComposeDeployment(deploymentName, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = removeComposeDeploymentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> removeComposeDeploymentDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Starts upgrading a compose deployment in the Service Fabric cluster.
     * Validates the supplied upgrade parameters and starts upgrading the deployment if the parameters are valid.
     *
     * @param deploymentName The identity of the deployment.
     * @param composeDeploymentUpgradeDescription Parameters for upgrading compose deployment.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void startComposeDeploymentUpgrade(String deploymentName, ComposeDeploymentUpgradeDescription composeDeploymentUpgradeDescription) {
        startComposeDeploymentUpgradeWithServiceResponseAsync(deploymentName, composeDeploymentUpgradeDescription).toBlocking().single().body();
    }

    /**
     * Starts upgrading a compose deployment in the Service Fabric cluster.
     * Validates the supplied upgrade parameters and starts upgrading the deployment if the parameters are valid.
     *
     * @param deploymentName The identity of the deployment.
     * @param composeDeploymentUpgradeDescription Parameters for upgrading compose deployment.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> startComposeDeploymentUpgradeAsync(String deploymentName, ComposeDeploymentUpgradeDescription composeDeploymentUpgradeDescription, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(startComposeDeploymentUpgradeWithServiceResponseAsync(deploymentName, composeDeploymentUpgradeDescription), serviceCallback);
    }

    /**
     * Starts upgrading a compose deployment in the Service Fabric cluster.
     * Validates the supplied upgrade parameters and starts upgrading the deployment if the parameters are valid.
     *
     * @param deploymentName The identity of the deployment.
     * @param composeDeploymentUpgradeDescription Parameters for upgrading compose deployment.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> startComposeDeploymentUpgradeAsync(String deploymentName, ComposeDeploymentUpgradeDescription composeDeploymentUpgradeDescription) {
        return startComposeDeploymentUpgradeWithServiceResponseAsync(deploymentName, composeDeploymentUpgradeDescription).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Starts upgrading a compose deployment in the Service Fabric cluster.
     * Validates the supplied upgrade parameters and starts upgrading the deployment if the parameters are valid.
     *
     * @param deploymentName The identity of the deployment.
     * @param composeDeploymentUpgradeDescription Parameters for upgrading compose deployment.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> startComposeDeploymentUpgradeWithServiceResponseAsync(String deploymentName, ComposeDeploymentUpgradeDescription composeDeploymentUpgradeDescription) {
        if (deploymentName == null) {
            throw new IllegalArgumentException("Parameter deploymentName is required and cannot be null.");
        }
        if (composeDeploymentUpgradeDescription == null) {
            throw new IllegalArgumentException("Parameter composeDeploymentUpgradeDescription is required and cannot be null.");
        }
        Validator.validate(composeDeploymentUpgradeDescription);
        final String apiVersion = "6.0-preview";
        final Long timeout = null;
        return service.startComposeDeploymentUpgrade(deploymentName, apiVersion, composeDeploymentUpgradeDescription, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = startComposeDeploymentUpgradeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Starts upgrading a compose deployment in the Service Fabric cluster.
     * Validates the supplied upgrade parameters and starts upgrading the deployment if the parameters are valid.
     *
     * @param deploymentName The identity of the deployment.
     * @param composeDeploymentUpgradeDescription Parameters for upgrading compose deployment.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void startComposeDeploymentUpgrade(String deploymentName, ComposeDeploymentUpgradeDescription composeDeploymentUpgradeDescription, Long timeout) {
        startComposeDeploymentUpgradeWithServiceResponseAsync(deploymentName, composeDeploymentUpgradeDescription, timeout).toBlocking().single().body();
    }

    /**
     * Starts upgrading a compose deployment in the Service Fabric cluster.
     * Validates the supplied upgrade parameters and starts upgrading the deployment if the parameters are valid.
     *
     * @param deploymentName The identity of the deployment.
     * @param composeDeploymentUpgradeDescription Parameters for upgrading compose deployment.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> startComposeDeploymentUpgradeAsync(String deploymentName, ComposeDeploymentUpgradeDescription composeDeploymentUpgradeDescription, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(startComposeDeploymentUpgradeWithServiceResponseAsync(deploymentName, composeDeploymentUpgradeDescription, timeout), serviceCallback);
    }

    /**
     * Starts upgrading a compose deployment in the Service Fabric cluster.
     * Validates the supplied upgrade parameters and starts upgrading the deployment if the parameters are valid.
     *
     * @param deploymentName The identity of the deployment.
     * @param composeDeploymentUpgradeDescription Parameters for upgrading compose deployment.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> startComposeDeploymentUpgradeAsync(String deploymentName, ComposeDeploymentUpgradeDescription composeDeploymentUpgradeDescription, Long timeout) {
        return startComposeDeploymentUpgradeWithServiceResponseAsync(deploymentName, composeDeploymentUpgradeDescription, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Starts upgrading a compose deployment in the Service Fabric cluster.
     * Validates the supplied upgrade parameters and starts upgrading the deployment if the parameters are valid.
     *
     * @param deploymentName The identity of the deployment.
     * @param composeDeploymentUpgradeDescription Parameters for upgrading compose deployment.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> startComposeDeploymentUpgradeWithServiceResponseAsync(String deploymentName, ComposeDeploymentUpgradeDescription composeDeploymentUpgradeDescription, Long timeout) {
        if (deploymentName == null) {
            throw new IllegalArgumentException("Parameter deploymentName is required and cannot be null.");
        }
        if (composeDeploymentUpgradeDescription == null) {
            throw new IllegalArgumentException("Parameter composeDeploymentUpgradeDescription is required and cannot be null.");
        }
        Validator.validate(composeDeploymentUpgradeDescription);
        final String apiVersion = "6.0-preview";
        return service.startComposeDeploymentUpgrade(deploymentName, apiVersion, composeDeploymentUpgradeDescription, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = startComposeDeploymentUpgradeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> startComposeDeploymentUpgradeDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Get the status of Chaos.
     * Get the status of Chaos indicating whether or not Chaos is running, the Chaos parameters used for running Chaos and the status of the Chaos Schedule.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ChaosInner object if successful.
     */
    public ChaosInner getChaos() {
        return getChaosWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get the status of Chaos.
     * Get the status of Chaos indicating whether or not Chaos is running, the Chaos parameters used for running Chaos and the status of the Chaos Schedule.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ChaosInner> getChaosAsync(final ServiceCallback<ChaosInner> serviceCallback) {
        return ServiceFuture.fromResponse(getChaosWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get the status of Chaos.
     * Get the status of Chaos indicating whether or not Chaos is running, the Chaos parameters used for running Chaos and the status of the Chaos Schedule.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ChaosInner object
     */
    public Observable<ChaosInner> getChaosAsync() {
        return getChaosWithServiceResponseAsync().map(new Func1<ServiceResponse<ChaosInner>, ChaosInner>() {
            @Override
            public ChaosInner call(ServiceResponse<ChaosInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get the status of Chaos.
     * Get the status of Chaos indicating whether or not Chaos is running, the Chaos parameters used for running Chaos and the status of the Chaos Schedule.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ChaosInner object
     */
    public Observable<ServiceResponse<ChaosInner>> getChaosWithServiceResponseAsync() {
        final String apiVersion = "6.2";
        final Long timeout = null;
        return service.getChaos(apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ChaosInner>>>() {
                @Override
                public Observable<ServiceResponse<ChaosInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ChaosInner> clientResponse = getChaosDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get the status of Chaos.
     * Get the status of Chaos indicating whether or not Chaos is running, the Chaos parameters used for running Chaos and the status of the Chaos Schedule.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ChaosInner object if successful.
     */
    public ChaosInner getChaos(Long timeout) {
        return getChaosWithServiceResponseAsync(timeout).toBlocking().single().body();
    }

    /**
     * Get the status of Chaos.
     * Get the status of Chaos indicating whether or not Chaos is running, the Chaos parameters used for running Chaos and the status of the Chaos Schedule.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ChaosInner> getChaosAsync(Long timeout, final ServiceCallback<ChaosInner> serviceCallback) {
        return ServiceFuture.fromResponse(getChaosWithServiceResponseAsync(timeout), serviceCallback);
    }

    /**
     * Get the status of Chaos.
     * Get the status of Chaos indicating whether or not Chaos is running, the Chaos parameters used for running Chaos and the status of the Chaos Schedule.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ChaosInner object
     */
    public Observable<ChaosInner> getChaosAsync(Long timeout) {
        return getChaosWithServiceResponseAsync(timeout).map(new Func1<ServiceResponse<ChaosInner>, ChaosInner>() {
            @Override
            public ChaosInner call(ServiceResponse<ChaosInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get the status of Chaos.
     * Get the status of Chaos indicating whether or not Chaos is running, the Chaos parameters used for running Chaos and the status of the Chaos Schedule.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ChaosInner object
     */
    public Observable<ServiceResponse<ChaosInner>> getChaosWithServiceResponseAsync(Long timeout) {
        final String apiVersion = "6.2";
        return service.getChaos(apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ChaosInner>>>() {
                @Override
                public Observable<ServiceResponse<ChaosInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ChaosInner> clientResponse = getChaosDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ChaosInner> getChaosDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException {
        return this.restClient().responseBuilderFactory().<ChaosInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ChaosInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Starts Chaos in the cluster.
     * If Chaos is not already running in the cluster, it starts Chaos with the passed in Chaos parameters.
     If Chaos is already running when this call is made, the call fails with the error code FABRIC_E_CHAOS_ALREADY_RUNNING.
     Refer to the article [Induce controlled Chaos in Service Fabric clusters](https://docs.microsoft.com/azure/service-fabric/service-fabric-controlled-chaos) for more details.
     *
     * @param chaosParameters Describes all the parameters to configure a Chaos run.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void startChaos(ChaosParameters chaosParameters) {
        startChaosWithServiceResponseAsync(chaosParameters).toBlocking().single().body();
    }

    /**
     * Starts Chaos in the cluster.
     * If Chaos is not already running in the cluster, it starts Chaos with the passed in Chaos parameters.
     If Chaos is already running when this call is made, the call fails with the error code FABRIC_E_CHAOS_ALREADY_RUNNING.
     Refer to the article [Induce controlled Chaos in Service Fabric clusters](https://docs.microsoft.com/azure/service-fabric/service-fabric-controlled-chaos) for more details.
     *
     * @param chaosParameters Describes all the parameters to configure a Chaos run.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> startChaosAsync(ChaosParameters chaosParameters, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(startChaosWithServiceResponseAsync(chaosParameters), serviceCallback);
    }

    /**
     * Starts Chaos in the cluster.
     * If Chaos is not already running in the cluster, it starts Chaos with the passed in Chaos parameters.
     If Chaos is already running when this call is made, the call fails with the error code FABRIC_E_CHAOS_ALREADY_RUNNING.
     Refer to the article [Induce controlled Chaos in Service Fabric clusters](https://docs.microsoft.com/azure/service-fabric/service-fabric-controlled-chaos) for more details.
     *
     * @param chaosParameters Describes all the parameters to configure a Chaos run.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> startChaosAsync(ChaosParameters chaosParameters) {
        return startChaosWithServiceResponseAsync(chaosParameters).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Starts Chaos in the cluster.
     * If Chaos is not already running in the cluster, it starts Chaos with the passed in Chaos parameters.
     If Chaos is already running when this call is made, the call fails with the error code FABRIC_E_CHAOS_ALREADY_RUNNING.
     Refer to the article [Induce controlled Chaos in Service Fabric clusters](https://docs.microsoft.com/azure/service-fabric/service-fabric-controlled-chaos) for more details.
     *
     * @param chaosParameters Describes all the parameters to configure a Chaos run.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> startChaosWithServiceResponseAsync(ChaosParameters chaosParameters) {
        if (chaosParameters == null) {
            throw new IllegalArgumentException("Parameter chaosParameters is required and cannot be null.");
        }
        Validator.validate(chaosParameters);
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.startChaos(apiVersion, chaosParameters, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = startChaosDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Starts Chaos in the cluster.
     * If Chaos is not already running in the cluster, it starts Chaos with the passed in Chaos parameters.
     If Chaos is already running when this call is made, the call fails with the error code FABRIC_E_CHAOS_ALREADY_RUNNING.
     Refer to the article [Induce controlled Chaos in Service Fabric clusters](https://docs.microsoft.com/azure/service-fabric/service-fabric-controlled-chaos) for more details.
     *
     * @param chaosParameters Describes all the parameters to configure a Chaos run.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void startChaos(ChaosParameters chaosParameters, Long timeout) {
        startChaosWithServiceResponseAsync(chaosParameters, timeout).toBlocking().single().body();
    }

    /**
     * Starts Chaos in the cluster.
     * If Chaos is not already running in the cluster, it starts Chaos with the passed in Chaos parameters.
     If Chaos is already running when this call is made, the call fails with the error code FABRIC_E_CHAOS_ALREADY_RUNNING.
     Refer to the article [Induce controlled Chaos in Service Fabric clusters](https://docs.microsoft.com/azure/service-fabric/service-fabric-controlled-chaos) for more details.
     *
     * @param chaosParameters Describes all the parameters to configure a Chaos run.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> startChaosAsync(ChaosParameters chaosParameters, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(startChaosWithServiceResponseAsync(chaosParameters, timeout), serviceCallback);
    }

    /**
     * Starts Chaos in the cluster.
     * If Chaos is not already running in the cluster, it starts Chaos with the passed in Chaos parameters.
     If Chaos is already running when this call is made, the call fails with the error code FABRIC_E_CHAOS_ALREADY_RUNNING.
     Refer to the article [Induce controlled Chaos in Service Fabric clusters](https://docs.microsoft.com/azure/service-fabric/service-fabric-controlled-chaos) for more details.
     *
     * @param chaosParameters Describes all the parameters to configure a Chaos run.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> startChaosAsync(ChaosParameters chaosParameters, Long timeout) {
        return startChaosWithServiceResponseAsync(chaosParameters, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Starts Chaos in the cluster.
     * If Chaos is not already running in the cluster, it starts Chaos with the passed in Chaos parameters.
     If Chaos is already running when this call is made, the call fails with the error code FABRIC_E_CHAOS_ALREADY_RUNNING.
     Refer to the article [Induce controlled Chaos in Service Fabric clusters](https://docs.microsoft.com/azure/service-fabric/service-fabric-controlled-chaos) for more details.
     *
     * @param chaosParameters Describes all the parameters to configure a Chaos run.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> startChaosWithServiceResponseAsync(ChaosParameters chaosParameters, Long timeout) {
        if (chaosParameters == null) {
            throw new IllegalArgumentException("Parameter chaosParameters is required and cannot be null.");
        }
        Validator.validate(chaosParameters);
        final String apiVersion = "6.0";
        return service.startChaos(apiVersion, chaosParameters, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = startChaosDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> startChaosDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Stops Chaos if it is running in the cluster and put the Chaos Schedule in a stopped state.
     * Stops Chaos from executing new faults. In-flight faults will continue to execute until they are complete. The current Chaos Schedule is put into a stopped state.
     Once a schedule is stopped, it will stay in the stopped state and not be used to Chaos Schedule new runs of Chaos. A new Chaos Schedule must be set in order to resume scheduling.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void stopChaos() {
        stopChaosWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Stops Chaos if it is running in the cluster and put the Chaos Schedule in a stopped state.
     * Stops Chaos from executing new faults. In-flight faults will continue to execute until they are complete. The current Chaos Schedule is put into a stopped state.
     Once a schedule is stopped, it will stay in the stopped state and not be used to Chaos Schedule new runs of Chaos. A new Chaos Schedule must be set in order to resume scheduling.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> stopChaosAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(stopChaosWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Stops Chaos if it is running in the cluster and put the Chaos Schedule in a stopped state.
     * Stops Chaos from executing new faults. In-flight faults will continue to execute until they are complete. The current Chaos Schedule is put into a stopped state.
     Once a schedule is stopped, it will stay in the stopped state and not be used to Chaos Schedule new runs of Chaos. A new Chaos Schedule must be set in order to resume scheduling.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> stopChaosAsync() {
        return stopChaosWithServiceResponseAsync().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Stops Chaos if it is running in the cluster and put the Chaos Schedule in a stopped state.
     * Stops Chaos from executing new faults. In-flight faults will continue to execute until they are complete. The current Chaos Schedule is put into a stopped state.
     Once a schedule is stopped, it will stay in the stopped state and not be used to Chaos Schedule new runs of Chaos. A new Chaos Schedule must be set in order to resume scheduling.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> stopChaosWithServiceResponseAsync() {
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.stopChaos(apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = stopChaosDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Stops Chaos if it is running in the cluster and put the Chaos Schedule in a stopped state.
     * Stops Chaos from executing new faults. In-flight faults will continue to execute until they are complete. The current Chaos Schedule is put into a stopped state.
     Once a schedule is stopped, it will stay in the stopped state and not be used to Chaos Schedule new runs of Chaos. A new Chaos Schedule must be set in order to resume scheduling.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void stopChaos(Long timeout) {
        stopChaosWithServiceResponseAsync(timeout).toBlocking().single().body();
    }

    /**
     * Stops Chaos if it is running in the cluster and put the Chaos Schedule in a stopped state.
     * Stops Chaos from executing new faults. In-flight faults will continue to execute until they are complete. The current Chaos Schedule is put into a stopped state.
     Once a schedule is stopped, it will stay in the stopped state and not be used to Chaos Schedule new runs of Chaos. A new Chaos Schedule must be set in order to resume scheduling.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> stopChaosAsync(Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(stopChaosWithServiceResponseAsync(timeout), serviceCallback);
    }

    /**
     * Stops Chaos if it is running in the cluster and put the Chaos Schedule in a stopped state.
     * Stops Chaos from executing new faults. In-flight faults will continue to execute until they are complete. The current Chaos Schedule is put into a stopped state.
     Once a schedule is stopped, it will stay in the stopped state and not be used to Chaos Schedule new runs of Chaos. A new Chaos Schedule must be set in order to resume scheduling.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> stopChaosAsync(Long timeout) {
        return stopChaosWithServiceResponseAsync(timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Stops Chaos if it is running in the cluster and put the Chaos Schedule in a stopped state.
     * Stops Chaos from executing new faults. In-flight faults will continue to execute until they are complete. The current Chaos Schedule is put into a stopped state.
     Once a schedule is stopped, it will stay in the stopped state and not be used to Chaos Schedule new runs of Chaos. A new Chaos Schedule must be set in order to resume scheduling.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> stopChaosWithServiceResponseAsync(Long timeout) {
        final String apiVersion = "6.0";
        return service.stopChaos(apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = stopChaosDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> stopChaosDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the next segment of the Chaos events based on the continuation token or the time range.
     * To get the next segment of the Chaos events, you can specify the ContinuationToken. To get the start of a new segment of Chaos events, you can specify the time range
     through StartTimeUtc and EndTimeUtc. You cannot specify both the ContinuationToken and the time range in the same call.
     When there are more than 100 Chaos events, the Chaos events are returned in multiple segments where a segment contains no more than 100 Chaos events and to get the next segment you make a call to this API with the continuation token.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ChaosEventsSegmentInner object if successful.
     */
    public ChaosEventsSegmentInner getChaosEvents() {
        return getChaosEventsWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets the next segment of the Chaos events based on the continuation token or the time range.
     * To get the next segment of the Chaos events, you can specify the ContinuationToken. To get the start of a new segment of Chaos events, you can specify the time range
     through StartTimeUtc and EndTimeUtc. You cannot specify both the ContinuationToken and the time range in the same call.
     When there are more than 100 Chaos events, the Chaos events are returned in multiple segments where a segment contains no more than 100 Chaos events and to get the next segment you make a call to this API with the continuation token.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ChaosEventsSegmentInner> getChaosEventsAsync(final ServiceCallback<ChaosEventsSegmentInner> serviceCallback) {
        return ServiceFuture.fromResponse(getChaosEventsWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets the next segment of the Chaos events based on the continuation token or the time range.
     * To get the next segment of the Chaos events, you can specify the ContinuationToken. To get the start of a new segment of Chaos events, you can specify the time range
     through StartTimeUtc and EndTimeUtc. You cannot specify both the ContinuationToken and the time range in the same call.
     When there are more than 100 Chaos events, the Chaos events are returned in multiple segments where a segment contains no more than 100 Chaos events and to get the next segment you make a call to this API with the continuation token.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ChaosEventsSegmentInner object
     */
    public Observable<ChaosEventsSegmentInner> getChaosEventsAsync() {
        return getChaosEventsWithServiceResponseAsync().map(new Func1<ServiceResponse<ChaosEventsSegmentInner>, ChaosEventsSegmentInner>() {
            @Override
            public ChaosEventsSegmentInner call(ServiceResponse<ChaosEventsSegmentInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the next segment of the Chaos events based on the continuation token or the time range.
     * To get the next segment of the Chaos events, you can specify the ContinuationToken. To get the start of a new segment of Chaos events, you can specify the time range
     through StartTimeUtc and EndTimeUtc. You cannot specify both the ContinuationToken and the time range in the same call.
     When there are more than 100 Chaos events, the Chaos events are returned in multiple segments where a segment contains no more than 100 Chaos events and to get the next segment you make a call to this API with the continuation token.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ChaosEventsSegmentInner object
     */
    public Observable<ServiceResponse<ChaosEventsSegmentInner>> getChaosEventsWithServiceResponseAsync() {
        final String apiVersion = "6.2";
        final String continuationToken = null;
        final String startTimeUtc = null;
        final String endTimeUtc = null;
        final Long maxResults = null;
        final Long timeout = null;
        return service.getChaosEvents(apiVersion, continuationToken, startTimeUtc, endTimeUtc, maxResults, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ChaosEventsSegmentInner>>>() {
                @Override
                public Observable<ServiceResponse<ChaosEventsSegmentInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ChaosEventsSegmentInner> clientResponse = getChaosEventsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the next segment of the Chaos events based on the continuation token or the time range.
     * To get the next segment of the Chaos events, you can specify the ContinuationToken. To get the start of a new segment of Chaos events, you can specify the time range
     through StartTimeUtc and EndTimeUtc. You cannot specify both the ContinuationToken and the time range in the same call.
     When there are more than 100 Chaos events, the Chaos events are returned in multiple segments where a segment contains no more than 100 Chaos events and to get the next segment you make a call to this API with the continuation token.
     *
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param startTimeUtc The Windows file time representing the start time of the time range for which a Chaos report is to be generated. Consult [DateTime.ToFileTimeUtc Method](https://msdn.microsoft.com/library/system.datetime.tofiletimeutc(v=vs.110).aspx) for details.
     * @param endTimeUtc The Windows file time representing the end time of the time range for which a Chaos report is to be generated. Consult [DateTime.ToFileTimeUtc Method](https://msdn.microsoft.com/library/system.datetime.tofiletimeutc(v=vs.110).aspx) for details.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ChaosEventsSegmentInner object if successful.
     */
    public ChaosEventsSegmentInner getChaosEvents(String continuationToken, String startTimeUtc, String endTimeUtc, Long maxResults, Long timeout) {
        return getChaosEventsWithServiceResponseAsync(continuationToken, startTimeUtc, endTimeUtc, maxResults, timeout).toBlocking().single().body();
    }

    /**
     * Gets the next segment of the Chaos events based on the continuation token or the time range.
     * To get the next segment of the Chaos events, you can specify the ContinuationToken. To get the start of a new segment of Chaos events, you can specify the time range
     through StartTimeUtc and EndTimeUtc. You cannot specify both the ContinuationToken and the time range in the same call.
     When there are more than 100 Chaos events, the Chaos events are returned in multiple segments where a segment contains no more than 100 Chaos events and to get the next segment you make a call to this API with the continuation token.
     *
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param startTimeUtc The Windows file time representing the start time of the time range for which a Chaos report is to be generated. Consult [DateTime.ToFileTimeUtc Method](https://msdn.microsoft.com/library/system.datetime.tofiletimeutc(v=vs.110).aspx) for details.
     * @param endTimeUtc The Windows file time representing the end time of the time range for which a Chaos report is to be generated. Consult [DateTime.ToFileTimeUtc Method](https://msdn.microsoft.com/library/system.datetime.tofiletimeutc(v=vs.110).aspx) for details.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ChaosEventsSegmentInner> getChaosEventsAsync(String continuationToken, String startTimeUtc, String endTimeUtc, Long maxResults, Long timeout, final ServiceCallback<ChaosEventsSegmentInner> serviceCallback) {
        return ServiceFuture.fromResponse(getChaosEventsWithServiceResponseAsync(continuationToken, startTimeUtc, endTimeUtc, maxResults, timeout), serviceCallback);
    }

    /**
     * Gets the next segment of the Chaos events based on the continuation token or the time range.
     * To get the next segment of the Chaos events, you can specify the ContinuationToken. To get the start of a new segment of Chaos events, you can specify the time range
     through StartTimeUtc and EndTimeUtc. You cannot specify both the ContinuationToken and the time range in the same call.
     When there are more than 100 Chaos events, the Chaos events are returned in multiple segments where a segment contains no more than 100 Chaos events and to get the next segment you make a call to this API with the continuation token.
     *
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param startTimeUtc The Windows file time representing the start time of the time range for which a Chaos report is to be generated. Consult [DateTime.ToFileTimeUtc Method](https://msdn.microsoft.com/library/system.datetime.tofiletimeutc(v=vs.110).aspx) for details.
     * @param endTimeUtc The Windows file time representing the end time of the time range for which a Chaos report is to be generated. Consult [DateTime.ToFileTimeUtc Method](https://msdn.microsoft.com/library/system.datetime.tofiletimeutc(v=vs.110).aspx) for details.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ChaosEventsSegmentInner object
     */
    public Observable<ChaosEventsSegmentInner> getChaosEventsAsync(String continuationToken, String startTimeUtc, String endTimeUtc, Long maxResults, Long timeout) {
        return getChaosEventsWithServiceResponseAsync(continuationToken, startTimeUtc, endTimeUtc, maxResults, timeout).map(new Func1<ServiceResponse<ChaosEventsSegmentInner>, ChaosEventsSegmentInner>() {
            @Override
            public ChaosEventsSegmentInner call(ServiceResponse<ChaosEventsSegmentInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the next segment of the Chaos events based on the continuation token or the time range.
     * To get the next segment of the Chaos events, you can specify the ContinuationToken. To get the start of a new segment of Chaos events, you can specify the time range
     through StartTimeUtc and EndTimeUtc. You cannot specify both the ContinuationToken and the time range in the same call.
     When there are more than 100 Chaos events, the Chaos events are returned in multiple segments where a segment contains no more than 100 Chaos events and to get the next segment you make a call to this API with the continuation token.
     *
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param startTimeUtc The Windows file time representing the start time of the time range for which a Chaos report is to be generated. Consult [DateTime.ToFileTimeUtc Method](https://msdn.microsoft.com/library/system.datetime.tofiletimeutc(v=vs.110).aspx) for details.
     * @param endTimeUtc The Windows file time representing the end time of the time range for which a Chaos report is to be generated. Consult [DateTime.ToFileTimeUtc Method](https://msdn.microsoft.com/library/system.datetime.tofiletimeutc(v=vs.110).aspx) for details.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ChaosEventsSegmentInner object
     */
    public Observable<ServiceResponse<ChaosEventsSegmentInner>> getChaosEventsWithServiceResponseAsync(String continuationToken, String startTimeUtc, String endTimeUtc, Long maxResults, Long timeout) {
        final String apiVersion = "6.2";
        return service.getChaosEvents(apiVersion, continuationToken, startTimeUtc, endTimeUtc, maxResults, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ChaosEventsSegmentInner>>>() {
                @Override
                public Observable<ServiceResponse<ChaosEventsSegmentInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ChaosEventsSegmentInner> clientResponse = getChaosEventsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ChaosEventsSegmentInner> getChaosEventsDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException {
        return this.restClient().responseBuilderFactory().<ChaosEventsSegmentInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ChaosEventsSegmentInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Get the Chaos Schedule defining when and how to run Chaos.
     * Gets the version of the Chaos Schedule in use and the Chaos Schedule that defines when and how to run Chaos.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ChaosScheduleDescriptionInner object if successful.
     */
    public ChaosScheduleDescriptionInner getChaosSchedule() {
        return getChaosScheduleWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get the Chaos Schedule defining when and how to run Chaos.
     * Gets the version of the Chaos Schedule in use and the Chaos Schedule that defines when and how to run Chaos.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ChaosScheduleDescriptionInner> getChaosScheduleAsync(final ServiceCallback<ChaosScheduleDescriptionInner> serviceCallback) {
        return ServiceFuture.fromResponse(getChaosScheduleWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get the Chaos Schedule defining when and how to run Chaos.
     * Gets the version of the Chaos Schedule in use and the Chaos Schedule that defines when and how to run Chaos.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ChaosScheduleDescriptionInner object
     */
    public Observable<ChaosScheduleDescriptionInner> getChaosScheduleAsync() {
        return getChaosScheduleWithServiceResponseAsync().map(new Func1<ServiceResponse<ChaosScheduleDescriptionInner>, ChaosScheduleDescriptionInner>() {
            @Override
            public ChaosScheduleDescriptionInner call(ServiceResponse<ChaosScheduleDescriptionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get the Chaos Schedule defining when and how to run Chaos.
     * Gets the version of the Chaos Schedule in use and the Chaos Schedule that defines when and how to run Chaos.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ChaosScheduleDescriptionInner object
     */
    public Observable<ServiceResponse<ChaosScheduleDescriptionInner>> getChaosScheduleWithServiceResponseAsync() {
        final String apiVersion = "6.2";
        final Long timeout = null;
        return service.getChaosSchedule(apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ChaosScheduleDescriptionInner>>>() {
                @Override
                public Observable<ServiceResponse<ChaosScheduleDescriptionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ChaosScheduleDescriptionInner> clientResponse = getChaosScheduleDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get the Chaos Schedule defining when and how to run Chaos.
     * Gets the version of the Chaos Schedule in use and the Chaos Schedule that defines when and how to run Chaos.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ChaosScheduleDescriptionInner object if successful.
     */
    public ChaosScheduleDescriptionInner getChaosSchedule(Long timeout) {
        return getChaosScheduleWithServiceResponseAsync(timeout).toBlocking().single().body();
    }

    /**
     * Get the Chaos Schedule defining when and how to run Chaos.
     * Gets the version of the Chaos Schedule in use and the Chaos Schedule that defines when and how to run Chaos.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ChaosScheduleDescriptionInner> getChaosScheduleAsync(Long timeout, final ServiceCallback<ChaosScheduleDescriptionInner> serviceCallback) {
        return ServiceFuture.fromResponse(getChaosScheduleWithServiceResponseAsync(timeout), serviceCallback);
    }

    /**
     * Get the Chaos Schedule defining when and how to run Chaos.
     * Gets the version of the Chaos Schedule in use and the Chaos Schedule that defines when and how to run Chaos.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ChaosScheduleDescriptionInner object
     */
    public Observable<ChaosScheduleDescriptionInner> getChaosScheduleAsync(Long timeout) {
        return getChaosScheduleWithServiceResponseAsync(timeout).map(new Func1<ServiceResponse<ChaosScheduleDescriptionInner>, ChaosScheduleDescriptionInner>() {
            @Override
            public ChaosScheduleDescriptionInner call(ServiceResponse<ChaosScheduleDescriptionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get the Chaos Schedule defining when and how to run Chaos.
     * Gets the version of the Chaos Schedule in use and the Chaos Schedule that defines when and how to run Chaos.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ChaosScheduleDescriptionInner object
     */
    public Observable<ServiceResponse<ChaosScheduleDescriptionInner>> getChaosScheduleWithServiceResponseAsync(Long timeout) {
        final String apiVersion = "6.2";
        return service.getChaosSchedule(apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ChaosScheduleDescriptionInner>>>() {
                @Override
                public Observable<ServiceResponse<ChaosScheduleDescriptionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ChaosScheduleDescriptionInner> clientResponse = getChaosScheduleDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ChaosScheduleDescriptionInner> getChaosScheduleDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException {
        return this.restClient().responseBuilderFactory().<ChaosScheduleDescriptionInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ChaosScheduleDescriptionInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Set the schedule used by Chaos.
     * Chaos will automatically schedule runs based on the Chaos Schedule.
     The Chaos Schedule will be updated if the provided version matches the version on the server.
     When updating the Chaos Schedule, the version on the server is incremented by 1.
     The version on the server will wrap back to 0 after reaching a large number.
     If Chaos is running when this call is made, the call will fail.
     *
     * @param chaosSchedule Describes the schedule used by Chaos.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void postChaosSchedule(ChaosScheduleDescriptionInner chaosSchedule) {
        postChaosScheduleWithServiceResponseAsync(chaosSchedule).toBlocking().single().body();
    }

    /**
     * Set the schedule used by Chaos.
     * Chaos will automatically schedule runs based on the Chaos Schedule.
     The Chaos Schedule will be updated if the provided version matches the version on the server.
     When updating the Chaos Schedule, the version on the server is incremented by 1.
     The version on the server will wrap back to 0 after reaching a large number.
     If Chaos is running when this call is made, the call will fail.
     *
     * @param chaosSchedule Describes the schedule used by Chaos.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> postChaosScheduleAsync(ChaosScheduleDescriptionInner chaosSchedule, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(postChaosScheduleWithServiceResponseAsync(chaosSchedule), serviceCallback);
    }

    /**
     * Set the schedule used by Chaos.
     * Chaos will automatically schedule runs based on the Chaos Schedule.
     The Chaos Schedule will be updated if the provided version matches the version on the server.
     When updating the Chaos Schedule, the version on the server is incremented by 1.
     The version on the server will wrap back to 0 after reaching a large number.
     If Chaos is running when this call is made, the call will fail.
     *
     * @param chaosSchedule Describes the schedule used by Chaos.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> postChaosScheduleAsync(ChaosScheduleDescriptionInner chaosSchedule) {
        return postChaosScheduleWithServiceResponseAsync(chaosSchedule).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Set the schedule used by Chaos.
     * Chaos will automatically schedule runs based on the Chaos Schedule.
     The Chaos Schedule will be updated if the provided version matches the version on the server.
     When updating the Chaos Schedule, the version on the server is incremented by 1.
     The version on the server will wrap back to 0 after reaching a large number.
     If Chaos is running when this call is made, the call will fail.
     *
     * @param chaosSchedule Describes the schedule used by Chaos.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> postChaosScheduleWithServiceResponseAsync(ChaosScheduleDescriptionInner chaosSchedule) {
        if (chaosSchedule == null) {
            throw new IllegalArgumentException("Parameter chaosSchedule is required and cannot be null.");
        }
        Validator.validate(chaosSchedule);
        final String apiVersion = "6.2";
        final Long timeout = null;
        return service.postChaosSchedule(apiVersion, timeout, chaosSchedule, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = postChaosScheduleDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Set the schedule used by Chaos.
     * Chaos will automatically schedule runs based on the Chaos Schedule.
     The Chaos Schedule will be updated if the provided version matches the version on the server.
     When updating the Chaos Schedule, the version on the server is incremented by 1.
     The version on the server will wrap back to 0 after reaching a large number.
     If Chaos is running when this call is made, the call will fail.
     *
     * @param chaosSchedule Describes the schedule used by Chaos.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void postChaosSchedule(ChaosScheduleDescriptionInner chaosSchedule, Long timeout) {
        postChaosScheduleWithServiceResponseAsync(chaosSchedule, timeout).toBlocking().single().body();
    }

    /**
     * Set the schedule used by Chaos.
     * Chaos will automatically schedule runs based on the Chaos Schedule.
     The Chaos Schedule will be updated if the provided version matches the version on the server.
     When updating the Chaos Schedule, the version on the server is incremented by 1.
     The version on the server will wrap back to 0 after reaching a large number.
     If Chaos is running when this call is made, the call will fail.
     *
     * @param chaosSchedule Describes the schedule used by Chaos.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> postChaosScheduleAsync(ChaosScheduleDescriptionInner chaosSchedule, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(postChaosScheduleWithServiceResponseAsync(chaosSchedule, timeout), serviceCallback);
    }

    /**
     * Set the schedule used by Chaos.
     * Chaos will automatically schedule runs based on the Chaos Schedule.
     The Chaos Schedule will be updated if the provided version matches the version on the server.
     When updating the Chaos Schedule, the version on the server is incremented by 1.
     The version on the server will wrap back to 0 after reaching a large number.
     If Chaos is running when this call is made, the call will fail.
     *
     * @param chaosSchedule Describes the schedule used by Chaos.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> postChaosScheduleAsync(ChaosScheduleDescriptionInner chaosSchedule, Long timeout) {
        return postChaosScheduleWithServiceResponseAsync(chaosSchedule, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Set the schedule used by Chaos.
     * Chaos will automatically schedule runs based on the Chaos Schedule.
     The Chaos Schedule will be updated if the provided version matches the version on the server.
     When updating the Chaos Schedule, the version on the server is incremented by 1.
     The version on the server will wrap back to 0 after reaching a large number.
     If Chaos is running when this call is made, the call will fail.
     *
     * @param chaosSchedule Describes the schedule used by Chaos.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> postChaosScheduleWithServiceResponseAsync(ChaosScheduleDescriptionInner chaosSchedule, Long timeout) {
        if (chaosSchedule == null) {
            throw new IllegalArgumentException("Parameter chaosSchedule is required and cannot be null.");
        }
        Validator.validate(chaosSchedule);
        final String apiVersion = "6.2";
        return service.postChaosSchedule(apiVersion, timeout, chaosSchedule, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = postChaosScheduleDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> postChaosScheduleDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Uploads contents of the file to the image store.
     * Uploads contents of the file to the image store. Use this API if the file is small enough to upload again if the connection fails. The file's data needs to be added to the request body. The contents will be uploaded to the specified path. Image store service uses a mark file to indicate the availability of the folder. The mark file is an empty file named "_.dir". The mark file is generated by the image store service when all files in a folder are uploaded. When using File-by-File approach to upload application package in REST, the image store service isn't aware of the file hierarchy of the application package; you need to create a mark file per folder and upload it last, to let the image store service know that the folder is complete.
     *
     * @param contentPath Relative path to file or folder in the image store from its root.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void uploadFile(String contentPath) {
        uploadFileWithServiceResponseAsync(contentPath).toBlocking().single().body();
    }

    /**
     * Uploads contents of the file to the image store.
     * Uploads contents of the file to the image store. Use this API if the file is small enough to upload again if the connection fails. The file's data needs to be added to the request body. The contents will be uploaded to the specified path. Image store service uses a mark file to indicate the availability of the folder. The mark file is an empty file named "_.dir". The mark file is generated by the image store service when all files in a folder are uploaded. When using File-by-File approach to upload application package in REST, the image store service isn't aware of the file hierarchy of the application package; you need to create a mark file per folder and upload it last, to let the image store service know that the folder is complete.
     *
     * @param contentPath Relative path to file or folder in the image store from its root.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> uploadFileAsync(String contentPath, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(uploadFileWithServiceResponseAsync(contentPath), serviceCallback);
    }

    /**
     * Uploads contents of the file to the image store.
     * Uploads contents of the file to the image store. Use this API if the file is small enough to upload again if the connection fails. The file's data needs to be added to the request body. The contents will be uploaded to the specified path. Image store service uses a mark file to indicate the availability of the folder. The mark file is an empty file named "_.dir". The mark file is generated by the image store service when all files in a folder are uploaded. When using File-by-File approach to upload application package in REST, the image store service isn't aware of the file hierarchy of the application package; you need to create a mark file per folder and upload it last, to let the image store service know that the folder is complete.
     *
     * @param contentPath Relative path to file or folder in the image store from its root.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> uploadFileAsync(String contentPath) {
        return uploadFileWithServiceResponseAsync(contentPath).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Uploads contents of the file to the image store.
     * Uploads contents of the file to the image store. Use this API if the file is small enough to upload again if the connection fails. The file's data needs to be added to the request body. The contents will be uploaded to the specified path. Image store service uses a mark file to indicate the availability of the folder. The mark file is an empty file named "_.dir". The mark file is generated by the image store service when all files in a folder are uploaded. When using File-by-File approach to upload application package in REST, the image store service isn't aware of the file hierarchy of the application package; you need to create a mark file per folder and upload it last, to let the image store service know that the folder is complete.
     *
     * @param contentPath Relative path to file or folder in the image store from its root.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> uploadFileWithServiceResponseAsync(String contentPath) {
        if (contentPath == null) {
            throw new IllegalArgumentException("Parameter contentPath is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.uploadFile(contentPath, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = uploadFileDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Uploads contents of the file to the image store.
     * Uploads contents of the file to the image store. Use this API if the file is small enough to upload again if the connection fails. The file's data needs to be added to the request body. The contents will be uploaded to the specified path. Image store service uses a mark file to indicate the availability of the folder. The mark file is an empty file named "_.dir". The mark file is generated by the image store service when all files in a folder are uploaded. When using File-by-File approach to upload application package in REST, the image store service isn't aware of the file hierarchy of the application package; you need to create a mark file per folder and upload it last, to let the image store service know that the folder is complete.
     *
     * @param contentPath Relative path to file or folder in the image store from its root.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void uploadFile(String contentPath, Long timeout) {
        uploadFileWithServiceResponseAsync(contentPath, timeout).toBlocking().single().body();
    }

    /**
     * Uploads contents of the file to the image store.
     * Uploads contents of the file to the image store. Use this API if the file is small enough to upload again if the connection fails. The file's data needs to be added to the request body. The contents will be uploaded to the specified path. Image store service uses a mark file to indicate the availability of the folder. The mark file is an empty file named "_.dir". The mark file is generated by the image store service when all files in a folder are uploaded. When using File-by-File approach to upload application package in REST, the image store service isn't aware of the file hierarchy of the application package; you need to create a mark file per folder and upload it last, to let the image store service know that the folder is complete.
     *
     * @param contentPath Relative path to file or folder in the image store from its root.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> uploadFileAsync(String contentPath, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(uploadFileWithServiceResponseAsync(contentPath, timeout), serviceCallback);
    }

    /**
     * Uploads contents of the file to the image store.
     * Uploads contents of the file to the image store. Use this API if the file is small enough to upload again if the connection fails. The file's data needs to be added to the request body. The contents will be uploaded to the specified path. Image store service uses a mark file to indicate the availability of the folder. The mark file is an empty file named "_.dir". The mark file is generated by the image store service when all files in a folder are uploaded. When using File-by-File approach to upload application package in REST, the image store service isn't aware of the file hierarchy of the application package; you need to create a mark file per folder and upload it last, to let the image store service know that the folder is complete.
     *
     * @param contentPath Relative path to file or folder in the image store from its root.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> uploadFileAsync(String contentPath, Long timeout) {
        return uploadFileWithServiceResponseAsync(contentPath, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Uploads contents of the file to the image store.
     * Uploads contents of the file to the image store. Use this API if the file is small enough to upload again if the connection fails. The file's data needs to be added to the request body. The contents will be uploaded to the specified path. Image store service uses a mark file to indicate the availability of the folder. The mark file is an empty file named "_.dir". The mark file is generated by the image store service when all files in a folder are uploaded. When using File-by-File approach to upload application package in REST, the image store service isn't aware of the file hierarchy of the application package; you need to create a mark file per folder and upload it last, to let the image store service know that the folder is complete.
     *
     * @param contentPath Relative path to file or folder in the image store from its root.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> uploadFileWithServiceResponseAsync(String contentPath, Long timeout) {
        if (contentPath == null) {
            throw new IllegalArgumentException("Parameter contentPath is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.uploadFile(contentPath, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = uploadFileDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> uploadFileDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the image store content information.
     * Returns the information about the image store content at the specified contentPath. The contentPath is relative to the root of the image store.
     *
     * @param contentPath Relative path to file or folder in the image store from its root.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ImageStoreContentInner object if successful.
     */
    public ImageStoreContentInner getImageStoreContent(String contentPath) {
        return getImageStoreContentWithServiceResponseAsync(contentPath).toBlocking().single().body();
    }

    /**
     * Gets the image store content information.
     * Returns the information about the image store content at the specified contentPath. The contentPath is relative to the root of the image store.
     *
     * @param contentPath Relative path to file or folder in the image store from its root.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ImageStoreContentInner> getImageStoreContentAsync(String contentPath, final ServiceCallback<ImageStoreContentInner> serviceCallback) {
        return ServiceFuture.fromResponse(getImageStoreContentWithServiceResponseAsync(contentPath), serviceCallback);
    }

    /**
     * Gets the image store content information.
     * Returns the information about the image store content at the specified contentPath. The contentPath is relative to the root of the image store.
     *
     * @param contentPath Relative path to file or folder in the image store from its root.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ImageStoreContentInner object
     */
    public Observable<ImageStoreContentInner> getImageStoreContentAsync(String contentPath) {
        return getImageStoreContentWithServiceResponseAsync(contentPath).map(new Func1<ServiceResponse<ImageStoreContentInner>, ImageStoreContentInner>() {
            @Override
            public ImageStoreContentInner call(ServiceResponse<ImageStoreContentInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the image store content information.
     * Returns the information about the image store content at the specified contentPath. The contentPath is relative to the root of the image store.
     *
     * @param contentPath Relative path to file or folder in the image store from its root.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ImageStoreContentInner object
     */
    public Observable<ServiceResponse<ImageStoreContentInner>> getImageStoreContentWithServiceResponseAsync(String contentPath) {
        if (contentPath == null) {
            throw new IllegalArgumentException("Parameter contentPath is required and cannot be null.");
        }
        final String apiVersion = "6.2";
        final Long timeout = null;
        return service.getImageStoreContent(contentPath, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ImageStoreContentInner>>>() {
                @Override
                public Observable<ServiceResponse<ImageStoreContentInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ImageStoreContentInner> clientResponse = getImageStoreContentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the image store content information.
     * Returns the information about the image store content at the specified contentPath. The contentPath is relative to the root of the image store.
     *
     * @param contentPath Relative path to file or folder in the image store from its root.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ImageStoreContentInner object if successful.
     */
    public ImageStoreContentInner getImageStoreContent(String contentPath, Long timeout) {
        return getImageStoreContentWithServiceResponseAsync(contentPath, timeout).toBlocking().single().body();
    }

    /**
     * Gets the image store content information.
     * Returns the information about the image store content at the specified contentPath. The contentPath is relative to the root of the image store.
     *
     * @param contentPath Relative path to file or folder in the image store from its root.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ImageStoreContentInner> getImageStoreContentAsync(String contentPath, Long timeout, final ServiceCallback<ImageStoreContentInner> serviceCallback) {
        return ServiceFuture.fromResponse(getImageStoreContentWithServiceResponseAsync(contentPath, timeout), serviceCallback);
    }

    /**
     * Gets the image store content information.
     * Returns the information about the image store content at the specified contentPath. The contentPath is relative to the root of the image store.
     *
     * @param contentPath Relative path to file or folder in the image store from its root.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ImageStoreContentInner object
     */
    public Observable<ImageStoreContentInner> getImageStoreContentAsync(String contentPath, Long timeout) {
        return getImageStoreContentWithServiceResponseAsync(contentPath, timeout).map(new Func1<ServiceResponse<ImageStoreContentInner>, ImageStoreContentInner>() {
            @Override
            public ImageStoreContentInner call(ServiceResponse<ImageStoreContentInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the image store content information.
     * Returns the information about the image store content at the specified contentPath. The contentPath is relative to the root of the image store.
     *
     * @param contentPath Relative path to file or folder in the image store from its root.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ImageStoreContentInner object
     */
    public Observable<ServiceResponse<ImageStoreContentInner>> getImageStoreContentWithServiceResponseAsync(String contentPath, Long timeout) {
        if (contentPath == null) {
            throw new IllegalArgumentException("Parameter contentPath is required and cannot be null.");
        }
        final String apiVersion = "6.2";
        return service.getImageStoreContent(contentPath, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ImageStoreContentInner>>>() {
                @Override
                public Observable<ServiceResponse<ImageStoreContentInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ImageStoreContentInner> clientResponse = getImageStoreContentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ImageStoreContentInner> getImageStoreContentDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ImageStoreContentInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ImageStoreContentInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Deletes existing image store content.
     * Deletes existing image store content being found within the given image store relative path. This can be used to delete uploaded application packages once they are provisioned.
     *
     * @param contentPath Relative path to file or folder in the image store from its root.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteImageStoreContent(String contentPath) {
        deleteImageStoreContentWithServiceResponseAsync(contentPath).toBlocking().single().body();
    }

    /**
     * Deletes existing image store content.
     * Deletes existing image store content being found within the given image store relative path. This can be used to delete uploaded application packages once they are provisioned.
     *
     * @param contentPath Relative path to file or folder in the image store from its root.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteImageStoreContentAsync(String contentPath, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteImageStoreContentWithServiceResponseAsync(contentPath), serviceCallback);
    }

    /**
     * Deletes existing image store content.
     * Deletes existing image store content being found within the given image store relative path. This can be used to delete uploaded application packages once they are provisioned.
     *
     * @param contentPath Relative path to file or folder in the image store from its root.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteImageStoreContentAsync(String contentPath) {
        return deleteImageStoreContentWithServiceResponseAsync(contentPath).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes existing image store content.
     * Deletes existing image store content being found within the given image store relative path. This can be used to delete uploaded application packages once they are provisioned.
     *
     * @param contentPath Relative path to file or folder in the image store from its root.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteImageStoreContentWithServiceResponseAsync(String contentPath) {
        if (contentPath == null) {
            throw new IllegalArgumentException("Parameter contentPath is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.deleteImageStoreContent(contentPath, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteImageStoreContentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Deletes existing image store content.
     * Deletes existing image store content being found within the given image store relative path. This can be used to delete uploaded application packages once they are provisioned.
     *
     * @param contentPath Relative path to file or folder in the image store from its root.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteImageStoreContent(String contentPath, Long timeout) {
        deleteImageStoreContentWithServiceResponseAsync(contentPath, timeout).toBlocking().single().body();
    }

    /**
     * Deletes existing image store content.
     * Deletes existing image store content being found within the given image store relative path. This can be used to delete uploaded application packages once they are provisioned.
     *
     * @param contentPath Relative path to file or folder in the image store from its root.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteImageStoreContentAsync(String contentPath, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteImageStoreContentWithServiceResponseAsync(contentPath, timeout), serviceCallback);
    }

    /**
     * Deletes existing image store content.
     * Deletes existing image store content being found within the given image store relative path. This can be used to delete uploaded application packages once they are provisioned.
     *
     * @param contentPath Relative path to file or folder in the image store from its root.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteImageStoreContentAsync(String contentPath, Long timeout) {
        return deleteImageStoreContentWithServiceResponseAsync(contentPath, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes existing image store content.
     * Deletes existing image store content being found within the given image store relative path. This can be used to delete uploaded application packages once they are provisioned.
     *
     * @param contentPath Relative path to file or folder in the image store from its root.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteImageStoreContentWithServiceResponseAsync(String contentPath, Long timeout) {
        if (contentPath == null) {
            throw new IllegalArgumentException("Parameter contentPath is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.deleteImageStoreContent(contentPath, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteImageStoreContentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteImageStoreContentDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the content information at the root of the image store.
     * Returns the information about the image store content at the root of the image store.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ImageStoreContentInner object if successful.
     */
    public ImageStoreContentInner getImageStoreRootContent() {
        return getImageStoreRootContentWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets the content information at the root of the image store.
     * Returns the information about the image store content at the root of the image store.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ImageStoreContentInner> getImageStoreRootContentAsync(final ServiceCallback<ImageStoreContentInner> serviceCallback) {
        return ServiceFuture.fromResponse(getImageStoreRootContentWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets the content information at the root of the image store.
     * Returns the information about the image store content at the root of the image store.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ImageStoreContentInner object
     */
    public Observable<ImageStoreContentInner> getImageStoreRootContentAsync() {
        return getImageStoreRootContentWithServiceResponseAsync().map(new Func1<ServiceResponse<ImageStoreContentInner>, ImageStoreContentInner>() {
            @Override
            public ImageStoreContentInner call(ServiceResponse<ImageStoreContentInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the content information at the root of the image store.
     * Returns the information about the image store content at the root of the image store.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ImageStoreContentInner object
     */
    public Observable<ServiceResponse<ImageStoreContentInner>> getImageStoreRootContentWithServiceResponseAsync() {
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.getImageStoreRootContent(apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ImageStoreContentInner>>>() {
                @Override
                public Observable<ServiceResponse<ImageStoreContentInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ImageStoreContentInner> clientResponse = getImageStoreRootContentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the content information at the root of the image store.
     * Returns the information about the image store content at the root of the image store.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ImageStoreContentInner object if successful.
     */
    public ImageStoreContentInner getImageStoreRootContent(Long timeout) {
        return getImageStoreRootContentWithServiceResponseAsync(timeout).toBlocking().single().body();
    }

    /**
     * Gets the content information at the root of the image store.
     * Returns the information about the image store content at the root of the image store.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ImageStoreContentInner> getImageStoreRootContentAsync(Long timeout, final ServiceCallback<ImageStoreContentInner> serviceCallback) {
        return ServiceFuture.fromResponse(getImageStoreRootContentWithServiceResponseAsync(timeout), serviceCallback);
    }

    /**
     * Gets the content information at the root of the image store.
     * Returns the information about the image store content at the root of the image store.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ImageStoreContentInner object
     */
    public Observable<ImageStoreContentInner> getImageStoreRootContentAsync(Long timeout) {
        return getImageStoreRootContentWithServiceResponseAsync(timeout).map(new Func1<ServiceResponse<ImageStoreContentInner>, ImageStoreContentInner>() {
            @Override
            public ImageStoreContentInner call(ServiceResponse<ImageStoreContentInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the content information at the root of the image store.
     * Returns the information about the image store content at the root of the image store.
     *
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ImageStoreContentInner object
     */
    public Observable<ServiceResponse<ImageStoreContentInner>> getImageStoreRootContentWithServiceResponseAsync(Long timeout) {
        final String apiVersion = "6.0";
        return service.getImageStoreRootContent(apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ImageStoreContentInner>>>() {
                @Override
                public Observable<ServiceResponse<ImageStoreContentInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ImageStoreContentInner> clientResponse = getImageStoreRootContentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ImageStoreContentInner> getImageStoreRootContentDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException {
        return this.restClient().responseBuilderFactory().<ImageStoreContentInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ImageStoreContentInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Copies image store content internally.
     * Copies the image store content from the source image store relative path to the destination image store relative path.
     *
     * @param imageStoreCopyDescription Describes the copy description for the image store.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void copyImageStoreContent(ImageStoreCopyDescription imageStoreCopyDescription) {
        copyImageStoreContentWithServiceResponseAsync(imageStoreCopyDescription).toBlocking().single().body();
    }

    /**
     * Copies image store content internally.
     * Copies the image store content from the source image store relative path to the destination image store relative path.
     *
     * @param imageStoreCopyDescription Describes the copy description for the image store.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> copyImageStoreContentAsync(ImageStoreCopyDescription imageStoreCopyDescription, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(copyImageStoreContentWithServiceResponseAsync(imageStoreCopyDescription), serviceCallback);
    }

    /**
     * Copies image store content internally.
     * Copies the image store content from the source image store relative path to the destination image store relative path.
     *
     * @param imageStoreCopyDescription Describes the copy description for the image store.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> copyImageStoreContentAsync(ImageStoreCopyDescription imageStoreCopyDescription) {
        return copyImageStoreContentWithServiceResponseAsync(imageStoreCopyDescription).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Copies image store content internally.
     * Copies the image store content from the source image store relative path to the destination image store relative path.
     *
     * @param imageStoreCopyDescription Describes the copy description for the image store.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> copyImageStoreContentWithServiceResponseAsync(ImageStoreCopyDescription imageStoreCopyDescription) {
        if (imageStoreCopyDescription == null) {
            throw new IllegalArgumentException("Parameter imageStoreCopyDescription is required and cannot be null.");
        }
        Validator.validate(imageStoreCopyDescription);
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.copyImageStoreContent(apiVersion, imageStoreCopyDescription, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = copyImageStoreContentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Copies image store content internally.
     * Copies the image store content from the source image store relative path to the destination image store relative path.
     *
     * @param imageStoreCopyDescription Describes the copy description for the image store.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void copyImageStoreContent(ImageStoreCopyDescription imageStoreCopyDescription, Long timeout) {
        copyImageStoreContentWithServiceResponseAsync(imageStoreCopyDescription, timeout).toBlocking().single().body();
    }

    /**
     * Copies image store content internally.
     * Copies the image store content from the source image store relative path to the destination image store relative path.
     *
     * @param imageStoreCopyDescription Describes the copy description for the image store.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> copyImageStoreContentAsync(ImageStoreCopyDescription imageStoreCopyDescription, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(copyImageStoreContentWithServiceResponseAsync(imageStoreCopyDescription, timeout), serviceCallback);
    }

    /**
     * Copies image store content internally.
     * Copies the image store content from the source image store relative path to the destination image store relative path.
     *
     * @param imageStoreCopyDescription Describes the copy description for the image store.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> copyImageStoreContentAsync(ImageStoreCopyDescription imageStoreCopyDescription, Long timeout) {
        return copyImageStoreContentWithServiceResponseAsync(imageStoreCopyDescription, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Copies image store content internally.
     * Copies the image store content from the source image store relative path to the destination image store relative path.
     *
     * @param imageStoreCopyDescription Describes the copy description for the image store.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> copyImageStoreContentWithServiceResponseAsync(ImageStoreCopyDescription imageStoreCopyDescription, Long timeout) {
        if (imageStoreCopyDescription == null) {
            throw new IllegalArgumentException("Parameter imageStoreCopyDescription is required and cannot be null.");
        }
        Validator.validate(imageStoreCopyDescription);
        final String apiVersion = "6.0";
        return service.copyImageStoreContent(apiVersion, imageStoreCopyDescription, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = copyImageStoreContentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> copyImageStoreContentDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Cancels an image store upload session.
     * The DELETE request will cause the existing upload session to expire and remove any previously uploaded file chunks.
     *
     * @param sessionId A GUID generated by the user for a file uploading. It identifies an image store upload session which keeps track of all file chunks until it is committed.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteImageStoreUploadSession(UUID sessionId) {
        deleteImageStoreUploadSessionWithServiceResponseAsync(sessionId).toBlocking().single().body();
    }

    /**
     * Cancels an image store upload session.
     * The DELETE request will cause the existing upload session to expire and remove any previously uploaded file chunks.
     *
     * @param sessionId A GUID generated by the user for a file uploading. It identifies an image store upload session which keeps track of all file chunks until it is committed.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteImageStoreUploadSessionAsync(UUID sessionId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteImageStoreUploadSessionWithServiceResponseAsync(sessionId), serviceCallback);
    }

    /**
     * Cancels an image store upload session.
     * The DELETE request will cause the existing upload session to expire and remove any previously uploaded file chunks.
     *
     * @param sessionId A GUID generated by the user for a file uploading. It identifies an image store upload session which keeps track of all file chunks until it is committed.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteImageStoreUploadSessionAsync(UUID sessionId) {
        return deleteImageStoreUploadSessionWithServiceResponseAsync(sessionId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Cancels an image store upload session.
     * The DELETE request will cause the existing upload session to expire and remove any previously uploaded file chunks.
     *
     * @param sessionId A GUID generated by the user for a file uploading. It identifies an image store upload session which keeps track of all file chunks until it is committed.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteImageStoreUploadSessionWithServiceResponseAsync(UUID sessionId) {
        if (sessionId == null) {
            throw new IllegalArgumentException("Parameter sessionId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.deleteImageStoreUploadSession(apiVersion, sessionId, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteImageStoreUploadSessionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Cancels an image store upload session.
     * The DELETE request will cause the existing upload session to expire and remove any previously uploaded file chunks.
     *
     * @param sessionId A GUID generated by the user for a file uploading. It identifies an image store upload session which keeps track of all file chunks until it is committed.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteImageStoreUploadSession(UUID sessionId, Long timeout) {
        deleteImageStoreUploadSessionWithServiceResponseAsync(sessionId, timeout).toBlocking().single().body();
    }

    /**
     * Cancels an image store upload session.
     * The DELETE request will cause the existing upload session to expire and remove any previously uploaded file chunks.
     *
     * @param sessionId A GUID generated by the user for a file uploading. It identifies an image store upload session which keeps track of all file chunks until it is committed.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteImageStoreUploadSessionAsync(UUID sessionId, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteImageStoreUploadSessionWithServiceResponseAsync(sessionId, timeout), serviceCallback);
    }

    /**
     * Cancels an image store upload session.
     * The DELETE request will cause the existing upload session to expire and remove any previously uploaded file chunks.
     *
     * @param sessionId A GUID generated by the user for a file uploading. It identifies an image store upload session which keeps track of all file chunks until it is committed.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteImageStoreUploadSessionAsync(UUID sessionId, Long timeout) {
        return deleteImageStoreUploadSessionWithServiceResponseAsync(sessionId, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Cancels an image store upload session.
     * The DELETE request will cause the existing upload session to expire and remove any previously uploaded file chunks.
     *
     * @param sessionId A GUID generated by the user for a file uploading. It identifies an image store upload session which keeps track of all file chunks until it is committed.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteImageStoreUploadSessionWithServiceResponseAsync(UUID sessionId, Long timeout) {
        if (sessionId == null) {
            throw new IllegalArgumentException("Parameter sessionId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.deleteImageStoreUploadSession(apiVersion, sessionId, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteImageStoreUploadSessionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteImageStoreUploadSessionDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Commit an image store upload session.
     * When all file chunks have been uploaded, the upload session needs to be committed explicitly to complete the upload. Image store preserves the upload session until the expiration time, which is 30 minutes after the last chunk received.
     *
     * @param sessionId A GUID generated by the user for a file uploading. It identifies an image store upload session which keeps track of all file chunks until it is committed.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void commitImageStoreUploadSession(UUID sessionId) {
        commitImageStoreUploadSessionWithServiceResponseAsync(sessionId).toBlocking().single().body();
    }

    /**
     * Commit an image store upload session.
     * When all file chunks have been uploaded, the upload session needs to be committed explicitly to complete the upload. Image store preserves the upload session until the expiration time, which is 30 minutes after the last chunk received.
     *
     * @param sessionId A GUID generated by the user for a file uploading. It identifies an image store upload session which keeps track of all file chunks until it is committed.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> commitImageStoreUploadSessionAsync(UUID sessionId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(commitImageStoreUploadSessionWithServiceResponseAsync(sessionId), serviceCallback);
    }

    /**
     * Commit an image store upload session.
     * When all file chunks have been uploaded, the upload session needs to be committed explicitly to complete the upload. Image store preserves the upload session until the expiration time, which is 30 minutes after the last chunk received.
     *
     * @param sessionId A GUID generated by the user for a file uploading. It identifies an image store upload session which keeps track of all file chunks until it is committed.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> commitImageStoreUploadSessionAsync(UUID sessionId) {
        return commitImageStoreUploadSessionWithServiceResponseAsync(sessionId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Commit an image store upload session.
     * When all file chunks have been uploaded, the upload session needs to be committed explicitly to complete the upload. Image store preserves the upload session until the expiration time, which is 30 minutes after the last chunk received.
     *
     * @param sessionId A GUID generated by the user for a file uploading. It identifies an image store upload session which keeps track of all file chunks until it is committed.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> commitImageStoreUploadSessionWithServiceResponseAsync(UUID sessionId) {
        if (sessionId == null) {
            throw new IllegalArgumentException("Parameter sessionId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.commitImageStoreUploadSession(apiVersion, sessionId, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = commitImageStoreUploadSessionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Commit an image store upload session.
     * When all file chunks have been uploaded, the upload session needs to be committed explicitly to complete the upload. Image store preserves the upload session until the expiration time, which is 30 minutes after the last chunk received.
     *
     * @param sessionId A GUID generated by the user for a file uploading. It identifies an image store upload session which keeps track of all file chunks until it is committed.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void commitImageStoreUploadSession(UUID sessionId, Long timeout) {
        commitImageStoreUploadSessionWithServiceResponseAsync(sessionId, timeout).toBlocking().single().body();
    }

    /**
     * Commit an image store upload session.
     * When all file chunks have been uploaded, the upload session needs to be committed explicitly to complete the upload. Image store preserves the upload session until the expiration time, which is 30 minutes after the last chunk received.
     *
     * @param sessionId A GUID generated by the user for a file uploading. It identifies an image store upload session which keeps track of all file chunks until it is committed.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> commitImageStoreUploadSessionAsync(UUID sessionId, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(commitImageStoreUploadSessionWithServiceResponseAsync(sessionId, timeout), serviceCallback);
    }

    /**
     * Commit an image store upload session.
     * When all file chunks have been uploaded, the upload session needs to be committed explicitly to complete the upload. Image store preserves the upload session until the expiration time, which is 30 minutes after the last chunk received.
     *
     * @param sessionId A GUID generated by the user for a file uploading. It identifies an image store upload session which keeps track of all file chunks until it is committed.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> commitImageStoreUploadSessionAsync(UUID sessionId, Long timeout) {
        return commitImageStoreUploadSessionWithServiceResponseAsync(sessionId, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Commit an image store upload session.
     * When all file chunks have been uploaded, the upload session needs to be committed explicitly to complete the upload. Image store preserves the upload session until the expiration time, which is 30 minutes after the last chunk received.
     *
     * @param sessionId A GUID generated by the user for a file uploading. It identifies an image store upload session which keeps track of all file chunks until it is committed.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> commitImageStoreUploadSessionWithServiceResponseAsync(UUID sessionId, Long timeout) {
        if (sessionId == null) {
            throw new IllegalArgumentException("Parameter sessionId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.commitImageStoreUploadSession(apiVersion, sessionId, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = commitImageStoreUploadSessionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> commitImageStoreUploadSessionDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Get the image store upload session by ID.
     * Gets the image store upload session identified by the given ID. User can query the upload session at any time during uploading.
     *
     * @param sessionId A GUID generated by the user for a file uploading. It identifies an image store upload session which keeps track of all file chunks until it is committed.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UploadSessionInner object if successful.
     */
    public UploadSessionInner getImageStoreUploadSessionById(UUID sessionId) {
        return getImageStoreUploadSessionByIdWithServiceResponseAsync(sessionId).toBlocking().single().body();
    }

    /**
     * Get the image store upload session by ID.
     * Gets the image store upload session identified by the given ID. User can query the upload session at any time during uploading.
     *
     * @param sessionId A GUID generated by the user for a file uploading. It identifies an image store upload session which keeps track of all file chunks until it is committed.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UploadSessionInner> getImageStoreUploadSessionByIdAsync(UUID sessionId, final ServiceCallback<UploadSessionInner> serviceCallback) {
        return ServiceFuture.fromResponse(getImageStoreUploadSessionByIdWithServiceResponseAsync(sessionId), serviceCallback);
    }

    /**
     * Get the image store upload session by ID.
     * Gets the image store upload session identified by the given ID. User can query the upload session at any time during uploading.
     *
     * @param sessionId A GUID generated by the user for a file uploading. It identifies an image store upload session which keeps track of all file chunks until it is committed.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UploadSessionInner object
     */
    public Observable<UploadSessionInner> getImageStoreUploadSessionByIdAsync(UUID sessionId) {
        return getImageStoreUploadSessionByIdWithServiceResponseAsync(sessionId).map(new Func1<ServiceResponse<UploadSessionInner>, UploadSessionInner>() {
            @Override
            public UploadSessionInner call(ServiceResponse<UploadSessionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get the image store upload session by ID.
     * Gets the image store upload session identified by the given ID. User can query the upload session at any time during uploading.
     *
     * @param sessionId A GUID generated by the user for a file uploading. It identifies an image store upload session which keeps track of all file chunks until it is committed.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UploadSessionInner object
     */
    public Observable<ServiceResponse<UploadSessionInner>> getImageStoreUploadSessionByIdWithServiceResponseAsync(UUID sessionId) {
        if (sessionId == null) {
            throw new IllegalArgumentException("Parameter sessionId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.getImageStoreUploadSessionById(apiVersion, sessionId, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UploadSessionInner>>>() {
                @Override
                public Observable<ServiceResponse<UploadSessionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UploadSessionInner> clientResponse = getImageStoreUploadSessionByIdDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get the image store upload session by ID.
     * Gets the image store upload session identified by the given ID. User can query the upload session at any time during uploading.
     *
     * @param sessionId A GUID generated by the user for a file uploading. It identifies an image store upload session which keeps track of all file chunks until it is committed.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UploadSessionInner object if successful.
     */
    public UploadSessionInner getImageStoreUploadSessionById(UUID sessionId, Long timeout) {
        return getImageStoreUploadSessionByIdWithServiceResponseAsync(sessionId, timeout).toBlocking().single().body();
    }

    /**
     * Get the image store upload session by ID.
     * Gets the image store upload session identified by the given ID. User can query the upload session at any time during uploading.
     *
     * @param sessionId A GUID generated by the user for a file uploading. It identifies an image store upload session which keeps track of all file chunks until it is committed.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UploadSessionInner> getImageStoreUploadSessionByIdAsync(UUID sessionId, Long timeout, final ServiceCallback<UploadSessionInner> serviceCallback) {
        return ServiceFuture.fromResponse(getImageStoreUploadSessionByIdWithServiceResponseAsync(sessionId, timeout), serviceCallback);
    }

    /**
     * Get the image store upload session by ID.
     * Gets the image store upload session identified by the given ID. User can query the upload session at any time during uploading.
     *
     * @param sessionId A GUID generated by the user for a file uploading. It identifies an image store upload session which keeps track of all file chunks until it is committed.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UploadSessionInner object
     */
    public Observable<UploadSessionInner> getImageStoreUploadSessionByIdAsync(UUID sessionId, Long timeout) {
        return getImageStoreUploadSessionByIdWithServiceResponseAsync(sessionId, timeout).map(new Func1<ServiceResponse<UploadSessionInner>, UploadSessionInner>() {
            @Override
            public UploadSessionInner call(ServiceResponse<UploadSessionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get the image store upload session by ID.
     * Gets the image store upload session identified by the given ID. User can query the upload session at any time during uploading.
     *
     * @param sessionId A GUID generated by the user for a file uploading. It identifies an image store upload session which keeps track of all file chunks until it is committed.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UploadSessionInner object
     */
    public Observable<ServiceResponse<UploadSessionInner>> getImageStoreUploadSessionByIdWithServiceResponseAsync(UUID sessionId, Long timeout) {
        if (sessionId == null) {
            throw new IllegalArgumentException("Parameter sessionId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.getImageStoreUploadSessionById(apiVersion, sessionId, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UploadSessionInner>>>() {
                @Override
                public Observable<ServiceResponse<UploadSessionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UploadSessionInner> clientResponse = getImageStoreUploadSessionByIdDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<UploadSessionInner> getImageStoreUploadSessionByIdDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<UploadSessionInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<UploadSessionInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Get the image store upload session by relative path.
     * Gets the image store upload session associated with the given image store relative path. User can query the upload session at any time during uploading.
     *
     * @param contentPath Relative path to file or folder in the image store from its root.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UploadSessionInner object if successful.
     */
    public UploadSessionInner getImageStoreUploadSessionByPath(String contentPath) {
        return getImageStoreUploadSessionByPathWithServiceResponseAsync(contentPath).toBlocking().single().body();
    }

    /**
     * Get the image store upload session by relative path.
     * Gets the image store upload session associated with the given image store relative path. User can query the upload session at any time during uploading.
     *
     * @param contentPath Relative path to file or folder in the image store from its root.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UploadSessionInner> getImageStoreUploadSessionByPathAsync(String contentPath, final ServiceCallback<UploadSessionInner> serviceCallback) {
        return ServiceFuture.fromResponse(getImageStoreUploadSessionByPathWithServiceResponseAsync(contentPath), serviceCallback);
    }

    /**
     * Get the image store upload session by relative path.
     * Gets the image store upload session associated with the given image store relative path. User can query the upload session at any time during uploading.
     *
     * @param contentPath Relative path to file or folder in the image store from its root.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UploadSessionInner object
     */
    public Observable<UploadSessionInner> getImageStoreUploadSessionByPathAsync(String contentPath) {
        return getImageStoreUploadSessionByPathWithServiceResponseAsync(contentPath).map(new Func1<ServiceResponse<UploadSessionInner>, UploadSessionInner>() {
            @Override
            public UploadSessionInner call(ServiceResponse<UploadSessionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get the image store upload session by relative path.
     * Gets the image store upload session associated with the given image store relative path. User can query the upload session at any time during uploading.
     *
     * @param contentPath Relative path to file or folder in the image store from its root.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UploadSessionInner object
     */
    public Observable<ServiceResponse<UploadSessionInner>> getImageStoreUploadSessionByPathWithServiceResponseAsync(String contentPath) {
        if (contentPath == null) {
            throw new IllegalArgumentException("Parameter contentPath is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.getImageStoreUploadSessionByPath(contentPath, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UploadSessionInner>>>() {
                @Override
                public Observable<ServiceResponse<UploadSessionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UploadSessionInner> clientResponse = getImageStoreUploadSessionByPathDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get the image store upload session by relative path.
     * Gets the image store upload session associated with the given image store relative path. User can query the upload session at any time during uploading.
     *
     * @param contentPath Relative path to file or folder in the image store from its root.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UploadSessionInner object if successful.
     */
    public UploadSessionInner getImageStoreUploadSessionByPath(String contentPath, Long timeout) {
        return getImageStoreUploadSessionByPathWithServiceResponseAsync(contentPath, timeout).toBlocking().single().body();
    }

    /**
     * Get the image store upload session by relative path.
     * Gets the image store upload session associated with the given image store relative path. User can query the upload session at any time during uploading.
     *
     * @param contentPath Relative path to file or folder in the image store from its root.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UploadSessionInner> getImageStoreUploadSessionByPathAsync(String contentPath, Long timeout, final ServiceCallback<UploadSessionInner> serviceCallback) {
        return ServiceFuture.fromResponse(getImageStoreUploadSessionByPathWithServiceResponseAsync(contentPath, timeout), serviceCallback);
    }

    /**
     * Get the image store upload session by relative path.
     * Gets the image store upload session associated with the given image store relative path. User can query the upload session at any time during uploading.
     *
     * @param contentPath Relative path to file or folder in the image store from its root.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UploadSessionInner object
     */
    public Observable<UploadSessionInner> getImageStoreUploadSessionByPathAsync(String contentPath, Long timeout) {
        return getImageStoreUploadSessionByPathWithServiceResponseAsync(contentPath, timeout).map(new Func1<ServiceResponse<UploadSessionInner>, UploadSessionInner>() {
            @Override
            public UploadSessionInner call(ServiceResponse<UploadSessionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get the image store upload session by relative path.
     * Gets the image store upload session associated with the given image store relative path. User can query the upload session at any time during uploading.
     *
     * @param contentPath Relative path to file or folder in the image store from its root.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UploadSessionInner object
     */
    public Observable<ServiceResponse<UploadSessionInner>> getImageStoreUploadSessionByPathWithServiceResponseAsync(String contentPath, Long timeout) {
        if (contentPath == null) {
            throw new IllegalArgumentException("Parameter contentPath is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.getImageStoreUploadSessionByPath(contentPath, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UploadSessionInner>>>() {
                @Override
                public Observable<ServiceResponse<UploadSessionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UploadSessionInner> clientResponse = getImageStoreUploadSessionByPathDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<UploadSessionInner> getImageStoreUploadSessionByPathDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<UploadSessionInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<UploadSessionInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Uploads a file chunk to the image store relative path.
     * Uploads a file chunk to the image store with the specified upload session ID and image store relative path. This API allows user to resume the file upload operation. user doesn't have to restart the file upload from scratch whenever there is a network interruption. Use this option if the file size is large.
     To perform a resumable file upload, user need to break the file into multiple chunks and upload these chunks to the image store one-by-one. Chunks don't have to be uploaded in order. If the file represented by the image store relative path already exists, it will be overwritten when the upload session commits.
     *
     * @param contentPath Relative path to file or folder in the image store from its root.
     * @param sessionId A GUID generated by the user for a file uploading. It identifies an image store upload session which keeps track of all file chunks until it is committed.
     * @param contentRange When uploading file chunks to the image store, the Content-Range header field need to be configured and sent with a request. The format should looks like "bytes {First-Byte-Position}-{Last-Byte-Position}/{File-Length}". For example, Content-Range:bytes 300-5000/20000 indicates that user is sending bytes 300 through 5,000 and the total file length is 20,000 bytes.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void uploadFileChunk(String contentPath, UUID sessionId, String contentRange) {
        uploadFileChunkWithServiceResponseAsync(contentPath, sessionId, contentRange).toBlocking().single().body();
    }

    /**
     * Uploads a file chunk to the image store relative path.
     * Uploads a file chunk to the image store with the specified upload session ID and image store relative path. This API allows user to resume the file upload operation. user doesn't have to restart the file upload from scratch whenever there is a network interruption. Use this option if the file size is large.
     To perform a resumable file upload, user need to break the file into multiple chunks and upload these chunks to the image store one-by-one. Chunks don't have to be uploaded in order. If the file represented by the image store relative path already exists, it will be overwritten when the upload session commits.
     *
     * @param contentPath Relative path to file or folder in the image store from its root.
     * @param sessionId A GUID generated by the user for a file uploading. It identifies an image store upload session which keeps track of all file chunks until it is committed.
     * @param contentRange When uploading file chunks to the image store, the Content-Range header field need to be configured and sent with a request. The format should looks like "bytes {First-Byte-Position}-{Last-Byte-Position}/{File-Length}". For example, Content-Range:bytes 300-5000/20000 indicates that user is sending bytes 300 through 5,000 and the total file length is 20,000 bytes.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> uploadFileChunkAsync(String contentPath, UUID sessionId, String contentRange, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(uploadFileChunkWithServiceResponseAsync(contentPath, sessionId, contentRange), serviceCallback);
    }

    /**
     * Uploads a file chunk to the image store relative path.
     * Uploads a file chunk to the image store with the specified upload session ID and image store relative path. This API allows user to resume the file upload operation. user doesn't have to restart the file upload from scratch whenever there is a network interruption. Use this option if the file size is large.
     To perform a resumable file upload, user need to break the file into multiple chunks and upload these chunks to the image store one-by-one. Chunks don't have to be uploaded in order. If the file represented by the image store relative path already exists, it will be overwritten when the upload session commits.
     *
     * @param contentPath Relative path to file or folder in the image store from its root.
     * @param sessionId A GUID generated by the user for a file uploading. It identifies an image store upload session which keeps track of all file chunks until it is committed.
     * @param contentRange When uploading file chunks to the image store, the Content-Range header field need to be configured and sent with a request. The format should looks like "bytes {First-Byte-Position}-{Last-Byte-Position}/{File-Length}". For example, Content-Range:bytes 300-5000/20000 indicates that user is sending bytes 300 through 5,000 and the total file length is 20,000 bytes.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> uploadFileChunkAsync(String contentPath, UUID sessionId, String contentRange) {
        return uploadFileChunkWithServiceResponseAsync(contentPath, sessionId, contentRange).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Uploads a file chunk to the image store relative path.
     * Uploads a file chunk to the image store with the specified upload session ID and image store relative path. This API allows user to resume the file upload operation. user doesn't have to restart the file upload from scratch whenever there is a network interruption. Use this option if the file size is large.
     To perform a resumable file upload, user need to break the file into multiple chunks and upload these chunks to the image store one-by-one. Chunks don't have to be uploaded in order. If the file represented by the image store relative path already exists, it will be overwritten when the upload session commits.
     *
     * @param contentPath Relative path to file or folder in the image store from its root.
     * @param sessionId A GUID generated by the user for a file uploading. It identifies an image store upload session which keeps track of all file chunks until it is committed.
     * @param contentRange When uploading file chunks to the image store, the Content-Range header field need to be configured and sent with a request. The format should looks like "bytes {First-Byte-Position}-{Last-Byte-Position}/{File-Length}". For example, Content-Range:bytes 300-5000/20000 indicates that user is sending bytes 300 through 5,000 and the total file length is 20,000 bytes.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> uploadFileChunkWithServiceResponseAsync(String contentPath, UUID sessionId, String contentRange) {
        if (contentPath == null) {
            throw new IllegalArgumentException("Parameter contentPath is required and cannot be null.");
        }
        if (sessionId == null) {
            throw new IllegalArgumentException("Parameter sessionId is required and cannot be null.");
        }
        if (contentRange == null) {
            throw new IllegalArgumentException("Parameter contentRange is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.uploadFileChunk(contentPath, apiVersion, sessionId, contentRange, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = uploadFileChunkDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Uploads a file chunk to the image store relative path.
     * Uploads a file chunk to the image store with the specified upload session ID and image store relative path. This API allows user to resume the file upload operation. user doesn't have to restart the file upload from scratch whenever there is a network interruption. Use this option if the file size is large.
     To perform a resumable file upload, user need to break the file into multiple chunks and upload these chunks to the image store one-by-one. Chunks don't have to be uploaded in order. If the file represented by the image store relative path already exists, it will be overwritten when the upload session commits.
     *
     * @param contentPath Relative path to file or folder in the image store from its root.
     * @param sessionId A GUID generated by the user for a file uploading. It identifies an image store upload session which keeps track of all file chunks until it is committed.
     * @param contentRange When uploading file chunks to the image store, the Content-Range header field need to be configured and sent with a request. The format should looks like "bytes {First-Byte-Position}-{Last-Byte-Position}/{File-Length}". For example, Content-Range:bytes 300-5000/20000 indicates that user is sending bytes 300 through 5,000 and the total file length is 20,000 bytes.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void uploadFileChunk(String contentPath, UUID sessionId, String contentRange, Long timeout) {
        uploadFileChunkWithServiceResponseAsync(contentPath, sessionId, contentRange, timeout).toBlocking().single().body();
    }

    /**
     * Uploads a file chunk to the image store relative path.
     * Uploads a file chunk to the image store with the specified upload session ID and image store relative path. This API allows user to resume the file upload operation. user doesn't have to restart the file upload from scratch whenever there is a network interruption. Use this option if the file size is large.
     To perform a resumable file upload, user need to break the file into multiple chunks and upload these chunks to the image store one-by-one. Chunks don't have to be uploaded in order. If the file represented by the image store relative path already exists, it will be overwritten when the upload session commits.
     *
     * @param contentPath Relative path to file or folder in the image store from its root.
     * @param sessionId A GUID generated by the user for a file uploading. It identifies an image store upload session which keeps track of all file chunks until it is committed.
     * @param contentRange When uploading file chunks to the image store, the Content-Range header field need to be configured and sent with a request. The format should looks like "bytes {First-Byte-Position}-{Last-Byte-Position}/{File-Length}". For example, Content-Range:bytes 300-5000/20000 indicates that user is sending bytes 300 through 5,000 and the total file length is 20,000 bytes.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> uploadFileChunkAsync(String contentPath, UUID sessionId, String contentRange, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(uploadFileChunkWithServiceResponseAsync(contentPath, sessionId, contentRange, timeout), serviceCallback);
    }

    /**
     * Uploads a file chunk to the image store relative path.
     * Uploads a file chunk to the image store with the specified upload session ID and image store relative path. This API allows user to resume the file upload operation. user doesn't have to restart the file upload from scratch whenever there is a network interruption. Use this option if the file size is large.
     To perform a resumable file upload, user need to break the file into multiple chunks and upload these chunks to the image store one-by-one. Chunks don't have to be uploaded in order. If the file represented by the image store relative path already exists, it will be overwritten when the upload session commits.
     *
     * @param contentPath Relative path to file or folder in the image store from its root.
     * @param sessionId A GUID generated by the user for a file uploading. It identifies an image store upload session which keeps track of all file chunks until it is committed.
     * @param contentRange When uploading file chunks to the image store, the Content-Range header field need to be configured and sent with a request. The format should looks like "bytes {First-Byte-Position}-{Last-Byte-Position}/{File-Length}". For example, Content-Range:bytes 300-5000/20000 indicates that user is sending bytes 300 through 5,000 and the total file length is 20,000 bytes.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> uploadFileChunkAsync(String contentPath, UUID sessionId, String contentRange, Long timeout) {
        return uploadFileChunkWithServiceResponseAsync(contentPath, sessionId, contentRange, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Uploads a file chunk to the image store relative path.
     * Uploads a file chunk to the image store with the specified upload session ID and image store relative path. This API allows user to resume the file upload operation. user doesn't have to restart the file upload from scratch whenever there is a network interruption. Use this option if the file size is large.
     To perform a resumable file upload, user need to break the file into multiple chunks and upload these chunks to the image store one-by-one. Chunks don't have to be uploaded in order. If the file represented by the image store relative path already exists, it will be overwritten when the upload session commits.
     *
     * @param contentPath Relative path to file or folder in the image store from its root.
     * @param sessionId A GUID generated by the user for a file uploading. It identifies an image store upload session which keeps track of all file chunks until it is committed.
     * @param contentRange When uploading file chunks to the image store, the Content-Range header field need to be configured and sent with a request. The format should looks like "bytes {First-Byte-Position}-{Last-Byte-Position}/{File-Length}". For example, Content-Range:bytes 300-5000/20000 indicates that user is sending bytes 300 through 5,000 and the total file length is 20,000 bytes.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> uploadFileChunkWithServiceResponseAsync(String contentPath, UUID sessionId, String contentRange, Long timeout) {
        if (contentPath == null) {
            throw new IllegalArgumentException("Parameter contentPath is required and cannot be null.");
        }
        if (sessionId == null) {
            throw new IllegalArgumentException("Parameter sessionId is required and cannot be null.");
        }
        if (contentRange == null) {
            throw new IllegalArgumentException("Parameter contentRange is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.uploadFileChunk(contentPath, apiVersion, sessionId, contentRange, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = uploadFileChunkDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> uploadFileChunkDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Invokes an administrative command on the given Infrastructure Service instance.
     * For clusters that have one or more instances of the Infrastructure Service configured,
     this API provides a way to send infrastructure-specific commands to a particular
     instance of the Infrastructure Service.
     Available commands and their corresponding response formats vary depending upon
     the infrastructure on which the cluster is running.
     This API supports the Service Fabric platform; it is not meant to be used directly from your code.
     *
     * @param command The text of the command to be invoked. The content of the command is infrastructure-specific.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the String object if successful.
     */
    public String invokeInfrastructureCommand(String command) {
        return invokeInfrastructureCommandWithServiceResponseAsync(command).toBlocking().single().body();
    }

    /**
     * Invokes an administrative command on the given Infrastructure Service instance.
     * For clusters that have one or more instances of the Infrastructure Service configured,
     this API provides a way to send infrastructure-specific commands to a particular
     instance of the Infrastructure Service.
     Available commands and their corresponding response formats vary depending upon
     the infrastructure on which the cluster is running.
     This API supports the Service Fabric platform; it is not meant to be used directly from your code.
     *
     * @param command The text of the command to be invoked. The content of the command is infrastructure-specific.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<String> invokeInfrastructureCommandAsync(String command, final ServiceCallback<String> serviceCallback) {
        return ServiceFuture.fromResponse(invokeInfrastructureCommandWithServiceResponseAsync(command), serviceCallback);
    }

    /**
     * Invokes an administrative command on the given Infrastructure Service instance.
     * For clusters that have one or more instances of the Infrastructure Service configured,
     this API provides a way to send infrastructure-specific commands to a particular
     instance of the Infrastructure Service.
     Available commands and their corresponding response formats vary depending upon
     the infrastructure on which the cluster is running.
     This API supports the Service Fabric platform; it is not meant to be used directly from your code.
     *
     * @param command The text of the command to be invoked. The content of the command is infrastructure-specific.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the String object
     */
    public Observable<String> invokeInfrastructureCommandAsync(String command) {
        return invokeInfrastructureCommandWithServiceResponseAsync(command).map(new Func1<ServiceResponse<String>, String>() {
            @Override
            public String call(ServiceResponse<String> response) {
                return response.body();
            }
        });
    }

    /**
     * Invokes an administrative command on the given Infrastructure Service instance.
     * For clusters that have one or more instances of the Infrastructure Service configured,
     this API provides a way to send infrastructure-specific commands to a particular
     instance of the Infrastructure Service.
     Available commands and their corresponding response formats vary depending upon
     the infrastructure on which the cluster is running.
     This API supports the Service Fabric platform; it is not meant to be used directly from your code.
     *
     * @param command The text of the command to be invoked. The content of the command is infrastructure-specific.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the String object
     */
    public Observable<ServiceResponse<String>> invokeInfrastructureCommandWithServiceResponseAsync(String command) {
        if (command == null) {
            throw new IllegalArgumentException("Parameter command is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final String serviceId = null;
        final Long timeout = null;
        return service.invokeInfrastructureCommand(apiVersion, command, serviceId, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<String>>>() {
                @Override
                public Observable<ServiceResponse<String>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<String> clientResponse = invokeInfrastructureCommandDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Invokes an administrative command on the given Infrastructure Service instance.
     * For clusters that have one or more instances of the Infrastructure Service configured,
     this API provides a way to send infrastructure-specific commands to a particular
     instance of the Infrastructure Service.
     Available commands and their corresponding response formats vary depending upon
     the infrastructure on which the cluster is running.
     This API supports the Service Fabric platform; it is not meant to be used directly from your code.
     *
     * @param command The text of the command to be invoked. The content of the command is infrastructure-specific.
     * @param serviceId The identity of the infrastructure service. This is the full name of the infrastructure service without the 'fabric:' URI scheme. This parameter required only for the cluster that has more than one instance of infrastructure service running.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the String object if successful.
     */
    public String invokeInfrastructureCommand(String command, String serviceId, Long timeout) {
        return invokeInfrastructureCommandWithServiceResponseAsync(command, serviceId, timeout).toBlocking().single().body();
    }

    /**
     * Invokes an administrative command on the given Infrastructure Service instance.
     * For clusters that have one or more instances of the Infrastructure Service configured,
     this API provides a way to send infrastructure-specific commands to a particular
     instance of the Infrastructure Service.
     Available commands and their corresponding response formats vary depending upon
     the infrastructure on which the cluster is running.
     This API supports the Service Fabric platform; it is not meant to be used directly from your code.
     *
     * @param command The text of the command to be invoked. The content of the command is infrastructure-specific.
     * @param serviceId The identity of the infrastructure service. This is the full name of the infrastructure service without the 'fabric:' URI scheme. This parameter required only for the cluster that has more than one instance of infrastructure service running.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<String> invokeInfrastructureCommandAsync(String command, String serviceId, Long timeout, final ServiceCallback<String> serviceCallback) {
        return ServiceFuture.fromResponse(invokeInfrastructureCommandWithServiceResponseAsync(command, serviceId, timeout), serviceCallback);
    }

    /**
     * Invokes an administrative command on the given Infrastructure Service instance.
     * For clusters that have one or more instances of the Infrastructure Service configured,
     this API provides a way to send infrastructure-specific commands to a particular
     instance of the Infrastructure Service.
     Available commands and their corresponding response formats vary depending upon
     the infrastructure on which the cluster is running.
     This API supports the Service Fabric platform; it is not meant to be used directly from your code.
     *
     * @param command The text of the command to be invoked. The content of the command is infrastructure-specific.
     * @param serviceId The identity of the infrastructure service. This is the full name of the infrastructure service without the 'fabric:' URI scheme. This parameter required only for the cluster that has more than one instance of infrastructure service running.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the String object
     */
    public Observable<String> invokeInfrastructureCommandAsync(String command, String serviceId, Long timeout) {
        return invokeInfrastructureCommandWithServiceResponseAsync(command, serviceId, timeout).map(new Func1<ServiceResponse<String>, String>() {
            @Override
            public String call(ServiceResponse<String> response) {
                return response.body();
            }
        });
    }

    /**
     * Invokes an administrative command on the given Infrastructure Service instance.
     * For clusters that have one or more instances of the Infrastructure Service configured,
     this API provides a way to send infrastructure-specific commands to a particular
     instance of the Infrastructure Service.
     Available commands and their corresponding response formats vary depending upon
     the infrastructure on which the cluster is running.
     This API supports the Service Fabric platform; it is not meant to be used directly from your code.
     *
     * @param command The text of the command to be invoked. The content of the command is infrastructure-specific.
     * @param serviceId The identity of the infrastructure service. This is the full name of the infrastructure service without the 'fabric:' URI scheme. This parameter required only for the cluster that has more than one instance of infrastructure service running.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the String object
     */
    public Observable<ServiceResponse<String>> invokeInfrastructureCommandWithServiceResponseAsync(String command, String serviceId, Long timeout) {
        if (command == null) {
            throw new IllegalArgumentException("Parameter command is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.invokeInfrastructureCommand(apiVersion, command, serviceId, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<String>>>() {
                @Override
                public Observable<ServiceResponse<String>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<String> clientResponse = invokeInfrastructureCommandDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<String> invokeInfrastructureCommandDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<String, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<String>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Invokes a read-only query on the given infrastructure service instance.
     * For clusters that have one or more instances of the Infrastructure Service configured,
     this API provides a way to send infrastructure-specific queries to a particular
     instance of the Infrastructure Service.
     Available commands and their corresponding response formats vary depending upon
     the infrastructure on which the cluster is running.
     This API supports the Service Fabric platform; it is not meant to be used directly from your code.
     *
     * @param command The text of the command to be invoked. The content of the command is infrastructure-specific.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the String object if successful.
     */
    public String invokeInfrastructureQuery(String command) {
        return invokeInfrastructureQueryWithServiceResponseAsync(command).toBlocking().single().body();
    }

    /**
     * Invokes a read-only query on the given infrastructure service instance.
     * For clusters that have one or more instances of the Infrastructure Service configured,
     this API provides a way to send infrastructure-specific queries to a particular
     instance of the Infrastructure Service.
     Available commands and their corresponding response formats vary depending upon
     the infrastructure on which the cluster is running.
     This API supports the Service Fabric platform; it is not meant to be used directly from your code.
     *
     * @param command The text of the command to be invoked. The content of the command is infrastructure-specific.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<String> invokeInfrastructureQueryAsync(String command, final ServiceCallback<String> serviceCallback) {
        return ServiceFuture.fromResponse(invokeInfrastructureQueryWithServiceResponseAsync(command), serviceCallback);
    }

    /**
     * Invokes a read-only query on the given infrastructure service instance.
     * For clusters that have one or more instances of the Infrastructure Service configured,
     this API provides a way to send infrastructure-specific queries to a particular
     instance of the Infrastructure Service.
     Available commands and their corresponding response formats vary depending upon
     the infrastructure on which the cluster is running.
     This API supports the Service Fabric platform; it is not meant to be used directly from your code.
     *
     * @param command The text of the command to be invoked. The content of the command is infrastructure-specific.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the String object
     */
    public Observable<String> invokeInfrastructureQueryAsync(String command) {
        return invokeInfrastructureQueryWithServiceResponseAsync(command).map(new Func1<ServiceResponse<String>, String>() {
            @Override
            public String call(ServiceResponse<String> response) {
                return response.body();
            }
        });
    }

    /**
     * Invokes a read-only query on the given infrastructure service instance.
     * For clusters that have one or more instances of the Infrastructure Service configured,
     this API provides a way to send infrastructure-specific queries to a particular
     instance of the Infrastructure Service.
     Available commands and their corresponding response formats vary depending upon
     the infrastructure on which the cluster is running.
     This API supports the Service Fabric platform; it is not meant to be used directly from your code.
     *
     * @param command The text of the command to be invoked. The content of the command is infrastructure-specific.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the String object
     */
    public Observable<ServiceResponse<String>> invokeInfrastructureQueryWithServiceResponseAsync(String command) {
        if (command == null) {
            throw new IllegalArgumentException("Parameter command is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final String serviceId = null;
        final Long timeout = null;
        return service.invokeInfrastructureQuery(apiVersion, command, serviceId, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<String>>>() {
                @Override
                public Observable<ServiceResponse<String>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<String> clientResponse = invokeInfrastructureQueryDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Invokes a read-only query on the given infrastructure service instance.
     * For clusters that have one or more instances of the Infrastructure Service configured,
     this API provides a way to send infrastructure-specific queries to a particular
     instance of the Infrastructure Service.
     Available commands and their corresponding response formats vary depending upon
     the infrastructure on which the cluster is running.
     This API supports the Service Fabric platform; it is not meant to be used directly from your code.
     *
     * @param command The text of the command to be invoked. The content of the command is infrastructure-specific.
     * @param serviceId The identity of the infrastructure service. This is the full name of the infrastructure service without the 'fabric:' URI scheme. This parameter required only for the cluster that has more than one instance of infrastructure service running.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the String object if successful.
     */
    public String invokeInfrastructureQuery(String command, String serviceId, Long timeout) {
        return invokeInfrastructureQueryWithServiceResponseAsync(command, serviceId, timeout).toBlocking().single().body();
    }

    /**
     * Invokes a read-only query on the given infrastructure service instance.
     * For clusters that have one or more instances of the Infrastructure Service configured,
     this API provides a way to send infrastructure-specific queries to a particular
     instance of the Infrastructure Service.
     Available commands and their corresponding response formats vary depending upon
     the infrastructure on which the cluster is running.
     This API supports the Service Fabric platform; it is not meant to be used directly from your code.
     *
     * @param command The text of the command to be invoked. The content of the command is infrastructure-specific.
     * @param serviceId The identity of the infrastructure service. This is the full name of the infrastructure service without the 'fabric:' URI scheme. This parameter required only for the cluster that has more than one instance of infrastructure service running.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<String> invokeInfrastructureQueryAsync(String command, String serviceId, Long timeout, final ServiceCallback<String> serviceCallback) {
        return ServiceFuture.fromResponse(invokeInfrastructureQueryWithServiceResponseAsync(command, serviceId, timeout), serviceCallback);
    }

    /**
     * Invokes a read-only query on the given infrastructure service instance.
     * For clusters that have one or more instances of the Infrastructure Service configured,
     this API provides a way to send infrastructure-specific queries to a particular
     instance of the Infrastructure Service.
     Available commands and their corresponding response formats vary depending upon
     the infrastructure on which the cluster is running.
     This API supports the Service Fabric platform; it is not meant to be used directly from your code.
     *
     * @param command The text of the command to be invoked. The content of the command is infrastructure-specific.
     * @param serviceId The identity of the infrastructure service. This is the full name of the infrastructure service without the 'fabric:' URI scheme. This parameter required only for the cluster that has more than one instance of infrastructure service running.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the String object
     */
    public Observable<String> invokeInfrastructureQueryAsync(String command, String serviceId, Long timeout) {
        return invokeInfrastructureQueryWithServiceResponseAsync(command, serviceId, timeout).map(new Func1<ServiceResponse<String>, String>() {
            @Override
            public String call(ServiceResponse<String> response) {
                return response.body();
            }
        });
    }

    /**
     * Invokes a read-only query on the given infrastructure service instance.
     * For clusters that have one or more instances of the Infrastructure Service configured,
     this API provides a way to send infrastructure-specific queries to a particular
     instance of the Infrastructure Service.
     Available commands and their corresponding response formats vary depending upon
     the infrastructure on which the cluster is running.
     This API supports the Service Fabric platform; it is not meant to be used directly from your code.
     *
     * @param command The text of the command to be invoked. The content of the command is infrastructure-specific.
     * @param serviceId The identity of the infrastructure service. This is the full name of the infrastructure service without the 'fabric:' URI scheme. This parameter required only for the cluster that has more than one instance of infrastructure service running.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the String object
     */
    public Observable<ServiceResponse<String>> invokeInfrastructureQueryWithServiceResponseAsync(String command, String serviceId, Long timeout) {
        if (command == null) {
            throw new IllegalArgumentException("Parameter command is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.invokeInfrastructureQuery(apiVersion, command, serviceId, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<String>>>() {
                @Override
                public Observable<ServiceResponse<String>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<String> clientResponse = invokeInfrastructureQueryDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<String> invokeInfrastructureQueryDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<String, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<String>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * This API will induce data loss for the specified partition. It will trigger a call to the OnDataLossAsync API of the partition.
     * This API will induce data loss for the specified partition. It will trigger a call to the OnDataLoss API of the partition.
     Actual data loss will depend on the specified DataLossMode.
     - PartialDataLoss - Only a quorum of replicas are removed and OnDataLoss is triggered for the partition but actual data loss depends on the presence of in-flight replication.
     - FullDataLoss - All replicas are removed hence all data is lost and OnDataLoss is triggered.
     This API should only be called with a stateful service as the target.
     Calling this API with a system service as the target is not advised.
     Note:  Once this API has been called, it cannot be reversed. Calling CancelOperation will only stop execution and clean up internal system state.
     It will not restore data if the command has progressed far enough to cause data loss.
     Call the GetDataLossProgress API with the same OperationId to return information on the operation started with this API.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param dataLossMode This enum is passed to the StartDataLoss API to indicate what type of data loss to induce. Possible values include: 'Invalid', 'PartialDataLoss', 'FullDataLoss'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void startDataLoss(String serviceId, UUID partitionId, UUID operationId, DataLossMode dataLossMode) {
        startDataLossWithServiceResponseAsync(serviceId, partitionId, operationId, dataLossMode).toBlocking().single().body();
    }

    /**
     * This API will induce data loss for the specified partition. It will trigger a call to the OnDataLossAsync API of the partition.
     * This API will induce data loss for the specified partition. It will trigger a call to the OnDataLoss API of the partition.
     Actual data loss will depend on the specified DataLossMode.
     - PartialDataLoss - Only a quorum of replicas are removed and OnDataLoss is triggered for the partition but actual data loss depends on the presence of in-flight replication.
     - FullDataLoss - All replicas are removed hence all data is lost and OnDataLoss is triggered.
     This API should only be called with a stateful service as the target.
     Calling this API with a system service as the target is not advised.
     Note:  Once this API has been called, it cannot be reversed. Calling CancelOperation will only stop execution and clean up internal system state.
     It will not restore data if the command has progressed far enough to cause data loss.
     Call the GetDataLossProgress API with the same OperationId to return information on the operation started with this API.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param dataLossMode This enum is passed to the StartDataLoss API to indicate what type of data loss to induce. Possible values include: 'Invalid', 'PartialDataLoss', 'FullDataLoss'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> startDataLossAsync(String serviceId, UUID partitionId, UUID operationId, DataLossMode dataLossMode, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(startDataLossWithServiceResponseAsync(serviceId, partitionId, operationId, dataLossMode), serviceCallback);
    }

    /**
     * This API will induce data loss for the specified partition. It will trigger a call to the OnDataLossAsync API of the partition.
     * This API will induce data loss for the specified partition. It will trigger a call to the OnDataLoss API of the partition.
     Actual data loss will depend on the specified DataLossMode.
     - PartialDataLoss - Only a quorum of replicas are removed and OnDataLoss is triggered for the partition but actual data loss depends on the presence of in-flight replication.
     - FullDataLoss - All replicas are removed hence all data is lost and OnDataLoss is triggered.
     This API should only be called with a stateful service as the target.
     Calling this API with a system service as the target is not advised.
     Note:  Once this API has been called, it cannot be reversed. Calling CancelOperation will only stop execution and clean up internal system state.
     It will not restore data if the command has progressed far enough to cause data loss.
     Call the GetDataLossProgress API with the same OperationId to return information on the operation started with this API.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param dataLossMode This enum is passed to the StartDataLoss API to indicate what type of data loss to induce. Possible values include: 'Invalid', 'PartialDataLoss', 'FullDataLoss'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> startDataLossAsync(String serviceId, UUID partitionId, UUID operationId, DataLossMode dataLossMode) {
        return startDataLossWithServiceResponseAsync(serviceId, partitionId, operationId, dataLossMode).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * This API will induce data loss for the specified partition. It will trigger a call to the OnDataLossAsync API of the partition.
     * This API will induce data loss for the specified partition. It will trigger a call to the OnDataLoss API of the partition.
     Actual data loss will depend on the specified DataLossMode.
     - PartialDataLoss - Only a quorum of replicas are removed and OnDataLoss is triggered for the partition but actual data loss depends on the presence of in-flight replication.
     - FullDataLoss - All replicas are removed hence all data is lost and OnDataLoss is triggered.
     This API should only be called with a stateful service as the target.
     Calling this API with a system service as the target is not advised.
     Note:  Once this API has been called, it cannot be reversed. Calling CancelOperation will only stop execution and clean up internal system state.
     It will not restore data if the command has progressed far enough to cause data loss.
     Call the GetDataLossProgress API with the same OperationId to return information on the operation started with this API.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param dataLossMode This enum is passed to the StartDataLoss API to indicate what type of data loss to induce. Possible values include: 'Invalid', 'PartialDataLoss', 'FullDataLoss'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> startDataLossWithServiceResponseAsync(String serviceId, UUID partitionId, UUID operationId, DataLossMode dataLossMode) {
        if (serviceId == null) {
            throw new IllegalArgumentException("Parameter serviceId is required and cannot be null.");
        }
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        if (operationId == null) {
            throw new IllegalArgumentException("Parameter operationId is required and cannot be null.");
        }
        if (dataLossMode == null) {
            throw new IllegalArgumentException("Parameter dataLossMode is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.startDataLoss(serviceId, partitionId, apiVersion, operationId, dataLossMode, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = startDataLossDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * This API will induce data loss for the specified partition. It will trigger a call to the OnDataLossAsync API of the partition.
     * This API will induce data loss for the specified partition. It will trigger a call to the OnDataLoss API of the partition.
     Actual data loss will depend on the specified DataLossMode.
     - PartialDataLoss - Only a quorum of replicas are removed and OnDataLoss is triggered for the partition but actual data loss depends on the presence of in-flight replication.
     - FullDataLoss - All replicas are removed hence all data is lost and OnDataLoss is triggered.
     This API should only be called with a stateful service as the target.
     Calling this API with a system service as the target is not advised.
     Note:  Once this API has been called, it cannot be reversed. Calling CancelOperation will only stop execution and clean up internal system state.
     It will not restore data if the command has progressed far enough to cause data loss.
     Call the GetDataLossProgress API with the same OperationId to return information on the operation started with this API.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param dataLossMode This enum is passed to the StartDataLoss API to indicate what type of data loss to induce. Possible values include: 'Invalid', 'PartialDataLoss', 'FullDataLoss'
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void startDataLoss(String serviceId, UUID partitionId, UUID operationId, DataLossMode dataLossMode, Long timeout) {
        startDataLossWithServiceResponseAsync(serviceId, partitionId, operationId, dataLossMode, timeout).toBlocking().single().body();
    }

    /**
     * This API will induce data loss for the specified partition. It will trigger a call to the OnDataLossAsync API of the partition.
     * This API will induce data loss for the specified partition. It will trigger a call to the OnDataLoss API of the partition.
     Actual data loss will depend on the specified DataLossMode.
     - PartialDataLoss - Only a quorum of replicas are removed and OnDataLoss is triggered for the partition but actual data loss depends on the presence of in-flight replication.
     - FullDataLoss - All replicas are removed hence all data is lost and OnDataLoss is triggered.
     This API should only be called with a stateful service as the target.
     Calling this API with a system service as the target is not advised.
     Note:  Once this API has been called, it cannot be reversed. Calling CancelOperation will only stop execution and clean up internal system state.
     It will not restore data if the command has progressed far enough to cause data loss.
     Call the GetDataLossProgress API with the same OperationId to return information on the operation started with this API.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param dataLossMode This enum is passed to the StartDataLoss API to indicate what type of data loss to induce. Possible values include: 'Invalid', 'PartialDataLoss', 'FullDataLoss'
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> startDataLossAsync(String serviceId, UUID partitionId, UUID operationId, DataLossMode dataLossMode, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(startDataLossWithServiceResponseAsync(serviceId, partitionId, operationId, dataLossMode, timeout), serviceCallback);
    }

    /**
     * This API will induce data loss for the specified partition. It will trigger a call to the OnDataLossAsync API of the partition.
     * This API will induce data loss for the specified partition. It will trigger a call to the OnDataLoss API of the partition.
     Actual data loss will depend on the specified DataLossMode.
     - PartialDataLoss - Only a quorum of replicas are removed and OnDataLoss is triggered for the partition but actual data loss depends on the presence of in-flight replication.
     - FullDataLoss - All replicas are removed hence all data is lost and OnDataLoss is triggered.
     This API should only be called with a stateful service as the target.
     Calling this API with a system service as the target is not advised.
     Note:  Once this API has been called, it cannot be reversed. Calling CancelOperation will only stop execution and clean up internal system state.
     It will not restore data if the command has progressed far enough to cause data loss.
     Call the GetDataLossProgress API with the same OperationId to return information on the operation started with this API.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param dataLossMode This enum is passed to the StartDataLoss API to indicate what type of data loss to induce. Possible values include: 'Invalid', 'PartialDataLoss', 'FullDataLoss'
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> startDataLossAsync(String serviceId, UUID partitionId, UUID operationId, DataLossMode dataLossMode, Long timeout) {
        return startDataLossWithServiceResponseAsync(serviceId, partitionId, operationId, dataLossMode, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * This API will induce data loss for the specified partition. It will trigger a call to the OnDataLossAsync API of the partition.
     * This API will induce data loss for the specified partition. It will trigger a call to the OnDataLoss API of the partition.
     Actual data loss will depend on the specified DataLossMode.
     - PartialDataLoss - Only a quorum of replicas are removed and OnDataLoss is triggered for the partition but actual data loss depends on the presence of in-flight replication.
     - FullDataLoss - All replicas are removed hence all data is lost and OnDataLoss is triggered.
     This API should only be called with a stateful service as the target.
     Calling this API with a system service as the target is not advised.
     Note:  Once this API has been called, it cannot be reversed. Calling CancelOperation will only stop execution and clean up internal system state.
     It will not restore data if the command has progressed far enough to cause data loss.
     Call the GetDataLossProgress API with the same OperationId to return information on the operation started with this API.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param dataLossMode This enum is passed to the StartDataLoss API to indicate what type of data loss to induce. Possible values include: 'Invalid', 'PartialDataLoss', 'FullDataLoss'
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> startDataLossWithServiceResponseAsync(String serviceId, UUID partitionId, UUID operationId, DataLossMode dataLossMode, Long timeout) {
        if (serviceId == null) {
            throw new IllegalArgumentException("Parameter serviceId is required and cannot be null.");
        }
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        if (operationId == null) {
            throw new IllegalArgumentException("Parameter operationId is required and cannot be null.");
        }
        if (dataLossMode == null) {
            throw new IllegalArgumentException("Parameter dataLossMode is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.startDataLoss(serviceId, partitionId, apiVersion, operationId, dataLossMode, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = startDataLossDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> startDataLossDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the progress of a partition data loss operation started using the StartDataLoss API.
     * Gets the progress of a data loss operation started with StartDataLoss, using the OperationId.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PartitionDataLossProgressInner object if successful.
     */
    public PartitionDataLossProgressInner getDataLossProgress(String serviceId, UUID partitionId, UUID operationId) {
        return getDataLossProgressWithServiceResponseAsync(serviceId, partitionId, operationId).toBlocking().single().body();
    }

    /**
     * Gets the progress of a partition data loss operation started using the StartDataLoss API.
     * Gets the progress of a data loss operation started with StartDataLoss, using the OperationId.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PartitionDataLossProgressInner> getDataLossProgressAsync(String serviceId, UUID partitionId, UUID operationId, final ServiceCallback<PartitionDataLossProgressInner> serviceCallback) {
        return ServiceFuture.fromResponse(getDataLossProgressWithServiceResponseAsync(serviceId, partitionId, operationId), serviceCallback);
    }

    /**
     * Gets the progress of a partition data loss operation started using the StartDataLoss API.
     * Gets the progress of a data loss operation started with StartDataLoss, using the OperationId.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PartitionDataLossProgressInner object
     */
    public Observable<PartitionDataLossProgressInner> getDataLossProgressAsync(String serviceId, UUID partitionId, UUID operationId) {
        return getDataLossProgressWithServiceResponseAsync(serviceId, partitionId, operationId).map(new Func1<ServiceResponse<PartitionDataLossProgressInner>, PartitionDataLossProgressInner>() {
            @Override
            public PartitionDataLossProgressInner call(ServiceResponse<PartitionDataLossProgressInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the progress of a partition data loss operation started using the StartDataLoss API.
     * Gets the progress of a data loss operation started with StartDataLoss, using the OperationId.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PartitionDataLossProgressInner object
     */
    public Observable<ServiceResponse<PartitionDataLossProgressInner>> getDataLossProgressWithServiceResponseAsync(String serviceId, UUID partitionId, UUID operationId) {
        if (serviceId == null) {
            throw new IllegalArgumentException("Parameter serviceId is required and cannot be null.");
        }
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        if (operationId == null) {
            throw new IllegalArgumentException("Parameter operationId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.getDataLossProgress(serviceId, partitionId, apiVersion, operationId, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PartitionDataLossProgressInner>>>() {
                @Override
                public Observable<ServiceResponse<PartitionDataLossProgressInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PartitionDataLossProgressInner> clientResponse = getDataLossProgressDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the progress of a partition data loss operation started using the StartDataLoss API.
     * Gets the progress of a data loss operation started with StartDataLoss, using the OperationId.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PartitionDataLossProgressInner object if successful.
     */
    public PartitionDataLossProgressInner getDataLossProgress(String serviceId, UUID partitionId, UUID operationId, Long timeout) {
        return getDataLossProgressWithServiceResponseAsync(serviceId, partitionId, operationId, timeout).toBlocking().single().body();
    }

    /**
     * Gets the progress of a partition data loss operation started using the StartDataLoss API.
     * Gets the progress of a data loss operation started with StartDataLoss, using the OperationId.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PartitionDataLossProgressInner> getDataLossProgressAsync(String serviceId, UUID partitionId, UUID operationId, Long timeout, final ServiceCallback<PartitionDataLossProgressInner> serviceCallback) {
        return ServiceFuture.fromResponse(getDataLossProgressWithServiceResponseAsync(serviceId, partitionId, operationId, timeout), serviceCallback);
    }

    /**
     * Gets the progress of a partition data loss operation started using the StartDataLoss API.
     * Gets the progress of a data loss operation started with StartDataLoss, using the OperationId.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PartitionDataLossProgressInner object
     */
    public Observable<PartitionDataLossProgressInner> getDataLossProgressAsync(String serviceId, UUID partitionId, UUID operationId, Long timeout) {
        return getDataLossProgressWithServiceResponseAsync(serviceId, partitionId, operationId, timeout).map(new Func1<ServiceResponse<PartitionDataLossProgressInner>, PartitionDataLossProgressInner>() {
            @Override
            public PartitionDataLossProgressInner call(ServiceResponse<PartitionDataLossProgressInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the progress of a partition data loss operation started using the StartDataLoss API.
     * Gets the progress of a data loss operation started with StartDataLoss, using the OperationId.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PartitionDataLossProgressInner object
     */
    public Observable<ServiceResponse<PartitionDataLossProgressInner>> getDataLossProgressWithServiceResponseAsync(String serviceId, UUID partitionId, UUID operationId, Long timeout) {
        if (serviceId == null) {
            throw new IllegalArgumentException("Parameter serviceId is required and cannot be null.");
        }
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        if (operationId == null) {
            throw new IllegalArgumentException("Parameter operationId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.getDataLossProgress(serviceId, partitionId, apiVersion, operationId, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PartitionDataLossProgressInner>>>() {
                @Override
                public Observable<ServiceResponse<PartitionDataLossProgressInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PartitionDataLossProgressInner> clientResponse = getDataLossProgressDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PartitionDataLossProgressInner> getDataLossProgressDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<PartitionDataLossProgressInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PartitionDataLossProgressInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Induces quorum loss for a given stateful service partition.
     * This API is useful for a temporary quorum loss situation on your service.
     Call the GetQuorumLossProgress API with the same OperationId to return information on the operation started with this API.
     This can only be called on stateful persisted (HasPersistedState==true) services.  Do not use this API on stateless services or stateful in-memory only services.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param quorumLossMode This enum is passed to the StartQuorumLoss API to indicate what type of quorum loss to induce. Possible values include: 'Invalid', 'QuorumReplicas', 'AllReplicas'
     * @param quorumLossDuration The amount of time for which the partition will be kept in quorum loss.  This must be specified in seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void startQuorumLoss(String serviceId, UUID partitionId, UUID operationId, QuorumLossMode quorumLossMode, int quorumLossDuration) {
        startQuorumLossWithServiceResponseAsync(serviceId, partitionId, operationId, quorumLossMode, quorumLossDuration).toBlocking().single().body();
    }

    /**
     * Induces quorum loss for a given stateful service partition.
     * This API is useful for a temporary quorum loss situation on your service.
     Call the GetQuorumLossProgress API with the same OperationId to return information on the operation started with this API.
     This can only be called on stateful persisted (HasPersistedState==true) services.  Do not use this API on stateless services or stateful in-memory only services.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param quorumLossMode This enum is passed to the StartQuorumLoss API to indicate what type of quorum loss to induce. Possible values include: 'Invalid', 'QuorumReplicas', 'AllReplicas'
     * @param quorumLossDuration The amount of time for which the partition will be kept in quorum loss.  This must be specified in seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> startQuorumLossAsync(String serviceId, UUID partitionId, UUID operationId, QuorumLossMode quorumLossMode, int quorumLossDuration, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(startQuorumLossWithServiceResponseAsync(serviceId, partitionId, operationId, quorumLossMode, quorumLossDuration), serviceCallback);
    }

    /**
     * Induces quorum loss for a given stateful service partition.
     * This API is useful for a temporary quorum loss situation on your service.
     Call the GetQuorumLossProgress API with the same OperationId to return information on the operation started with this API.
     This can only be called on stateful persisted (HasPersistedState==true) services.  Do not use this API on stateless services or stateful in-memory only services.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param quorumLossMode This enum is passed to the StartQuorumLoss API to indicate what type of quorum loss to induce. Possible values include: 'Invalid', 'QuorumReplicas', 'AllReplicas'
     * @param quorumLossDuration The amount of time for which the partition will be kept in quorum loss.  This must be specified in seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> startQuorumLossAsync(String serviceId, UUID partitionId, UUID operationId, QuorumLossMode quorumLossMode, int quorumLossDuration) {
        return startQuorumLossWithServiceResponseAsync(serviceId, partitionId, operationId, quorumLossMode, quorumLossDuration).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Induces quorum loss for a given stateful service partition.
     * This API is useful for a temporary quorum loss situation on your service.
     Call the GetQuorumLossProgress API with the same OperationId to return information on the operation started with this API.
     This can only be called on stateful persisted (HasPersistedState==true) services.  Do not use this API on stateless services or stateful in-memory only services.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param quorumLossMode This enum is passed to the StartQuorumLoss API to indicate what type of quorum loss to induce. Possible values include: 'Invalid', 'QuorumReplicas', 'AllReplicas'
     * @param quorumLossDuration The amount of time for which the partition will be kept in quorum loss.  This must be specified in seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> startQuorumLossWithServiceResponseAsync(String serviceId, UUID partitionId, UUID operationId, QuorumLossMode quorumLossMode, int quorumLossDuration) {
        if (serviceId == null) {
            throw new IllegalArgumentException("Parameter serviceId is required and cannot be null.");
        }
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        if (operationId == null) {
            throw new IllegalArgumentException("Parameter operationId is required and cannot be null.");
        }
        if (quorumLossMode == null) {
            throw new IllegalArgumentException("Parameter quorumLossMode is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.startQuorumLoss(serviceId, partitionId, apiVersion, operationId, quorumLossMode, quorumLossDuration, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = startQuorumLossDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Induces quorum loss for a given stateful service partition.
     * This API is useful for a temporary quorum loss situation on your service.
     Call the GetQuorumLossProgress API with the same OperationId to return information on the operation started with this API.
     This can only be called on stateful persisted (HasPersistedState==true) services.  Do not use this API on stateless services or stateful in-memory only services.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param quorumLossMode This enum is passed to the StartQuorumLoss API to indicate what type of quorum loss to induce. Possible values include: 'Invalid', 'QuorumReplicas', 'AllReplicas'
     * @param quorumLossDuration The amount of time for which the partition will be kept in quorum loss.  This must be specified in seconds.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void startQuorumLoss(String serviceId, UUID partitionId, UUID operationId, QuorumLossMode quorumLossMode, int quorumLossDuration, Long timeout) {
        startQuorumLossWithServiceResponseAsync(serviceId, partitionId, operationId, quorumLossMode, quorumLossDuration, timeout).toBlocking().single().body();
    }

    /**
     * Induces quorum loss for a given stateful service partition.
     * This API is useful for a temporary quorum loss situation on your service.
     Call the GetQuorumLossProgress API with the same OperationId to return information on the operation started with this API.
     This can only be called on stateful persisted (HasPersistedState==true) services.  Do not use this API on stateless services or stateful in-memory only services.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param quorumLossMode This enum is passed to the StartQuorumLoss API to indicate what type of quorum loss to induce. Possible values include: 'Invalid', 'QuorumReplicas', 'AllReplicas'
     * @param quorumLossDuration The amount of time for which the partition will be kept in quorum loss.  This must be specified in seconds.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> startQuorumLossAsync(String serviceId, UUID partitionId, UUID operationId, QuorumLossMode quorumLossMode, int quorumLossDuration, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(startQuorumLossWithServiceResponseAsync(serviceId, partitionId, operationId, quorumLossMode, quorumLossDuration, timeout), serviceCallback);
    }

    /**
     * Induces quorum loss for a given stateful service partition.
     * This API is useful for a temporary quorum loss situation on your service.
     Call the GetQuorumLossProgress API with the same OperationId to return information on the operation started with this API.
     This can only be called on stateful persisted (HasPersistedState==true) services.  Do not use this API on stateless services or stateful in-memory only services.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param quorumLossMode This enum is passed to the StartQuorumLoss API to indicate what type of quorum loss to induce. Possible values include: 'Invalid', 'QuorumReplicas', 'AllReplicas'
     * @param quorumLossDuration The amount of time for which the partition will be kept in quorum loss.  This must be specified in seconds.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> startQuorumLossAsync(String serviceId, UUID partitionId, UUID operationId, QuorumLossMode quorumLossMode, int quorumLossDuration, Long timeout) {
        return startQuorumLossWithServiceResponseAsync(serviceId, partitionId, operationId, quorumLossMode, quorumLossDuration, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Induces quorum loss for a given stateful service partition.
     * This API is useful for a temporary quorum loss situation on your service.
     Call the GetQuorumLossProgress API with the same OperationId to return information on the operation started with this API.
     This can only be called on stateful persisted (HasPersistedState==true) services.  Do not use this API on stateless services or stateful in-memory only services.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param quorumLossMode This enum is passed to the StartQuorumLoss API to indicate what type of quorum loss to induce. Possible values include: 'Invalid', 'QuorumReplicas', 'AllReplicas'
     * @param quorumLossDuration The amount of time for which the partition will be kept in quorum loss.  This must be specified in seconds.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> startQuorumLossWithServiceResponseAsync(String serviceId, UUID partitionId, UUID operationId, QuorumLossMode quorumLossMode, int quorumLossDuration, Long timeout) {
        if (serviceId == null) {
            throw new IllegalArgumentException("Parameter serviceId is required and cannot be null.");
        }
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        if (operationId == null) {
            throw new IllegalArgumentException("Parameter operationId is required and cannot be null.");
        }
        if (quorumLossMode == null) {
            throw new IllegalArgumentException("Parameter quorumLossMode is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.startQuorumLoss(serviceId, partitionId, apiVersion, operationId, quorumLossMode, quorumLossDuration, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = startQuorumLossDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> startQuorumLossDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the progress of a quorum loss operation on a partition started using the StartQuorumLoss API.
     * Gets the progress of a quorum loss operation started with StartQuorumLoss, using the provided OperationId.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PartitionQuorumLossProgressInner object if successful.
     */
    public PartitionQuorumLossProgressInner getQuorumLossProgress(String serviceId, UUID partitionId, UUID operationId) {
        return getQuorumLossProgressWithServiceResponseAsync(serviceId, partitionId, operationId).toBlocking().single().body();
    }

    /**
     * Gets the progress of a quorum loss operation on a partition started using the StartQuorumLoss API.
     * Gets the progress of a quorum loss operation started with StartQuorumLoss, using the provided OperationId.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PartitionQuorumLossProgressInner> getQuorumLossProgressAsync(String serviceId, UUID partitionId, UUID operationId, final ServiceCallback<PartitionQuorumLossProgressInner> serviceCallback) {
        return ServiceFuture.fromResponse(getQuorumLossProgressWithServiceResponseAsync(serviceId, partitionId, operationId), serviceCallback);
    }

    /**
     * Gets the progress of a quorum loss operation on a partition started using the StartQuorumLoss API.
     * Gets the progress of a quorum loss operation started with StartQuorumLoss, using the provided OperationId.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PartitionQuorumLossProgressInner object
     */
    public Observable<PartitionQuorumLossProgressInner> getQuorumLossProgressAsync(String serviceId, UUID partitionId, UUID operationId) {
        return getQuorumLossProgressWithServiceResponseAsync(serviceId, partitionId, operationId).map(new Func1<ServiceResponse<PartitionQuorumLossProgressInner>, PartitionQuorumLossProgressInner>() {
            @Override
            public PartitionQuorumLossProgressInner call(ServiceResponse<PartitionQuorumLossProgressInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the progress of a quorum loss operation on a partition started using the StartQuorumLoss API.
     * Gets the progress of a quorum loss operation started with StartQuorumLoss, using the provided OperationId.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PartitionQuorumLossProgressInner object
     */
    public Observable<ServiceResponse<PartitionQuorumLossProgressInner>> getQuorumLossProgressWithServiceResponseAsync(String serviceId, UUID partitionId, UUID operationId) {
        if (serviceId == null) {
            throw new IllegalArgumentException("Parameter serviceId is required and cannot be null.");
        }
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        if (operationId == null) {
            throw new IllegalArgumentException("Parameter operationId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.getQuorumLossProgress(serviceId, partitionId, apiVersion, operationId, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PartitionQuorumLossProgressInner>>>() {
                @Override
                public Observable<ServiceResponse<PartitionQuorumLossProgressInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PartitionQuorumLossProgressInner> clientResponse = getQuorumLossProgressDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the progress of a quorum loss operation on a partition started using the StartQuorumLoss API.
     * Gets the progress of a quorum loss operation started with StartQuorumLoss, using the provided OperationId.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PartitionQuorumLossProgressInner object if successful.
     */
    public PartitionQuorumLossProgressInner getQuorumLossProgress(String serviceId, UUID partitionId, UUID operationId, Long timeout) {
        return getQuorumLossProgressWithServiceResponseAsync(serviceId, partitionId, operationId, timeout).toBlocking().single().body();
    }

    /**
     * Gets the progress of a quorum loss operation on a partition started using the StartQuorumLoss API.
     * Gets the progress of a quorum loss operation started with StartQuorumLoss, using the provided OperationId.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PartitionQuorumLossProgressInner> getQuorumLossProgressAsync(String serviceId, UUID partitionId, UUID operationId, Long timeout, final ServiceCallback<PartitionQuorumLossProgressInner> serviceCallback) {
        return ServiceFuture.fromResponse(getQuorumLossProgressWithServiceResponseAsync(serviceId, partitionId, operationId, timeout), serviceCallback);
    }

    /**
     * Gets the progress of a quorum loss operation on a partition started using the StartQuorumLoss API.
     * Gets the progress of a quorum loss operation started with StartQuorumLoss, using the provided OperationId.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PartitionQuorumLossProgressInner object
     */
    public Observable<PartitionQuorumLossProgressInner> getQuorumLossProgressAsync(String serviceId, UUID partitionId, UUID operationId, Long timeout) {
        return getQuorumLossProgressWithServiceResponseAsync(serviceId, partitionId, operationId, timeout).map(new Func1<ServiceResponse<PartitionQuorumLossProgressInner>, PartitionQuorumLossProgressInner>() {
            @Override
            public PartitionQuorumLossProgressInner call(ServiceResponse<PartitionQuorumLossProgressInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the progress of a quorum loss operation on a partition started using the StartQuorumLoss API.
     * Gets the progress of a quorum loss operation started with StartQuorumLoss, using the provided OperationId.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PartitionQuorumLossProgressInner object
     */
    public Observable<ServiceResponse<PartitionQuorumLossProgressInner>> getQuorumLossProgressWithServiceResponseAsync(String serviceId, UUID partitionId, UUID operationId, Long timeout) {
        if (serviceId == null) {
            throw new IllegalArgumentException("Parameter serviceId is required and cannot be null.");
        }
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        if (operationId == null) {
            throw new IllegalArgumentException("Parameter operationId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.getQuorumLossProgress(serviceId, partitionId, apiVersion, operationId, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PartitionQuorumLossProgressInner>>>() {
                @Override
                public Observable<ServiceResponse<PartitionQuorumLossProgressInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PartitionQuorumLossProgressInner> clientResponse = getQuorumLossProgressDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PartitionQuorumLossProgressInner> getQuorumLossProgressDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<PartitionQuorumLossProgressInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PartitionQuorumLossProgressInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * This API will restart some or all replicas or instances of the specified partition.
     * This API is useful for testing failover.
     If used to target a stateless service partition, RestartPartitionMode must be AllReplicasOrInstances.
     Call the GetPartitionRestartProgress API using the same OperationId to get the progress.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param restartPartitionMode Describe which partitions to restart. Possible values include: 'Invalid', 'AllReplicasOrInstances', 'OnlyActiveSecondaries'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void startPartitionRestart(String serviceId, UUID partitionId, UUID operationId, RestartPartitionMode restartPartitionMode) {
        startPartitionRestartWithServiceResponseAsync(serviceId, partitionId, operationId, restartPartitionMode).toBlocking().single().body();
    }

    /**
     * This API will restart some or all replicas or instances of the specified partition.
     * This API is useful for testing failover.
     If used to target a stateless service partition, RestartPartitionMode must be AllReplicasOrInstances.
     Call the GetPartitionRestartProgress API using the same OperationId to get the progress.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param restartPartitionMode Describe which partitions to restart. Possible values include: 'Invalid', 'AllReplicasOrInstances', 'OnlyActiveSecondaries'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> startPartitionRestartAsync(String serviceId, UUID partitionId, UUID operationId, RestartPartitionMode restartPartitionMode, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(startPartitionRestartWithServiceResponseAsync(serviceId, partitionId, operationId, restartPartitionMode), serviceCallback);
    }

    /**
     * This API will restart some or all replicas or instances of the specified partition.
     * This API is useful for testing failover.
     If used to target a stateless service partition, RestartPartitionMode must be AllReplicasOrInstances.
     Call the GetPartitionRestartProgress API using the same OperationId to get the progress.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param restartPartitionMode Describe which partitions to restart. Possible values include: 'Invalid', 'AllReplicasOrInstances', 'OnlyActiveSecondaries'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> startPartitionRestartAsync(String serviceId, UUID partitionId, UUID operationId, RestartPartitionMode restartPartitionMode) {
        return startPartitionRestartWithServiceResponseAsync(serviceId, partitionId, operationId, restartPartitionMode).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * This API will restart some or all replicas or instances of the specified partition.
     * This API is useful for testing failover.
     If used to target a stateless service partition, RestartPartitionMode must be AllReplicasOrInstances.
     Call the GetPartitionRestartProgress API using the same OperationId to get the progress.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param restartPartitionMode Describe which partitions to restart. Possible values include: 'Invalid', 'AllReplicasOrInstances', 'OnlyActiveSecondaries'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> startPartitionRestartWithServiceResponseAsync(String serviceId, UUID partitionId, UUID operationId, RestartPartitionMode restartPartitionMode) {
        if (serviceId == null) {
            throw new IllegalArgumentException("Parameter serviceId is required and cannot be null.");
        }
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        if (operationId == null) {
            throw new IllegalArgumentException("Parameter operationId is required and cannot be null.");
        }
        if (restartPartitionMode == null) {
            throw new IllegalArgumentException("Parameter restartPartitionMode is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.startPartitionRestart(serviceId, partitionId, apiVersion, operationId, restartPartitionMode, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = startPartitionRestartDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * This API will restart some or all replicas or instances of the specified partition.
     * This API is useful for testing failover.
     If used to target a stateless service partition, RestartPartitionMode must be AllReplicasOrInstances.
     Call the GetPartitionRestartProgress API using the same OperationId to get the progress.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param restartPartitionMode Describe which partitions to restart. Possible values include: 'Invalid', 'AllReplicasOrInstances', 'OnlyActiveSecondaries'
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void startPartitionRestart(String serviceId, UUID partitionId, UUID operationId, RestartPartitionMode restartPartitionMode, Long timeout) {
        startPartitionRestartWithServiceResponseAsync(serviceId, partitionId, operationId, restartPartitionMode, timeout).toBlocking().single().body();
    }

    /**
     * This API will restart some or all replicas or instances of the specified partition.
     * This API is useful for testing failover.
     If used to target a stateless service partition, RestartPartitionMode must be AllReplicasOrInstances.
     Call the GetPartitionRestartProgress API using the same OperationId to get the progress.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param restartPartitionMode Describe which partitions to restart. Possible values include: 'Invalid', 'AllReplicasOrInstances', 'OnlyActiveSecondaries'
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> startPartitionRestartAsync(String serviceId, UUID partitionId, UUID operationId, RestartPartitionMode restartPartitionMode, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(startPartitionRestartWithServiceResponseAsync(serviceId, partitionId, operationId, restartPartitionMode, timeout), serviceCallback);
    }

    /**
     * This API will restart some or all replicas or instances of the specified partition.
     * This API is useful for testing failover.
     If used to target a stateless service partition, RestartPartitionMode must be AllReplicasOrInstances.
     Call the GetPartitionRestartProgress API using the same OperationId to get the progress.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param restartPartitionMode Describe which partitions to restart. Possible values include: 'Invalid', 'AllReplicasOrInstances', 'OnlyActiveSecondaries'
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> startPartitionRestartAsync(String serviceId, UUID partitionId, UUID operationId, RestartPartitionMode restartPartitionMode, Long timeout) {
        return startPartitionRestartWithServiceResponseAsync(serviceId, partitionId, operationId, restartPartitionMode, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * This API will restart some or all replicas or instances of the specified partition.
     * This API is useful for testing failover.
     If used to target a stateless service partition, RestartPartitionMode must be AllReplicasOrInstances.
     Call the GetPartitionRestartProgress API using the same OperationId to get the progress.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param restartPartitionMode Describe which partitions to restart. Possible values include: 'Invalid', 'AllReplicasOrInstances', 'OnlyActiveSecondaries'
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> startPartitionRestartWithServiceResponseAsync(String serviceId, UUID partitionId, UUID operationId, RestartPartitionMode restartPartitionMode, Long timeout) {
        if (serviceId == null) {
            throw new IllegalArgumentException("Parameter serviceId is required and cannot be null.");
        }
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        if (operationId == null) {
            throw new IllegalArgumentException("Parameter operationId is required and cannot be null.");
        }
        if (restartPartitionMode == null) {
            throw new IllegalArgumentException("Parameter restartPartitionMode is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.startPartitionRestart(serviceId, partitionId, apiVersion, operationId, restartPartitionMode, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = startPartitionRestartDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> startPartitionRestartDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the progress of a PartitionRestart operation started using StartPartitionRestart.
     * Gets the progress of a PartitionRestart started with StartPartitionRestart using the provided OperationId.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PartitionRestartProgressInner object if successful.
     */
    public PartitionRestartProgressInner getPartitionRestartProgress(String serviceId, UUID partitionId, UUID operationId) {
        return getPartitionRestartProgressWithServiceResponseAsync(serviceId, partitionId, operationId).toBlocking().single().body();
    }

    /**
     * Gets the progress of a PartitionRestart operation started using StartPartitionRestart.
     * Gets the progress of a PartitionRestart started with StartPartitionRestart using the provided OperationId.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PartitionRestartProgressInner> getPartitionRestartProgressAsync(String serviceId, UUID partitionId, UUID operationId, final ServiceCallback<PartitionRestartProgressInner> serviceCallback) {
        return ServiceFuture.fromResponse(getPartitionRestartProgressWithServiceResponseAsync(serviceId, partitionId, operationId), serviceCallback);
    }

    /**
     * Gets the progress of a PartitionRestart operation started using StartPartitionRestart.
     * Gets the progress of a PartitionRestart started with StartPartitionRestart using the provided OperationId.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PartitionRestartProgressInner object
     */
    public Observable<PartitionRestartProgressInner> getPartitionRestartProgressAsync(String serviceId, UUID partitionId, UUID operationId) {
        return getPartitionRestartProgressWithServiceResponseAsync(serviceId, partitionId, operationId).map(new Func1<ServiceResponse<PartitionRestartProgressInner>, PartitionRestartProgressInner>() {
            @Override
            public PartitionRestartProgressInner call(ServiceResponse<PartitionRestartProgressInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the progress of a PartitionRestart operation started using StartPartitionRestart.
     * Gets the progress of a PartitionRestart started with StartPartitionRestart using the provided OperationId.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PartitionRestartProgressInner object
     */
    public Observable<ServiceResponse<PartitionRestartProgressInner>> getPartitionRestartProgressWithServiceResponseAsync(String serviceId, UUID partitionId, UUID operationId) {
        if (serviceId == null) {
            throw new IllegalArgumentException("Parameter serviceId is required and cannot be null.");
        }
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        if (operationId == null) {
            throw new IllegalArgumentException("Parameter operationId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.getPartitionRestartProgress(serviceId, partitionId, apiVersion, operationId, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PartitionRestartProgressInner>>>() {
                @Override
                public Observable<ServiceResponse<PartitionRestartProgressInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PartitionRestartProgressInner> clientResponse = getPartitionRestartProgressDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the progress of a PartitionRestart operation started using StartPartitionRestart.
     * Gets the progress of a PartitionRestart started with StartPartitionRestart using the provided OperationId.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PartitionRestartProgressInner object if successful.
     */
    public PartitionRestartProgressInner getPartitionRestartProgress(String serviceId, UUID partitionId, UUID operationId, Long timeout) {
        return getPartitionRestartProgressWithServiceResponseAsync(serviceId, partitionId, operationId, timeout).toBlocking().single().body();
    }

    /**
     * Gets the progress of a PartitionRestart operation started using StartPartitionRestart.
     * Gets the progress of a PartitionRestart started with StartPartitionRestart using the provided OperationId.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PartitionRestartProgressInner> getPartitionRestartProgressAsync(String serviceId, UUID partitionId, UUID operationId, Long timeout, final ServiceCallback<PartitionRestartProgressInner> serviceCallback) {
        return ServiceFuture.fromResponse(getPartitionRestartProgressWithServiceResponseAsync(serviceId, partitionId, operationId, timeout), serviceCallback);
    }

    /**
     * Gets the progress of a PartitionRestart operation started using StartPartitionRestart.
     * Gets the progress of a PartitionRestart started with StartPartitionRestart using the provided OperationId.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PartitionRestartProgressInner object
     */
    public Observable<PartitionRestartProgressInner> getPartitionRestartProgressAsync(String serviceId, UUID partitionId, UUID operationId, Long timeout) {
        return getPartitionRestartProgressWithServiceResponseAsync(serviceId, partitionId, operationId, timeout).map(new Func1<ServiceResponse<PartitionRestartProgressInner>, PartitionRestartProgressInner>() {
            @Override
            public PartitionRestartProgressInner call(ServiceResponse<PartitionRestartProgressInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the progress of a PartitionRestart operation started using StartPartitionRestart.
     * Gets the progress of a PartitionRestart started with StartPartitionRestart using the provided OperationId.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param partitionId The identity of the partition.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PartitionRestartProgressInner object
     */
    public Observable<ServiceResponse<PartitionRestartProgressInner>> getPartitionRestartProgressWithServiceResponseAsync(String serviceId, UUID partitionId, UUID operationId, Long timeout) {
        if (serviceId == null) {
            throw new IllegalArgumentException("Parameter serviceId is required and cannot be null.");
        }
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        if (operationId == null) {
            throw new IllegalArgumentException("Parameter operationId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.getPartitionRestartProgress(serviceId, partitionId, apiVersion, operationId, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PartitionRestartProgressInner>>>() {
                @Override
                public Observable<ServiceResponse<PartitionRestartProgressInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PartitionRestartProgressInner> clientResponse = getPartitionRestartProgressDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PartitionRestartProgressInner> getPartitionRestartProgressDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<PartitionRestartProgressInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PartitionRestartProgressInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Starts or stops a cluster node.
     * Starts or stops a cluster node.  A cluster node is a process, not the OS instance itself.  To start a node, pass in "Start" for the NodeTransitionType parameter.
     To stop a node, pass in "Stop" for the NodeTransitionType parameter.  This API starts the operation - when the API returns the node may not have finished transitioning yet.
     Call GetNodeTransitionProgress with the same OperationId to get the progress of the operation.
     *
     * @param nodeName The name of the node.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param nodeTransitionType Indicates the type of transition to perform.  NodeTransitionType.Start will start a stopped node.  NodeTransitionType.Stop will stop a node that is up. Possible values include: 'Invalid', 'Start', 'Stop'
     * @param nodeInstanceId The node instance ID of the target node.  This can be determined through GetNodeInfo API.
     * @param stopDurationInSeconds The duration, in seconds, to keep the node stopped.  The minimum value is 600, the maximum is 14400.  After this time expires, the node will automatically come back up.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void startNodeTransition(String nodeName, UUID operationId, NodeTransitionType nodeTransitionType, String nodeInstanceId, int stopDurationInSeconds) {
        startNodeTransitionWithServiceResponseAsync(nodeName, operationId, nodeTransitionType, nodeInstanceId, stopDurationInSeconds).toBlocking().single().body();
    }

    /**
     * Starts or stops a cluster node.
     * Starts or stops a cluster node.  A cluster node is a process, not the OS instance itself.  To start a node, pass in "Start" for the NodeTransitionType parameter.
     To stop a node, pass in "Stop" for the NodeTransitionType parameter.  This API starts the operation - when the API returns the node may not have finished transitioning yet.
     Call GetNodeTransitionProgress with the same OperationId to get the progress of the operation.
     *
     * @param nodeName The name of the node.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param nodeTransitionType Indicates the type of transition to perform.  NodeTransitionType.Start will start a stopped node.  NodeTransitionType.Stop will stop a node that is up. Possible values include: 'Invalid', 'Start', 'Stop'
     * @param nodeInstanceId The node instance ID of the target node.  This can be determined through GetNodeInfo API.
     * @param stopDurationInSeconds The duration, in seconds, to keep the node stopped.  The minimum value is 600, the maximum is 14400.  After this time expires, the node will automatically come back up.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> startNodeTransitionAsync(String nodeName, UUID operationId, NodeTransitionType nodeTransitionType, String nodeInstanceId, int stopDurationInSeconds, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(startNodeTransitionWithServiceResponseAsync(nodeName, operationId, nodeTransitionType, nodeInstanceId, stopDurationInSeconds), serviceCallback);
    }

    /**
     * Starts or stops a cluster node.
     * Starts or stops a cluster node.  A cluster node is a process, not the OS instance itself.  To start a node, pass in "Start" for the NodeTransitionType parameter.
     To stop a node, pass in "Stop" for the NodeTransitionType parameter.  This API starts the operation - when the API returns the node may not have finished transitioning yet.
     Call GetNodeTransitionProgress with the same OperationId to get the progress of the operation.
     *
     * @param nodeName The name of the node.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param nodeTransitionType Indicates the type of transition to perform.  NodeTransitionType.Start will start a stopped node.  NodeTransitionType.Stop will stop a node that is up. Possible values include: 'Invalid', 'Start', 'Stop'
     * @param nodeInstanceId The node instance ID of the target node.  This can be determined through GetNodeInfo API.
     * @param stopDurationInSeconds The duration, in seconds, to keep the node stopped.  The minimum value is 600, the maximum is 14400.  After this time expires, the node will automatically come back up.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> startNodeTransitionAsync(String nodeName, UUID operationId, NodeTransitionType nodeTransitionType, String nodeInstanceId, int stopDurationInSeconds) {
        return startNodeTransitionWithServiceResponseAsync(nodeName, operationId, nodeTransitionType, nodeInstanceId, stopDurationInSeconds).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Starts or stops a cluster node.
     * Starts or stops a cluster node.  A cluster node is a process, not the OS instance itself.  To start a node, pass in "Start" for the NodeTransitionType parameter.
     To stop a node, pass in "Stop" for the NodeTransitionType parameter.  This API starts the operation - when the API returns the node may not have finished transitioning yet.
     Call GetNodeTransitionProgress with the same OperationId to get the progress of the operation.
     *
     * @param nodeName The name of the node.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param nodeTransitionType Indicates the type of transition to perform.  NodeTransitionType.Start will start a stopped node.  NodeTransitionType.Stop will stop a node that is up. Possible values include: 'Invalid', 'Start', 'Stop'
     * @param nodeInstanceId The node instance ID of the target node.  This can be determined through GetNodeInfo API.
     * @param stopDurationInSeconds The duration, in seconds, to keep the node stopped.  The minimum value is 600, the maximum is 14400.  After this time expires, the node will automatically come back up.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> startNodeTransitionWithServiceResponseAsync(String nodeName, UUID operationId, NodeTransitionType nodeTransitionType, String nodeInstanceId, int stopDurationInSeconds) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (operationId == null) {
            throw new IllegalArgumentException("Parameter operationId is required and cannot be null.");
        }
        if (nodeTransitionType == null) {
            throw new IllegalArgumentException("Parameter nodeTransitionType is required and cannot be null.");
        }
        if (nodeInstanceId == null) {
            throw new IllegalArgumentException("Parameter nodeInstanceId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.startNodeTransition(nodeName, apiVersion, operationId, nodeTransitionType, nodeInstanceId, stopDurationInSeconds, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = startNodeTransitionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Starts or stops a cluster node.
     * Starts or stops a cluster node.  A cluster node is a process, not the OS instance itself.  To start a node, pass in "Start" for the NodeTransitionType parameter.
     To stop a node, pass in "Stop" for the NodeTransitionType parameter.  This API starts the operation - when the API returns the node may not have finished transitioning yet.
     Call GetNodeTransitionProgress with the same OperationId to get the progress of the operation.
     *
     * @param nodeName The name of the node.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param nodeTransitionType Indicates the type of transition to perform.  NodeTransitionType.Start will start a stopped node.  NodeTransitionType.Stop will stop a node that is up. Possible values include: 'Invalid', 'Start', 'Stop'
     * @param nodeInstanceId The node instance ID of the target node.  This can be determined through GetNodeInfo API.
     * @param stopDurationInSeconds The duration, in seconds, to keep the node stopped.  The minimum value is 600, the maximum is 14400.  After this time expires, the node will automatically come back up.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void startNodeTransition(String nodeName, UUID operationId, NodeTransitionType nodeTransitionType, String nodeInstanceId, int stopDurationInSeconds, Long timeout) {
        startNodeTransitionWithServiceResponseAsync(nodeName, operationId, nodeTransitionType, nodeInstanceId, stopDurationInSeconds, timeout).toBlocking().single().body();
    }

    /**
     * Starts or stops a cluster node.
     * Starts or stops a cluster node.  A cluster node is a process, not the OS instance itself.  To start a node, pass in "Start" for the NodeTransitionType parameter.
     To stop a node, pass in "Stop" for the NodeTransitionType parameter.  This API starts the operation - when the API returns the node may not have finished transitioning yet.
     Call GetNodeTransitionProgress with the same OperationId to get the progress of the operation.
     *
     * @param nodeName The name of the node.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param nodeTransitionType Indicates the type of transition to perform.  NodeTransitionType.Start will start a stopped node.  NodeTransitionType.Stop will stop a node that is up. Possible values include: 'Invalid', 'Start', 'Stop'
     * @param nodeInstanceId The node instance ID of the target node.  This can be determined through GetNodeInfo API.
     * @param stopDurationInSeconds The duration, in seconds, to keep the node stopped.  The minimum value is 600, the maximum is 14400.  After this time expires, the node will automatically come back up.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> startNodeTransitionAsync(String nodeName, UUID operationId, NodeTransitionType nodeTransitionType, String nodeInstanceId, int stopDurationInSeconds, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(startNodeTransitionWithServiceResponseAsync(nodeName, operationId, nodeTransitionType, nodeInstanceId, stopDurationInSeconds, timeout), serviceCallback);
    }

    /**
     * Starts or stops a cluster node.
     * Starts or stops a cluster node.  A cluster node is a process, not the OS instance itself.  To start a node, pass in "Start" for the NodeTransitionType parameter.
     To stop a node, pass in "Stop" for the NodeTransitionType parameter.  This API starts the operation - when the API returns the node may not have finished transitioning yet.
     Call GetNodeTransitionProgress with the same OperationId to get the progress of the operation.
     *
     * @param nodeName The name of the node.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param nodeTransitionType Indicates the type of transition to perform.  NodeTransitionType.Start will start a stopped node.  NodeTransitionType.Stop will stop a node that is up. Possible values include: 'Invalid', 'Start', 'Stop'
     * @param nodeInstanceId The node instance ID of the target node.  This can be determined through GetNodeInfo API.
     * @param stopDurationInSeconds The duration, in seconds, to keep the node stopped.  The minimum value is 600, the maximum is 14400.  After this time expires, the node will automatically come back up.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> startNodeTransitionAsync(String nodeName, UUID operationId, NodeTransitionType nodeTransitionType, String nodeInstanceId, int stopDurationInSeconds, Long timeout) {
        return startNodeTransitionWithServiceResponseAsync(nodeName, operationId, nodeTransitionType, nodeInstanceId, stopDurationInSeconds, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Starts or stops a cluster node.
     * Starts or stops a cluster node.  A cluster node is a process, not the OS instance itself.  To start a node, pass in "Start" for the NodeTransitionType parameter.
     To stop a node, pass in "Stop" for the NodeTransitionType parameter.  This API starts the operation - when the API returns the node may not have finished transitioning yet.
     Call GetNodeTransitionProgress with the same OperationId to get the progress of the operation.
     *
     * @param nodeName The name of the node.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param nodeTransitionType Indicates the type of transition to perform.  NodeTransitionType.Start will start a stopped node.  NodeTransitionType.Stop will stop a node that is up. Possible values include: 'Invalid', 'Start', 'Stop'
     * @param nodeInstanceId The node instance ID of the target node.  This can be determined through GetNodeInfo API.
     * @param stopDurationInSeconds The duration, in seconds, to keep the node stopped.  The minimum value is 600, the maximum is 14400.  After this time expires, the node will automatically come back up.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> startNodeTransitionWithServiceResponseAsync(String nodeName, UUID operationId, NodeTransitionType nodeTransitionType, String nodeInstanceId, int stopDurationInSeconds, Long timeout) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (operationId == null) {
            throw new IllegalArgumentException("Parameter operationId is required and cannot be null.");
        }
        if (nodeTransitionType == null) {
            throw new IllegalArgumentException("Parameter nodeTransitionType is required and cannot be null.");
        }
        if (nodeInstanceId == null) {
            throw new IllegalArgumentException("Parameter nodeInstanceId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.startNodeTransition(nodeName, apiVersion, operationId, nodeTransitionType, nodeInstanceId, stopDurationInSeconds, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = startNodeTransitionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> startNodeTransitionDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the progress of an operation started using StartNodeTransition.
     * Gets the progress of an operation started with StartNodeTransition using the provided OperationId.
     *
     * @param nodeName The name of the node.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the NodeTransitionProgressInner object if successful.
     */
    public NodeTransitionProgressInner getNodeTransitionProgress(String nodeName, UUID operationId) {
        return getNodeTransitionProgressWithServiceResponseAsync(nodeName, operationId).toBlocking().single().body();
    }

    /**
     * Gets the progress of an operation started using StartNodeTransition.
     * Gets the progress of an operation started with StartNodeTransition using the provided OperationId.
     *
     * @param nodeName The name of the node.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<NodeTransitionProgressInner> getNodeTransitionProgressAsync(String nodeName, UUID operationId, final ServiceCallback<NodeTransitionProgressInner> serviceCallback) {
        return ServiceFuture.fromResponse(getNodeTransitionProgressWithServiceResponseAsync(nodeName, operationId), serviceCallback);
    }

    /**
     * Gets the progress of an operation started using StartNodeTransition.
     * Gets the progress of an operation started with StartNodeTransition using the provided OperationId.
     *
     * @param nodeName The name of the node.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the NodeTransitionProgressInner object
     */
    public Observable<NodeTransitionProgressInner> getNodeTransitionProgressAsync(String nodeName, UUID operationId) {
        return getNodeTransitionProgressWithServiceResponseAsync(nodeName, operationId).map(new Func1<ServiceResponse<NodeTransitionProgressInner>, NodeTransitionProgressInner>() {
            @Override
            public NodeTransitionProgressInner call(ServiceResponse<NodeTransitionProgressInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the progress of an operation started using StartNodeTransition.
     * Gets the progress of an operation started with StartNodeTransition using the provided OperationId.
     *
     * @param nodeName The name of the node.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the NodeTransitionProgressInner object
     */
    public Observable<ServiceResponse<NodeTransitionProgressInner>> getNodeTransitionProgressWithServiceResponseAsync(String nodeName, UUID operationId) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (operationId == null) {
            throw new IllegalArgumentException("Parameter operationId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.getNodeTransitionProgress(nodeName, apiVersion, operationId, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<NodeTransitionProgressInner>>>() {
                @Override
                public Observable<ServiceResponse<NodeTransitionProgressInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<NodeTransitionProgressInner> clientResponse = getNodeTransitionProgressDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the progress of an operation started using StartNodeTransition.
     * Gets the progress of an operation started with StartNodeTransition using the provided OperationId.
     *
     * @param nodeName The name of the node.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the NodeTransitionProgressInner object if successful.
     */
    public NodeTransitionProgressInner getNodeTransitionProgress(String nodeName, UUID operationId, Long timeout) {
        return getNodeTransitionProgressWithServiceResponseAsync(nodeName, operationId, timeout).toBlocking().single().body();
    }

    /**
     * Gets the progress of an operation started using StartNodeTransition.
     * Gets the progress of an operation started with StartNodeTransition using the provided OperationId.
     *
     * @param nodeName The name of the node.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<NodeTransitionProgressInner> getNodeTransitionProgressAsync(String nodeName, UUID operationId, Long timeout, final ServiceCallback<NodeTransitionProgressInner> serviceCallback) {
        return ServiceFuture.fromResponse(getNodeTransitionProgressWithServiceResponseAsync(nodeName, operationId, timeout), serviceCallback);
    }

    /**
     * Gets the progress of an operation started using StartNodeTransition.
     * Gets the progress of an operation started with StartNodeTransition using the provided OperationId.
     *
     * @param nodeName The name of the node.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the NodeTransitionProgressInner object
     */
    public Observable<NodeTransitionProgressInner> getNodeTransitionProgressAsync(String nodeName, UUID operationId, Long timeout) {
        return getNodeTransitionProgressWithServiceResponseAsync(nodeName, operationId, timeout).map(new Func1<ServiceResponse<NodeTransitionProgressInner>, NodeTransitionProgressInner>() {
            @Override
            public NodeTransitionProgressInner call(ServiceResponse<NodeTransitionProgressInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the progress of an operation started using StartNodeTransition.
     * Gets the progress of an operation started with StartNodeTransition using the provided OperationId.
     *
     * @param nodeName The name of the node.
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the NodeTransitionProgressInner object
     */
    public Observable<ServiceResponse<NodeTransitionProgressInner>> getNodeTransitionProgressWithServiceResponseAsync(String nodeName, UUID operationId, Long timeout) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (operationId == null) {
            throw new IllegalArgumentException("Parameter operationId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.getNodeTransitionProgress(nodeName, apiVersion, operationId, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<NodeTransitionProgressInner>>>() {
                @Override
                public Observable<ServiceResponse<NodeTransitionProgressInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<NodeTransitionProgressInner> clientResponse = getNodeTransitionProgressDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<NodeTransitionProgressInner> getNodeTransitionProgressDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<NodeTransitionProgressInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<NodeTransitionProgressInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets a list of user-induced fault operations filtered by provided input.
     * Gets the a list of user-induced fault operations filtered by provided input.
     *
     * @param typeFilter Used to filter on OperationType for user-induced operations.
     - 65535 - select all
     - 1 - select PartitionDataLoss.
     - 2 - select PartitionQuorumLoss.
     - 4 - select PartitionRestart.
     - 8 - select NodeTransition.
     * @param stateFilter Used to filter on OperationState's for user-induced operations.
     - 65535 - select All
     - 1 - select Running
     - 2 - select RollingBack
     - 8 - select Completed
     - 16 - select Faulted
     - 32 - select Cancelled
     - 64 - select ForceCancelled
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;OperationStatusInner&gt; object if successful.
     */
    public List<OperationStatusInner> getFaultOperationList(int typeFilter, int stateFilter) {
        return getFaultOperationListWithServiceResponseAsync(typeFilter, stateFilter).toBlocking().single().body();
    }

    /**
     * Gets a list of user-induced fault operations filtered by provided input.
     * Gets the a list of user-induced fault operations filtered by provided input.
     *
     * @param typeFilter Used to filter on OperationType for user-induced operations.
     - 65535 - select all
     - 1 - select PartitionDataLoss.
     - 2 - select PartitionQuorumLoss.
     - 4 - select PartitionRestart.
     - 8 - select NodeTransition.
     * @param stateFilter Used to filter on OperationState's for user-induced operations.
     - 65535 - select All
     - 1 - select Running
     - 2 - select RollingBack
     - 8 - select Completed
     - 16 - select Faulted
     - 32 - select Cancelled
     - 64 - select ForceCancelled
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<OperationStatusInner>> getFaultOperationListAsync(int typeFilter, int stateFilter, final ServiceCallback<List<OperationStatusInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getFaultOperationListWithServiceResponseAsync(typeFilter, stateFilter), serviceCallback);
    }

    /**
     * Gets a list of user-induced fault operations filtered by provided input.
     * Gets the a list of user-induced fault operations filtered by provided input.
     *
     * @param typeFilter Used to filter on OperationType for user-induced operations.
     - 65535 - select all
     - 1 - select PartitionDataLoss.
     - 2 - select PartitionQuorumLoss.
     - 4 - select PartitionRestart.
     - 8 - select NodeTransition.
     * @param stateFilter Used to filter on OperationState's for user-induced operations.
     - 65535 - select All
     - 1 - select Running
     - 2 - select RollingBack
     - 8 - select Completed
     - 16 - select Faulted
     - 32 - select Cancelled
     - 64 - select ForceCancelled
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;OperationStatusInner&gt; object
     */
    public Observable<List<OperationStatusInner>> getFaultOperationListAsync(int typeFilter, int stateFilter) {
        return getFaultOperationListWithServiceResponseAsync(typeFilter, stateFilter).map(new Func1<ServiceResponse<List<OperationStatusInner>>, List<OperationStatusInner>>() {
            @Override
            public List<OperationStatusInner> call(ServiceResponse<List<OperationStatusInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of user-induced fault operations filtered by provided input.
     * Gets the a list of user-induced fault operations filtered by provided input.
     *
     * @param typeFilter Used to filter on OperationType for user-induced operations.
     - 65535 - select all
     - 1 - select PartitionDataLoss.
     - 2 - select PartitionQuorumLoss.
     - 4 - select PartitionRestart.
     - 8 - select NodeTransition.
     * @param stateFilter Used to filter on OperationState's for user-induced operations.
     - 65535 - select All
     - 1 - select Running
     - 2 - select RollingBack
     - 8 - select Completed
     - 16 - select Faulted
     - 32 - select Cancelled
     - 64 - select ForceCancelled
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;OperationStatusInner&gt; object
     */
    public Observable<ServiceResponse<List<OperationStatusInner>>> getFaultOperationListWithServiceResponseAsync(int typeFilter, int stateFilter) {
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.getFaultOperationList(apiVersion, typeFilter, stateFilter, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<OperationStatusInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<OperationStatusInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<OperationStatusInner>> clientResponse = getFaultOperationListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets a list of user-induced fault operations filtered by provided input.
     * Gets the a list of user-induced fault operations filtered by provided input.
     *
     * @param typeFilter Used to filter on OperationType for user-induced operations.
     - 65535 - select all
     - 1 - select PartitionDataLoss.
     - 2 - select PartitionQuorumLoss.
     - 4 - select PartitionRestart.
     - 8 - select NodeTransition.
     * @param stateFilter Used to filter on OperationState's for user-induced operations.
     - 65535 - select All
     - 1 - select Running
     - 2 - select RollingBack
     - 8 - select Completed
     - 16 - select Faulted
     - 32 - select Cancelled
     - 64 - select ForceCancelled
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;OperationStatusInner&gt; object if successful.
     */
    public List<OperationStatusInner> getFaultOperationList(int typeFilter, int stateFilter, Long timeout) {
        return getFaultOperationListWithServiceResponseAsync(typeFilter, stateFilter, timeout).toBlocking().single().body();
    }

    /**
     * Gets a list of user-induced fault operations filtered by provided input.
     * Gets the a list of user-induced fault operations filtered by provided input.
     *
     * @param typeFilter Used to filter on OperationType for user-induced operations.
     - 65535 - select all
     - 1 - select PartitionDataLoss.
     - 2 - select PartitionQuorumLoss.
     - 4 - select PartitionRestart.
     - 8 - select NodeTransition.
     * @param stateFilter Used to filter on OperationState's for user-induced operations.
     - 65535 - select All
     - 1 - select Running
     - 2 - select RollingBack
     - 8 - select Completed
     - 16 - select Faulted
     - 32 - select Cancelled
     - 64 - select ForceCancelled
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<OperationStatusInner>> getFaultOperationListAsync(int typeFilter, int stateFilter, Long timeout, final ServiceCallback<List<OperationStatusInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getFaultOperationListWithServiceResponseAsync(typeFilter, stateFilter, timeout), serviceCallback);
    }

    /**
     * Gets a list of user-induced fault operations filtered by provided input.
     * Gets the a list of user-induced fault operations filtered by provided input.
     *
     * @param typeFilter Used to filter on OperationType for user-induced operations.
     - 65535 - select all
     - 1 - select PartitionDataLoss.
     - 2 - select PartitionQuorumLoss.
     - 4 - select PartitionRestart.
     - 8 - select NodeTransition.
     * @param stateFilter Used to filter on OperationState's for user-induced operations.
     - 65535 - select All
     - 1 - select Running
     - 2 - select RollingBack
     - 8 - select Completed
     - 16 - select Faulted
     - 32 - select Cancelled
     - 64 - select ForceCancelled
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;OperationStatusInner&gt; object
     */
    public Observable<List<OperationStatusInner>> getFaultOperationListAsync(int typeFilter, int stateFilter, Long timeout) {
        return getFaultOperationListWithServiceResponseAsync(typeFilter, stateFilter, timeout).map(new Func1<ServiceResponse<List<OperationStatusInner>>, List<OperationStatusInner>>() {
            @Override
            public List<OperationStatusInner> call(ServiceResponse<List<OperationStatusInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of user-induced fault operations filtered by provided input.
     * Gets the a list of user-induced fault operations filtered by provided input.
     *
     * @param typeFilter Used to filter on OperationType for user-induced operations.
     - 65535 - select all
     - 1 - select PartitionDataLoss.
     - 2 - select PartitionQuorumLoss.
     - 4 - select PartitionRestart.
     - 8 - select NodeTransition.
     * @param stateFilter Used to filter on OperationState's for user-induced operations.
     - 65535 - select All
     - 1 - select Running
     - 2 - select RollingBack
     - 8 - select Completed
     - 16 - select Faulted
     - 32 - select Cancelled
     - 64 - select ForceCancelled
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;OperationStatusInner&gt; object
     */
    public Observable<ServiceResponse<List<OperationStatusInner>>> getFaultOperationListWithServiceResponseAsync(int typeFilter, int stateFilter, Long timeout) {
        final String apiVersion = "6.0";
        return service.getFaultOperationList(apiVersion, typeFilter, stateFilter, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<OperationStatusInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<OperationStatusInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<OperationStatusInner>> clientResponse = getFaultOperationListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<OperationStatusInner>> getFaultOperationListDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException {
        return this.restClient().responseBuilderFactory().<List<OperationStatusInner>, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<OperationStatusInner>>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Cancels a user-induced fault operation.
     * The following APIs start fault operations that may be cancelled by using CancelOperation: StartDataLoss, StartQuorumLoss, StartPartitionRestart, StartNodeTransition.
     If force is false, then the specified user-induced operation will be gracefully stopped and cleaned up.  If force is true, the command will be aborted, and some internal state
     may be left behind.  Specifying force as true should be used with care.  Calling this API with force set to true is not allowed until this API has already
     been called on the same test command with force set to false first, or unless the test command already has an OperationState of OperationState.RollingBack.
     Clarification: OperationState.RollingBack means that the system will be/is cleaning up internal system state caused by executing the command.  It will not restore data if the
     test command was to cause data loss.  For example, if you call StartDataLoss then call this API, the system will only clean up internal state from running the command.
     It will not restore the target partition's data, if the command progressed far enough to cause data loss.
     Important note:  if this API is invoked with force==true, internal state may be left behind.
     *
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param force Indicates whether to gracefully rollback and clean up internal system state modified by executing the user-induced operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void cancelOperation(UUID operationId, boolean force) {
        cancelOperationWithServiceResponseAsync(operationId, force).toBlocking().single().body();
    }

    /**
     * Cancels a user-induced fault operation.
     * The following APIs start fault operations that may be cancelled by using CancelOperation: StartDataLoss, StartQuorumLoss, StartPartitionRestart, StartNodeTransition.
     If force is false, then the specified user-induced operation will be gracefully stopped and cleaned up.  If force is true, the command will be aborted, and some internal state
     may be left behind.  Specifying force as true should be used with care.  Calling this API with force set to true is not allowed until this API has already
     been called on the same test command with force set to false first, or unless the test command already has an OperationState of OperationState.RollingBack.
     Clarification: OperationState.RollingBack means that the system will be/is cleaning up internal system state caused by executing the command.  It will not restore data if the
     test command was to cause data loss.  For example, if you call StartDataLoss then call this API, the system will only clean up internal state from running the command.
     It will not restore the target partition's data, if the command progressed far enough to cause data loss.
     Important note:  if this API is invoked with force==true, internal state may be left behind.
     *
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param force Indicates whether to gracefully rollback and clean up internal system state modified by executing the user-induced operation.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> cancelOperationAsync(UUID operationId, boolean force, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(cancelOperationWithServiceResponseAsync(operationId, force), serviceCallback);
    }

    /**
     * Cancels a user-induced fault operation.
     * The following APIs start fault operations that may be cancelled by using CancelOperation: StartDataLoss, StartQuorumLoss, StartPartitionRestart, StartNodeTransition.
     If force is false, then the specified user-induced operation will be gracefully stopped and cleaned up.  If force is true, the command will be aborted, and some internal state
     may be left behind.  Specifying force as true should be used with care.  Calling this API with force set to true is not allowed until this API has already
     been called on the same test command with force set to false first, or unless the test command already has an OperationState of OperationState.RollingBack.
     Clarification: OperationState.RollingBack means that the system will be/is cleaning up internal system state caused by executing the command.  It will not restore data if the
     test command was to cause data loss.  For example, if you call StartDataLoss then call this API, the system will only clean up internal state from running the command.
     It will not restore the target partition's data, if the command progressed far enough to cause data loss.
     Important note:  if this API is invoked with force==true, internal state may be left behind.
     *
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param force Indicates whether to gracefully rollback and clean up internal system state modified by executing the user-induced operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> cancelOperationAsync(UUID operationId, boolean force) {
        return cancelOperationWithServiceResponseAsync(operationId, force).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Cancels a user-induced fault operation.
     * The following APIs start fault operations that may be cancelled by using CancelOperation: StartDataLoss, StartQuorumLoss, StartPartitionRestart, StartNodeTransition.
     If force is false, then the specified user-induced operation will be gracefully stopped and cleaned up.  If force is true, the command will be aborted, and some internal state
     may be left behind.  Specifying force as true should be used with care.  Calling this API with force set to true is not allowed until this API has already
     been called on the same test command with force set to false first, or unless the test command already has an OperationState of OperationState.RollingBack.
     Clarification: OperationState.RollingBack means that the system will be/is cleaning up internal system state caused by executing the command.  It will not restore data if the
     test command was to cause data loss.  For example, if you call StartDataLoss then call this API, the system will only clean up internal state from running the command.
     It will not restore the target partition's data, if the command progressed far enough to cause data loss.
     Important note:  if this API is invoked with force==true, internal state may be left behind.
     *
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param force Indicates whether to gracefully rollback and clean up internal system state modified by executing the user-induced operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> cancelOperationWithServiceResponseAsync(UUID operationId, boolean force) {
        if (operationId == null) {
            throw new IllegalArgumentException("Parameter operationId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.cancelOperation(apiVersion, operationId, force, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = cancelOperationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Cancels a user-induced fault operation.
     * The following APIs start fault operations that may be cancelled by using CancelOperation: StartDataLoss, StartQuorumLoss, StartPartitionRestart, StartNodeTransition.
     If force is false, then the specified user-induced operation will be gracefully stopped and cleaned up.  If force is true, the command will be aborted, and some internal state
     may be left behind.  Specifying force as true should be used with care.  Calling this API with force set to true is not allowed until this API has already
     been called on the same test command with force set to false first, or unless the test command already has an OperationState of OperationState.RollingBack.
     Clarification: OperationState.RollingBack means that the system will be/is cleaning up internal system state caused by executing the command.  It will not restore data if the
     test command was to cause data loss.  For example, if you call StartDataLoss then call this API, the system will only clean up internal state from running the command.
     It will not restore the target partition's data, if the command progressed far enough to cause data loss.
     Important note:  if this API is invoked with force==true, internal state may be left behind.
     *
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param force Indicates whether to gracefully rollback and clean up internal system state modified by executing the user-induced operation.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void cancelOperation(UUID operationId, boolean force, Long timeout) {
        cancelOperationWithServiceResponseAsync(operationId, force, timeout).toBlocking().single().body();
    }

    /**
     * Cancels a user-induced fault operation.
     * The following APIs start fault operations that may be cancelled by using CancelOperation: StartDataLoss, StartQuorumLoss, StartPartitionRestart, StartNodeTransition.
     If force is false, then the specified user-induced operation will be gracefully stopped and cleaned up.  If force is true, the command will be aborted, and some internal state
     may be left behind.  Specifying force as true should be used with care.  Calling this API with force set to true is not allowed until this API has already
     been called on the same test command with force set to false first, or unless the test command already has an OperationState of OperationState.RollingBack.
     Clarification: OperationState.RollingBack means that the system will be/is cleaning up internal system state caused by executing the command.  It will not restore data if the
     test command was to cause data loss.  For example, if you call StartDataLoss then call this API, the system will only clean up internal state from running the command.
     It will not restore the target partition's data, if the command progressed far enough to cause data loss.
     Important note:  if this API is invoked with force==true, internal state may be left behind.
     *
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param force Indicates whether to gracefully rollback and clean up internal system state modified by executing the user-induced operation.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> cancelOperationAsync(UUID operationId, boolean force, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(cancelOperationWithServiceResponseAsync(operationId, force, timeout), serviceCallback);
    }

    /**
     * Cancels a user-induced fault operation.
     * The following APIs start fault operations that may be cancelled by using CancelOperation: StartDataLoss, StartQuorumLoss, StartPartitionRestart, StartNodeTransition.
     If force is false, then the specified user-induced operation will be gracefully stopped and cleaned up.  If force is true, the command will be aborted, and some internal state
     may be left behind.  Specifying force as true should be used with care.  Calling this API with force set to true is not allowed until this API has already
     been called on the same test command with force set to false first, or unless the test command already has an OperationState of OperationState.RollingBack.
     Clarification: OperationState.RollingBack means that the system will be/is cleaning up internal system state caused by executing the command.  It will not restore data if the
     test command was to cause data loss.  For example, if you call StartDataLoss then call this API, the system will only clean up internal state from running the command.
     It will not restore the target partition's data, if the command progressed far enough to cause data loss.
     Important note:  if this API is invoked with force==true, internal state may be left behind.
     *
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param force Indicates whether to gracefully rollback and clean up internal system state modified by executing the user-induced operation.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> cancelOperationAsync(UUID operationId, boolean force, Long timeout) {
        return cancelOperationWithServiceResponseAsync(operationId, force, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Cancels a user-induced fault operation.
     * The following APIs start fault operations that may be cancelled by using CancelOperation: StartDataLoss, StartQuorumLoss, StartPartitionRestart, StartNodeTransition.
     If force is false, then the specified user-induced operation will be gracefully stopped and cleaned up.  If force is true, the command will be aborted, and some internal state
     may be left behind.  Specifying force as true should be used with care.  Calling this API with force set to true is not allowed until this API has already
     been called on the same test command with force set to false first, or unless the test command already has an OperationState of OperationState.RollingBack.
     Clarification: OperationState.RollingBack means that the system will be/is cleaning up internal system state caused by executing the command.  It will not restore data if the
     test command was to cause data loss.  For example, if you call StartDataLoss then call this API, the system will only clean up internal state from running the command.
     It will not restore the target partition's data, if the command progressed far enough to cause data loss.
     Important note:  if this API is invoked with force==true, internal state may be left behind.
     *
     * @param operationId A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
     * @param force Indicates whether to gracefully rollback and clean up internal system state modified by executing the user-induced operation.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> cancelOperationWithServiceResponseAsync(UUID operationId, boolean force, Long timeout) {
        if (operationId == null) {
            throw new IllegalArgumentException("Parameter operationId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.cancelOperation(apiVersion, operationId, force, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = cancelOperationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> cancelOperationDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Creates a backup policy.
     * Creates a backup policy which can be associated later with a Service Fabric application, service or a partition for periodic backup.
     *
     * @param backupPolicyDescription Describes the backup policy.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void createBackupPolicy(BackupPolicyDescriptionInner backupPolicyDescription) {
        createBackupPolicyWithServiceResponseAsync(backupPolicyDescription).toBlocking().single().body();
    }

    /**
     * Creates a backup policy.
     * Creates a backup policy which can be associated later with a Service Fabric application, service or a partition for periodic backup.
     *
     * @param backupPolicyDescription Describes the backup policy.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> createBackupPolicyAsync(BackupPolicyDescriptionInner backupPolicyDescription, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(createBackupPolicyWithServiceResponseAsync(backupPolicyDescription), serviceCallback);
    }

    /**
     * Creates a backup policy.
     * Creates a backup policy which can be associated later with a Service Fabric application, service or a partition for periodic backup.
     *
     * @param backupPolicyDescription Describes the backup policy.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> createBackupPolicyAsync(BackupPolicyDescriptionInner backupPolicyDescription) {
        return createBackupPolicyWithServiceResponseAsync(backupPolicyDescription).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a backup policy.
     * Creates a backup policy which can be associated later with a Service Fabric application, service or a partition for periodic backup.
     *
     * @param backupPolicyDescription Describes the backup policy.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> createBackupPolicyWithServiceResponseAsync(BackupPolicyDescriptionInner backupPolicyDescription) {
        if (backupPolicyDescription == null) {
            throw new IllegalArgumentException("Parameter backupPolicyDescription is required and cannot be null.");
        }
        Validator.validate(backupPolicyDescription);
        final String apiVersion = "6.2-preview";
        final Long timeout = null;
        return service.createBackupPolicy(backupPolicyDescription, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = createBackupPolicyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Creates a backup policy.
     * Creates a backup policy which can be associated later with a Service Fabric application, service or a partition for periodic backup.
     *
     * @param backupPolicyDescription Describes the backup policy.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void createBackupPolicy(BackupPolicyDescriptionInner backupPolicyDescription, Long timeout) {
        createBackupPolicyWithServiceResponseAsync(backupPolicyDescription, timeout).toBlocking().single().body();
    }

    /**
     * Creates a backup policy.
     * Creates a backup policy which can be associated later with a Service Fabric application, service or a partition for periodic backup.
     *
     * @param backupPolicyDescription Describes the backup policy.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> createBackupPolicyAsync(BackupPolicyDescriptionInner backupPolicyDescription, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(createBackupPolicyWithServiceResponseAsync(backupPolicyDescription, timeout), serviceCallback);
    }

    /**
     * Creates a backup policy.
     * Creates a backup policy which can be associated later with a Service Fabric application, service or a partition for periodic backup.
     *
     * @param backupPolicyDescription Describes the backup policy.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> createBackupPolicyAsync(BackupPolicyDescriptionInner backupPolicyDescription, Long timeout) {
        return createBackupPolicyWithServiceResponseAsync(backupPolicyDescription, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a backup policy.
     * Creates a backup policy which can be associated later with a Service Fabric application, service or a partition for periodic backup.
     *
     * @param backupPolicyDescription Describes the backup policy.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> createBackupPolicyWithServiceResponseAsync(BackupPolicyDescriptionInner backupPolicyDescription, Long timeout) {
        if (backupPolicyDescription == null) {
            throw new IllegalArgumentException("Parameter backupPolicyDescription is required and cannot be null.");
        }
        Validator.validate(backupPolicyDescription);
        final String apiVersion = "6.2-preview";
        return service.createBackupPolicy(backupPolicyDescription, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = createBackupPolicyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> createBackupPolicyDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(201, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Deletes the backup policy.
     * Deletes an existing backup policy. A backup policy must be created before it can be deleted. A currently active backup policy, associated with any Service Fabric application, service or partition, cannot be deleted without first deleting the mapping.
     *
     * @param backupPolicyName The name of the backup policy.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteBackupPolicy(String backupPolicyName) {
        deleteBackupPolicyWithServiceResponseAsync(backupPolicyName).toBlocking().single().body();
    }

    /**
     * Deletes the backup policy.
     * Deletes an existing backup policy. A backup policy must be created before it can be deleted. A currently active backup policy, associated with any Service Fabric application, service or partition, cannot be deleted without first deleting the mapping.
     *
     * @param backupPolicyName The name of the backup policy.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteBackupPolicyAsync(String backupPolicyName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteBackupPolicyWithServiceResponseAsync(backupPolicyName), serviceCallback);
    }

    /**
     * Deletes the backup policy.
     * Deletes an existing backup policy. A backup policy must be created before it can be deleted. A currently active backup policy, associated with any Service Fabric application, service or partition, cannot be deleted without first deleting the mapping.
     *
     * @param backupPolicyName The name of the backup policy.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteBackupPolicyAsync(String backupPolicyName) {
        return deleteBackupPolicyWithServiceResponseAsync(backupPolicyName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes the backup policy.
     * Deletes an existing backup policy. A backup policy must be created before it can be deleted. A currently active backup policy, associated with any Service Fabric application, service or partition, cannot be deleted without first deleting the mapping.
     *
     * @param backupPolicyName The name of the backup policy.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteBackupPolicyWithServiceResponseAsync(String backupPolicyName) {
        if (backupPolicyName == null) {
            throw new IllegalArgumentException("Parameter backupPolicyName is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        final Long timeout = null;
        return service.deleteBackupPolicy(backupPolicyName, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteBackupPolicyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Deletes the backup policy.
     * Deletes an existing backup policy. A backup policy must be created before it can be deleted. A currently active backup policy, associated with any Service Fabric application, service or partition, cannot be deleted without first deleting the mapping.
     *
     * @param backupPolicyName The name of the backup policy.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteBackupPolicy(String backupPolicyName, Long timeout) {
        deleteBackupPolicyWithServiceResponseAsync(backupPolicyName, timeout).toBlocking().single().body();
    }

    /**
     * Deletes the backup policy.
     * Deletes an existing backup policy. A backup policy must be created before it can be deleted. A currently active backup policy, associated with any Service Fabric application, service or partition, cannot be deleted without first deleting the mapping.
     *
     * @param backupPolicyName The name of the backup policy.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteBackupPolicyAsync(String backupPolicyName, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteBackupPolicyWithServiceResponseAsync(backupPolicyName, timeout), serviceCallback);
    }

    /**
     * Deletes the backup policy.
     * Deletes an existing backup policy. A backup policy must be created before it can be deleted. A currently active backup policy, associated with any Service Fabric application, service or partition, cannot be deleted without first deleting the mapping.
     *
     * @param backupPolicyName The name of the backup policy.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteBackupPolicyAsync(String backupPolicyName, Long timeout) {
        return deleteBackupPolicyWithServiceResponseAsync(backupPolicyName, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes the backup policy.
     * Deletes an existing backup policy. A backup policy must be created before it can be deleted. A currently active backup policy, associated with any Service Fabric application, service or partition, cannot be deleted without first deleting the mapping.
     *
     * @param backupPolicyName The name of the backup policy.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteBackupPolicyWithServiceResponseAsync(String backupPolicyName, Long timeout) {
        if (backupPolicyName == null) {
            throw new IllegalArgumentException("Parameter backupPolicyName is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        return service.deleteBackupPolicy(backupPolicyName, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteBackupPolicyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteBackupPolicyDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets all the backup policies configured.
     * Get a list of all the backup policies configured.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedBackupPolicyDescriptionListInner object if successful.
     */
    public PagedBackupPolicyDescriptionListInner getBackupPolicyList() {
        return getBackupPolicyListWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets all the backup policies configured.
     * Get a list of all the backup policies configured.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedBackupPolicyDescriptionListInner> getBackupPolicyListAsync(final ServiceCallback<PagedBackupPolicyDescriptionListInner> serviceCallback) {
        return ServiceFuture.fromResponse(getBackupPolicyListWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets all the backup policies configured.
     * Get a list of all the backup policies configured.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedBackupPolicyDescriptionListInner object
     */
    public Observable<PagedBackupPolicyDescriptionListInner> getBackupPolicyListAsync() {
        return getBackupPolicyListWithServiceResponseAsync().map(new Func1<ServiceResponse<PagedBackupPolicyDescriptionListInner>, PagedBackupPolicyDescriptionListInner>() {
            @Override
            public PagedBackupPolicyDescriptionListInner call(ServiceResponse<PagedBackupPolicyDescriptionListInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets all the backup policies configured.
     * Get a list of all the backup policies configured.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedBackupPolicyDescriptionListInner object
     */
    public Observable<ServiceResponse<PagedBackupPolicyDescriptionListInner>> getBackupPolicyListWithServiceResponseAsync() {
        final String apiVersion = "6.2-preview";
        final String continuationToken = null;
        final Long maxResults = null;
        final Long timeout = null;
        return service.getBackupPolicyList(apiVersion, continuationToken, maxResults, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedBackupPolicyDescriptionListInner>>>() {
                @Override
                public Observable<ServiceResponse<PagedBackupPolicyDescriptionListInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedBackupPolicyDescriptionListInner> clientResponse = getBackupPolicyListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets all the backup policies configured.
     * Get a list of all the backup policies configured.
     *
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedBackupPolicyDescriptionListInner object if successful.
     */
    public PagedBackupPolicyDescriptionListInner getBackupPolicyList(String continuationToken, Long maxResults, Long timeout) {
        return getBackupPolicyListWithServiceResponseAsync(continuationToken, maxResults, timeout).toBlocking().single().body();
    }

    /**
     * Gets all the backup policies configured.
     * Get a list of all the backup policies configured.
     *
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedBackupPolicyDescriptionListInner> getBackupPolicyListAsync(String continuationToken, Long maxResults, Long timeout, final ServiceCallback<PagedBackupPolicyDescriptionListInner> serviceCallback) {
        return ServiceFuture.fromResponse(getBackupPolicyListWithServiceResponseAsync(continuationToken, maxResults, timeout), serviceCallback);
    }

    /**
     * Gets all the backup policies configured.
     * Get a list of all the backup policies configured.
     *
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedBackupPolicyDescriptionListInner object
     */
    public Observable<PagedBackupPolicyDescriptionListInner> getBackupPolicyListAsync(String continuationToken, Long maxResults, Long timeout) {
        return getBackupPolicyListWithServiceResponseAsync(continuationToken, maxResults, timeout).map(new Func1<ServiceResponse<PagedBackupPolicyDescriptionListInner>, PagedBackupPolicyDescriptionListInner>() {
            @Override
            public PagedBackupPolicyDescriptionListInner call(ServiceResponse<PagedBackupPolicyDescriptionListInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets all the backup policies configured.
     * Get a list of all the backup policies configured.
     *
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedBackupPolicyDescriptionListInner object
     */
    public Observable<ServiceResponse<PagedBackupPolicyDescriptionListInner>> getBackupPolicyListWithServiceResponseAsync(String continuationToken, Long maxResults, Long timeout) {
        final String apiVersion = "6.2-preview";
        return service.getBackupPolicyList(apiVersion, continuationToken, maxResults, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedBackupPolicyDescriptionListInner>>>() {
                @Override
                public Observable<ServiceResponse<PagedBackupPolicyDescriptionListInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedBackupPolicyDescriptionListInner> clientResponse = getBackupPolicyListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PagedBackupPolicyDescriptionListInner> getBackupPolicyListDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException {
        return this.restClient().responseBuilderFactory().<PagedBackupPolicyDescriptionListInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PagedBackupPolicyDescriptionListInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets a particular backup policy by name.
     * Gets a particular backup policy identified by {backupPolicyName}.
     *
     * @param backupPolicyName The name of the backup policy.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BackupPolicyDescriptionInner object if successful.
     */
    public BackupPolicyDescriptionInner getBackupPolicyByName(String backupPolicyName) {
        return getBackupPolicyByNameWithServiceResponseAsync(backupPolicyName).toBlocking().single().body();
    }

    /**
     * Gets a particular backup policy by name.
     * Gets a particular backup policy identified by {backupPolicyName}.
     *
     * @param backupPolicyName The name of the backup policy.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BackupPolicyDescriptionInner> getBackupPolicyByNameAsync(String backupPolicyName, final ServiceCallback<BackupPolicyDescriptionInner> serviceCallback) {
        return ServiceFuture.fromResponse(getBackupPolicyByNameWithServiceResponseAsync(backupPolicyName), serviceCallback);
    }

    /**
     * Gets a particular backup policy by name.
     * Gets a particular backup policy identified by {backupPolicyName}.
     *
     * @param backupPolicyName The name of the backup policy.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BackupPolicyDescriptionInner object
     */
    public Observable<BackupPolicyDescriptionInner> getBackupPolicyByNameAsync(String backupPolicyName) {
        return getBackupPolicyByNameWithServiceResponseAsync(backupPolicyName).map(new Func1<ServiceResponse<BackupPolicyDescriptionInner>, BackupPolicyDescriptionInner>() {
            @Override
            public BackupPolicyDescriptionInner call(ServiceResponse<BackupPolicyDescriptionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a particular backup policy by name.
     * Gets a particular backup policy identified by {backupPolicyName}.
     *
     * @param backupPolicyName The name of the backup policy.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BackupPolicyDescriptionInner object
     */
    public Observable<ServiceResponse<BackupPolicyDescriptionInner>> getBackupPolicyByNameWithServiceResponseAsync(String backupPolicyName) {
        if (backupPolicyName == null) {
            throw new IllegalArgumentException("Parameter backupPolicyName is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        final Long timeout = null;
        return service.getBackupPolicyByName(backupPolicyName, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupPolicyDescriptionInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupPolicyDescriptionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupPolicyDescriptionInner> clientResponse = getBackupPolicyByNameDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets a particular backup policy by name.
     * Gets a particular backup policy identified by {backupPolicyName}.
     *
     * @param backupPolicyName The name of the backup policy.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BackupPolicyDescriptionInner object if successful.
     */
    public BackupPolicyDescriptionInner getBackupPolicyByName(String backupPolicyName, Long timeout) {
        return getBackupPolicyByNameWithServiceResponseAsync(backupPolicyName, timeout).toBlocking().single().body();
    }

    /**
     * Gets a particular backup policy by name.
     * Gets a particular backup policy identified by {backupPolicyName}.
     *
     * @param backupPolicyName The name of the backup policy.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BackupPolicyDescriptionInner> getBackupPolicyByNameAsync(String backupPolicyName, Long timeout, final ServiceCallback<BackupPolicyDescriptionInner> serviceCallback) {
        return ServiceFuture.fromResponse(getBackupPolicyByNameWithServiceResponseAsync(backupPolicyName, timeout), serviceCallback);
    }

    /**
     * Gets a particular backup policy by name.
     * Gets a particular backup policy identified by {backupPolicyName}.
     *
     * @param backupPolicyName The name of the backup policy.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BackupPolicyDescriptionInner object
     */
    public Observable<BackupPolicyDescriptionInner> getBackupPolicyByNameAsync(String backupPolicyName, Long timeout) {
        return getBackupPolicyByNameWithServiceResponseAsync(backupPolicyName, timeout).map(new Func1<ServiceResponse<BackupPolicyDescriptionInner>, BackupPolicyDescriptionInner>() {
            @Override
            public BackupPolicyDescriptionInner call(ServiceResponse<BackupPolicyDescriptionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a particular backup policy by name.
     * Gets a particular backup policy identified by {backupPolicyName}.
     *
     * @param backupPolicyName The name of the backup policy.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BackupPolicyDescriptionInner object
     */
    public Observable<ServiceResponse<BackupPolicyDescriptionInner>> getBackupPolicyByNameWithServiceResponseAsync(String backupPolicyName, Long timeout) {
        if (backupPolicyName == null) {
            throw new IllegalArgumentException("Parameter backupPolicyName is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        return service.getBackupPolicyByName(backupPolicyName, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupPolicyDescriptionInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupPolicyDescriptionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupPolicyDescriptionInner> clientResponse = getBackupPolicyByNameDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupPolicyDescriptionInner> getBackupPolicyByNameDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<BackupPolicyDescriptionInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<BackupPolicyDescriptionInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the list of backup entities that are associated with this policy.
     * Returns a list of Service Fabric application, service or partition which are associated with this backup policy.
     *
     * @param backupPolicyName The name of the backup policy.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedBackupEntityListInner object if successful.
     */
    public PagedBackupEntityListInner getAllEntitiesBackedUpByPolicy(String backupPolicyName) {
        return getAllEntitiesBackedUpByPolicyWithServiceResponseAsync(backupPolicyName).toBlocking().single().body();
    }

    /**
     * Gets the list of backup entities that are associated with this policy.
     * Returns a list of Service Fabric application, service or partition which are associated with this backup policy.
     *
     * @param backupPolicyName The name of the backup policy.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedBackupEntityListInner> getAllEntitiesBackedUpByPolicyAsync(String backupPolicyName, final ServiceCallback<PagedBackupEntityListInner> serviceCallback) {
        return ServiceFuture.fromResponse(getAllEntitiesBackedUpByPolicyWithServiceResponseAsync(backupPolicyName), serviceCallback);
    }

    /**
     * Gets the list of backup entities that are associated with this policy.
     * Returns a list of Service Fabric application, service or partition which are associated with this backup policy.
     *
     * @param backupPolicyName The name of the backup policy.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedBackupEntityListInner object
     */
    public Observable<PagedBackupEntityListInner> getAllEntitiesBackedUpByPolicyAsync(String backupPolicyName) {
        return getAllEntitiesBackedUpByPolicyWithServiceResponseAsync(backupPolicyName).map(new Func1<ServiceResponse<PagedBackupEntityListInner>, PagedBackupEntityListInner>() {
            @Override
            public PagedBackupEntityListInner call(ServiceResponse<PagedBackupEntityListInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the list of backup entities that are associated with this policy.
     * Returns a list of Service Fabric application, service or partition which are associated with this backup policy.
     *
     * @param backupPolicyName The name of the backup policy.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedBackupEntityListInner object
     */
    public Observable<ServiceResponse<PagedBackupEntityListInner>> getAllEntitiesBackedUpByPolicyWithServiceResponseAsync(String backupPolicyName) {
        if (backupPolicyName == null) {
            throw new IllegalArgumentException("Parameter backupPolicyName is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        final String continuationToken = null;
        final Long maxResults = null;
        final Long timeout = null;
        return service.getAllEntitiesBackedUpByPolicy(backupPolicyName, apiVersion, continuationToken, maxResults, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedBackupEntityListInner>>>() {
                @Override
                public Observable<ServiceResponse<PagedBackupEntityListInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedBackupEntityListInner> clientResponse = getAllEntitiesBackedUpByPolicyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the list of backup entities that are associated with this policy.
     * Returns a list of Service Fabric application, service or partition which are associated with this backup policy.
     *
     * @param backupPolicyName The name of the backup policy.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedBackupEntityListInner object if successful.
     */
    public PagedBackupEntityListInner getAllEntitiesBackedUpByPolicy(String backupPolicyName, String continuationToken, Long maxResults, Long timeout) {
        return getAllEntitiesBackedUpByPolicyWithServiceResponseAsync(backupPolicyName, continuationToken, maxResults, timeout).toBlocking().single().body();
    }

    /**
     * Gets the list of backup entities that are associated with this policy.
     * Returns a list of Service Fabric application, service or partition which are associated with this backup policy.
     *
     * @param backupPolicyName The name of the backup policy.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedBackupEntityListInner> getAllEntitiesBackedUpByPolicyAsync(String backupPolicyName, String continuationToken, Long maxResults, Long timeout, final ServiceCallback<PagedBackupEntityListInner> serviceCallback) {
        return ServiceFuture.fromResponse(getAllEntitiesBackedUpByPolicyWithServiceResponseAsync(backupPolicyName, continuationToken, maxResults, timeout), serviceCallback);
    }

    /**
     * Gets the list of backup entities that are associated with this policy.
     * Returns a list of Service Fabric application, service or partition which are associated with this backup policy.
     *
     * @param backupPolicyName The name of the backup policy.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedBackupEntityListInner object
     */
    public Observable<PagedBackupEntityListInner> getAllEntitiesBackedUpByPolicyAsync(String backupPolicyName, String continuationToken, Long maxResults, Long timeout) {
        return getAllEntitiesBackedUpByPolicyWithServiceResponseAsync(backupPolicyName, continuationToken, maxResults, timeout).map(new Func1<ServiceResponse<PagedBackupEntityListInner>, PagedBackupEntityListInner>() {
            @Override
            public PagedBackupEntityListInner call(ServiceResponse<PagedBackupEntityListInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the list of backup entities that are associated with this policy.
     * Returns a list of Service Fabric application, service or partition which are associated with this backup policy.
     *
     * @param backupPolicyName The name of the backup policy.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedBackupEntityListInner object
     */
    public Observable<ServiceResponse<PagedBackupEntityListInner>> getAllEntitiesBackedUpByPolicyWithServiceResponseAsync(String backupPolicyName, String continuationToken, Long maxResults, Long timeout) {
        if (backupPolicyName == null) {
            throw new IllegalArgumentException("Parameter backupPolicyName is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        return service.getAllEntitiesBackedUpByPolicy(backupPolicyName, apiVersion, continuationToken, maxResults, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedBackupEntityListInner>>>() {
                @Override
                public Observable<ServiceResponse<PagedBackupEntityListInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedBackupEntityListInner> clientResponse = getAllEntitiesBackedUpByPolicyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PagedBackupEntityListInner> getAllEntitiesBackedUpByPolicyDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<PagedBackupEntityListInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PagedBackupEntityListInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Updates the backup policy.
     * Updates the backup policy identified by {backupPolicyName}.
     *
     * @param backupPolicyName The name of the backup policy.
     * @param backupPolicyDescription Describes the backup policy.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void updateBackupPolicy(String backupPolicyName, BackupPolicyDescriptionInner backupPolicyDescription) {
        updateBackupPolicyWithServiceResponseAsync(backupPolicyName, backupPolicyDescription).toBlocking().single().body();
    }

    /**
     * Updates the backup policy.
     * Updates the backup policy identified by {backupPolicyName}.
     *
     * @param backupPolicyName The name of the backup policy.
     * @param backupPolicyDescription Describes the backup policy.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> updateBackupPolicyAsync(String backupPolicyName, BackupPolicyDescriptionInner backupPolicyDescription, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(updateBackupPolicyWithServiceResponseAsync(backupPolicyName, backupPolicyDescription), serviceCallback);
    }

    /**
     * Updates the backup policy.
     * Updates the backup policy identified by {backupPolicyName}.
     *
     * @param backupPolicyName The name of the backup policy.
     * @param backupPolicyDescription Describes the backup policy.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> updateBackupPolicyAsync(String backupPolicyName, BackupPolicyDescriptionInner backupPolicyDescription) {
        return updateBackupPolicyWithServiceResponseAsync(backupPolicyName, backupPolicyDescription).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the backup policy.
     * Updates the backup policy identified by {backupPolicyName}.
     *
     * @param backupPolicyName The name of the backup policy.
     * @param backupPolicyDescription Describes the backup policy.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> updateBackupPolicyWithServiceResponseAsync(String backupPolicyName, BackupPolicyDescriptionInner backupPolicyDescription) {
        if (backupPolicyName == null) {
            throw new IllegalArgumentException("Parameter backupPolicyName is required and cannot be null.");
        }
        if (backupPolicyDescription == null) {
            throw new IllegalArgumentException("Parameter backupPolicyDescription is required and cannot be null.");
        }
        Validator.validate(backupPolicyDescription);
        final String apiVersion = "6.2-preview";
        final Long timeout = null;
        return service.updateBackupPolicy(backupPolicyName, backupPolicyDescription, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = updateBackupPolicyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Updates the backup policy.
     * Updates the backup policy identified by {backupPolicyName}.
     *
     * @param backupPolicyName The name of the backup policy.
     * @param backupPolicyDescription Describes the backup policy.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void updateBackupPolicy(String backupPolicyName, BackupPolicyDescriptionInner backupPolicyDescription, Long timeout) {
        updateBackupPolicyWithServiceResponseAsync(backupPolicyName, backupPolicyDescription, timeout).toBlocking().single().body();
    }

    /**
     * Updates the backup policy.
     * Updates the backup policy identified by {backupPolicyName}.
     *
     * @param backupPolicyName The name of the backup policy.
     * @param backupPolicyDescription Describes the backup policy.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> updateBackupPolicyAsync(String backupPolicyName, BackupPolicyDescriptionInner backupPolicyDescription, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(updateBackupPolicyWithServiceResponseAsync(backupPolicyName, backupPolicyDescription, timeout), serviceCallback);
    }

    /**
     * Updates the backup policy.
     * Updates the backup policy identified by {backupPolicyName}.
     *
     * @param backupPolicyName The name of the backup policy.
     * @param backupPolicyDescription Describes the backup policy.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> updateBackupPolicyAsync(String backupPolicyName, BackupPolicyDescriptionInner backupPolicyDescription, Long timeout) {
        return updateBackupPolicyWithServiceResponseAsync(backupPolicyName, backupPolicyDescription, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the backup policy.
     * Updates the backup policy identified by {backupPolicyName}.
     *
     * @param backupPolicyName The name of the backup policy.
     * @param backupPolicyDescription Describes the backup policy.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> updateBackupPolicyWithServiceResponseAsync(String backupPolicyName, BackupPolicyDescriptionInner backupPolicyDescription, Long timeout) {
        if (backupPolicyName == null) {
            throw new IllegalArgumentException("Parameter backupPolicyName is required and cannot be null.");
        }
        if (backupPolicyDescription == null) {
            throw new IllegalArgumentException("Parameter backupPolicyDescription is required and cannot be null.");
        }
        Validator.validate(backupPolicyDescription);
        final String apiVersion = "6.2-preview";
        return service.updateBackupPolicy(backupPolicyName, backupPolicyDescription, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = updateBackupPolicyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> updateBackupPolicyDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Enables periodic backup of stateful partitions under this Service Fabric application.
     * Enables periodic backup of stateful partitions which are part of this Service Fabric application. Each partition is backed up individually as per the specified backup policy description.
     Note only C# based Reliable Actor and Reliable Stateful services are currently supported for periodic backup.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param backupPolicyName Name of the backup policy to be used for enabling periodic backups.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void enableApplicationBackup(String applicationId, String backupPolicyName) {
        enableApplicationBackupWithServiceResponseAsync(applicationId, backupPolicyName).toBlocking().single().body();
    }

    /**
     * Enables periodic backup of stateful partitions under this Service Fabric application.
     * Enables periodic backup of stateful partitions which are part of this Service Fabric application. Each partition is backed up individually as per the specified backup policy description.
     Note only C# based Reliable Actor and Reliable Stateful services are currently supported for periodic backup.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param backupPolicyName Name of the backup policy to be used for enabling periodic backups.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> enableApplicationBackupAsync(String applicationId, String backupPolicyName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(enableApplicationBackupWithServiceResponseAsync(applicationId, backupPolicyName), serviceCallback);
    }

    /**
     * Enables periodic backup of stateful partitions under this Service Fabric application.
     * Enables periodic backup of stateful partitions which are part of this Service Fabric application. Each partition is backed up individually as per the specified backup policy description.
     Note only C# based Reliable Actor and Reliable Stateful services are currently supported for periodic backup.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param backupPolicyName Name of the backup policy to be used for enabling periodic backups.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> enableApplicationBackupAsync(String applicationId, String backupPolicyName) {
        return enableApplicationBackupWithServiceResponseAsync(applicationId, backupPolicyName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Enables periodic backup of stateful partitions under this Service Fabric application.
     * Enables periodic backup of stateful partitions which are part of this Service Fabric application. Each partition is backed up individually as per the specified backup policy description.
     Note only C# based Reliable Actor and Reliable Stateful services are currently supported for periodic backup.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param backupPolicyName Name of the backup policy to be used for enabling periodic backups.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> enableApplicationBackupWithServiceResponseAsync(String applicationId, String backupPolicyName) {
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        if (backupPolicyName == null) {
            throw new IllegalArgumentException("Parameter backupPolicyName is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        final Long timeout = null;
        EnableBackupDescription enableBackupDescription = new EnableBackupDescription();
        enableBackupDescription.withBackupPolicyName(backupPolicyName);
        return service.enableApplicationBackup(applicationId, apiVersion, timeout, this.acceptLanguage(), enableBackupDescription, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = enableApplicationBackupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Enables periodic backup of stateful partitions under this Service Fabric application.
     * Enables periodic backup of stateful partitions which are part of this Service Fabric application. Each partition is backed up individually as per the specified backup policy description.
     Note only C# based Reliable Actor and Reliable Stateful services are currently supported for periodic backup.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param backupPolicyName Name of the backup policy to be used for enabling periodic backups.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void enableApplicationBackup(String applicationId, String backupPolicyName, Long timeout) {
        enableApplicationBackupWithServiceResponseAsync(applicationId, backupPolicyName, timeout).toBlocking().single().body();
    }

    /**
     * Enables periodic backup of stateful partitions under this Service Fabric application.
     * Enables periodic backup of stateful partitions which are part of this Service Fabric application. Each partition is backed up individually as per the specified backup policy description.
     Note only C# based Reliable Actor and Reliable Stateful services are currently supported for periodic backup.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param backupPolicyName Name of the backup policy to be used for enabling periodic backups.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> enableApplicationBackupAsync(String applicationId, String backupPolicyName, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(enableApplicationBackupWithServiceResponseAsync(applicationId, backupPolicyName, timeout), serviceCallback);
    }

    /**
     * Enables periodic backup of stateful partitions under this Service Fabric application.
     * Enables periodic backup of stateful partitions which are part of this Service Fabric application. Each partition is backed up individually as per the specified backup policy description.
     Note only C# based Reliable Actor and Reliable Stateful services are currently supported for periodic backup.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param backupPolicyName Name of the backup policy to be used for enabling periodic backups.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> enableApplicationBackupAsync(String applicationId, String backupPolicyName, Long timeout) {
        return enableApplicationBackupWithServiceResponseAsync(applicationId, backupPolicyName, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Enables periodic backup of stateful partitions under this Service Fabric application.
     * Enables periodic backup of stateful partitions which are part of this Service Fabric application. Each partition is backed up individually as per the specified backup policy description.
     Note only C# based Reliable Actor and Reliable Stateful services are currently supported for periodic backup.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param backupPolicyName Name of the backup policy to be used for enabling periodic backups.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> enableApplicationBackupWithServiceResponseAsync(String applicationId, String backupPolicyName, Long timeout) {
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        if (backupPolicyName == null) {
            throw new IllegalArgumentException("Parameter backupPolicyName is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        EnableBackupDescription enableBackupDescription = new EnableBackupDescription();
        enableBackupDescription.withBackupPolicyName(backupPolicyName);
        return service.enableApplicationBackup(applicationId, apiVersion, timeout, this.acceptLanguage(), enableBackupDescription, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = enableApplicationBackupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> enableApplicationBackupDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Disables periodic backup of Service Fabric application.
     * Disables periodic backup of Service Fabric application which was previously enabled.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void disableApplicationBackup(String applicationId) {
        disableApplicationBackupWithServiceResponseAsync(applicationId).toBlocking().single().body();
    }

    /**
     * Disables periodic backup of Service Fabric application.
     * Disables periodic backup of Service Fabric application which was previously enabled.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> disableApplicationBackupAsync(String applicationId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(disableApplicationBackupWithServiceResponseAsync(applicationId), serviceCallback);
    }

    /**
     * Disables periodic backup of Service Fabric application.
     * Disables periodic backup of Service Fabric application which was previously enabled.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> disableApplicationBackupAsync(String applicationId) {
        return disableApplicationBackupWithServiceResponseAsync(applicationId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Disables periodic backup of Service Fabric application.
     * Disables periodic backup of Service Fabric application which was previously enabled.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> disableApplicationBackupWithServiceResponseAsync(String applicationId) {
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        final Long timeout = null;
        return service.disableApplicationBackup(applicationId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = disableApplicationBackupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Disables periodic backup of Service Fabric application.
     * Disables periodic backup of Service Fabric application which was previously enabled.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void disableApplicationBackup(String applicationId, Long timeout) {
        disableApplicationBackupWithServiceResponseAsync(applicationId, timeout).toBlocking().single().body();
    }

    /**
     * Disables periodic backup of Service Fabric application.
     * Disables periodic backup of Service Fabric application which was previously enabled.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> disableApplicationBackupAsync(String applicationId, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(disableApplicationBackupWithServiceResponseAsync(applicationId, timeout), serviceCallback);
    }

    /**
     * Disables periodic backup of Service Fabric application.
     * Disables periodic backup of Service Fabric application which was previously enabled.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> disableApplicationBackupAsync(String applicationId, Long timeout) {
        return disableApplicationBackupWithServiceResponseAsync(applicationId, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Disables periodic backup of Service Fabric application.
     * Disables periodic backup of Service Fabric application which was previously enabled.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> disableApplicationBackupWithServiceResponseAsync(String applicationId, Long timeout) {
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        return service.disableApplicationBackup(applicationId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = disableApplicationBackupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> disableApplicationBackupDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the Service Fabric application backup configuration information.
     * Gets the Service Fabric backup configuration information for the application and the services and partitions under this application.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedBackupConfigurationInfoListInner object if successful.
     */
    public PagedBackupConfigurationInfoListInner getApplicationBackupConfigurationInfo(String applicationId) {
        return getApplicationBackupConfigurationInfoWithServiceResponseAsync(applicationId).toBlocking().single().body();
    }

    /**
     * Gets the Service Fabric application backup configuration information.
     * Gets the Service Fabric backup configuration information for the application and the services and partitions under this application.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedBackupConfigurationInfoListInner> getApplicationBackupConfigurationInfoAsync(String applicationId, final ServiceCallback<PagedBackupConfigurationInfoListInner> serviceCallback) {
        return ServiceFuture.fromResponse(getApplicationBackupConfigurationInfoWithServiceResponseAsync(applicationId), serviceCallback);
    }

    /**
     * Gets the Service Fabric application backup configuration information.
     * Gets the Service Fabric backup configuration information for the application and the services and partitions under this application.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedBackupConfigurationInfoListInner object
     */
    public Observable<PagedBackupConfigurationInfoListInner> getApplicationBackupConfigurationInfoAsync(String applicationId) {
        return getApplicationBackupConfigurationInfoWithServiceResponseAsync(applicationId).map(new Func1<ServiceResponse<PagedBackupConfigurationInfoListInner>, PagedBackupConfigurationInfoListInner>() {
            @Override
            public PagedBackupConfigurationInfoListInner call(ServiceResponse<PagedBackupConfigurationInfoListInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the Service Fabric application backup configuration information.
     * Gets the Service Fabric backup configuration information for the application and the services and partitions under this application.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedBackupConfigurationInfoListInner object
     */
    public Observable<ServiceResponse<PagedBackupConfigurationInfoListInner>> getApplicationBackupConfigurationInfoWithServiceResponseAsync(String applicationId) {
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        final String continuationToken = null;
        final Long maxResults = null;
        final Long timeout = null;
        return service.getApplicationBackupConfigurationInfo(applicationId, apiVersion, continuationToken, maxResults, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedBackupConfigurationInfoListInner>>>() {
                @Override
                public Observable<ServiceResponse<PagedBackupConfigurationInfoListInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedBackupConfigurationInfoListInner> clientResponse = getApplicationBackupConfigurationInfoDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the Service Fabric application backup configuration information.
     * Gets the Service Fabric backup configuration information for the application and the services and partitions under this application.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedBackupConfigurationInfoListInner object if successful.
     */
    public PagedBackupConfigurationInfoListInner getApplicationBackupConfigurationInfo(String applicationId, String continuationToken, Long maxResults, Long timeout) {
        return getApplicationBackupConfigurationInfoWithServiceResponseAsync(applicationId, continuationToken, maxResults, timeout).toBlocking().single().body();
    }

    /**
     * Gets the Service Fabric application backup configuration information.
     * Gets the Service Fabric backup configuration information for the application and the services and partitions under this application.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedBackupConfigurationInfoListInner> getApplicationBackupConfigurationInfoAsync(String applicationId, String continuationToken, Long maxResults, Long timeout, final ServiceCallback<PagedBackupConfigurationInfoListInner> serviceCallback) {
        return ServiceFuture.fromResponse(getApplicationBackupConfigurationInfoWithServiceResponseAsync(applicationId, continuationToken, maxResults, timeout), serviceCallback);
    }

    /**
     * Gets the Service Fabric application backup configuration information.
     * Gets the Service Fabric backup configuration information for the application and the services and partitions under this application.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedBackupConfigurationInfoListInner object
     */
    public Observable<PagedBackupConfigurationInfoListInner> getApplicationBackupConfigurationInfoAsync(String applicationId, String continuationToken, Long maxResults, Long timeout) {
        return getApplicationBackupConfigurationInfoWithServiceResponseAsync(applicationId, continuationToken, maxResults, timeout).map(new Func1<ServiceResponse<PagedBackupConfigurationInfoListInner>, PagedBackupConfigurationInfoListInner>() {
            @Override
            public PagedBackupConfigurationInfoListInner call(ServiceResponse<PagedBackupConfigurationInfoListInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the Service Fabric application backup configuration information.
     * Gets the Service Fabric backup configuration information for the application and the services and partitions under this application.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedBackupConfigurationInfoListInner object
     */
    public Observable<ServiceResponse<PagedBackupConfigurationInfoListInner>> getApplicationBackupConfigurationInfoWithServiceResponseAsync(String applicationId, String continuationToken, Long maxResults, Long timeout) {
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        return service.getApplicationBackupConfigurationInfo(applicationId, apiVersion, continuationToken, maxResults, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedBackupConfigurationInfoListInner>>>() {
                @Override
                public Observable<ServiceResponse<PagedBackupConfigurationInfoListInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedBackupConfigurationInfoListInner> clientResponse = getApplicationBackupConfigurationInfoDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PagedBackupConfigurationInfoListInner> getApplicationBackupConfigurationInfoDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<PagedBackupConfigurationInfoListInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PagedBackupConfigurationInfoListInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the list of backups available for every partition in this application.
     * Returns a list of backups available for every partition in this Service Fabric application. The server enumerates all the backups available at the backup location configured in the backup policy. It also allows filtering of the result based on start and end datetime or just fetching the latest available backup for every partition.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedBackupInfoListInner object if successful.
     */
    public PagedBackupInfoListInner getApplicationBackupList(String applicationId) {
        return getApplicationBackupListWithServiceResponseAsync(applicationId).toBlocking().single().body();
    }

    /**
     * Gets the list of backups available for every partition in this application.
     * Returns a list of backups available for every partition in this Service Fabric application. The server enumerates all the backups available at the backup location configured in the backup policy. It also allows filtering of the result based on start and end datetime or just fetching the latest available backup for every partition.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedBackupInfoListInner> getApplicationBackupListAsync(String applicationId, final ServiceCallback<PagedBackupInfoListInner> serviceCallback) {
        return ServiceFuture.fromResponse(getApplicationBackupListWithServiceResponseAsync(applicationId), serviceCallback);
    }

    /**
     * Gets the list of backups available for every partition in this application.
     * Returns a list of backups available for every partition in this Service Fabric application. The server enumerates all the backups available at the backup location configured in the backup policy. It also allows filtering of the result based on start and end datetime or just fetching the latest available backup for every partition.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedBackupInfoListInner object
     */
    public Observable<PagedBackupInfoListInner> getApplicationBackupListAsync(String applicationId) {
        return getApplicationBackupListWithServiceResponseAsync(applicationId).map(new Func1<ServiceResponse<PagedBackupInfoListInner>, PagedBackupInfoListInner>() {
            @Override
            public PagedBackupInfoListInner call(ServiceResponse<PagedBackupInfoListInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the list of backups available for every partition in this application.
     * Returns a list of backups available for every partition in this Service Fabric application. The server enumerates all the backups available at the backup location configured in the backup policy. It also allows filtering of the result based on start and end datetime or just fetching the latest available backup for every partition.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedBackupInfoListInner object
     */
    public Observable<ServiceResponse<PagedBackupInfoListInner>> getApplicationBackupListWithServiceResponseAsync(String applicationId) {
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        final Long timeout = null;
        final Boolean latest = null;
        final DateTime startDateTimeFilter = null;
        final DateTime endDateTimeFilter = null;
        final String continuationToken = null;
        final Long maxResults = null;
        return service.getApplicationBackupList(applicationId, apiVersion, timeout, latest, startDateTimeFilter, endDateTimeFilter, continuationToken, maxResults, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedBackupInfoListInner>>>() {
                @Override
                public Observable<ServiceResponse<PagedBackupInfoListInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedBackupInfoListInner> clientResponse = getApplicationBackupListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the list of backups available for every partition in this application.
     * Returns a list of backups available for every partition in this Service Fabric application. The server enumerates all the backups available at the backup location configured in the backup policy. It also allows filtering of the result based on start and end datetime or just fetching the latest available backup for every partition.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param latest Specifies whether to get only the most recent backup available for a partition for the specified time range.
     * @param startDateTimeFilter Specify the start date time from which to enumerate backups, in datetime format. The date time must be specified in ISO8601 format. This is an optional parameter. If not specified, all backups from the beginning are enumerated.
     * @param endDateTimeFilter Specify the end date time till which to enumerate backups, in datetime format. The date time must be specified in ISO8601 format. This is an optional parameter. If not specified, enumeration is done till the most recent backup.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedBackupInfoListInner object if successful.
     */
    public PagedBackupInfoListInner getApplicationBackupList(String applicationId, Long timeout, Boolean latest, DateTime startDateTimeFilter, DateTime endDateTimeFilter, String continuationToken, Long maxResults) {
        return getApplicationBackupListWithServiceResponseAsync(applicationId, timeout, latest, startDateTimeFilter, endDateTimeFilter, continuationToken, maxResults).toBlocking().single().body();
    }

    /**
     * Gets the list of backups available for every partition in this application.
     * Returns a list of backups available for every partition in this Service Fabric application. The server enumerates all the backups available at the backup location configured in the backup policy. It also allows filtering of the result based on start and end datetime or just fetching the latest available backup for every partition.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param latest Specifies whether to get only the most recent backup available for a partition for the specified time range.
     * @param startDateTimeFilter Specify the start date time from which to enumerate backups, in datetime format. The date time must be specified in ISO8601 format. This is an optional parameter. If not specified, all backups from the beginning are enumerated.
     * @param endDateTimeFilter Specify the end date time till which to enumerate backups, in datetime format. The date time must be specified in ISO8601 format. This is an optional parameter. If not specified, enumeration is done till the most recent backup.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedBackupInfoListInner> getApplicationBackupListAsync(String applicationId, Long timeout, Boolean latest, DateTime startDateTimeFilter, DateTime endDateTimeFilter, String continuationToken, Long maxResults, final ServiceCallback<PagedBackupInfoListInner> serviceCallback) {
        return ServiceFuture.fromResponse(getApplicationBackupListWithServiceResponseAsync(applicationId, timeout, latest, startDateTimeFilter, endDateTimeFilter, continuationToken, maxResults), serviceCallback);
    }

    /**
     * Gets the list of backups available for every partition in this application.
     * Returns a list of backups available for every partition in this Service Fabric application. The server enumerates all the backups available at the backup location configured in the backup policy. It also allows filtering of the result based on start and end datetime or just fetching the latest available backup for every partition.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param latest Specifies whether to get only the most recent backup available for a partition for the specified time range.
     * @param startDateTimeFilter Specify the start date time from which to enumerate backups, in datetime format. The date time must be specified in ISO8601 format. This is an optional parameter. If not specified, all backups from the beginning are enumerated.
     * @param endDateTimeFilter Specify the end date time till which to enumerate backups, in datetime format. The date time must be specified in ISO8601 format. This is an optional parameter. If not specified, enumeration is done till the most recent backup.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedBackupInfoListInner object
     */
    public Observable<PagedBackupInfoListInner> getApplicationBackupListAsync(String applicationId, Long timeout, Boolean latest, DateTime startDateTimeFilter, DateTime endDateTimeFilter, String continuationToken, Long maxResults) {
        return getApplicationBackupListWithServiceResponseAsync(applicationId, timeout, latest, startDateTimeFilter, endDateTimeFilter, continuationToken, maxResults).map(new Func1<ServiceResponse<PagedBackupInfoListInner>, PagedBackupInfoListInner>() {
            @Override
            public PagedBackupInfoListInner call(ServiceResponse<PagedBackupInfoListInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the list of backups available for every partition in this application.
     * Returns a list of backups available for every partition in this Service Fabric application. The server enumerates all the backups available at the backup location configured in the backup policy. It also allows filtering of the result based on start and end datetime or just fetching the latest available backup for every partition.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param latest Specifies whether to get only the most recent backup available for a partition for the specified time range.
     * @param startDateTimeFilter Specify the start date time from which to enumerate backups, in datetime format. The date time must be specified in ISO8601 format. This is an optional parameter. If not specified, all backups from the beginning are enumerated.
     * @param endDateTimeFilter Specify the end date time till which to enumerate backups, in datetime format. The date time must be specified in ISO8601 format. This is an optional parameter. If not specified, enumeration is done till the most recent backup.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedBackupInfoListInner object
     */
    public Observable<ServiceResponse<PagedBackupInfoListInner>> getApplicationBackupListWithServiceResponseAsync(String applicationId, Long timeout, Boolean latest, DateTime startDateTimeFilter, DateTime endDateTimeFilter, String continuationToken, Long maxResults) {
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        return service.getApplicationBackupList(applicationId, apiVersion, timeout, latest, startDateTimeFilter, endDateTimeFilter, continuationToken, maxResults, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedBackupInfoListInner>>>() {
                @Override
                public Observable<ServiceResponse<PagedBackupInfoListInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedBackupInfoListInner> clientResponse = getApplicationBackupListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PagedBackupInfoListInner> getApplicationBackupListDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<PagedBackupInfoListInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PagedBackupInfoListInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Suspends periodic backup for the specified Service Fabric application.
     * The application which is configured to take periodic backups, is suspended for taking further backups till it is resumed again. This operation applies to the entire application's hierarchy. It means all the services and partitions under this application are now suspended for backup.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void suspendApplicationBackup(String applicationId) {
        suspendApplicationBackupWithServiceResponseAsync(applicationId).toBlocking().single().body();
    }

    /**
     * Suspends periodic backup for the specified Service Fabric application.
     * The application which is configured to take periodic backups, is suspended for taking further backups till it is resumed again. This operation applies to the entire application's hierarchy. It means all the services and partitions under this application are now suspended for backup.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> suspendApplicationBackupAsync(String applicationId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(suspendApplicationBackupWithServiceResponseAsync(applicationId), serviceCallback);
    }

    /**
     * Suspends periodic backup for the specified Service Fabric application.
     * The application which is configured to take periodic backups, is suspended for taking further backups till it is resumed again. This operation applies to the entire application's hierarchy. It means all the services and partitions under this application are now suspended for backup.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> suspendApplicationBackupAsync(String applicationId) {
        return suspendApplicationBackupWithServiceResponseAsync(applicationId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Suspends periodic backup for the specified Service Fabric application.
     * The application which is configured to take periodic backups, is suspended for taking further backups till it is resumed again. This operation applies to the entire application's hierarchy. It means all the services and partitions under this application are now suspended for backup.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> suspendApplicationBackupWithServiceResponseAsync(String applicationId) {
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        final Long timeout = null;
        return service.suspendApplicationBackup(applicationId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = suspendApplicationBackupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Suspends periodic backup for the specified Service Fabric application.
     * The application which is configured to take periodic backups, is suspended for taking further backups till it is resumed again. This operation applies to the entire application's hierarchy. It means all the services and partitions under this application are now suspended for backup.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void suspendApplicationBackup(String applicationId, Long timeout) {
        suspendApplicationBackupWithServiceResponseAsync(applicationId, timeout).toBlocking().single().body();
    }

    /**
     * Suspends periodic backup for the specified Service Fabric application.
     * The application which is configured to take periodic backups, is suspended for taking further backups till it is resumed again. This operation applies to the entire application's hierarchy. It means all the services and partitions under this application are now suspended for backup.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> suspendApplicationBackupAsync(String applicationId, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(suspendApplicationBackupWithServiceResponseAsync(applicationId, timeout), serviceCallback);
    }

    /**
     * Suspends periodic backup for the specified Service Fabric application.
     * The application which is configured to take periodic backups, is suspended for taking further backups till it is resumed again. This operation applies to the entire application's hierarchy. It means all the services and partitions under this application are now suspended for backup.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> suspendApplicationBackupAsync(String applicationId, Long timeout) {
        return suspendApplicationBackupWithServiceResponseAsync(applicationId, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Suspends periodic backup for the specified Service Fabric application.
     * The application which is configured to take periodic backups, is suspended for taking further backups till it is resumed again. This operation applies to the entire application's hierarchy. It means all the services and partitions under this application are now suspended for backup.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> suspendApplicationBackupWithServiceResponseAsync(String applicationId, Long timeout) {
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        return service.suspendApplicationBackup(applicationId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = suspendApplicationBackupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> suspendApplicationBackupDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Resumes periodic backup of a Service Fabric application which was previously suspended.
     * The previously suspended Service Fabric application resumes taking periodic backup as per the backup policy currently configured for the same.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void resumeApplicationBackup(String applicationId) {
        resumeApplicationBackupWithServiceResponseAsync(applicationId).toBlocking().single().body();
    }

    /**
     * Resumes periodic backup of a Service Fabric application which was previously suspended.
     * The previously suspended Service Fabric application resumes taking periodic backup as per the backup policy currently configured for the same.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> resumeApplicationBackupAsync(String applicationId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(resumeApplicationBackupWithServiceResponseAsync(applicationId), serviceCallback);
    }

    /**
     * Resumes periodic backup of a Service Fabric application which was previously suspended.
     * The previously suspended Service Fabric application resumes taking periodic backup as per the backup policy currently configured for the same.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> resumeApplicationBackupAsync(String applicationId) {
        return resumeApplicationBackupWithServiceResponseAsync(applicationId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Resumes periodic backup of a Service Fabric application which was previously suspended.
     * The previously suspended Service Fabric application resumes taking periodic backup as per the backup policy currently configured for the same.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> resumeApplicationBackupWithServiceResponseAsync(String applicationId) {
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        final Long timeout = null;
        return service.resumeApplicationBackup(applicationId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = resumeApplicationBackupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Resumes periodic backup of a Service Fabric application which was previously suspended.
     * The previously suspended Service Fabric application resumes taking periodic backup as per the backup policy currently configured for the same.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void resumeApplicationBackup(String applicationId, Long timeout) {
        resumeApplicationBackupWithServiceResponseAsync(applicationId, timeout).toBlocking().single().body();
    }

    /**
     * Resumes periodic backup of a Service Fabric application which was previously suspended.
     * The previously suspended Service Fabric application resumes taking periodic backup as per the backup policy currently configured for the same.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> resumeApplicationBackupAsync(String applicationId, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(resumeApplicationBackupWithServiceResponseAsync(applicationId, timeout), serviceCallback);
    }

    /**
     * Resumes periodic backup of a Service Fabric application which was previously suspended.
     * The previously suspended Service Fabric application resumes taking periodic backup as per the backup policy currently configured for the same.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> resumeApplicationBackupAsync(String applicationId, Long timeout) {
        return resumeApplicationBackupWithServiceResponseAsync(applicationId, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Resumes periodic backup of a Service Fabric application which was previously suspended.
     * The previously suspended Service Fabric application resumes taking periodic backup as per the backup policy currently configured for the same.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> resumeApplicationBackupWithServiceResponseAsync(String applicationId, Long timeout) {
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        return service.resumeApplicationBackup(applicationId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = resumeApplicationBackupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> resumeApplicationBackupDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Enables periodic backup of stateful partitions under this Service Fabric service.
     * Enables periodic backup of stateful partitions which are part of this Service Fabric service. Each partition is backed up individually as per the specified backup policy description. In case the application, which the service is part of, is already enabled for backup then this operation would override the policy being used to take the periodic backup for this service and its partitions (unless explicitly overridden at the partition level).
     Note only C# based Reliable Actor and Reliable Stateful services are currently supported for periodic backup.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param backupPolicyName Name of the backup policy to be used for enabling periodic backups.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void enableServiceBackup(String serviceId, String backupPolicyName) {
        enableServiceBackupWithServiceResponseAsync(serviceId, backupPolicyName).toBlocking().single().body();
    }

    /**
     * Enables periodic backup of stateful partitions under this Service Fabric service.
     * Enables periodic backup of stateful partitions which are part of this Service Fabric service. Each partition is backed up individually as per the specified backup policy description. In case the application, which the service is part of, is already enabled for backup then this operation would override the policy being used to take the periodic backup for this service and its partitions (unless explicitly overridden at the partition level).
     Note only C# based Reliable Actor and Reliable Stateful services are currently supported for periodic backup.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param backupPolicyName Name of the backup policy to be used for enabling periodic backups.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> enableServiceBackupAsync(String serviceId, String backupPolicyName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(enableServiceBackupWithServiceResponseAsync(serviceId, backupPolicyName), serviceCallback);
    }

    /**
     * Enables periodic backup of stateful partitions under this Service Fabric service.
     * Enables periodic backup of stateful partitions which are part of this Service Fabric service. Each partition is backed up individually as per the specified backup policy description. In case the application, which the service is part of, is already enabled for backup then this operation would override the policy being used to take the periodic backup for this service and its partitions (unless explicitly overridden at the partition level).
     Note only C# based Reliable Actor and Reliable Stateful services are currently supported for periodic backup.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param backupPolicyName Name of the backup policy to be used for enabling periodic backups.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> enableServiceBackupAsync(String serviceId, String backupPolicyName) {
        return enableServiceBackupWithServiceResponseAsync(serviceId, backupPolicyName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Enables periodic backup of stateful partitions under this Service Fabric service.
     * Enables periodic backup of stateful partitions which are part of this Service Fabric service. Each partition is backed up individually as per the specified backup policy description. In case the application, which the service is part of, is already enabled for backup then this operation would override the policy being used to take the periodic backup for this service and its partitions (unless explicitly overridden at the partition level).
     Note only C# based Reliable Actor and Reliable Stateful services are currently supported for periodic backup.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param backupPolicyName Name of the backup policy to be used for enabling periodic backups.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> enableServiceBackupWithServiceResponseAsync(String serviceId, String backupPolicyName) {
        if (serviceId == null) {
            throw new IllegalArgumentException("Parameter serviceId is required and cannot be null.");
        }
        if (backupPolicyName == null) {
            throw new IllegalArgumentException("Parameter backupPolicyName is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        final Long timeout = null;
        EnableBackupDescription enableBackupDescription = new EnableBackupDescription();
        enableBackupDescription.withBackupPolicyName(backupPolicyName);
        return service.enableServiceBackup(serviceId, apiVersion, timeout, this.acceptLanguage(), enableBackupDescription, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = enableServiceBackupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Enables periodic backup of stateful partitions under this Service Fabric service.
     * Enables periodic backup of stateful partitions which are part of this Service Fabric service. Each partition is backed up individually as per the specified backup policy description. In case the application, which the service is part of, is already enabled for backup then this operation would override the policy being used to take the periodic backup for this service and its partitions (unless explicitly overridden at the partition level).
     Note only C# based Reliable Actor and Reliable Stateful services are currently supported for periodic backup.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param backupPolicyName Name of the backup policy to be used for enabling periodic backups.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void enableServiceBackup(String serviceId, String backupPolicyName, Long timeout) {
        enableServiceBackupWithServiceResponseAsync(serviceId, backupPolicyName, timeout).toBlocking().single().body();
    }

    /**
     * Enables periodic backup of stateful partitions under this Service Fabric service.
     * Enables periodic backup of stateful partitions which are part of this Service Fabric service. Each partition is backed up individually as per the specified backup policy description. In case the application, which the service is part of, is already enabled for backup then this operation would override the policy being used to take the periodic backup for this service and its partitions (unless explicitly overridden at the partition level).
     Note only C# based Reliable Actor and Reliable Stateful services are currently supported for periodic backup.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param backupPolicyName Name of the backup policy to be used for enabling periodic backups.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> enableServiceBackupAsync(String serviceId, String backupPolicyName, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(enableServiceBackupWithServiceResponseAsync(serviceId, backupPolicyName, timeout), serviceCallback);
    }

    /**
     * Enables periodic backup of stateful partitions under this Service Fabric service.
     * Enables periodic backup of stateful partitions which are part of this Service Fabric service. Each partition is backed up individually as per the specified backup policy description. In case the application, which the service is part of, is already enabled for backup then this operation would override the policy being used to take the periodic backup for this service and its partitions (unless explicitly overridden at the partition level).
     Note only C# based Reliable Actor and Reliable Stateful services are currently supported for periodic backup.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param backupPolicyName Name of the backup policy to be used for enabling periodic backups.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> enableServiceBackupAsync(String serviceId, String backupPolicyName, Long timeout) {
        return enableServiceBackupWithServiceResponseAsync(serviceId, backupPolicyName, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Enables periodic backup of stateful partitions under this Service Fabric service.
     * Enables periodic backup of stateful partitions which are part of this Service Fabric service. Each partition is backed up individually as per the specified backup policy description. In case the application, which the service is part of, is already enabled for backup then this operation would override the policy being used to take the periodic backup for this service and its partitions (unless explicitly overridden at the partition level).
     Note only C# based Reliable Actor and Reliable Stateful services are currently supported for periodic backup.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param backupPolicyName Name of the backup policy to be used for enabling periodic backups.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> enableServiceBackupWithServiceResponseAsync(String serviceId, String backupPolicyName, Long timeout) {
        if (serviceId == null) {
            throw new IllegalArgumentException("Parameter serviceId is required and cannot be null.");
        }
        if (backupPolicyName == null) {
            throw new IllegalArgumentException("Parameter backupPolicyName is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        EnableBackupDescription enableBackupDescription = new EnableBackupDescription();
        enableBackupDescription.withBackupPolicyName(backupPolicyName);
        return service.enableServiceBackup(serviceId, apiVersion, timeout, this.acceptLanguage(), enableBackupDescription, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = enableServiceBackupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> enableServiceBackupDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Disables periodic backup of Service Fabric service which was previously enabled.
     * Disables periodic backup of Service Fabric service which was previously enabled. Backup must be explicitly enabled before it can be disabled.
     In case the backup is enabled for the Service Fabric application, which this service is part of, this service would continue to be periodically backed up as per the policy mapped at the application level.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void disableServiceBackup(String serviceId) {
        disableServiceBackupWithServiceResponseAsync(serviceId).toBlocking().single().body();
    }

    /**
     * Disables periodic backup of Service Fabric service which was previously enabled.
     * Disables periodic backup of Service Fabric service which was previously enabled. Backup must be explicitly enabled before it can be disabled.
     In case the backup is enabled for the Service Fabric application, which this service is part of, this service would continue to be periodically backed up as per the policy mapped at the application level.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> disableServiceBackupAsync(String serviceId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(disableServiceBackupWithServiceResponseAsync(serviceId), serviceCallback);
    }

    /**
     * Disables periodic backup of Service Fabric service which was previously enabled.
     * Disables periodic backup of Service Fabric service which was previously enabled. Backup must be explicitly enabled before it can be disabled.
     In case the backup is enabled for the Service Fabric application, which this service is part of, this service would continue to be periodically backed up as per the policy mapped at the application level.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> disableServiceBackupAsync(String serviceId) {
        return disableServiceBackupWithServiceResponseAsync(serviceId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Disables periodic backup of Service Fabric service which was previously enabled.
     * Disables periodic backup of Service Fabric service which was previously enabled. Backup must be explicitly enabled before it can be disabled.
     In case the backup is enabled for the Service Fabric application, which this service is part of, this service would continue to be periodically backed up as per the policy mapped at the application level.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> disableServiceBackupWithServiceResponseAsync(String serviceId) {
        if (serviceId == null) {
            throw new IllegalArgumentException("Parameter serviceId is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        final Long timeout = null;
        return service.disableServiceBackup(serviceId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = disableServiceBackupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Disables periodic backup of Service Fabric service which was previously enabled.
     * Disables periodic backup of Service Fabric service which was previously enabled. Backup must be explicitly enabled before it can be disabled.
     In case the backup is enabled for the Service Fabric application, which this service is part of, this service would continue to be periodically backed up as per the policy mapped at the application level.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void disableServiceBackup(String serviceId, Long timeout) {
        disableServiceBackupWithServiceResponseAsync(serviceId, timeout).toBlocking().single().body();
    }

    /**
     * Disables periodic backup of Service Fabric service which was previously enabled.
     * Disables periodic backup of Service Fabric service which was previously enabled. Backup must be explicitly enabled before it can be disabled.
     In case the backup is enabled for the Service Fabric application, which this service is part of, this service would continue to be periodically backed up as per the policy mapped at the application level.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> disableServiceBackupAsync(String serviceId, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(disableServiceBackupWithServiceResponseAsync(serviceId, timeout), serviceCallback);
    }

    /**
     * Disables periodic backup of Service Fabric service which was previously enabled.
     * Disables periodic backup of Service Fabric service which was previously enabled. Backup must be explicitly enabled before it can be disabled.
     In case the backup is enabled for the Service Fabric application, which this service is part of, this service would continue to be periodically backed up as per the policy mapped at the application level.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> disableServiceBackupAsync(String serviceId, Long timeout) {
        return disableServiceBackupWithServiceResponseAsync(serviceId, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Disables periodic backup of Service Fabric service which was previously enabled.
     * Disables periodic backup of Service Fabric service which was previously enabled. Backup must be explicitly enabled before it can be disabled.
     In case the backup is enabled for the Service Fabric application, which this service is part of, this service would continue to be periodically backed up as per the policy mapped at the application level.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> disableServiceBackupWithServiceResponseAsync(String serviceId, Long timeout) {
        if (serviceId == null) {
            throw new IllegalArgumentException("Parameter serviceId is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        return service.disableServiceBackup(serviceId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = disableServiceBackupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> disableServiceBackupDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the Service Fabric service backup configuration information.
     * Gets the Service Fabric backup configuration information for the service and the partitions under this service.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedBackupConfigurationInfoListInner object if successful.
     */
    public PagedBackupConfigurationInfoListInner getServiceBackupConfigurationInfo(String serviceId) {
        return getServiceBackupConfigurationInfoWithServiceResponseAsync(serviceId).toBlocking().single().body();
    }

    /**
     * Gets the Service Fabric service backup configuration information.
     * Gets the Service Fabric backup configuration information for the service and the partitions under this service.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedBackupConfigurationInfoListInner> getServiceBackupConfigurationInfoAsync(String serviceId, final ServiceCallback<PagedBackupConfigurationInfoListInner> serviceCallback) {
        return ServiceFuture.fromResponse(getServiceBackupConfigurationInfoWithServiceResponseAsync(serviceId), serviceCallback);
    }

    /**
     * Gets the Service Fabric service backup configuration information.
     * Gets the Service Fabric backup configuration information for the service and the partitions under this service.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedBackupConfigurationInfoListInner object
     */
    public Observable<PagedBackupConfigurationInfoListInner> getServiceBackupConfigurationInfoAsync(String serviceId) {
        return getServiceBackupConfigurationInfoWithServiceResponseAsync(serviceId).map(new Func1<ServiceResponse<PagedBackupConfigurationInfoListInner>, PagedBackupConfigurationInfoListInner>() {
            @Override
            public PagedBackupConfigurationInfoListInner call(ServiceResponse<PagedBackupConfigurationInfoListInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the Service Fabric service backup configuration information.
     * Gets the Service Fabric backup configuration information for the service and the partitions under this service.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedBackupConfigurationInfoListInner object
     */
    public Observable<ServiceResponse<PagedBackupConfigurationInfoListInner>> getServiceBackupConfigurationInfoWithServiceResponseAsync(String serviceId) {
        if (serviceId == null) {
            throw new IllegalArgumentException("Parameter serviceId is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        final String continuationToken = null;
        final Long maxResults = null;
        final Long timeout = null;
        return service.getServiceBackupConfigurationInfo(serviceId, apiVersion, continuationToken, maxResults, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedBackupConfigurationInfoListInner>>>() {
                @Override
                public Observable<ServiceResponse<PagedBackupConfigurationInfoListInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedBackupConfigurationInfoListInner> clientResponse = getServiceBackupConfigurationInfoDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the Service Fabric service backup configuration information.
     * Gets the Service Fabric backup configuration information for the service and the partitions under this service.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedBackupConfigurationInfoListInner object if successful.
     */
    public PagedBackupConfigurationInfoListInner getServiceBackupConfigurationInfo(String serviceId, String continuationToken, Long maxResults, Long timeout) {
        return getServiceBackupConfigurationInfoWithServiceResponseAsync(serviceId, continuationToken, maxResults, timeout).toBlocking().single().body();
    }

    /**
     * Gets the Service Fabric service backup configuration information.
     * Gets the Service Fabric backup configuration information for the service and the partitions under this service.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedBackupConfigurationInfoListInner> getServiceBackupConfigurationInfoAsync(String serviceId, String continuationToken, Long maxResults, Long timeout, final ServiceCallback<PagedBackupConfigurationInfoListInner> serviceCallback) {
        return ServiceFuture.fromResponse(getServiceBackupConfigurationInfoWithServiceResponseAsync(serviceId, continuationToken, maxResults, timeout), serviceCallback);
    }

    /**
     * Gets the Service Fabric service backup configuration information.
     * Gets the Service Fabric backup configuration information for the service and the partitions under this service.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedBackupConfigurationInfoListInner object
     */
    public Observable<PagedBackupConfigurationInfoListInner> getServiceBackupConfigurationInfoAsync(String serviceId, String continuationToken, Long maxResults, Long timeout) {
        return getServiceBackupConfigurationInfoWithServiceResponseAsync(serviceId, continuationToken, maxResults, timeout).map(new Func1<ServiceResponse<PagedBackupConfigurationInfoListInner>, PagedBackupConfigurationInfoListInner>() {
            @Override
            public PagedBackupConfigurationInfoListInner call(ServiceResponse<PagedBackupConfigurationInfoListInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the Service Fabric service backup configuration information.
     * Gets the Service Fabric backup configuration information for the service and the partitions under this service.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedBackupConfigurationInfoListInner object
     */
    public Observable<ServiceResponse<PagedBackupConfigurationInfoListInner>> getServiceBackupConfigurationInfoWithServiceResponseAsync(String serviceId, String continuationToken, Long maxResults, Long timeout) {
        if (serviceId == null) {
            throw new IllegalArgumentException("Parameter serviceId is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        return service.getServiceBackupConfigurationInfo(serviceId, apiVersion, continuationToken, maxResults, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedBackupConfigurationInfoListInner>>>() {
                @Override
                public Observable<ServiceResponse<PagedBackupConfigurationInfoListInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedBackupConfigurationInfoListInner> clientResponse = getServiceBackupConfigurationInfoDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PagedBackupConfigurationInfoListInner> getServiceBackupConfigurationInfoDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<PagedBackupConfigurationInfoListInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PagedBackupConfigurationInfoListInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the list of backups available for every partition in this service.
     * Returns a list of backups available for every partition in this Service Fabric service. The server enumerates all the backups available in the backup store configured in the backup policy. It also allows filtering of the result based on start and end datetime or just fetching the latest available backup for every partition.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedBackupInfoListInner object if successful.
     */
    public PagedBackupInfoListInner getServiceBackupList(String serviceId) {
        return getServiceBackupListWithServiceResponseAsync(serviceId).toBlocking().single().body();
    }

    /**
     * Gets the list of backups available for every partition in this service.
     * Returns a list of backups available for every partition in this Service Fabric service. The server enumerates all the backups available in the backup store configured in the backup policy. It also allows filtering of the result based on start and end datetime or just fetching the latest available backup for every partition.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedBackupInfoListInner> getServiceBackupListAsync(String serviceId, final ServiceCallback<PagedBackupInfoListInner> serviceCallback) {
        return ServiceFuture.fromResponse(getServiceBackupListWithServiceResponseAsync(serviceId), serviceCallback);
    }

    /**
     * Gets the list of backups available for every partition in this service.
     * Returns a list of backups available for every partition in this Service Fabric service. The server enumerates all the backups available in the backup store configured in the backup policy. It also allows filtering of the result based on start and end datetime or just fetching the latest available backup for every partition.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedBackupInfoListInner object
     */
    public Observable<PagedBackupInfoListInner> getServiceBackupListAsync(String serviceId) {
        return getServiceBackupListWithServiceResponseAsync(serviceId).map(new Func1<ServiceResponse<PagedBackupInfoListInner>, PagedBackupInfoListInner>() {
            @Override
            public PagedBackupInfoListInner call(ServiceResponse<PagedBackupInfoListInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the list of backups available for every partition in this service.
     * Returns a list of backups available for every partition in this Service Fabric service. The server enumerates all the backups available in the backup store configured in the backup policy. It also allows filtering of the result based on start and end datetime or just fetching the latest available backup for every partition.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedBackupInfoListInner object
     */
    public Observable<ServiceResponse<PagedBackupInfoListInner>> getServiceBackupListWithServiceResponseAsync(String serviceId) {
        if (serviceId == null) {
            throw new IllegalArgumentException("Parameter serviceId is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        final Long timeout = null;
        final Boolean latest = null;
        final DateTime startDateTimeFilter = null;
        final DateTime endDateTimeFilter = null;
        final String continuationToken = null;
        final Long maxResults = null;
        return service.getServiceBackupList(serviceId, apiVersion, timeout, latest, startDateTimeFilter, endDateTimeFilter, continuationToken, maxResults, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedBackupInfoListInner>>>() {
                @Override
                public Observable<ServiceResponse<PagedBackupInfoListInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedBackupInfoListInner> clientResponse = getServiceBackupListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the list of backups available for every partition in this service.
     * Returns a list of backups available for every partition in this Service Fabric service. The server enumerates all the backups available in the backup store configured in the backup policy. It also allows filtering of the result based on start and end datetime or just fetching the latest available backup for every partition.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param latest Specifies whether to get only the most recent backup available for a partition for the specified time range.
     * @param startDateTimeFilter Specify the start date time from which to enumerate backups, in datetime format. The date time must be specified in ISO8601 format. This is an optional parameter. If not specified, all backups from the beginning are enumerated.
     * @param endDateTimeFilter Specify the end date time till which to enumerate backups, in datetime format. The date time must be specified in ISO8601 format. This is an optional parameter. If not specified, enumeration is done till the most recent backup.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedBackupInfoListInner object if successful.
     */
    public PagedBackupInfoListInner getServiceBackupList(String serviceId, Long timeout, Boolean latest, DateTime startDateTimeFilter, DateTime endDateTimeFilter, String continuationToken, Long maxResults) {
        return getServiceBackupListWithServiceResponseAsync(serviceId, timeout, latest, startDateTimeFilter, endDateTimeFilter, continuationToken, maxResults).toBlocking().single().body();
    }

    /**
     * Gets the list of backups available for every partition in this service.
     * Returns a list of backups available for every partition in this Service Fabric service. The server enumerates all the backups available in the backup store configured in the backup policy. It also allows filtering of the result based on start and end datetime or just fetching the latest available backup for every partition.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param latest Specifies whether to get only the most recent backup available for a partition for the specified time range.
     * @param startDateTimeFilter Specify the start date time from which to enumerate backups, in datetime format. The date time must be specified in ISO8601 format. This is an optional parameter. If not specified, all backups from the beginning are enumerated.
     * @param endDateTimeFilter Specify the end date time till which to enumerate backups, in datetime format. The date time must be specified in ISO8601 format. This is an optional parameter. If not specified, enumeration is done till the most recent backup.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedBackupInfoListInner> getServiceBackupListAsync(String serviceId, Long timeout, Boolean latest, DateTime startDateTimeFilter, DateTime endDateTimeFilter, String continuationToken, Long maxResults, final ServiceCallback<PagedBackupInfoListInner> serviceCallback) {
        return ServiceFuture.fromResponse(getServiceBackupListWithServiceResponseAsync(serviceId, timeout, latest, startDateTimeFilter, endDateTimeFilter, continuationToken, maxResults), serviceCallback);
    }

    /**
     * Gets the list of backups available for every partition in this service.
     * Returns a list of backups available for every partition in this Service Fabric service. The server enumerates all the backups available in the backup store configured in the backup policy. It also allows filtering of the result based on start and end datetime or just fetching the latest available backup for every partition.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param latest Specifies whether to get only the most recent backup available for a partition for the specified time range.
     * @param startDateTimeFilter Specify the start date time from which to enumerate backups, in datetime format. The date time must be specified in ISO8601 format. This is an optional parameter. If not specified, all backups from the beginning are enumerated.
     * @param endDateTimeFilter Specify the end date time till which to enumerate backups, in datetime format. The date time must be specified in ISO8601 format. This is an optional parameter. If not specified, enumeration is done till the most recent backup.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedBackupInfoListInner object
     */
    public Observable<PagedBackupInfoListInner> getServiceBackupListAsync(String serviceId, Long timeout, Boolean latest, DateTime startDateTimeFilter, DateTime endDateTimeFilter, String continuationToken, Long maxResults) {
        return getServiceBackupListWithServiceResponseAsync(serviceId, timeout, latest, startDateTimeFilter, endDateTimeFilter, continuationToken, maxResults).map(new Func1<ServiceResponse<PagedBackupInfoListInner>, PagedBackupInfoListInner>() {
            @Override
            public PagedBackupInfoListInner call(ServiceResponse<PagedBackupInfoListInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the list of backups available for every partition in this service.
     * Returns a list of backups available for every partition in this Service Fabric service. The server enumerates all the backups available in the backup store configured in the backup policy. It also allows filtering of the result based on start and end datetime or just fetching the latest available backup for every partition.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param latest Specifies whether to get only the most recent backup available for a partition for the specified time range.
     * @param startDateTimeFilter Specify the start date time from which to enumerate backups, in datetime format. The date time must be specified in ISO8601 format. This is an optional parameter. If not specified, all backups from the beginning are enumerated.
     * @param endDateTimeFilter Specify the end date time till which to enumerate backups, in datetime format. The date time must be specified in ISO8601 format. This is an optional parameter. If not specified, enumeration is done till the most recent backup.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedBackupInfoListInner object
     */
    public Observable<ServiceResponse<PagedBackupInfoListInner>> getServiceBackupListWithServiceResponseAsync(String serviceId, Long timeout, Boolean latest, DateTime startDateTimeFilter, DateTime endDateTimeFilter, String continuationToken, Long maxResults) {
        if (serviceId == null) {
            throw new IllegalArgumentException("Parameter serviceId is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        return service.getServiceBackupList(serviceId, apiVersion, timeout, latest, startDateTimeFilter, endDateTimeFilter, continuationToken, maxResults, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedBackupInfoListInner>>>() {
                @Override
                public Observable<ServiceResponse<PagedBackupInfoListInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedBackupInfoListInner> clientResponse = getServiceBackupListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PagedBackupInfoListInner> getServiceBackupListDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<PagedBackupInfoListInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PagedBackupInfoListInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Suspends periodic backup for the specified Service Fabric service.
     * The service which is configured to take periodic backups, is suspended for taking further backups till it is resumed again. This operation applies to the entire service's hierarchy. It means all the partitions under this service are now suspended for backup.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void suspendServiceBackup(String serviceId) {
        suspendServiceBackupWithServiceResponseAsync(serviceId).toBlocking().single().body();
    }

    /**
     * Suspends periodic backup for the specified Service Fabric service.
     * The service which is configured to take periodic backups, is suspended for taking further backups till it is resumed again. This operation applies to the entire service's hierarchy. It means all the partitions under this service are now suspended for backup.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> suspendServiceBackupAsync(String serviceId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(suspendServiceBackupWithServiceResponseAsync(serviceId), serviceCallback);
    }

    /**
     * Suspends periodic backup for the specified Service Fabric service.
     * The service which is configured to take periodic backups, is suspended for taking further backups till it is resumed again. This operation applies to the entire service's hierarchy. It means all the partitions under this service are now suspended for backup.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> suspendServiceBackupAsync(String serviceId) {
        return suspendServiceBackupWithServiceResponseAsync(serviceId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Suspends periodic backup for the specified Service Fabric service.
     * The service which is configured to take periodic backups, is suspended for taking further backups till it is resumed again. This operation applies to the entire service's hierarchy. It means all the partitions under this service are now suspended for backup.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> suspendServiceBackupWithServiceResponseAsync(String serviceId) {
        if (serviceId == null) {
            throw new IllegalArgumentException("Parameter serviceId is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        final Long timeout = null;
        return service.suspendServiceBackup(serviceId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = suspendServiceBackupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Suspends periodic backup for the specified Service Fabric service.
     * The service which is configured to take periodic backups, is suspended for taking further backups till it is resumed again. This operation applies to the entire service's hierarchy. It means all the partitions under this service are now suspended for backup.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void suspendServiceBackup(String serviceId, Long timeout) {
        suspendServiceBackupWithServiceResponseAsync(serviceId, timeout).toBlocking().single().body();
    }

    /**
     * Suspends periodic backup for the specified Service Fabric service.
     * The service which is configured to take periodic backups, is suspended for taking further backups till it is resumed again. This operation applies to the entire service's hierarchy. It means all the partitions under this service are now suspended for backup.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> suspendServiceBackupAsync(String serviceId, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(suspendServiceBackupWithServiceResponseAsync(serviceId, timeout), serviceCallback);
    }

    /**
     * Suspends periodic backup for the specified Service Fabric service.
     * The service which is configured to take periodic backups, is suspended for taking further backups till it is resumed again. This operation applies to the entire service's hierarchy. It means all the partitions under this service are now suspended for backup.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> suspendServiceBackupAsync(String serviceId, Long timeout) {
        return suspendServiceBackupWithServiceResponseAsync(serviceId, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Suspends periodic backup for the specified Service Fabric service.
     * The service which is configured to take periodic backups, is suspended for taking further backups till it is resumed again. This operation applies to the entire service's hierarchy. It means all the partitions under this service are now suspended for backup.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> suspendServiceBackupWithServiceResponseAsync(String serviceId, Long timeout) {
        if (serviceId == null) {
            throw new IllegalArgumentException("Parameter serviceId is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        return service.suspendServiceBackup(serviceId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = suspendServiceBackupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> suspendServiceBackupDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Resumes periodic backup of a Service Fabric service which was previously suspended.
     * The previously suspended Service Fabric service resumes taking periodic backup as per the backup policy currently configured for the same.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void resumeServiceBackup(String serviceId) {
        resumeServiceBackupWithServiceResponseAsync(serviceId).toBlocking().single().body();
    }

    /**
     * Resumes periodic backup of a Service Fabric service which was previously suspended.
     * The previously suspended Service Fabric service resumes taking periodic backup as per the backup policy currently configured for the same.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> resumeServiceBackupAsync(String serviceId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(resumeServiceBackupWithServiceResponseAsync(serviceId), serviceCallback);
    }

    /**
     * Resumes periodic backup of a Service Fabric service which was previously suspended.
     * The previously suspended Service Fabric service resumes taking periodic backup as per the backup policy currently configured for the same.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> resumeServiceBackupAsync(String serviceId) {
        return resumeServiceBackupWithServiceResponseAsync(serviceId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Resumes periodic backup of a Service Fabric service which was previously suspended.
     * The previously suspended Service Fabric service resumes taking periodic backup as per the backup policy currently configured for the same.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> resumeServiceBackupWithServiceResponseAsync(String serviceId) {
        if (serviceId == null) {
            throw new IllegalArgumentException("Parameter serviceId is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        final Long timeout = null;
        return service.resumeServiceBackup(serviceId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = resumeServiceBackupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Resumes periodic backup of a Service Fabric service which was previously suspended.
     * The previously suspended Service Fabric service resumes taking periodic backup as per the backup policy currently configured for the same.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void resumeServiceBackup(String serviceId, Long timeout) {
        resumeServiceBackupWithServiceResponseAsync(serviceId, timeout).toBlocking().single().body();
    }

    /**
     * Resumes periodic backup of a Service Fabric service which was previously suspended.
     * The previously suspended Service Fabric service resumes taking periodic backup as per the backup policy currently configured for the same.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> resumeServiceBackupAsync(String serviceId, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(resumeServiceBackupWithServiceResponseAsync(serviceId, timeout), serviceCallback);
    }

    /**
     * Resumes periodic backup of a Service Fabric service which was previously suspended.
     * The previously suspended Service Fabric service resumes taking periodic backup as per the backup policy currently configured for the same.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> resumeServiceBackupAsync(String serviceId, Long timeout) {
        return resumeServiceBackupWithServiceResponseAsync(serviceId, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Resumes periodic backup of a Service Fabric service which was previously suspended.
     * The previously suspended Service Fabric service resumes taking periodic backup as per the backup policy currently configured for the same.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> resumeServiceBackupWithServiceResponseAsync(String serviceId, Long timeout) {
        if (serviceId == null) {
            throw new IllegalArgumentException("Parameter serviceId is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        return service.resumeServiceBackup(serviceId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = resumeServiceBackupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> resumeServiceBackupDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Enables periodic backup of the stateful persisted partition.
     * Enables periodic backup of stateful persisted partition. Each partition is backed up as per the specified backup policy description. In case the application or service, which is partition is part of, is already enabled for backup then this operation would override the policy being used to take the periodic backup of this partition.
     Note only C# based Reliable Actor and Reliable Stateful services are currently supported for periodic backup.
     *
     * @param partitionId The identity of the partition.
     * @param backupPolicyName Name of the backup policy to be used for enabling periodic backups.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void enablePartitionBackup(UUID partitionId, String backupPolicyName) {
        enablePartitionBackupWithServiceResponseAsync(partitionId, backupPolicyName).toBlocking().single().body();
    }

    /**
     * Enables periodic backup of the stateful persisted partition.
     * Enables periodic backup of stateful persisted partition. Each partition is backed up as per the specified backup policy description. In case the application or service, which is partition is part of, is already enabled for backup then this operation would override the policy being used to take the periodic backup of this partition.
     Note only C# based Reliable Actor and Reliable Stateful services are currently supported for periodic backup.
     *
     * @param partitionId The identity of the partition.
     * @param backupPolicyName Name of the backup policy to be used for enabling periodic backups.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> enablePartitionBackupAsync(UUID partitionId, String backupPolicyName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(enablePartitionBackupWithServiceResponseAsync(partitionId, backupPolicyName), serviceCallback);
    }

    /**
     * Enables periodic backup of the stateful persisted partition.
     * Enables periodic backup of stateful persisted partition. Each partition is backed up as per the specified backup policy description. In case the application or service, which is partition is part of, is already enabled for backup then this operation would override the policy being used to take the periodic backup of this partition.
     Note only C# based Reliable Actor and Reliable Stateful services are currently supported for periodic backup.
     *
     * @param partitionId The identity of the partition.
     * @param backupPolicyName Name of the backup policy to be used for enabling periodic backups.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> enablePartitionBackupAsync(UUID partitionId, String backupPolicyName) {
        return enablePartitionBackupWithServiceResponseAsync(partitionId, backupPolicyName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Enables periodic backup of the stateful persisted partition.
     * Enables periodic backup of stateful persisted partition. Each partition is backed up as per the specified backup policy description. In case the application or service, which is partition is part of, is already enabled for backup then this operation would override the policy being used to take the periodic backup of this partition.
     Note only C# based Reliable Actor and Reliable Stateful services are currently supported for periodic backup.
     *
     * @param partitionId The identity of the partition.
     * @param backupPolicyName Name of the backup policy to be used for enabling periodic backups.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> enablePartitionBackupWithServiceResponseAsync(UUID partitionId, String backupPolicyName) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        if (backupPolicyName == null) {
            throw new IllegalArgumentException("Parameter backupPolicyName is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        final Long timeout = null;
        EnableBackupDescription enableBackupDescription = new EnableBackupDescription();
        enableBackupDescription.withBackupPolicyName(backupPolicyName);
        return service.enablePartitionBackup(partitionId, apiVersion, timeout, this.acceptLanguage(), enableBackupDescription, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = enablePartitionBackupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Enables periodic backup of the stateful persisted partition.
     * Enables periodic backup of stateful persisted partition. Each partition is backed up as per the specified backup policy description. In case the application or service, which is partition is part of, is already enabled for backup then this operation would override the policy being used to take the periodic backup of this partition.
     Note only C# based Reliable Actor and Reliable Stateful services are currently supported for periodic backup.
     *
     * @param partitionId The identity of the partition.
     * @param backupPolicyName Name of the backup policy to be used for enabling periodic backups.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void enablePartitionBackup(UUID partitionId, String backupPolicyName, Long timeout) {
        enablePartitionBackupWithServiceResponseAsync(partitionId, backupPolicyName, timeout).toBlocking().single().body();
    }

    /**
     * Enables periodic backup of the stateful persisted partition.
     * Enables periodic backup of stateful persisted partition. Each partition is backed up as per the specified backup policy description. In case the application or service, which is partition is part of, is already enabled for backup then this operation would override the policy being used to take the periodic backup of this partition.
     Note only C# based Reliable Actor and Reliable Stateful services are currently supported for periodic backup.
     *
     * @param partitionId The identity of the partition.
     * @param backupPolicyName Name of the backup policy to be used for enabling periodic backups.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> enablePartitionBackupAsync(UUID partitionId, String backupPolicyName, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(enablePartitionBackupWithServiceResponseAsync(partitionId, backupPolicyName, timeout), serviceCallback);
    }

    /**
     * Enables periodic backup of the stateful persisted partition.
     * Enables periodic backup of stateful persisted partition. Each partition is backed up as per the specified backup policy description. In case the application or service, which is partition is part of, is already enabled for backup then this operation would override the policy being used to take the periodic backup of this partition.
     Note only C# based Reliable Actor and Reliable Stateful services are currently supported for periodic backup.
     *
     * @param partitionId The identity of the partition.
     * @param backupPolicyName Name of the backup policy to be used for enabling periodic backups.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> enablePartitionBackupAsync(UUID partitionId, String backupPolicyName, Long timeout) {
        return enablePartitionBackupWithServiceResponseAsync(partitionId, backupPolicyName, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Enables periodic backup of the stateful persisted partition.
     * Enables periodic backup of stateful persisted partition. Each partition is backed up as per the specified backup policy description. In case the application or service, which is partition is part of, is already enabled for backup then this operation would override the policy being used to take the periodic backup of this partition.
     Note only C# based Reliable Actor and Reliable Stateful services are currently supported for periodic backup.
     *
     * @param partitionId The identity of the partition.
     * @param backupPolicyName Name of the backup policy to be used for enabling periodic backups.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> enablePartitionBackupWithServiceResponseAsync(UUID partitionId, String backupPolicyName, Long timeout) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        if (backupPolicyName == null) {
            throw new IllegalArgumentException("Parameter backupPolicyName is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        EnableBackupDescription enableBackupDescription = new EnableBackupDescription();
        enableBackupDescription.withBackupPolicyName(backupPolicyName);
        return service.enablePartitionBackup(partitionId, apiVersion, timeout, this.acceptLanguage(), enableBackupDescription, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = enablePartitionBackupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> enablePartitionBackupDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Disables periodic backup of Service Fabric partition which was previously enabled.
     * Disables periodic backup of partition which was previously enabled. Backup must be explicitly enabled before it can be disabled.
     In case the backup is enabled for the Service Fabric application or service, which this partition is part of, this partition would continue to be periodically backed up as per the policy mapped at the higher level entity.
     *
     * @param partitionId The identity of the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void disablePartitionBackup(UUID partitionId) {
        disablePartitionBackupWithServiceResponseAsync(partitionId).toBlocking().single().body();
    }

    /**
     * Disables periodic backup of Service Fabric partition which was previously enabled.
     * Disables periodic backup of partition which was previously enabled. Backup must be explicitly enabled before it can be disabled.
     In case the backup is enabled for the Service Fabric application or service, which this partition is part of, this partition would continue to be periodically backed up as per the policy mapped at the higher level entity.
     *
     * @param partitionId The identity of the partition.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> disablePartitionBackupAsync(UUID partitionId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(disablePartitionBackupWithServiceResponseAsync(partitionId), serviceCallback);
    }

    /**
     * Disables periodic backup of Service Fabric partition which was previously enabled.
     * Disables periodic backup of partition which was previously enabled. Backup must be explicitly enabled before it can be disabled.
     In case the backup is enabled for the Service Fabric application or service, which this partition is part of, this partition would continue to be periodically backed up as per the policy mapped at the higher level entity.
     *
     * @param partitionId The identity of the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> disablePartitionBackupAsync(UUID partitionId) {
        return disablePartitionBackupWithServiceResponseAsync(partitionId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Disables periodic backup of Service Fabric partition which was previously enabled.
     * Disables periodic backup of partition which was previously enabled. Backup must be explicitly enabled before it can be disabled.
     In case the backup is enabled for the Service Fabric application or service, which this partition is part of, this partition would continue to be periodically backed up as per the policy mapped at the higher level entity.
     *
     * @param partitionId The identity of the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> disablePartitionBackupWithServiceResponseAsync(UUID partitionId) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        final Long timeout = null;
        return service.disablePartitionBackup(partitionId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = disablePartitionBackupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Disables periodic backup of Service Fabric partition which was previously enabled.
     * Disables periodic backup of partition which was previously enabled. Backup must be explicitly enabled before it can be disabled.
     In case the backup is enabled for the Service Fabric application or service, which this partition is part of, this partition would continue to be periodically backed up as per the policy mapped at the higher level entity.
     *
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void disablePartitionBackup(UUID partitionId, Long timeout) {
        disablePartitionBackupWithServiceResponseAsync(partitionId, timeout).toBlocking().single().body();
    }

    /**
     * Disables periodic backup of Service Fabric partition which was previously enabled.
     * Disables periodic backup of partition which was previously enabled. Backup must be explicitly enabled before it can be disabled.
     In case the backup is enabled for the Service Fabric application or service, which this partition is part of, this partition would continue to be periodically backed up as per the policy mapped at the higher level entity.
     *
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> disablePartitionBackupAsync(UUID partitionId, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(disablePartitionBackupWithServiceResponseAsync(partitionId, timeout), serviceCallback);
    }

    /**
     * Disables periodic backup of Service Fabric partition which was previously enabled.
     * Disables periodic backup of partition which was previously enabled. Backup must be explicitly enabled before it can be disabled.
     In case the backup is enabled for the Service Fabric application or service, which this partition is part of, this partition would continue to be periodically backed up as per the policy mapped at the higher level entity.
     *
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> disablePartitionBackupAsync(UUID partitionId, Long timeout) {
        return disablePartitionBackupWithServiceResponseAsync(partitionId, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Disables periodic backup of Service Fabric partition which was previously enabled.
     * Disables periodic backup of partition which was previously enabled. Backup must be explicitly enabled before it can be disabled.
     In case the backup is enabled for the Service Fabric application or service, which this partition is part of, this partition would continue to be periodically backed up as per the policy mapped at the higher level entity.
     *
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> disablePartitionBackupWithServiceResponseAsync(UUID partitionId, Long timeout) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        return service.disablePartitionBackup(partitionId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = disablePartitionBackupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> disablePartitionBackupDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the partition backup configuration information.
     * Gets the Service Fabric Backup configuration information for the specified partition.
     *
     * @param partitionId The identity of the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PartitionBackupConfigurationInfoInner object if successful.
     */
    public PartitionBackupConfigurationInfoInner getPartitionBackupConfigurationInfo(UUID partitionId) {
        return getPartitionBackupConfigurationInfoWithServiceResponseAsync(partitionId).toBlocking().single().body();
    }

    /**
     * Gets the partition backup configuration information.
     * Gets the Service Fabric Backup configuration information for the specified partition.
     *
     * @param partitionId The identity of the partition.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PartitionBackupConfigurationInfoInner> getPartitionBackupConfigurationInfoAsync(UUID partitionId, final ServiceCallback<PartitionBackupConfigurationInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getPartitionBackupConfigurationInfoWithServiceResponseAsync(partitionId), serviceCallback);
    }

    /**
     * Gets the partition backup configuration information.
     * Gets the Service Fabric Backup configuration information for the specified partition.
     *
     * @param partitionId The identity of the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PartitionBackupConfigurationInfoInner object
     */
    public Observable<PartitionBackupConfigurationInfoInner> getPartitionBackupConfigurationInfoAsync(UUID partitionId) {
        return getPartitionBackupConfigurationInfoWithServiceResponseAsync(partitionId).map(new Func1<ServiceResponse<PartitionBackupConfigurationInfoInner>, PartitionBackupConfigurationInfoInner>() {
            @Override
            public PartitionBackupConfigurationInfoInner call(ServiceResponse<PartitionBackupConfigurationInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the partition backup configuration information.
     * Gets the Service Fabric Backup configuration information for the specified partition.
     *
     * @param partitionId The identity of the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PartitionBackupConfigurationInfoInner object
     */
    public Observable<ServiceResponse<PartitionBackupConfigurationInfoInner>> getPartitionBackupConfigurationInfoWithServiceResponseAsync(UUID partitionId) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        final Long timeout = null;
        return service.getPartitionBackupConfigurationInfo(partitionId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PartitionBackupConfigurationInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<PartitionBackupConfigurationInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PartitionBackupConfigurationInfoInner> clientResponse = getPartitionBackupConfigurationInfoDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the partition backup configuration information.
     * Gets the Service Fabric Backup configuration information for the specified partition.
     *
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PartitionBackupConfigurationInfoInner object if successful.
     */
    public PartitionBackupConfigurationInfoInner getPartitionBackupConfigurationInfo(UUID partitionId, Long timeout) {
        return getPartitionBackupConfigurationInfoWithServiceResponseAsync(partitionId, timeout).toBlocking().single().body();
    }

    /**
     * Gets the partition backup configuration information.
     * Gets the Service Fabric Backup configuration information for the specified partition.
     *
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PartitionBackupConfigurationInfoInner> getPartitionBackupConfigurationInfoAsync(UUID partitionId, Long timeout, final ServiceCallback<PartitionBackupConfigurationInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getPartitionBackupConfigurationInfoWithServiceResponseAsync(partitionId, timeout), serviceCallback);
    }

    /**
     * Gets the partition backup configuration information.
     * Gets the Service Fabric Backup configuration information for the specified partition.
     *
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PartitionBackupConfigurationInfoInner object
     */
    public Observable<PartitionBackupConfigurationInfoInner> getPartitionBackupConfigurationInfoAsync(UUID partitionId, Long timeout) {
        return getPartitionBackupConfigurationInfoWithServiceResponseAsync(partitionId, timeout).map(new Func1<ServiceResponse<PartitionBackupConfigurationInfoInner>, PartitionBackupConfigurationInfoInner>() {
            @Override
            public PartitionBackupConfigurationInfoInner call(ServiceResponse<PartitionBackupConfigurationInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the partition backup configuration information.
     * Gets the Service Fabric Backup configuration information for the specified partition.
     *
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PartitionBackupConfigurationInfoInner object
     */
    public Observable<ServiceResponse<PartitionBackupConfigurationInfoInner>> getPartitionBackupConfigurationInfoWithServiceResponseAsync(UUID partitionId, Long timeout) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        return service.getPartitionBackupConfigurationInfo(partitionId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PartitionBackupConfigurationInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<PartitionBackupConfigurationInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PartitionBackupConfigurationInfoInner> clientResponse = getPartitionBackupConfigurationInfoDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PartitionBackupConfigurationInfoInner> getPartitionBackupConfigurationInfoDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<PartitionBackupConfigurationInfoInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PartitionBackupConfigurationInfoInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the list of backups available for the specified partition.
     * Returns a list of backups available for the specified partition. The server enumerates all the backups available in the backup store configured in the backup policy. It also allows filtering of the result based on start and end datetime or just fetching the latest available backup for the partition.
     *
     * @param partitionId The identity of the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedBackupInfoListInner object if successful.
     */
    public PagedBackupInfoListInner getPartitionBackupList(UUID partitionId) {
        return getPartitionBackupListWithServiceResponseAsync(partitionId).toBlocking().single().body();
    }

    /**
     * Gets the list of backups available for the specified partition.
     * Returns a list of backups available for the specified partition. The server enumerates all the backups available in the backup store configured in the backup policy. It also allows filtering of the result based on start and end datetime or just fetching the latest available backup for the partition.
     *
     * @param partitionId The identity of the partition.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedBackupInfoListInner> getPartitionBackupListAsync(UUID partitionId, final ServiceCallback<PagedBackupInfoListInner> serviceCallback) {
        return ServiceFuture.fromResponse(getPartitionBackupListWithServiceResponseAsync(partitionId), serviceCallback);
    }

    /**
     * Gets the list of backups available for the specified partition.
     * Returns a list of backups available for the specified partition. The server enumerates all the backups available in the backup store configured in the backup policy. It also allows filtering of the result based on start and end datetime or just fetching the latest available backup for the partition.
     *
     * @param partitionId The identity of the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedBackupInfoListInner object
     */
    public Observable<PagedBackupInfoListInner> getPartitionBackupListAsync(UUID partitionId) {
        return getPartitionBackupListWithServiceResponseAsync(partitionId).map(new Func1<ServiceResponse<PagedBackupInfoListInner>, PagedBackupInfoListInner>() {
            @Override
            public PagedBackupInfoListInner call(ServiceResponse<PagedBackupInfoListInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the list of backups available for the specified partition.
     * Returns a list of backups available for the specified partition. The server enumerates all the backups available in the backup store configured in the backup policy. It also allows filtering of the result based on start and end datetime or just fetching the latest available backup for the partition.
     *
     * @param partitionId The identity of the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedBackupInfoListInner object
     */
    public Observable<ServiceResponse<PagedBackupInfoListInner>> getPartitionBackupListWithServiceResponseAsync(UUID partitionId) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        final Long timeout = null;
        final Boolean latest = null;
        final DateTime startDateTimeFilter = null;
        final DateTime endDateTimeFilter = null;
        return service.getPartitionBackupList(partitionId, apiVersion, timeout, latest, startDateTimeFilter, endDateTimeFilter, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedBackupInfoListInner>>>() {
                @Override
                public Observable<ServiceResponse<PagedBackupInfoListInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedBackupInfoListInner> clientResponse = getPartitionBackupListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the list of backups available for the specified partition.
     * Returns a list of backups available for the specified partition. The server enumerates all the backups available in the backup store configured in the backup policy. It also allows filtering of the result based on start and end datetime or just fetching the latest available backup for the partition.
     *
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param latest Specifies whether to get only the most recent backup available for a partition for the specified time range.
     * @param startDateTimeFilter Specify the start date time from which to enumerate backups, in datetime format. The date time must be specified in ISO8601 format. This is an optional parameter. If not specified, all backups from the beginning are enumerated.
     * @param endDateTimeFilter Specify the end date time till which to enumerate backups, in datetime format. The date time must be specified in ISO8601 format. This is an optional parameter. If not specified, enumeration is done till the most recent backup.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedBackupInfoListInner object if successful.
     */
    public PagedBackupInfoListInner getPartitionBackupList(UUID partitionId, Long timeout, Boolean latest, DateTime startDateTimeFilter, DateTime endDateTimeFilter) {
        return getPartitionBackupListWithServiceResponseAsync(partitionId, timeout, latest, startDateTimeFilter, endDateTimeFilter).toBlocking().single().body();
    }

    /**
     * Gets the list of backups available for the specified partition.
     * Returns a list of backups available for the specified partition. The server enumerates all the backups available in the backup store configured in the backup policy. It also allows filtering of the result based on start and end datetime or just fetching the latest available backup for the partition.
     *
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param latest Specifies whether to get only the most recent backup available for a partition for the specified time range.
     * @param startDateTimeFilter Specify the start date time from which to enumerate backups, in datetime format. The date time must be specified in ISO8601 format. This is an optional parameter. If not specified, all backups from the beginning are enumerated.
     * @param endDateTimeFilter Specify the end date time till which to enumerate backups, in datetime format. The date time must be specified in ISO8601 format. This is an optional parameter. If not specified, enumeration is done till the most recent backup.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedBackupInfoListInner> getPartitionBackupListAsync(UUID partitionId, Long timeout, Boolean latest, DateTime startDateTimeFilter, DateTime endDateTimeFilter, final ServiceCallback<PagedBackupInfoListInner> serviceCallback) {
        return ServiceFuture.fromResponse(getPartitionBackupListWithServiceResponseAsync(partitionId, timeout, latest, startDateTimeFilter, endDateTimeFilter), serviceCallback);
    }

    /**
     * Gets the list of backups available for the specified partition.
     * Returns a list of backups available for the specified partition. The server enumerates all the backups available in the backup store configured in the backup policy. It also allows filtering of the result based on start and end datetime or just fetching the latest available backup for the partition.
     *
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param latest Specifies whether to get only the most recent backup available for a partition for the specified time range.
     * @param startDateTimeFilter Specify the start date time from which to enumerate backups, in datetime format. The date time must be specified in ISO8601 format. This is an optional parameter. If not specified, all backups from the beginning are enumerated.
     * @param endDateTimeFilter Specify the end date time till which to enumerate backups, in datetime format. The date time must be specified in ISO8601 format. This is an optional parameter. If not specified, enumeration is done till the most recent backup.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedBackupInfoListInner object
     */
    public Observable<PagedBackupInfoListInner> getPartitionBackupListAsync(UUID partitionId, Long timeout, Boolean latest, DateTime startDateTimeFilter, DateTime endDateTimeFilter) {
        return getPartitionBackupListWithServiceResponseAsync(partitionId, timeout, latest, startDateTimeFilter, endDateTimeFilter).map(new Func1<ServiceResponse<PagedBackupInfoListInner>, PagedBackupInfoListInner>() {
            @Override
            public PagedBackupInfoListInner call(ServiceResponse<PagedBackupInfoListInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the list of backups available for the specified partition.
     * Returns a list of backups available for the specified partition. The server enumerates all the backups available in the backup store configured in the backup policy. It also allows filtering of the result based on start and end datetime or just fetching the latest available backup for the partition.
     *
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param latest Specifies whether to get only the most recent backup available for a partition for the specified time range.
     * @param startDateTimeFilter Specify the start date time from which to enumerate backups, in datetime format. The date time must be specified in ISO8601 format. This is an optional parameter. If not specified, all backups from the beginning are enumerated.
     * @param endDateTimeFilter Specify the end date time till which to enumerate backups, in datetime format. The date time must be specified in ISO8601 format. This is an optional parameter. If not specified, enumeration is done till the most recent backup.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedBackupInfoListInner object
     */
    public Observable<ServiceResponse<PagedBackupInfoListInner>> getPartitionBackupListWithServiceResponseAsync(UUID partitionId, Long timeout, Boolean latest, DateTime startDateTimeFilter, DateTime endDateTimeFilter) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        return service.getPartitionBackupList(partitionId, apiVersion, timeout, latest, startDateTimeFilter, endDateTimeFilter, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedBackupInfoListInner>>>() {
                @Override
                public Observable<ServiceResponse<PagedBackupInfoListInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedBackupInfoListInner> clientResponse = getPartitionBackupListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PagedBackupInfoListInner> getPartitionBackupListDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<PagedBackupInfoListInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PagedBackupInfoListInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Suspends periodic backup for the specified partition.
     * The partition which is configured to take periodic backups, is suspended for taking further backups till it is resumed again.
     *
     * @param partitionId The identity of the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void suspendPartitionBackup(UUID partitionId) {
        suspendPartitionBackupWithServiceResponseAsync(partitionId).toBlocking().single().body();
    }

    /**
     * Suspends periodic backup for the specified partition.
     * The partition which is configured to take periodic backups, is suspended for taking further backups till it is resumed again.
     *
     * @param partitionId The identity of the partition.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> suspendPartitionBackupAsync(UUID partitionId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(suspendPartitionBackupWithServiceResponseAsync(partitionId), serviceCallback);
    }

    /**
     * Suspends periodic backup for the specified partition.
     * The partition which is configured to take periodic backups, is suspended for taking further backups till it is resumed again.
     *
     * @param partitionId The identity of the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> suspendPartitionBackupAsync(UUID partitionId) {
        return suspendPartitionBackupWithServiceResponseAsync(partitionId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Suspends periodic backup for the specified partition.
     * The partition which is configured to take periodic backups, is suspended for taking further backups till it is resumed again.
     *
     * @param partitionId The identity of the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> suspendPartitionBackupWithServiceResponseAsync(UUID partitionId) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        final Long timeout = null;
        return service.suspendPartitionBackup(partitionId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = suspendPartitionBackupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Suspends periodic backup for the specified partition.
     * The partition which is configured to take periodic backups, is suspended for taking further backups till it is resumed again.
     *
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void suspendPartitionBackup(UUID partitionId, Long timeout) {
        suspendPartitionBackupWithServiceResponseAsync(partitionId, timeout).toBlocking().single().body();
    }

    /**
     * Suspends periodic backup for the specified partition.
     * The partition which is configured to take periodic backups, is suspended for taking further backups till it is resumed again.
     *
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> suspendPartitionBackupAsync(UUID partitionId, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(suspendPartitionBackupWithServiceResponseAsync(partitionId, timeout), serviceCallback);
    }

    /**
     * Suspends periodic backup for the specified partition.
     * The partition which is configured to take periodic backups, is suspended for taking further backups till it is resumed again.
     *
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> suspendPartitionBackupAsync(UUID partitionId, Long timeout) {
        return suspendPartitionBackupWithServiceResponseAsync(partitionId, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Suspends periodic backup for the specified partition.
     * The partition which is configured to take periodic backups, is suspended for taking further backups till it is resumed again.
     *
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> suspendPartitionBackupWithServiceResponseAsync(UUID partitionId, Long timeout) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        return service.suspendPartitionBackup(partitionId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = suspendPartitionBackupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> suspendPartitionBackupDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Resumes periodic backup of partition which was previously suspended.
     * The previously suspended partition resumes taking periodic backup as per the backup policy currently configured for the same.
     *
     * @param partitionId The identity of the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void resumePartitionBackup(UUID partitionId) {
        resumePartitionBackupWithServiceResponseAsync(partitionId).toBlocking().single().body();
    }

    /**
     * Resumes periodic backup of partition which was previously suspended.
     * The previously suspended partition resumes taking periodic backup as per the backup policy currently configured for the same.
     *
     * @param partitionId The identity of the partition.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> resumePartitionBackupAsync(UUID partitionId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(resumePartitionBackupWithServiceResponseAsync(partitionId), serviceCallback);
    }

    /**
     * Resumes periodic backup of partition which was previously suspended.
     * The previously suspended partition resumes taking periodic backup as per the backup policy currently configured for the same.
     *
     * @param partitionId The identity of the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> resumePartitionBackupAsync(UUID partitionId) {
        return resumePartitionBackupWithServiceResponseAsync(partitionId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Resumes periodic backup of partition which was previously suspended.
     * The previously suspended partition resumes taking periodic backup as per the backup policy currently configured for the same.
     *
     * @param partitionId The identity of the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> resumePartitionBackupWithServiceResponseAsync(UUID partitionId) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        final Long timeout = null;
        return service.resumePartitionBackup(partitionId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = resumePartitionBackupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Resumes periodic backup of partition which was previously suspended.
     * The previously suspended partition resumes taking periodic backup as per the backup policy currently configured for the same.
     *
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void resumePartitionBackup(UUID partitionId, Long timeout) {
        resumePartitionBackupWithServiceResponseAsync(partitionId, timeout).toBlocking().single().body();
    }

    /**
     * Resumes periodic backup of partition which was previously suspended.
     * The previously suspended partition resumes taking periodic backup as per the backup policy currently configured for the same.
     *
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> resumePartitionBackupAsync(UUID partitionId, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(resumePartitionBackupWithServiceResponseAsync(partitionId, timeout), serviceCallback);
    }

    /**
     * Resumes periodic backup of partition which was previously suspended.
     * The previously suspended partition resumes taking periodic backup as per the backup policy currently configured for the same.
     *
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> resumePartitionBackupAsync(UUID partitionId, Long timeout) {
        return resumePartitionBackupWithServiceResponseAsync(partitionId, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Resumes periodic backup of partition which was previously suspended.
     * The previously suspended partition resumes taking periodic backup as per the backup policy currently configured for the same.
     *
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> resumePartitionBackupWithServiceResponseAsync(UUID partitionId, Long timeout) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        return service.resumePartitionBackup(partitionId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = resumePartitionBackupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> resumePartitionBackupDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Triggers backup of the partition's state.
     * Creates a backup of the stateful persisted partition's state. In case the partition is already being periodically backed up, then by default the new backup is created at the same backup storage. One can also override the same by specifying the backup storage details as part of the request body. Once the backup is initiated, its progress can be tracked using the GetBackupProgress operation.
     In case, the operation times out, specify a greater backup timeout value in the query parameter.
     *
     * @param partitionId The identity of the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void backupPartition(UUID partitionId) {
        backupPartitionWithServiceResponseAsync(partitionId).toBlocking().single().body();
    }

    /**
     * Triggers backup of the partition's state.
     * Creates a backup of the stateful persisted partition's state. In case the partition is already being periodically backed up, then by default the new backup is created at the same backup storage. One can also override the same by specifying the backup storage details as part of the request body. Once the backup is initiated, its progress can be tracked using the GetBackupProgress operation.
     In case, the operation times out, specify a greater backup timeout value in the query parameter.
     *
     * @param partitionId The identity of the partition.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> backupPartitionAsync(UUID partitionId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(backupPartitionWithServiceResponseAsync(partitionId), serviceCallback);
    }

    /**
     * Triggers backup of the partition's state.
     * Creates a backup of the stateful persisted partition's state. In case the partition is already being periodically backed up, then by default the new backup is created at the same backup storage. One can also override the same by specifying the backup storage details as part of the request body. Once the backup is initiated, its progress can be tracked using the GetBackupProgress operation.
     In case, the operation times out, specify a greater backup timeout value in the query parameter.
     *
     * @param partitionId The identity of the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> backupPartitionAsync(UUID partitionId) {
        return backupPartitionWithServiceResponseAsync(partitionId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Triggers backup of the partition's state.
     * Creates a backup of the stateful persisted partition's state. In case the partition is already being periodically backed up, then by default the new backup is created at the same backup storage. One can also override the same by specifying the backup storage details as part of the request body. Once the backup is initiated, its progress can be tracked using the GetBackupProgress operation.
     In case, the operation times out, specify a greater backup timeout value in the query parameter.
     *
     * @param partitionId The identity of the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> backupPartitionWithServiceResponseAsync(UUID partitionId) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        final Integer backupTimeout = null;
        final Long timeout = null;
        final BackupStorageDescription backupStorage = null;
        BackupPartitionDescription backupPartitionDescription = new BackupPartitionDescription();
        backupPartitionDescription.withBackupStorage(null);
        return service.backupPartition(partitionId, backupTimeout, apiVersion, timeout, this.acceptLanguage(), backupPartitionDescription, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = backupPartitionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Triggers backup of the partition's state.
     * Creates a backup of the stateful persisted partition's state. In case the partition is already being periodically backed up, then by default the new backup is created at the same backup storage. One can also override the same by specifying the backup storage details as part of the request body. Once the backup is initiated, its progress can be tracked using the GetBackupProgress operation.
     In case, the operation times out, specify a greater backup timeout value in the query parameter.
     *
     * @param partitionId The identity of the partition.
     * @param backupTimeout Specifies the maximum amount of time, in minutes, to wait for the backup operation to complete. Post that, the operation completes with timeout error. However, in certain corner cases it could be that though the operation returns back timeout, the backup actually goes through. In case of timeout error, its recommended to invoke this operation again with a greater timeout value. The default value for the same is 10 minutes.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param backupStorage Specifies the details of the backup storage where to save the backup.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void backupPartition(UUID partitionId, Integer backupTimeout, Long timeout, BackupStorageDescription backupStorage) {
        backupPartitionWithServiceResponseAsync(partitionId, backupTimeout, timeout, backupStorage).toBlocking().single().body();
    }

    /**
     * Triggers backup of the partition's state.
     * Creates a backup of the stateful persisted partition's state. In case the partition is already being periodically backed up, then by default the new backup is created at the same backup storage. One can also override the same by specifying the backup storage details as part of the request body. Once the backup is initiated, its progress can be tracked using the GetBackupProgress operation.
     In case, the operation times out, specify a greater backup timeout value in the query parameter.
     *
     * @param partitionId The identity of the partition.
     * @param backupTimeout Specifies the maximum amount of time, in minutes, to wait for the backup operation to complete. Post that, the operation completes with timeout error. However, in certain corner cases it could be that though the operation returns back timeout, the backup actually goes through. In case of timeout error, its recommended to invoke this operation again with a greater timeout value. The default value for the same is 10 minutes.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param backupStorage Specifies the details of the backup storage where to save the backup.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> backupPartitionAsync(UUID partitionId, Integer backupTimeout, Long timeout, BackupStorageDescription backupStorage, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(backupPartitionWithServiceResponseAsync(partitionId, backupTimeout, timeout, backupStorage), serviceCallback);
    }

    /**
     * Triggers backup of the partition's state.
     * Creates a backup of the stateful persisted partition's state. In case the partition is already being periodically backed up, then by default the new backup is created at the same backup storage. One can also override the same by specifying the backup storage details as part of the request body. Once the backup is initiated, its progress can be tracked using the GetBackupProgress operation.
     In case, the operation times out, specify a greater backup timeout value in the query parameter.
     *
     * @param partitionId The identity of the partition.
     * @param backupTimeout Specifies the maximum amount of time, in minutes, to wait for the backup operation to complete. Post that, the operation completes with timeout error. However, in certain corner cases it could be that though the operation returns back timeout, the backup actually goes through. In case of timeout error, its recommended to invoke this operation again with a greater timeout value. The default value for the same is 10 minutes.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param backupStorage Specifies the details of the backup storage where to save the backup.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> backupPartitionAsync(UUID partitionId, Integer backupTimeout, Long timeout, BackupStorageDescription backupStorage) {
        return backupPartitionWithServiceResponseAsync(partitionId, backupTimeout, timeout, backupStorage).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Triggers backup of the partition's state.
     * Creates a backup of the stateful persisted partition's state. In case the partition is already being periodically backed up, then by default the new backup is created at the same backup storage. One can also override the same by specifying the backup storage details as part of the request body. Once the backup is initiated, its progress can be tracked using the GetBackupProgress operation.
     In case, the operation times out, specify a greater backup timeout value in the query parameter.
     *
     * @param partitionId The identity of the partition.
     * @param backupTimeout Specifies the maximum amount of time, in minutes, to wait for the backup operation to complete. Post that, the operation completes with timeout error. However, in certain corner cases it could be that though the operation returns back timeout, the backup actually goes through. In case of timeout error, its recommended to invoke this operation again with a greater timeout value. The default value for the same is 10 minutes.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param backupStorage Specifies the details of the backup storage where to save the backup.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> backupPartitionWithServiceResponseAsync(UUID partitionId, Integer backupTimeout, Long timeout, BackupStorageDescription backupStorage) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        Validator.validate(backupStorage);
        final String apiVersion = "6.2-preview";
        BackupPartitionDescription backupPartitionDescription = null;
        if (backupStorage != null) {
            backupPartitionDescription = new BackupPartitionDescription();
            backupPartitionDescription.withBackupStorage(backupStorage);
        }
        return service.backupPartition(partitionId, backupTimeout, apiVersion, timeout, this.acceptLanguage(), backupPartitionDescription, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = backupPartitionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> backupPartitionDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets details for the latest backup triggered for this partition.
     * Returns information about the state of the latest backup along with details or failure reason in case of completion.
     *
     * @param partitionId The identity of the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BackupProgressInfoInner object if successful.
     */
    public BackupProgressInfoInner getPartitionBackupProgress(UUID partitionId) {
        return getPartitionBackupProgressWithServiceResponseAsync(partitionId).toBlocking().single().body();
    }

    /**
     * Gets details for the latest backup triggered for this partition.
     * Returns information about the state of the latest backup along with details or failure reason in case of completion.
     *
     * @param partitionId The identity of the partition.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BackupProgressInfoInner> getPartitionBackupProgressAsync(UUID partitionId, final ServiceCallback<BackupProgressInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getPartitionBackupProgressWithServiceResponseAsync(partitionId), serviceCallback);
    }

    /**
     * Gets details for the latest backup triggered for this partition.
     * Returns information about the state of the latest backup along with details or failure reason in case of completion.
     *
     * @param partitionId The identity of the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BackupProgressInfoInner object
     */
    public Observable<BackupProgressInfoInner> getPartitionBackupProgressAsync(UUID partitionId) {
        return getPartitionBackupProgressWithServiceResponseAsync(partitionId).map(new Func1<ServiceResponse<BackupProgressInfoInner>, BackupProgressInfoInner>() {
            @Override
            public BackupProgressInfoInner call(ServiceResponse<BackupProgressInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets details for the latest backup triggered for this partition.
     * Returns information about the state of the latest backup along with details or failure reason in case of completion.
     *
     * @param partitionId The identity of the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BackupProgressInfoInner object
     */
    public Observable<ServiceResponse<BackupProgressInfoInner>> getPartitionBackupProgressWithServiceResponseAsync(UUID partitionId) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        final Long timeout = null;
        return service.getPartitionBackupProgress(partitionId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupProgressInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupProgressInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupProgressInfoInner> clientResponse = getPartitionBackupProgressDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets details for the latest backup triggered for this partition.
     * Returns information about the state of the latest backup along with details or failure reason in case of completion.
     *
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BackupProgressInfoInner object if successful.
     */
    public BackupProgressInfoInner getPartitionBackupProgress(UUID partitionId, Long timeout) {
        return getPartitionBackupProgressWithServiceResponseAsync(partitionId, timeout).toBlocking().single().body();
    }

    /**
     * Gets details for the latest backup triggered for this partition.
     * Returns information about the state of the latest backup along with details or failure reason in case of completion.
     *
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BackupProgressInfoInner> getPartitionBackupProgressAsync(UUID partitionId, Long timeout, final ServiceCallback<BackupProgressInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getPartitionBackupProgressWithServiceResponseAsync(partitionId, timeout), serviceCallback);
    }

    /**
     * Gets details for the latest backup triggered for this partition.
     * Returns information about the state of the latest backup along with details or failure reason in case of completion.
     *
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BackupProgressInfoInner object
     */
    public Observable<BackupProgressInfoInner> getPartitionBackupProgressAsync(UUID partitionId, Long timeout) {
        return getPartitionBackupProgressWithServiceResponseAsync(partitionId, timeout).map(new Func1<ServiceResponse<BackupProgressInfoInner>, BackupProgressInfoInner>() {
            @Override
            public BackupProgressInfoInner call(ServiceResponse<BackupProgressInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets details for the latest backup triggered for this partition.
     * Returns information about the state of the latest backup along with details or failure reason in case of completion.
     *
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BackupProgressInfoInner object
     */
    public Observable<ServiceResponse<BackupProgressInfoInner>> getPartitionBackupProgressWithServiceResponseAsync(UUID partitionId, Long timeout) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        return service.getPartitionBackupProgress(partitionId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupProgressInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupProgressInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupProgressInfoInner> clientResponse = getPartitionBackupProgressDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupProgressInfoInner> getPartitionBackupProgressDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<BackupProgressInfoInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<BackupProgressInfoInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Triggers restore of the state of the partition using the specified restore partition description.
     * Restores the state of a of the stateful persisted partition using the specified backup point. In case the partition is already being periodically backed up, then by default the backup point is looked for in the storage specified in backup policy. One can also override the same by specifying the backup storage details as part of the restore partition description in body. Once the restore is initiated, its progress can be tracked using the GetRestoreProgress operation.
     In case, the operation times out, specify a greater restore timeout value in the query parameter.
     *
     * @param partitionId The identity of the partition.
     * @param restorePartitionDescription Describes the parameters to restore the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void restorePartition(UUID partitionId, RestorePartitionDescription restorePartitionDescription) {
        restorePartitionWithServiceResponseAsync(partitionId, restorePartitionDescription).toBlocking().single().body();
    }

    /**
     * Triggers restore of the state of the partition using the specified restore partition description.
     * Restores the state of a of the stateful persisted partition using the specified backup point. In case the partition is already being periodically backed up, then by default the backup point is looked for in the storage specified in backup policy. One can also override the same by specifying the backup storage details as part of the restore partition description in body. Once the restore is initiated, its progress can be tracked using the GetRestoreProgress operation.
     In case, the operation times out, specify a greater restore timeout value in the query parameter.
     *
     * @param partitionId The identity of the partition.
     * @param restorePartitionDescription Describes the parameters to restore the partition.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> restorePartitionAsync(UUID partitionId, RestorePartitionDescription restorePartitionDescription, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(restorePartitionWithServiceResponseAsync(partitionId, restorePartitionDescription), serviceCallback);
    }

    /**
     * Triggers restore of the state of the partition using the specified restore partition description.
     * Restores the state of a of the stateful persisted partition using the specified backup point. In case the partition is already being periodically backed up, then by default the backup point is looked for in the storage specified in backup policy. One can also override the same by specifying the backup storage details as part of the restore partition description in body. Once the restore is initiated, its progress can be tracked using the GetRestoreProgress operation.
     In case, the operation times out, specify a greater restore timeout value in the query parameter.
     *
     * @param partitionId The identity of the partition.
     * @param restorePartitionDescription Describes the parameters to restore the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> restorePartitionAsync(UUID partitionId, RestorePartitionDescription restorePartitionDescription) {
        return restorePartitionWithServiceResponseAsync(partitionId, restorePartitionDescription).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Triggers restore of the state of the partition using the specified restore partition description.
     * Restores the state of a of the stateful persisted partition using the specified backup point. In case the partition is already being periodically backed up, then by default the backup point is looked for in the storage specified in backup policy. One can also override the same by specifying the backup storage details as part of the restore partition description in body. Once the restore is initiated, its progress can be tracked using the GetRestoreProgress operation.
     In case, the operation times out, specify a greater restore timeout value in the query parameter.
     *
     * @param partitionId The identity of the partition.
     * @param restorePartitionDescription Describes the parameters to restore the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> restorePartitionWithServiceResponseAsync(UUID partitionId, RestorePartitionDescription restorePartitionDescription) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        if (restorePartitionDescription == null) {
            throw new IllegalArgumentException("Parameter restorePartitionDescription is required and cannot be null.");
        }
        Validator.validate(restorePartitionDescription);
        final String apiVersion = "6.2-preview";
        final Integer restoreTimeout = null;
        final Long timeout = null;
        return service.restorePartition(partitionId, restorePartitionDescription, restoreTimeout, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = restorePartitionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Triggers restore of the state of the partition using the specified restore partition description.
     * Restores the state of a of the stateful persisted partition using the specified backup point. In case the partition is already being periodically backed up, then by default the backup point is looked for in the storage specified in backup policy. One can also override the same by specifying the backup storage details as part of the restore partition description in body. Once the restore is initiated, its progress can be tracked using the GetRestoreProgress operation.
     In case, the operation times out, specify a greater restore timeout value in the query parameter.
     *
     * @param partitionId The identity of the partition.
     * @param restorePartitionDescription Describes the parameters to restore the partition.
     * @param restoreTimeout Specifies the maximum amount of time to wait, in minutes, for the restore operation to complete. Post that, the operation returns back with timeout error. However, in certain corner cases it could be that the restore operation goes through even though it completes with timeout. In case of timeout error, its recommended to invoke this operation again with a greater timeout value. the default value for the same is 10 minutes.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void restorePartition(UUID partitionId, RestorePartitionDescription restorePartitionDescription, Integer restoreTimeout, Long timeout) {
        restorePartitionWithServiceResponseAsync(partitionId, restorePartitionDescription, restoreTimeout, timeout).toBlocking().single().body();
    }

    /**
     * Triggers restore of the state of the partition using the specified restore partition description.
     * Restores the state of a of the stateful persisted partition using the specified backup point. In case the partition is already being periodically backed up, then by default the backup point is looked for in the storage specified in backup policy. One can also override the same by specifying the backup storage details as part of the restore partition description in body. Once the restore is initiated, its progress can be tracked using the GetRestoreProgress operation.
     In case, the operation times out, specify a greater restore timeout value in the query parameter.
     *
     * @param partitionId The identity of the partition.
     * @param restorePartitionDescription Describes the parameters to restore the partition.
     * @param restoreTimeout Specifies the maximum amount of time to wait, in minutes, for the restore operation to complete. Post that, the operation returns back with timeout error. However, in certain corner cases it could be that the restore operation goes through even though it completes with timeout. In case of timeout error, its recommended to invoke this operation again with a greater timeout value. the default value for the same is 10 minutes.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> restorePartitionAsync(UUID partitionId, RestorePartitionDescription restorePartitionDescription, Integer restoreTimeout, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(restorePartitionWithServiceResponseAsync(partitionId, restorePartitionDescription, restoreTimeout, timeout), serviceCallback);
    }

    /**
     * Triggers restore of the state of the partition using the specified restore partition description.
     * Restores the state of a of the stateful persisted partition using the specified backup point. In case the partition is already being periodically backed up, then by default the backup point is looked for in the storage specified in backup policy. One can also override the same by specifying the backup storage details as part of the restore partition description in body. Once the restore is initiated, its progress can be tracked using the GetRestoreProgress operation.
     In case, the operation times out, specify a greater restore timeout value in the query parameter.
     *
     * @param partitionId The identity of the partition.
     * @param restorePartitionDescription Describes the parameters to restore the partition.
     * @param restoreTimeout Specifies the maximum amount of time to wait, in minutes, for the restore operation to complete. Post that, the operation returns back with timeout error. However, in certain corner cases it could be that the restore operation goes through even though it completes with timeout. In case of timeout error, its recommended to invoke this operation again with a greater timeout value. the default value for the same is 10 minutes.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> restorePartitionAsync(UUID partitionId, RestorePartitionDescription restorePartitionDescription, Integer restoreTimeout, Long timeout) {
        return restorePartitionWithServiceResponseAsync(partitionId, restorePartitionDescription, restoreTimeout, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Triggers restore of the state of the partition using the specified restore partition description.
     * Restores the state of a of the stateful persisted partition using the specified backup point. In case the partition is already being periodically backed up, then by default the backup point is looked for in the storage specified in backup policy. One can also override the same by specifying the backup storage details as part of the restore partition description in body. Once the restore is initiated, its progress can be tracked using the GetRestoreProgress operation.
     In case, the operation times out, specify a greater restore timeout value in the query parameter.
     *
     * @param partitionId The identity of the partition.
     * @param restorePartitionDescription Describes the parameters to restore the partition.
     * @param restoreTimeout Specifies the maximum amount of time to wait, in minutes, for the restore operation to complete. Post that, the operation returns back with timeout error. However, in certain corner cases it could be that the restore operation goes through even though it completes with timeout. In case of timeout error, its recommended to invoke this operation again with a greater timeout value. the default value for the same is 10 minutes.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> restorePartitionWithServiceResponseAsync(UUID partitionId, RestorePartitionDescription restorePartitionDescription, Integer restoreTimeout, Long timeout) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        if (restorePartitionDescription == null) {
            throw new IllegalArgumentException("Parameter restorePartitionDescription is required and cannot be null.");
        }
        Validator.validate(restorePartitionDescription);
        final String apiVersion = "6.2-preview";
        return service.restorePartition(partitionId, restorePartitionDescription, restoreTimeout, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = restorePartitionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> restorePartitionDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets details for the latest restore operation triggered for this partition.
     * Returns information about the state of the latest restore operation along with details or failure reason in case of completion.
     *
     * @param partitionId The identity of the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RestoreProgressInfoInner object if successful.
     */
    public RestoreProgressInfoInner getPartitionRestoreProgress(UUID partitionId) {
        return getPartitionRestoreProgressWithServiceResponseAsync(partitionId).toBlocking().single().body();
    }

    /**
     * Gets details for the latest restore operation triggered for this partition.
     * Returns information about the state of the latest restore operation along with details or failure reason in case of completion.
     *
     * @param partitionId The identity of the partition.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RestoreProgressInfoInner> getPartitionRestoreProgressAsync(UUID partitionId, final ServiceCallback<RestoreProgressInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getPartitionRestoreProgressWithServiceResponseAsync(partitionId), serviceCallback);
    }

    /**
     * Gets details for the latest restore operation triggered for this partition.
     * Returns information about the state of the latest restore operation along with details or failure reason in case of completion.
     *
     * @param partitionId The identity of the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RestoreProgressInfoInner object
     */
    public Observable<RestoreProgressInfoInner> getPartitionRestoreProgressAsync(UUID partitionId) {
        return getPartitionRestoreProgressWithServiceResponseAsync(partitionId).map(new Func1<ServiceResponse<RestoreProgressInfoInner>, RestoreProgressInfoInner>() {
            @Override
            public RestoreProgressInfoInner call(ServiceResponse<RestoreProgressInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets details for the latest restore operation triggered for this partition.
     * Returns information about the state of the latest restore operation along with details or failure reason in case of completion.
     *
     * @param partitionId The identity of the partition.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RestoreProgressInfoInner object
     */
    public Observable<ServiceResponse<RestoreProgressInfoInner>> getPartitionRestoreProgressWithServiceResponseAsync(UUID partitionId) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        final Long timeout = null;
        return service.getPartitionRestoreProgress(partitionId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RestoreProgressInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<RestoreProgressInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RestoreProgressInfoInner> clientResponse = getPartitionRestoreProgressDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets details for the latest restore operation triggered for this partition.
     * Returns information about the state of the latest restore operation along with details or failure reason in case of completion.
     *
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RestoreProgressInfoInner object if successful.
     */
    public RestoreProgressInfoInner getPartitionRestoreProgress(UUID partitionId, Long timeout) {
        return getPartitionRestoreProgressWithServiceResponseAsync(partitionId, timeout).toBlocking().single().body();
    }

    /**
     * Gets details for the latest restore operation triggered for this partition.
     * Returns information about the state of the latest restore operation along with details or failure reason in case of completion.
     *
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RestoreProgressInfoInner> getPartitionRestoreProgressAsync(UUID partitionId, Long timeout, final ServiceCallback<RestoreProgressInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getPartitionRestoreProgressWithServiceResponseAsync(partitionId, timeout), serviceCallback);
    }

    /**
     * Gets details for the latest restore operation triggered for this partition.
     * Returns information about the state of the latest restore operation along with details or failure reason in case of completion.
     *
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RestoreProgressInfoInner object
     */
    public Observable<RestoreProgressInfoInner> getPartitionRestoreProgressAsync(UUID partitionId, Long timeout) {
        return getPartitionRestoreProgressWithServiceResponseAsync(partitionId, timeout).map(new Func1<ServiceResponse<RestoreProgressInfoInner>, RestoreProgressInfoInner>() {
            @Override
            public RestoreProgressInfoInner call(ServiceResponse<RestoreProgressInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets details for the latest restore operation triggered for this partition.
     * Returns information about the state of the latest restore operation along with details or failure reason in case of completion.
     *
     * @param partitionId The identity of the partition.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RestoreProgressInfoInner object
     */
    public Observable<ServiceResponse<RestoreProgressInfoInner>> getPartitionRestoreProgressWithServiceResponseAsync(UUID partitionId, Long timeout) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        return service.getPartitionRestoreProgress(partitionId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RestoreProgressInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<RestoreProgressInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RestoreProgressInfoInner> clientResponse = getPartitionRestoreProgressDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RestoreProgressInfoInner> getPartitionRestoreProgressDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<RestoreProgressInfoInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<RestoreProgressInfoInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the list of backups available for the specified backed up entity at the specified backup location.
     * Gets the list of backups available for the specified backed up entity (Application, Service or Partition) at the specified backup location (FileShare or Azure Blob Storage).
     *
     * @param getBackupByStorageQueryDescription Describes the filters and backup storage details to be used for enumerating backups.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedBackupInfoListInner object if successful.
     */
    public PagedBackupInfoListInner getBackupsFromBackupLocation(GetBackupByStorageQueryDescription getBackupByStorageQueryDescription) {
        return getBackupsFromBackupLocationWithServiceResponseAsync(getBackupByStorageQueryDescription).toBlocking().single().body();
    }

    /**
     * Gets the list of backups available for the specified backed up entity at the specified backup location.
     * Gets the list of backups available for the specified backed up entity (Application, Service or Partition) at the specified backup location (FileShare or Azure Blob Storage).
     *
     * @param getBackupByStorageQueryDescription Describes the filters and backup storage details to be used for enumerating backups.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedBackupInfoListInner> getBackupsFromBackupLocationAsync(GetBackupByStorageQueryDescription getBackupByStorageQueryDescription, final ServiceCallback<PagedBackupInfoListInner> serviceCallback) {
        return ServiceFuture.fromResponse(getBackupsFromBackupLocationWithServiceResponseAsync(getBackupByStorageQueryDescription), serviceCallback);
    }

    /**
     * Gets the list of backups available for the specified backed up entity at the specified backup location.
     * Gets the list of backups available for the specified backed up entity (Application, Service or Partition) at the specified backup location (FileShare or Azure Blob Storage).
     *
     * @param getBackupByStorageQueryDescription Describes the filters and backup storage details to be used for enumerating backups.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedBackupInfoListInner object
     */
    public Observable<PagedBackupInfoListInner> getBackupsFromBackupLocationAsync(GetBackupByStorageQueryDescription getBackupByStorageQueryDescription) {
        return getBackupsFromBackupLocationWithServiceResponseAsync(getBackupByStorageQueryDescription).map(new Func1<ServiceResponse<PagedBackupInfoListInner>, PagedBackupInfoListInner>() {
            @Override
            public PagedBackupInfoListInner call(ServiceResponse<PagedBackupInfoListInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the list of backups available for the specified backed up entity at the specified backup location.
     * Gets the list of backups available for the specified backed up entity (Application, Service or Partition) at the specified backup location (FileShare or Azure Blob Storage).
     *
     * @param getBackupByStorageQueryDescription Describes the filters and backup storage details to be used for enumerating backups.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedBackupInfoListInner object
     */
    public Observable<ServiceResponse<PagedBackupInfoListInner>> getBackupsFromBackupLocationWithServiceResponseAsync(GetBackupByStorageQueryDescription getBackupByStorageQueryDescription) {
        if (getBackupByStorageQueryDescription == null) {
            throw new IllegalArgumentException("Parameter getBackupByStorageQueryDescription is required and cannot be null.");
        }
        Validator.validate(getBackupByStorageQueryDescription);
        final String apiVersion = "6.2-preview";
        final Long timeout = null;
        final String continuationToken = null;
        final Long maxResults = null;
        return service.getBackupsFromBackupLocation(apiVersion, timeout, continuationToken, maxResults, getBackupByStorageQueryDescription, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedBackupInfoListInner>>>() {
                @Override
                public Observable<ServiceResponse<PagedBackupInfoListInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedBackupInfoListInner> clientResponse = getBackupsFromBackupLocationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the list of backups available for the specified backed up entity at the specified backup location.
     * Gets the list of backups available for the specified backed up entity (Application, Service or Partition) at the specified backup location (FileShare or Azure Blob Storage).
     *
     * @param getBackupByStorageQueryDescription Describes the filters and backup storage details to be used for enumerating backups.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedBackupInfoListInner object if successful.
     */
    public PagedBackupInfoListInner getBackupsFromBackupLocation(GetBackupByStorageQueryDescription getBackupByStorageQueryDescription, Long timeout, String continuationToken, Long maxResults) {
        return getBackupsFromBackupLocationWithServiceResponseAsync(getBackupByStorageQueryDescription, timeout, continuationToken, maxResults).toBlocking().single().body();
    }

    /**
     * Gets the list of backups available for the specified backed up entity at the specified backup location.
     * Gets the list of backups available for the specified backed up entity (Application, Service or Partition) at the specified backup location (FileShare or Azure Blob Storage).
     *
     * @param getBackupByStorageQueryDescription Describes the filters and backup storage details to be used for enumerating backups.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedBackupInfoListInner> getBackupsFromBackupLocationAsync(GetBackupByStorageQueryDescription getBackupByStorageQueryDescription, Long timeout, String continuationToken, Long maxResults, final ServiceCallback<PagedBackupInfoListInner> serviceCallback) {
        return ServiceFuture.fromResponse(getBackupsFromBackupLocationWithServiceResponseAsync(getBackupByStorageQueryDescription, timeout, continuationToken, maxResults), serviceCallback);
    }

    /**
     * Gets the list of backups available for the specified backed up entity at the specified backup location.
     * Gets the list of backups available for the specified backed up entity (Application, Service or Partition) at the specified backup location (FileShare or Azure Blob Storage).
     *
     * @param getBackupByStorageQueryDescription Describes the filters and backup storage details to be used for enumerating backups.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedBackupInfoListInner object
     */
    public Observable<PagedBackupInfoListInner> getBackupsFromBackupLocationAsync(GetBackupByStorageQueryDescription getBackupByStorageQueryDescription, Long timeout, String continuationToken, Long maxResults) {
        return getBackupsFromBackupLocationWithServiceResponseAsync(getBackupByStorageQueryDescription, timeout, continuationToken, maxResults).map(new Func1<ServiceResponse<PagedBackupInfoListInner>, PagedBackupInfoListInner>() {
            @Override
            public PagedBackupInfoListInner call(ServiceResponse<PagedBackupInfoListInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the list of backups available for the specified backed up entity at the specified backup location.
     * Gets the list of backups available for the specified backed up entity (Application, Service or Partition) at the specified backup location (FileShare or Azure Blob Storage).
     *
     * @param getBackupByStorageQueryDescription Describes the filters and backup storage details to be used for enumerating backups.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param maxResults The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedBackupInfoListInner object
     */
    public Observable<ServiceResponse<PagedBackupInfoListInner>> getBackupsFromBackupLocationWithServiceResponseAsync(GetBackupByStorageQueryDescription getBackupByStorageQueryDescription, Long timeout, String continuationToken, Long maxResults) {
        if (getBackupByStorageQueryDescription == null) {
            throw new IllegalArgumentException("Parameter getBackupByStorageQueryDescription is required and cannot be null.");
        }
        Validator.validate(getBackupByStorageQueryDescription);
        final String apiVersion = "6.2-preview";
        return service.getBackupsFromBackupLocation(apiVersion, timeout, continuationToken, maxResults, getBackupByStorageQueryDescription, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedBackupInfoListInner>>>() {
                @Override
                public Observable<ServiceResponse<PagedBackupInfoListInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedBackupInfoListInner> clientResponse = getBackupsFromBackupLocationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PagedBackupInfoListInner> getBackupsFromBackupLocationDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<PagedBackupInfoListInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PagedBackupInfoListInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Creates a Service Fabric name.
     * Creates the specified Service Fabric name.
     *
     * @param name The Service Fabric name, including the 'fabric:' URI scheme.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void createName(String name) {
        createNameWithServiceResponseAsync(name).toBlocking().single().body();
    }

    /**
     * Creates a Service Fabric name.
     * Creates the specified Service Fabric name.
     *
     * @param name The Service Fabric name, including the 'fabric:' URI scheme.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> createNameAsync(String name, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(createNameWithServiceResponseAsync(name), serviceCallback);
    }

    /**
     * Creates a Service Fabric name.
     * Creates the specified Service Fabric name.
     *
     * @param name The Service Fabric name, including the 'fabric:' URI scheme.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> createNameAsync(String name) {
        return createNameWithServiceResponseAsync(name).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a Service Fabric name.
     * Creates the specified Service Fabric name.
     *
     * @param name The Service Fabric name, including the 'fabric:' URI scheme.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> createNameWithServiceResponseAsync(String name) {
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        NameDescription nameDescription = new NameDescription();
        nameDescription.withName(name);
        return service.createName(apiVersion, timeout, this.acceptLanguage(), nameDescription, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = createNameDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Creates a Service Fabric name.
     * Creates the specified Service Fabric name.
     *
     * @param name The Service Fabric name, including the 'fabric:' URI scheme.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void createName(String name, Long timeout) {
        createNameWithServiceResponseAsync(name, timeout).toBlocking().single().body();
    }

    /**
     * Creates a Service Fabric name.
     * Creates the specified Service Fabric name.
     *
     * @param name The Service Fabric name, including the 'fabric:' URI scheme.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> createNameAsync(String name, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(createNameWithServiceResponseAsync(name, timeout), serviceCallback);
    }

    /**
     * Creates a Service Fabric name.
     * Creates the specified Service Fabric name.
     *
     * @param name The Service Fabric name, including the 'fabric:' URI scheme.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> createNameAsync(String name, Long timeout) {
        return createNameWithServiceResponseAsync(name, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a Service Fabric name.
     * Creates the specified Service Fabric name.
     *
     * @param name The Service Fabric name, including the 'fabric:' URI scheme.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> createNameWithServiceResponseAsync(String name, Long timeout) {
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        NameDescription nameDescription = new NameDescription();
        nameDescription.withName(name);
        return service.createName(apiVersion, timeout, this.acceptLanguage(), nameDescription, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = createNameDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> createNameDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(201, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Returns whether the Service Fabric name exists.
     * Returns whether the specified Service Fabric name exists.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void getNameExistsInfo(String nameId) {
        getNameExistsInfoWithServiceResponseAsync(nameId).toBlocking().single().body();
    }

    /**
     * Returns whether the Service Fabric name exists.
     * Returns whether the specified Service Fabric name exists.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> getNameExistsInfoAsync(String nameId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(getNameExistsInfoWithServiceResponseAsync(nameId), serviceCallback);
    }

    /**
     * Returns whether the Service Fabric name exists.
     * Returns whether the specified Service Fabric name exists.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> getNameExistsInfoAsync(String nameId) {
        return getNameExistsInfoWithServiceResponseAsync(nameId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Returns whether the Service Fabric name exists.
     * Returns whether the specified Service Fabric name exists.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> getNameExistsInfoWithServiceResponseAsync(String nameId) {
        if (nameId == null) {
            throw new IllegalArgumentException("Parameter nameId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.getNameExistsInfo(nameId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = getNameExistsInfoDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Returns whether the Service Fabric name exists.
     * Returns whether the specified Service Fabric name exists.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void getNameExistsInfo(String nameId, Long timeout) {
        getNameExistsInfoWithServiceResponseAsync(nameId, timeout).toBlocking().single().body();
    }

    /**
     * Returns whether the Service Fabric name exists.
     * Returns whether the specified Service Fabric name exists.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> getNameExistsInfoAsync(String nameId, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(getNameExistsInfoWithServiceResponseAsync(nameId, timeout), serviceCallback);
    }

    /**
     * Returns whether the Service Fabric name exists.
     * Returns whether the specified Service Fabric name exists.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> getNameExistsInfoAsync(String nameId, Long timeout) {
        return getNameExistsInfoWithServiceResponseAsync(nameId, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Returns whether the Service Fabric name exists.
     * Returns whether the specified Service Fabric name exists.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> getNameExistsInfoWithServiceResponseAsync(String nameId, Long timeout) {
        if (nameId == null) {
            throw new IllegalArgumentException("Parameter nameId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.getNameExistsInfo(nameId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = getNameExistsInfoDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> getNameExistsInfoDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Deletes a Service Fabric name.
     * Deletes the specified Service Fabric name. A name must be created before it can be deleted. Deleting a name with child properties will fail.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteName(String nameId) {
        deleteNameWithServiceResponseAsync(nameId).toBlocking().single().body();
    }

    /**
     * Deletes a Service Fabric name.
     * Deletes the specified Service Fabric name. A name must be created before it can be deleted. Deleting a name with child properties will fail.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteNameAsync(String nameId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteNameWithServiceResponseAsync(nameId), serviceCallback);
    }

    /**
     * Deletes a Service Fabric name.
     * Deletes the specified Service Fabric name. A name must be created before it can be deleted. Deleting a name with child properties will fail.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteNameAsync(String nameId) {
        return deleteNameWithServiceResponseAsync(nameId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a Service Fabric name.
     * Deletes the specified Service Fabric name. A name must be created before it can be deleted. Deleting a name with child properties will fail.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteNameWithServiceResponseAsync(String nameId) {
        if (nameId == null) {
            throw new IllegalArgumentException("Parameter nameId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.deleteName(nameId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteNameDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Deletes a Service Fabric name.
     * Deletes the specified Service Fabric name. A name must be created before it can be deleted. Deleting a name with child properties will fail.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteName(String nameId, Long timeout) {
        deleteNameWithServiceResponseAsync(nameId, timeout).toBlocking().single().body();
    }

    /**
     * Deletes a Service Fabric name.
     * Deletes the specified Service Fabric name. A name must be created before it can be deleted. Deleting a name with child properties will fail.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteNameAsync(String nameId, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteNameWithServiceResponseAsync(nameId, timeout), serviceCallback);
    }

    /**
     * Deletes a Service Fabric name.
     * Deletes the specified Service Fabric name. A name must be created before it can be deleted. Deleting a name with child properties will fail.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteNameAsync(String nameId, Long timeout) {
        return deleteNameWithServiceResponseAsync(nameId, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a Service Fabric name.
     * Deletes the specified Service Fabric name. A name must be created before it can be deleted. Deleting a name with child properties will fail.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteNameWithServiceResponseAsync(String nameId, Long timeout) {
        if (nameId == null) {
            throw new IllegalArgumentException("Parameter nameId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.deleteName(nameId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteNameDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteNameDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Enumerates all the Service Fabric names under a given name.
     * Enumerates all the Service Fabric names under a given name. If the subnames do not fit in a page, one page of results is returned as well as a continuation token, which can be used to get the next page. Querying a name that doesn't exist will fail.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedSubNameInfoListInner object if successful.
     */
    public PagedSubNameInfoListInner getSubNameInfoList(String nameId) {
        return getSubNameInfoListWithServiceResponseAsync(nameId).toBlocking().single().body();
    }

    /**
     * Enumerates all the Service Fabric names under a given name.
     * Enumerates all the Service Fabric names under a given name. If the subnames do not fit in a page, one page of results is returned as well as a continuation token, which can be used to get the next page. Querying a name that doesn't exist will fail.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedSubNameInfoListInner> getSubNameInfoListAsync(String nameId, final ServiceCallback<PagedSubNameInfoListInner> serviceCallback) {
        return ServiceFuture.fromResponse(getSubNameInfoListWithServiceResponseAsync(nameId), serviceCallback);
    }

    /**
     * Enumerates all the Service Fabric names under a given name.
     * Enumerates all the Service Fabric names under a given name. If the subnames do not fit in a page, one page of results is returned as well as a continuation token, which can be used to get the next page. Querying a name that doesn't exist will fail.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedSubNameInfoListInner object
     */
    public Observable<PagedSubNameInfoListInner> getSubNameInfoListAsync(String nameId) {
        return getSubNameInfoListWithServiceResponseAsync(nameId).map(new Func1<ServiceResponse<PagedSubNameInfoListInner>, PagedSubNameInfoListInner>() {
            @Override
            public PagedSubNameInfoListInner call(ServiceResponse<PagedSubNameInfoListInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Enumerates all the Service Fabric names under a given name.
     * Enumerates all the Service Fabric names under a given name. If the subnames do not fit in a page, one page of results is returned as well as a continuation token, which can be used to get the next page. Querying a name that doesn't exist will fail.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedSubNameInfoListInner object
     */
    public Observable<ServiceResponse<PagedSubNameInfoListInner>> getSubNameInfoListWithServiceResponseAsync(String nameId) {
        if (nameId == null) {
            throw new IllegalArgumentException("Parameter nameId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Boolean recursive = null;
        final String continuationToken = null;
        final Long timeout = null;
        return service.getSubNameInfoList(nameId, apiVersion, recursive, continuationToken, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedSubNameInfoListInner>>>() {
                @Override
                public Observable<ServiceResponse<PagedSubNameInfoListInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedSubNameInfoListInner> clientResponse = getSubNameInfoListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Enumerates all the Service Fabric names under a given name.
     * Enumerates all the Service Fabric names under a given name. If the subnames do not fit in a page, one page of results is returned as well as a continuation token, which can be used to get the next page. Querying a name that doesn't exist will fail.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @param recursive Allows specifying that the search performed should be recursive.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedSubNameInfoListInner object if successful.
     */
    public PagedSubNameInfoListInner getSubNameInfoList(String nameId, Boolean recursive, String continuationToken, Long timeout) {
        return getSubNameInfoListWithServiceResponseAsync(nameId, recursive, continuationToken, timeout).toBlocking().single().body();
    }

    /**
     * Enumerates all the Service Fabric names under a given name.
     * Enumerates all the Service Fabric names under a given name. If the subnames do not fit in a page, one page of results is returned as well as a continuation token, which can be used to get the next page. Querying a name that doesn't exist will fail.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @param recursive Allows specifying that the search performed should be recursive.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedSubNameInfoListInner> getSubNameInfoListAsync(String nameId, Boolean recursive, String continuationToken, Long timeout, final ServiceCallback<PagedSubNameInfoListInner> serviceCallback) {
        return ServiceFuture.fromResponse(getSubNameInfoListWithServiceResponseAsync(nameId, recursive, continuationToken, timeout), serviceCallback);
    }

    /**
     * Enumerates all the Service Fabric names under a given name.
     * Enumerates all the Service Fabric names under a given name. If the subnames do not fit in a page, one page of results is returned as well as a continuation token, which can be used to get the next page. Querying a name that doesn't exist will fail.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @param recursive Allows specifying that the search performed should be recursive.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedSubNameInfoListInner object
     */
    public Observable<PagedSubNameInfoListInner> getSubNameInfoListAsync(String nameId, Boolean recursive, String continuationToken, Long timeout) {
        return getSubNameInfoListWithServiceResponseAsync(nameId, recursive, continuationToken, timeout).map(new Func1<ServiceResponse<PagedSubNameInfoListInner>, PagedSubNameInfoListInner>() {
            @Override
            public PagedSubNameInfoListInner call(ServiceResponse<PagedSubNameInfoListInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Enumerates all the Service Fabric names under a given name.
     * Enumerates all the Service Fabric names under a given name. If the subnames do not fit in a page, one page of results is returned as well as a continuation token, which can be used to get the next page. Querying a name that doesn't exist will fail.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @param recursive Allows specifying that the search performed should be recursive.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedSubNameInfoListInner object
     */
    public Observable<ServiceResponse<PagedSubNameInfoListInner>> getSubNameInfoListWithServiceResponseAsync(String nameId, Boolean recursive, String continuationToken, Long timeout) {
        if (nameId == null) {
            throw new IllegalArgumentException("Parameter nameId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.getSubNameInfoList(nameId, apiVersion, recursive, continuationToken, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedSubNameInfoListInner>>>() {
                @Override
                public Observable<ServiceResponse<PagedSubNameInfoListInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedSubNameInfoListInner> clientResponse = getSubNameInfoListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PagedSubNameInfoListInner> getSubNameInfoListDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<PagedSubNameInfoListInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PagedSubNameInfoListInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets information on all Service Fabric properties under a given name.
     * A Service Fabric name can have one or more named properties that store custom information. This operation gets the information about these properties in a paged list. The information includes name, value, and metadata about each of the properties.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedPropertyInfoListInner object if successful.
     */
    public PagedPropertyInfoListInner getPropertyInfoList(String nameId) {
        return getPropertyInfoListWithServiceResponseAsync(nameId).toBlocking().single().body();
    }

    /**
     * Gets information on all Service Fabric properties under a given name.
     * A Service Fabric name can have one or more named properties that store custom information. This operation gets the information about these properties in a paged list. The information includes name, value, and metadata about each of the properties.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedPropertyInfoListInner> getPropertyInfoListAsync(String nameId, final ServiceCallback<PagedPropertyInfoListInner> serviceCallback) {
        return ServiceFuture.fromResponse(getPropertyInfoListWithServiceResponseAsync(nameId), serviceCallback);
    }

    /**
     * Gets information on all Service Fabric properties under a given name.
     * A Service Fabric name can have one or more named properties that store custom information. This operation gets the information about these properties in a paged list. The information includes name, value, and metadata about each of the properties.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedPropertyInfoListInner object
     */
    public Observable<PagedPropertyInfoListInner> getPropertyInfoListAsync(String nameId) {
        return getPropertyInfoListWithServiceResponseAsync(nameId).map(new Func1<ServiceResponse<PagedPropertyInfoListInner>, PagedPropertyInfoListInner>() {
            @Override
            public PagedPropertyInfoListInner call(ServiceResponse<PagedPropertyInfoListInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets information on all Service Fabric properties under a given name.
     * A Service Fabric name can have one or more named properties that store custom information. This operation gets the information about these properties in a paged list. The information includes name, value, and metadata about each of the properties.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedPropertyInfoListInner object
     */
    public Observable<ServiceResponse<PagedPropertyInfoListInner>> getPropertyInfoListWithServiceResponseAsync(String nameId) {
        if (nameId == null) {
            throw new IllegalArgumentException("Parameter nameId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Boolean includeValues = null;
        final String continuationToken = null;
        final Long timeout = null;
        return service.getPropertyInfoList(nameId, apiVersion, includeValues, continuationToken, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedPropertyInfoListInner>>>() {
                @Override
                public Observable<ServiceResponse<PagedPropertyInfoListInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedPropertyInfoListInner> clientResponse = getPropertyInfoListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets information on all Service Fabric properties under a given name.
     * A Service Fabric name can have one or more named properties that store custom information. This operation gets the information about these properties in a paged list. The information includes name, value, and metadata about each of the properties.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @param includeValues Allows specifying whether to include the values of the properties returned. True if values should be returned with the metadata; False to return only property metadata.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedPropertyInfoListInner object if successful.
     */
    public PagedPropertyInfoListInner getPropertyInfoList(String nameId, Boolean includeValues, String continuationToken, Long timeout) {
        return getPropertyInfoListWithServiceResponseAsync(nameId, includeValues, continuationToken, timeout).toBlocking().single().body();
    }

    /**
     * Gets information on all Service Fabric properties under a given name.
     * A Service Fabric name can have one or more named properties that store custom information. This operation gets the information about these properties in a paged list. The information includes name, value, and metadata about each of the properties.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @param includeValues Allows specifying whether to include the values of the properties returned. True if values should be returned with the metadata; False to return only property metadata.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedPropertyInfoListInner> getPropertyInfoListAsync(String nameId, Boolean includeValues, String continuationToken, Long timeout, final ServiceCallback<PagedPropertyInfoListInner> serviceCallback) {
        return ServiceFuture.fromResponse(getPropertyInfoListWithServiceResponseAsync(nameId, includeValues, continuationToken, timeout), serviceCallback);
    }

    /**
     * Gets information on all Service Fabric properties under a given name.
     * A Service Fabric name can have one or more named properties that store custom information. This operation gets the information about these properties in a paged list. The information includes name, value, and metadata about each of the properties.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @param includeValues Allows specifying whether to include the values of the properties returned. True if values should be returned with the metadata; False to return only property metadata.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedPropertyInfoListInner object
     */
    public Observable<PagedPropertyInfoListInner> getPropertyInfoListAsync(String nameId, Boolean includeValues, String continuationToken, Long timeout) {
        return getPropertyInfoListWithServiceResponseAsync(nameId, includeValues, continuationToken, timeout).map(new Func1<ServiceResponse<PagedPropertyInfoListInner>, PagedPropertyInfoListInner>() {
            @Override
            public PagedPropertyInfoListInner call(ServiceResponse<PagedPropertyInfoListInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets information on all Service Fabric properties under a given name.
     * A Service Fabric name can have one or more named properties that store custom information. This operation gets the information about these properties in a paged list. The information includes name, value, and metadata about each of the properties.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @param includeValues Allows specifying whether to include the values of the properties returned. True if values should be returned with the metadata; False to return only property metadata.
     * @param continuationToken The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedPropertyInfoListInner object
     */
    public Observable<ServiceResponse<PagedPropertyInfoListInner>> getPropertyInfoListWithServiceResponseAsync(String nameId, Boolean includeValues, String continuationToken, Long timeout) {
        if (nameId == null) {
            throw new IllegalArgumentException("Parameter nameId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.getPropertyInfoList(nameId, apiVersion, includeValues, continuationToken, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedPropertyInfoListInner>>>() {
                @Override
                public Observable<ServiceResponse<PagedPropertyInfoListInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedPropertyInfoListInner> clientResponse = getPropertyInfoListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PagedPropertyInfoListInner> getPropertyInfoListDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<PagedPropertyInfoListInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PagedPropertyInfoListInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Creates or updates a Service Fabric property.
     * Creates or updates the specified Service Fabric property under a given name.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @param propertyDescription Describes the Service Fabric property to be created.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void putProperty(String nameId, PropertyDescription propertyDescription) {
        putPropertyWithServiceResponseAsync(nameId, propertyDescription).toBlocking().single().body();
    }

    /**
     * Creates or updates a Service Fabric property.
     * Creates or updates the specified Service Fabric property under a given name.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @param propertyDescription Describes the Service Fabric property to be created.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> putPropertyAsync(String nameId, PropertyDescription propertyDescription, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(putPropertyWithServiceResponseAsync(nameId, propertyDescription), serviceCallback);
    }

    /**
     * Creates or updates a Service Fabric property.
     * Creates or updates the specified Service Fabric property under a given name.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @param propertyDescription Describes the Service Fabric property to be created.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> putPropertyAsync(String nameId, PropertyDescription propertyDescription) {
        return putPropertyWithServiceResponseAsync(nameId, propertyDescription).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates or updates a Service Fabric property.
     * Creates or updates the specified Service Fabric property under a given name.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @param propertyDescription Describes the Service Fabric property to be created.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> putPropertyWithServiceResponseAsync(String nameId, PropertyDescription propertyDescription) {
        if (nameId == null) {
            throw new IllegalArgumentException("Parameter nameId is required and cannot be null.");
        }
        if (propertyDescription == null) {
            throw new IllegalArgumentException("Parameter propertyDescription is required and cannot be null.");
        }
        Validator.validate(propertyDescription);
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.putProperty(nameId, apiVersion, propertyDescription, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = putPropertyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Creates or updates a Service Fabric property.
     * Creates or updates the specified Service Fabric property under a given name.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @param propertyDescription Describes the Service Fabric property to be created.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void putProperty(String nameId, PropertyDescription propertyDescription, Long timeout) {
        putPropertyWithServiceResponseAsync(nameId, propertyDescription, timeout).toBlocking().single().body();
    }

    /**
     * Creates or updates a Service Fabric property.
     * Creates or updates the specified Service Fabric property under a given name.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @param propertyDescription Describes the Service Fabric property to be created.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> putPropertyAsync(String nameId, PropertyDescription propertyDescription, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(putPropertyWithServiceResponseAsync(nameId, propertyDescription, timeout), serviceCallback);
    }

    /**
     * Creates or updates a Service Fabric property.
     * Creates or updates the specified Service Fabric property under a given name.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @param propertyDescription Describes the Service Fabric property to be created.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> putPropertyAsync(String nameId, PropertyDescription propertyDescription, Long timeout) {
        return putPropertyWithServiceResponseAsync(nameId, propertyDescription, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates or updates a Service Fabric property.
     * Creates or updates the specified Service Fabric property under a given name.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @param propertyDescription Describes the Service Fabric property to be created.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> putPropertyWithServiceResponseAsync(String nameId, PropertyDescription propertyDescription, Long timeout) {
        if (nameId == null) {
            throw new IllegalArgumentException("Parameter nameId is required and cannot be null.");
        }
        if (propertyDescription == null) {
            throw new IllegalArgumentException("Parameter propertyDescription is required and cannot be null.");
        }
        Validator.validate(propertyDescription);
        final String apiVersion = "6.0";
        return service.putProperty(nameId, apiVersion, propertyDescription, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = putPropertyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> putPropertyDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the specified Service Fabric property.
     * Gets the specified Service Fabric property under a given name. This will always return both value and metadata.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @param propertyName Specifies the name of the property to get.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PropertyInfoInner object if successful.
     */
    public PropertyInfoInner getPropertyInfo(String nameId, String propertyName) {
        return getPropertyInfoWithServiceResponseAsync(nameId, propertyName).toBlocking().single().body();
    }

    /**
     * Gets the specified Service Fabric property.
     * Gets the specified Service Fabric property under a given name. This will always return both value and metadata.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @param propertyName Specifies the name of the property to get.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PropertyInfoInner> getPropertyInfoAsync(String nameId, String propertyName, final ServiceCallback<PropertyInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getPropertyInfoWithServiceResponseAsync(nameId, propertyName), serviceCallback);
    }

    /**
     * Gets the specified Service Fabric property.
     * Gets the specified Service Fabric property under a given name. This will always return both value and metadata.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @param propertyName Specifies the name of the property to get.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PropertyInfoInner object
     */
    public Observable<PropertyInfoInner> getPropertyInfoAsync(String nameId, String propertyName) {
        return getPropertyInfoWithServiceResponseAsync(nameId, propertyName).map(new Func1<ServiceResponse<PropertyInfoInner>, PropertyInfoInner>() {
            @Override
            public PropertyInfoInner call(ServiceResponse<PropertyInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the specified Service Fabric property.
     * Gets the specified Service Fabric property under a given name. This will always return both value and metadata.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @param propertyName Specifies the name of the property to get.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PropertyInfoInner object
     */
    public Observable<ServiceResponse<PropertyInfoInner>> getPropertyInfoWithServiceResponseAsync(String nameId, String propertyName) {
        if (nameId == null) {
            throw new IllegalArgumentException("Parameter nameId is required and cannot be null.");
        }
        if (propertyName == null) {
            throw new IllegalArgumentException("Parameter propertyName is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.getPropertyInfo(nameId, apiVersion, propertyName, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PropertyInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<PropertyInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PropertyInfoInner> clientResponse = getPropertyInfoDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the specified Service Fabric property.
     * Gets the specified Service Fabric property under a given name. This will always return both value and metadata.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @param propertyName Specifies the name of the property to get.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PropertyInfoInner object if successful.
     */
    public PropertyInfoInner getPropertyInfo(String nameId, String propertyName, Long timeout) {
        return getPropertyInfoWithServiceResponseAsync(nameId, propertyName, timeout).toBlocking().single().body();
    }

    /**
     * Gets the specified Service Fabric property.
     * Gets the specified Service Fabric property under a given name. This will always return both value and metadata.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @param propertyName Specifies the name of the property to get.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PropertyInfoInner> getPropertyInfoAsync(String nameId, String propertyName, Long timeout, final ServiceCallback<PropertyInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getPropertyInfoWithServiceResponseAsync(nameId, propertyName, timeout), serviceCallback);
    }

    /**
     * Gets the specified Service Fabric property.
     * Gets the specified Service Fabric property under a given name. This will always return both value and metadata.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @param propertyName Specifies the name of the property to get.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PropertyInfoInner object
     */
    public Observable<PropertyInfoInner> getPropertyInfoAsync(String nameId, String propertyName, Long timeout) {
        return getPropertyInfoWithServiceResponseAsync(nameId, propertyName, timeout).map(new Func1<ServiceResponse<PropertyInfoInner>, PropertyInfoInner>() {
            @Override
            public PropertyInfoInner call(ServiceResponse<PropertyInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the specified Service Fabric property.
     * Gets the specified Service Fabric property under a given name. This will always return both value and metadata.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @param propertyName Specifies the name of the property to get.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PropertyInfoInner object
     */
    public Observable<ServiceResponse<PropertyInfoInner>> getPropertyInfoWithServiceResponseAsync(String nameId, String propertyName, Long timeout) {
        if (nameId == null) {
            throw new IllegalArgumentException("Parameter nameId is required and cannot be null.");
        }
        if (propertyName == null) {
            throw new IllegalArgumentException("Parameter propertyName is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.getPropertyInfo(nameId, apiVersion, propertyName, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PropertyInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<PropertyInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PropertyInfoInner> clientResponse = getPropertyInfoDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PropertyInfoInner> getPropertyInfoDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<PropertyInfoInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PropertyInfoInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Deletes the specified Service Fabric property.
     * Deletes the specified Service Fabric property under a given name. A property must be created before it can be deleted.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @param propertyName Specifies the name of the property to get.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteProperty(String nameId, String propertyName) {
        deletePropertyWithServiceResponseAsync(nameId, propertyName).toBlocking().single().body();
    }

    /**
     * Deletes the specified Service Fabric property.
     * Deletes the specified Service Fabric property under a given name. A property must be created before it can be deleted.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @param propertyName Specifies the name of the property to get.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deletePropertyAsync(String nameId, String propertyName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deletePropertyWithServiceResponseAsync(nameId, propertyName), serviceCallback);
    }

    /**
     * Deletes the specified Service Fabric property.
     * Deletes the specified Service Fabric property under a given name. A property must be created before it can be deleted.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @param propertyName Specifies the name of the property to get.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deletePropertyAsync(String nameId, String propertyName) {
        return deletePropertyWithServiceResponseAsync(nameId, propertyName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes the specified Service Fabric property.
     * Deletes the specified Service Fabric property under a given name. A property must be created before it can be deleted.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @param propertyName Specifies the name of the property to get.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deletePropertyWithServiceResponseAsync(String nameId, String propertyName) {
        if (nameId == null) {
            throw new IllegalArgumentException("Parameter nameId is required and cannot be null.");
        }
        if (propertyName == null) {
            throw new IllegalArgumentException("Parameter propertyName is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        return service.deleteProperty(nameId, apiVersion, propertyName, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deletePropertyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Deletes the specified Service Fabric property.
     * Deletes the specified Service Fabric property under a given name. A property must be created before it can be deleted.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @param propertyName Specifies the name of the property to get.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteProperty(String nameId, String propertyName, Long timeout) {
        deletePropertyWithServiceResponseAsync(nameId, propertyName, timeout).toBlocking().single().body();
    }

    /**
     * Deletes the specified Service Fabric property.
     * Deletes the specified Service Fabric property under a given name. A property must be created before it can be deleted.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @param propertyName Specifies the name of the property to get.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deletePropertyAsync(String nameId, String propertyName, Long timeout, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deletePropertyWithServiceResponseAsync(nameId, propertyName, timeout), serviceCallback);
    }

    /**
     * Deletes the specified Service Fabric property.
     * Deletes the specified Service Fabric property under a given name. A property must be created before it can be deleted.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @param propertyName Specifies the name of the property to get.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deletePropertyAsync(String nameId, String propertyName, Long timeout) {
        return deletePropertyWithServiceResponseAsync(nameId, propertyName, timeout).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes the specified Service Fabric property.
     * Deletes the specified Service Fabric property under a given name. A property must be created before it can be deleted.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @param propertyName Specifies the name of the property to get.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deletePropertyWithServiceResponseAsync(String nameId, String propertyName, Long timeout) {
        if (nameId == null) {
            throw new IllegalArgumentException("Parameter nameId is required and cannot be null.");
        }
        if (propertyName == null) {
            throw new IllegalArgumentException("Parameter propertyName is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        return service.deleteProperty(nameId, apiVersion, propertyName, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deletePropertyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deletePropertyDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Submits a property batch.
     * Submits a batch of property operations. Either all or none of the operations will be committed.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PropertyBatchInfo object if successful.
     */
    public PropertyBatchInfo submitPropertyBatch(String nameId) {
        return submitPropertyBatchWithServiceResponseAsync(nameId).toBlocking().single().body();
    }

    /**
     * Submits a property batch.
     * Submits a batch of property operations. Either all or none of the operations will be committed.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PropertyBatchInfo> submitPropertyBatchAsync(String nameId, final ServiceCallback<PropertyBatchInfo> serviceCallback) {
        return ServiceFuture.fromResponse(submitPropertyBatchWithServiceResponseAsync(nameId), serviceCallback);
    }

    /**
     * Submits a property batch.
     * Submits a batch of property operations. Either all or none of the operations will be committed.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PropertyBatchInfo object
     */
    public Observable<PropertyBatchInfo> submitPropertyBatchAsync(String nameId) {
        return submitPropertyBatchWithServiceResponseAsync(nameId).map(new Func1<ServiceResponse<PropertyBatchInfo>, PropertyBatchInfo>() {
            @Override
            public PropertyBatchInfo call(ServiceResponse<PropertyBatchInfo> response) {
                return response.body();
            }
        });
    }

    /**
     * Submits a property batch.
     * Submits a batch of property operations. Either all or none of the operations will be committed.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PropertyBatchInfo object
     */
    public Observable<ServiceResponse<PropertyBatchInfo>> submitPropertyBatchWithServiceResponseAsync(String nameId) {
        if (nameId == null) {
            throw new IllegalArgumentException("Parameter nameId is required and cannot be null.");
        }
        final String apiVersion = "6.0";
        final Long timeout = null;
        final List<PropertyBatchOperation> operations = null;
        PropertyBatchDescriptionList propertyBatchDescriptionList = new PropertyBatchDescriptionList();
        propertyBatchDescriptionList.withOperations(null);
        return service.submitPropertyBatch(nameId, apiVersion, timeout, this.acceptLanguage(), propertyBatchDescriptionList, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PropertyBatchInfo>>>() {
                @Override
                public Observable<ServiceResponse<PropertyBatchInfo>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PropertyBatchInfo> clientResponse = submitPropertyBatchDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Submits a property batch.
     * Submits a batch of property operations. Either all or none of the operations will be committed.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param operations A list of the property batch operations to be executed.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PropertyBatchInfo object if successful.
     */
    public PropertyBatchInfo submitPropertyBatch(String nameId, Long timeout, List<PropertyBatchOperation> operations) {
        return submitPropertyBatchWithServiceResponseAsync(nameId, timeout, operations).toBlocking().single().body();
    }

    /**
     * Submits a property batch.
     * Submits a batch of property operations. Either all or none of the operations will be committed.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param operations A list of the property batch operations to be executed.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PropertyBatchInfo> submitPropertyBatchAsync(String nameId, Long timeout, List<PropertyBatchOperation> operations, final ServiceCallback<PropertyBatchInfo> serviceCallback) {
        return ServiceFuture.fromResponse(submitPropertyBatchWithServiceResponseAsync(nameId, timeout, operations), serviceCallback);
    }

    /**
     * Submits a property batch.
     * Submits a batch of property operations. Either all or none of the operations will be committed.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param operations A list of the property batch operations to be executed.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PropertyBatchInfo object
     */
    public Observable<PropertyBatchInfo> submitPropertyBatchAsync(String nameId, Long timeout, List<PropertyBatchOperation> operations) {
        return submitPropertyBatchWithServiceResponseAsync(nameId, timeout, operations).map(new Func1<ServiceResponse<PropertyBatchInfo>, PropertyBatchInfo>() {
            @Override
            public PropertyBatchInfo call(ServiceResponse<PropertyBatchInfo> response) {
                return response.body();
            }
        });
    }

    /**
     * Submits a property batch.
     * Submits a batch of property operations. Either all or none of the operations will be committed.
     *
     * @param nameId The Service Fabric name, without the 'fabric:' URI scheme.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param operations A list of the property batch operations to be executed.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PropertyBatchInfo object
     */
    public Observable<ServiceResponse<PropertyBatchInfo>> submitPropertyBatchWithServiceResponseAsync(String nameId, Long timeout, List<PropertyBatchOperation> operations) {
        if (nameId == null) {
            throw new IllegalArgumentException("Parameter nameId is required and cannot be null.");
        }
        Validator.validate(operations);
        final String apiVersion = "6.0";
        PropertyBatchDescriptionList propertyBatchDescriptionList = new PropertyBatchDescriptionList();
        propertyBatchDescriptionList.withOperations(operations);
        return service.submitPropertyBatch(nameId, apiVersion, timeout, this.acceptLanguage(), propertyBatchDescriptionList, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PropertyBatchInfo>>>() {
                @Override
                public Observable<ServiceResponse<PropertyBatchInfo>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PropertyBatchInfo> clientResponse = submitPropertyBatchDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PropertyBatchInfo> submitPropertyBatchDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<PropertyBatchInfo, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<SuccessfulPropertyBatchInfoInner>() { }.getType())
                .register(409, new TypeToken<FailedPropertyBatchInfoInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets all Cluster-related events.
     * The response is list of ClusterEvent objects.
     *
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ClusterEventInner&gt; object if successful.
     */
    public List<ClusterEventInner> getClusterEventList(String startTimeUtc, String endTimeUtc) {
        return getClusterEventListWithServiceResponseAsync(startTimeUtc, endTimeUtc).toBlocking().single().body();
    }

    /**
     * Gets all Cluster-related events.
     * The response is list of ClusterEvent objects.
     *
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ClusterEventInner>> getClusterEventListAsync(String startTimeUtc, String endTimeUtc, final ServiceCallback<List<ClusterEventInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getClusterEventListWithServiceResponseAsync(startTimeUtc, endTimeUtc), serviceCallback);
    }

    /**
     * Gets all Cluster-related events.
     * The response is list of ClusterEvent objects.
     *
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ClusterEventInner&gt; object
     */
    public Observable<List<ClusterEventInner>> getClusterEventListAsync(String startTimeUtc, String endTimeUtc) {
        return getClusterEventListWithServiceResponseAsync(startTimeUtc, endTimeUtc).map(new Func1<ServiceResponse<List<ClusterEventInner>>, List<ClusterEventInner>>() {
            @Override
            public List<ClusterEventInner> call(ServiceResponse<List<ClusterEventInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets all Cluster-related events.
     * The response is list of ClusterEvent objects.
     *
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ClusterEventInner&gt; object
     */
    public Observable<ServiceResponse<List<ClusterEventInner>>> getClusterEventListWithServiceResponseAsync(String startTimeUtc, String endTimeUtc) {
        if (startTimeUtc == null) {
            throw new IllegalArgumentException("Parameter startTimeUtc is required and cannot be null.");
        }
        if (endTimeUtc == null) {
            throw new IllegalArgumentException("Parameter endTimeUtc is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        final Long timeout = null;
        final String eventsTypesFilter = null;
        final Boolean excludeAnalysisEvents = null;
        final Boolean skipCorrelationLookup = null;
        return service.getClusterEventList(apiVersion, timeout, startTimeUtc, endTimeUtc, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ClusterEventInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<ClusterEventInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<ClusterEventInner>> clientResponse = getClusterEventListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets all Cluster-related events.
     * The response is list of ClusterEvent objects.
     *
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param eventsTypesFilter This is a comma separated string specifying the types of FabricEvents that should only be included in the response.
     * @param excludeAnalysisEvents This param disables the retrieval of AnalysisEvents if true is passed.
     * @param skipCorrelationLookup This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ClusterEventInner&gt; object if successful.
     */
    public List<ClusterEventInner> getClusterEventList(String startTimeUtc, String endTimeUtc, Long timeout, String eventsTypesFilter, Boolean excludeAnalysisEvents, Boolean skipCorrelationLookup) {
        return getClusterEventListWithServiceResponseAsync(startTimeUtc, endTimeUtc, timeout, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup).toBlocking().single().body();
    }

    /**
     * Gets all Cluster-related events.
     * The response is list of ClusterEvent objects.
     *
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param eventsTypesFilter This is a comma separated string specifying the types of FabricEvents that should only be included in the response.
     * @param excludeAnalysisEvents This param disables the retrieval of AnalysisEvents if true is passed.
     * @param skipCorrelationLookup This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ClusterEventInner>> getClusterEventListAsync(String startTimeUtc, String endTimeUtc, Long timeout, String eventsTypesFilter, Boolean excludeAnalysisEvents, Boolean skipCorrelationLookup, final ServiceCallback<List<ClusterEventInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getClusterEventListWithServiceResponseAsync(startTimeUtc, endTimeUtc, timeout, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup), serviceCallback);
    }

    /**
     * Gets all Cluster-related events.
     * The response is list of ClusterEvent objects.
     *
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param eventsTypesFilter This is a comma separated string specifying the types of FabricEvents that should only be included in the response.
     * @param excludeAnalysisEvents This param disables the retrieval of AnalysisEvents if true is passed.
     * @param skipCorrelationLookup This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ClusterEventInner&gt; object
     */
    public Observable<List<ClusterEventInner>> getClusterEventListAsync(String startTimeUtc, String endTimeUtc, Long timeout, String eventsTypesFilter, Boolean excludeAnalysisEvents, Boolean skipCorrelationLookup) {
        return getClusterEventListWithServiceResponseAsync(startTimeUtc, endTimeUtc, timeout, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup).map(new Func1<ServiceResponse<List<ClusterEventInner>>, List<ClusterEventInner>>() {
            @Override
            public List<ClusterEventInner> call(ServiceResponse<List<ClusterEventInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets all Cluster-related events.
     * The response is list of ClusterEvent objects.
     *
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param eventsTypesFilter This is a comma separated string specifying the types of FabricEvents that should only be included in the response.
     * @param excludeAnalysisEvents This param disables the retrieval of AnalysisEvents if true is passed.
     * @param skipCorrelationLookup This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ClusterEventInner&gt; object
     */
    public Observable<ServiceResponse<List<ClusterEventInner>>> getClusterEventListWithServiceResponseAsync(String startTimeUtc, String endTimeUtc, Long timeout, String eventsTypesFilter, Boolean excludeAnalysisEvents, Boolean skipCorrelationLookup) {
        if (startTimeUtc == null) {
            throw new IllegalArgumentException("Parameter startTimeUtc is required and cannot be null.");
        }
        if (endTimeUtc == null) {
            throw new IllegalArgumentException("Parameter endTimeUtc is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        return service.getClusterEventList(apiVersion, timeout, startTimeUtc, endTimeUtc, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ClusterEventInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<ClusterEventInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<ClusterEventInner>> clientResponse = getClusterEventListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<ClusterEventInner>> getClusterEventListDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<ClusterEventInner>, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<ClusterEventInner>>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets all Containers-related events.
     * The response is list of ContainerInstanceEvent objects.
     *
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ContainerInstanceEventInner&gt; object if successful.
     */
    public List<ContainerInstanceEventInner> getContainersEventList(String startTimeUtc, String endTimeUtc) {
        return getContainersEventListWithServiceResponseAsync(startTimeUtc, endTimeUtc).toBlocking().single().body();
    }

    /**
     * Gets all Containers-related events.
     * The response is list of ContainerInstanceEvent objects.
     *
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ContainerInstanceEventInner>> getContainersEventListAsync(String startTimeUtc, String endTimeUtc, final ServiceCallback<List<ContainerInstanceEventInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getContainersEventListWithServiceResponseAsync(startTimeUtc, endTimeUtc), serviceCallback);
    }

    /**
     * Gets all Containers-related events.
     * The response is list of ContainerInstanceEvent objects.
     *
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ContainerInstanceEventInner&gt; object
     */
    public Observable<List<ContainerInstanceEventInner>> getContainersEventListAsync(String startTimeUtc, String endTimeUtc) {
        return getContainersEventListWithServiceResponseAsync(startTimeUtc, endTimeUtc).map(new Func1<ServiceResponse<List<ContainerInstanceEventInner>>, List<ContainerInstanceEventInner>>() {
            @Override
            public List<ContainerInstanceEventInner> call(ServiceResponse<List<ContainerInstanceEventInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets all Containers-related events.
     * The response is list of ContainerInstanceEvent objects.
     *
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ContainerInstanceEventInner&gt; object
     */
    public Observable<ServiceResponse<List<ContainerInstanceEventInner>>> getContainersEventListWithServiceResponseAsync(String startTimeUtc, String endTimeUtc) {
        if (startTimeUtc == null) {
            throw new IllegalArgumentException("Parameter startTimeUtc is required and cannot be null.");
        }
        if (endTimeUtc == null) {
            throw new IllegalArgumentException("Parameter endTimeUtc is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        final Long timeout = null;
        final String eventsTypesFilter = null;
        final Boolean excludeAnalysisEvents = null;
        final Boolean skipCorrelationLookup = null;
        return service.getContainersEventList(apiVersion, timeout, startTimeUtc, endTimeUtc, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ContainerInstanceEventInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<ContainerInstanceEventInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<ContainerInstanceEventInner>> clientResponse = getContainersEventListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets all Containers-related events.
     * The response is list of ContainerInstanceEvent objects.
     *
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param eventsTypesFilter This is a comma separated string specifying the types of FabricEvents that should only be included in the response.
     * @param excludeAnalysisEvents This param disables the retrieval of AnalysisEvents if true is passed.
     * @param skipCorrelationLookup This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ContainerInstanceEventInner&gt; object if successful.
     */
    public List<ContainerInstanceEventInner> getContainersEventList(String startTimeUtc, String endTimeUtc, Long timeout, String eventsTypesFilter, Boolean excludeAnalysisEvents, Boolean skipCorrelationLookup) {
        return getContainersEventListWithServiceResponseAsync(startTimeUtc, endTimeUtc, timeout, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup).toBlocking().single().body();
    }

    /**
     * Gets all Containers-related events.
     * The response is list of ContainerInstanceEvent objects.
     *
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param eventsTypesFilter This is a comma separated string specifying the types of FabricEvents that should only be included in the response.
     * @param excludeAnalysisEvents This param disables the retrieval of AnalysisEvents if true is passed.
     * @param skipCorrelationLookup This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ContainerInstanceEventInner>> getContainersEventListAsync(String startTimeUtc, String endTimeUtc, Long timeout, String eventsTypesFilter, Boolean excludeAnalysisEvents, Boolean skipCorrelationLookup, final ServiceCallback<List<ContainerInstanceEventInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getContainersEventListWithServiceResponseAsync(startTimeUtc, endTimeUtc, timeout, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup), serviceCallback);
    }

    /**
     * Gets all Containers-related events.
     * The response is list of ContainerInstanceEvent objects.
     *
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param eventsTypesFilter This is a comma separated string specifying the types of FabricEvents that should only be included in the response.
     * @param excludeAnalysisEvents This param disables the retrieval of AnalysisEvents if true is passed.
     * @param skipCorrelationLookup This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ContainerInstanceEventInner&gt; object
     */
    public Observable<List<ContainerInstanceEventInner>> getContainersEventListAsync(String startTimeUtc, String endTimeUtc, Long timeout, String eventsTypesFilter, Boolean excludeAnalysisEvents, Boolean skipCorrelationLookup) {
        return getContainersEventListWithServiceResponseAsync(startTimeUtc, endTimeUtc, timeout, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup).map(new Func1<ServiceResponse<List<ContainerInstanceEventInner>>, List<ContainerInstanceEventInner>>() {
            @Override
            public List<ContainerInstanceEventInner> call(ServiceResponse<List<ContainerInstanceEventInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets all Containers-related events.
     * The response is list of ContainerInstanceEvent objects.
     *
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param eventsTypesFilter This is a comma separated string specifying the types of FabricEvents that should only be included in the response.
     * @param excludeAnalysisEvents This param disables the retrieval of AnalysisEvents if true is passed.
     * @param skipCorrelationLookup This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ContainerInstanceEventInner&gt; object
     */
    public Observable<ServiceResponse<List<ContainerInstanceEventInner>>> getContainersEventListWithServiceResponseAsync(String startTimeUtc, String endTimeUtc, Long timeout, String eventsTypesFilter, Boolean excludeAnalysisEvents, Boolean skipCorrelationLookup) {
        if (startTimeUtc == null) {
            throw new IllegalArgumentException("Parameter startTimeUtc is required and cannot be null.");
        }
        if (endTimeUtc == null) {
            throw new IllegalArgumentException("Parameter endTimeUtc is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        return service.getContainersEventList(apiVersion, timeout, startTimeUtc, endTimeUtc, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ContainerInstanceEventInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<ContainerInstanceEventInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<ContainerInstanceEventInner>> clientResponse = getContainersEventListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<ContainerInstanceEventInner>> getContainersEventListDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<ContainerInstanceEventInner>, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<ContainerInstanceEventInner>>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets a Node-related events.
     * The response is list of NodeEvent objects.
     *
     * @param nodeName The name of the node.
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;NodeEventInner&gt; object if successful.
     */
    public List<NodeEventInner> getNodeEventList(String nodeName, String startTimeUtc, String endTimeUtc) {
        return getNodeEventListWithServiceResponseAsync(nodeName, startTimeUtc, endTimeUtc).toBlocking().single().body();
    }

    /**
     * Gets a Node-related events.
     * The response is list of NodeEvent objects.
     *
     * @param nodeName The name of the node.
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<NodeEventInner>> getNodeEventListAsync(String nodeName, String startTimeUtc, String endTimeUtc, final ServiceCallback<List<NodeEventInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getNodeEventListWithServiceResponseAsync(nodeName, startTimeUtc, endTimeUtc), serviceCallback);
    }

    /**
     * Gets a Node-related events.
     * The response is list of NodeEvent objects.
     *
     * @param nodeName The name of the node.
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;NodeEventInner&gt; object
     */
    public Observable<List<NodeEventInner>> getNodeEventListAsync(String nodeName, String startTimeUtc, String endTimeUtc) {
        return getNodeEventListWithServiceResponseAsync(nodeName, startTimeUtc, endTimeUtc).map(new Func1<ServiceResponse<List<NodeEventInner>>, List<NodeEventInner>>() {
            @Override
            public List<NodeEventInner> call(ServiceResponse<List<NodeEventInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a Node-related events.
     * The response is list of NodeEvent objects.
     *
     * @param nodeName The name of the node.
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;NodeEventInner&gt; object
     */
    public Observable<ServiceResponse<List<NodeEventInner>>> getNodeEventListWithServiceResponseAsync(String nodeName, String startTimeUtc, String endTimeUtc) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (startTimeUtc == null) {
            throw new IllegalArgumentException("Parameter startTimeUtc is required and cannot be null.");
        }
        if (endTimeUtc == null) {
            throw new IllegalArgumentException("Parameter endTimeUtc is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        final Long timeout = null;
        final String eventsTypesFilter = null;
        final Boolean excludeAnalysisEvents = null;
        final Boolean skipCorrelationLookup = null;
        return service.getNodeEventList(nodeName, apiVersion, timeout, startTimeUtc, endTimeUtc, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<NodeEventInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<NodeEventInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<NodeEventInner>> clientResponse = getNodeEventListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets a Node-related events.
     * The response is list of NodeEvent objects.
     *
     * @param nodeName The name of the node.
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param eventsTypesFilter This is a comma separated string specifying the types of FabricEvents that should only be included in the response.
     * @param excludeAnalysisEvents This param disables the retrieval of AnalysisEvents if true is passed.
     * @param skipCorrelationLookup This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;NodeEventInner&gt; object if successful.
     */
    public List<NodeEventInner> getNodeEventList(String nodeName, String startTimeUtc, String endTimeUtc, Long timeout, String eventsTypesFilter, Boolean excludeAnalysisEvents, Boolean skipCorrelationLookup) {
        return getNodeEventListWithServiceResponseAsync(nodeName, startTimeUtc, endTimeUtc, timeout, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup).toBlocking().single().body();
    }

    /**
     * Gets a Node-related events.
     * The response is list of NodeEvent objects.
     *
     * @param nodeName The name of the node.
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param eventsTypesFilter This is a comma separated string specifying the types of FabricEvents that should only be included in the response.
     * @param excludeAnalysisEvents This param disables the retrieval of AnalysisEvents if true is passed.
     * @param skipCorrelationLookup This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<NodeEventInner>> getNodeEventListAsync(String nodeName, String startTimeUtc, String endTimeUtc, Long timeout, String eventsTypesFilter, Boolean excludeAnalysisEvents, Boolean skipCorrelationLookup, final ServiceCallback<List<NodeEventInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getNodeEventListWithServiceResponseAsync(nodeName, startTimeUtc, endTimeUtc, timeout, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup), serviceCallback);
    }

    /**
     * Gets a Node-related events.
     * The response is list of NodeEvent objects.
     *
     * @param nodeName The name of the node.
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param eventsTypesFilter This is a comma separated string specifying the types of FabricEvents that should only be included in the response.
     * @param excludeAnalysisEvents This param disables the retrieval of AnalysisEvents if true is passed.
     * @param skipCorrelationLookup This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;NodeEventInner&gt; object
     */
    public Observable<List<NodeEventInner>> getNodeEventListAsync(String nodeName, String startTimeUtc, String endTimeUtc, Long timeout, String eventsTypesFilter, Boolean excludeAnalysisEvents, Boolean skipCorrelationLookup) {
        return getNodeEventListWithServiceResponseAsync(nodeName, startTimeUtc, endTimeUtc, timeout, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup).map(new Func1<ServiceResponse<List<NodeEventInner>>, List<NodeEventInner>>() {
            @Override
            public List<NodeEventInner> call(ServiceResponse<List<NodeEventInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a Node-related events.
     * The response is list of NodeEvent objects.
     *
     * @param nodeName The name of the node.
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param eventsTypesFilter This is a comma separated string specifying the types of FabricEvents that should only be included in the response.
     * @param excludeAnalysisEvents This param disables the retrieval of AnalysisEvents if true is passed.
     * @param skipCorrelationLookup This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;NodeEventInner&gt; object
     */
    public Observable<ServiceResponse<List<NodeEventInner>>> getNodeEventListWithServiceResponseAsync(String nodeName, String startTimeUtc, String endTimeUtc, Long timeout, String eventsTypesFilter, Boolean excludeAnalysisEvents, Boolean skipCorrelationLookup) {
        if (nodeName == null) {
            throw new IllegalArgumentException("Parameter nodeName is required and cannot be null.");
        }
        if (startTimeUtc == null) {
            throw new IllegalArgumentException("Parameter startTimeUtc is required and cannot be null.");
        }
        if (endTimeUtc == null) {
            throw new IllegalArgumentException("Parameter endTimeUtc is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        return service.getNodeEventList(nodeName, apiVersion, timeout, startTimeUtc, endTimeUtc, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<NodeEventInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<NodeEventInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<NodeEventInner>> clientResponse = getNodeEventListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<NodeEventInner>> getNodeEventListDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<NodeEventInner>, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<NodeEventInner>>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets all Nodes-related Events.
     * The response is list of NodeEvent objects.
     *
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;NodeEventInner&gt; object if successful.
     */
    public List<NodeEventInner> getNodesEventList(String startTimeUtc, String endTimeUtc) {
        return getNodesEventListWithServiceResponseAsync(startTimeUtc, endTimeUtc).toBlocking().single().body();
    }

    /**
     * Gets all Nodes-related Events.
     * The response is list of NodeEvent objects.
     *
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<NodeEventInner>> getNodesEventListAsync(String startTimeUtc, String endTimeUtc, final ServiceCallback<List<NodeEventInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getNodesEventListWithServiceResponseAsync(startTimeUtc, endTimeUtc), serviceCallback);
    }

    /**
     * Gets all Nodes-related Events.
     * The response is list of NodeEvent objects.
     *
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;NodeEventInner&gt; object
     */
    public Observable<List<NodeEventInner>> getNodesEventListAsync(String startTimeUtc, String endTimeUtc) {
        return getNodesEventListWithServiceResponseAsync(startTimeUtc, endTimeUtc).map(new Func1<ServiceResponse<List<NodeEventInner>>, List<NodeEventInner>>() {
            @Override
            public List<NodeEventInner> call(ServiceResponse<List<NodeEventInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets all Nodes-related Events.
     * The response is list of NodeEvent objects.
     *
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;NodeEventInner&gt; object
     */
    public Observable<ServiceResponse<List<NodeEventInner>>> getNodesEventListWithServiceResponseAsync(String startTimeUtc, String endTimeUtc) {
        if (startTimeUtc == null) {
            throw new IllegalArgumentException("Parameter startTimeUtc is required and cannot be null.");
        }
        if (endTimeUtc == null) {
            throw new IllegalArgumentException("Parameter endTimeUtc is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        final Long timeout = null;
        final String eventsTypesFilter = null;
        final Boolean excludeAnalysisEvents = null;
        final Boolean skipCorrelationLookup = null;
        return service.getNodesEventList(apiVersion, timeout, startTimeUtc, endTimeUtc, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<NodeEventInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<NodeEventInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<NodeEventInner>> clientResponse = getNodesEventListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets all Nodes-related Events.
     * The response is list of NodeEvent objects.
     *
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param eventsTypesFilter This is a comma separated string specifying the types of FabricEvents that should only be included in the response.
     * @param excludeAnalysisEvents This param disables the retrieval of AnalysisEvents if true is passed.
     * @param skipCorrelationLookup This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;NodeEventInner&gt; object if successful.
     */
    public List<NodeEventInner> getNodesEventList(String startTimeUtc, String endTimeUtc, Long timeout, String eventsTypesFilter, Boolean excludeAnalysisEvents, Boolean skipCorrelationLookup) {
        return getNodesEventListWithServiceResponseAsync(startTimeUtc, endTimeUtc, timeout, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup).toBlocking().single().body();
    }

    /**
     * Gets all Nodes-related Events.
     * The response is list of NodeEvent objects.
     *
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param eventsTypesFilter This is a comma separated string specifying the types of FabricEvents that should only be included in the response.
     * @param excludeAnalysisEvents This param disables the retrieval of AnalysisEvents if true is passed.
     * @param skipCorrelationLookup This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<NodeEventInner>> getNodesEventListAsync(String startTimeUtc, String endTimeUtc, Long timeout, String eventsTypesFilter, Boolean excludeAnalysisEvents, Boolean skipCorrelationLookup, final ServiceCallback<List<NodeEventInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getNodesEventListWithServiceResponseAsync(startTimeUtc, endTimeUtc, timeout, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup), serviceCallback);
    }

    /**
     * Gets all Nodes-related Events.
     * The response is list of NodeEvent objects.
     *
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param eventsTypesFilter This is a comma separated string specifying the types of FabricEvents that should only be included in the response.
     * @param excludeAnalysisEvents This param disables the retrieval of AnalysisEvents if true is passed.
     * @param skipCorrelationLookup This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;NodeEventInner&gt; object
     */
    public Observable<List<NodeEventInner>> getNodesEventListAsync(String startTimeUtc, String endTimeUtc, Long timeout, String eventsTypesFilter, Boolean excludeAnalysisEvents, Boolean skipCorrelationLookup) {
        return getNodesEventListWithServiceResponseAsync(startTimeUtc, endTimeUtc, timeout, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup).map(new Func1<ServiceResponse<List<NodeEventInner>>, List<NodeEventInner>>() {
            @Override
            public List<NodeEventInner> call(ServiceResponse<List<NodeEventInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets all Nodes-related Events.
     * The response is list of NodeEvent objects.
     *
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param eventsTypesFilter This is a comma separated string specifying the types of FabricEvents that should only be included in the response.
     * @param excludeAnalysisEvents This param disables the retrieval of AnalysisEvents if true is passed.
     * @param skipCorrelationLookup This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;NodeEventInner&gt; object
     */
    public Observable<ServiceResponse<List<NodeEventInner>>> getNodesEventListWithServiceResponseAsync(String startTimeUtc, String endTimeUtc, Long timeout, String eventsTypesFilter, Boolean excludeAnalysisEvents, Boolean skipCorrelationLookup) {
        if (startTimeUtc == null) {
            throw new IllegalArgumentException("Parameter startTimeUtc is required and cannot be null.");
        }
        if (endTimeUtc == null) {
            throw new IllegalArgumentException("Parameter endTimeUtc is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        return service.getNodesEventList(apiVersion, timeout, startTimeUtc, endTimeUtc, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<NodeEventInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<NodeEventInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<NodeEventInner>> clientResponse = getNodesEventListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<NodeEventInner>> getNodesEventListDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<NodeEventInner>, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<NodeEventInner>>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets an Application-related events.
     * The response is list of ApplicationEvent objects.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ApplicationEventInner&gt; object if successful.
     */
    public List<ApplicationEventInner> getApplicationEventList(String applicationId, String startTimeUtc, String endTimeUtc) {
        return getApplicationEventListWithServiceResponseAsync(applicationId, startTimeUtc, endTimeUtc).toBlocking().single().body();
    }

    /**
     * Gets an Application-related events.
     * The response is list of ApplicationEvent objects.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ApplicationEventInner>> getApplicationEventListAsync(String applicationId, String startTimeUtc, String endTimeUtc, final ServiceCallback<List<ApplicationEventInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getApplicationEventListWithServiceResponseAsync(applicationId, startTimeUtc, endTimeUtc), serviceCallback);
    }

    /**
     * Gets an Application-related events.
     * The response is list of ApplicationEvent objects.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ApplicationEventInner&gt; object
     */
    public Observable<List<ApplicationEventInner>> getApplicationEventListAsync(String applicationId, String startTimeUtc, String endTimeUtc) {
        return getApplicationEventListWithServiceResponseAsync(applicationId, startTimeUtc, endTimeUtc).map(new Func1<ServiceResponse<List<ApplicationEventInner>>, List<ApplicationEventInner>>() {
            @Override
            public List<ApplicationEventInner> call(ServiceResponse<List<ApplicationEventInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets an Application-related events.
     * The response is list of ApplicationEvent objects.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ApplicationEventInner&gt; object
     */
    public Observable<ServiceResponse<List<ApplicationEventInner>>> getApplicationEventListWithServiceResponseAsync(String applicationId, String startTimeUtc, String endTimeUtc) {
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        if (startTimeUtc == null) {
            throw new IllegalArgumentException("Parameter startTimeUtc is required and cannot be null.");
        }
        if (endTimeUtc == null) {
            throw new IllegalArgumentException("Parameter endTimeUtc is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        final Long timeout = null;
        final String eventsTypesFilter = null;
        final Boolean excludeAnalysisEvents = null;
        final Boolean skipCorrelationLookup = null;
        return service.getApplicationEventList(applicationId, apiVersion, timeout, startTimeUtc, endTimeUtc, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ApplicationEventInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<ApplicationEventInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<ApplicationEventInner>> clientResponse = getApplicationEventListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets an Application-related events.
     * The response is list of ApplicationEvent objects.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param eventsTypesFilter This is a comma separated string specifying the types of FabricEvents that should only be included in the response.
     * @param excludeAnalysisEvents This param disables the retrieval of AnalysisEvents if true is passed.
     * @param skipCorrelationLookup This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ApplicationEventInner&gt; object if successful.
     */
    public List<ApplicationEventInner> getApplicationEventList(String applicationId, String startTimeUtc, String endTimeUtc, Long timeout, String eventsTypesFilter, Boolean excludeAnalysisEvents, Boolean skipCorrelationLookup) {
        return getApplicationEventListWithServiceResponseAsync(applicationId, startTimeUtc, endTimeUtc, timeout, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup).toBlocking().single().body();
    }

    /**
     * Gets an Application-related events.
     * The response is list of ApplicationEvent objects.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param eventsTypesFilter This is a comma separated string specifying the types of FabricEvents that should only be included in the response.
     * @param excludeAnalysisEvents This param disables the retrieval of AnalysisEvents if true is passed.
     * @param skipCorrelationLookup This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ApplicationEventInner>> getApplicationEventListAsync(String applicationId, String startTimeUtc, String endTimeUtc, Long timeout, String eventsTypesFilter, Boolean excludeAnalysisEvents, Boolean skipCorrelationLookup, final ServiceCallback<List<ApplicationEventInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getApplicationEventListWithServiceResponseAsync(applicationId, startTimeUtc, endTimeUtc, timeout, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup), serviceCallback);
    }

    /**
     * Gets an Application-related events.
     * The response is list of ApplicationEvent objects.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param eventsTypesFilter This is a comma separated string specifying the types of FabricEvents that should only be included in the response.
     * @param excludeAnalysisEvents This param disables the retrieval of AnalysisEvents if true is passed.
     * @param skipCorrelationLookup This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ApplicationEventInner&gt; object
     */
    public Observable<List<ApplicationEventInner>> getApplicationEventListAsync(String applicationId, String startTimeUtc, String endTimeUtc, Long timeout, String eventsTypesFilter, Boolean excludeAnalysisEvents, Boolean skipCorrelationLookup) {
        return getApplicationEventListWithServiceResponseAsync(applicationId, startTimeUtc, endTimeUtc, timeout, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup).map(new Func1<ServiceResponse<List<ApplicationEventInner>>, List<ApplicationEventInner>>() {
            @Override
            public List<ApplicationEventInner> call(ServiceResponse<List<ApplicationEventInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets an Application-related events.
     * The response is list of ApplicationEvent objects.
     *
     * @param applicationId The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param eventsTypesFilter This is a comma separated string specifying the types of FabricEvents that should only be included in the response.
     * @param excludeAnalysisEvents This param disables the retrieval of AnalysisEvents if true is passed.
     * @param skipCorrelationLookup This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ApplicationEventInner&gt; object
     */
    public Observable<ServiceResponse<List<ApplicationEventInner>>> getApplicationEventListWithServiceResponseAsync(String applicationId, String startTimeUtc, String endTimeUtc, Long timeout, String eventsTypesFilter, Boolean excludeAnalysisEvents, Boolean skipCorrelationLookup) {
        if (applicationId == null) {
            throw new IllegalArgumentException("Parameter applicationId is required and cannot be null.");
        }
        if (startTimeUtc == null) {
            throw new IllegalArgumentException("Parameter startTimeUtc is required and cannot be null.");
        }
        if (endTimeUtc == null) {
            throw new IllegalArgumentException("Parameter endTimeUtc is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        return service.getApplicationEventList(applicationId, apiVersion, timeout, startTimeUtc, endTimeUtc, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ApplicationEventInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<ApplicationEventInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<ApplicationEventInner>> clientResponse = getApplicationEventListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<ApplicationEventInner>> getApplicationEventListDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<ApplicationEventInner>, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<ApplicationEventInner>>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets all Applications-related events.
     * The response is list of ApplicationEvent objects.
     *
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ApplicationEventInner&gt; object if successful.
     */
    public List<ApplicationEventInner> getApplicationsEventList(String startTimeUtc, String endTimeUtc) {
        return getApplicationsEventListWithServiceResponseAsync(startTimeUtc, endTimeUtc).toBlocking().single().body();
    }

    /**
     * Gets all Applications-related events.
     * The response is list of ApplicationEvent objects.
     *
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ApplicationEventInner>> getApplicationsEventListAsync(String startTimeUtc, String endTimeUtc, final ServiceCallback<List<ApplicationEventInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getApplicationsEventListWithServiceResponseAsync(startTimeUtc, endTimeUtc), serviceCallback);
    }

    /**
     * Gets all Applications-related events.
     * The response is list of ApplicationEvent objects.
     *
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ApplicationEventInner&gt; object
     */
    public Observable<List<ApplicationEventInner>> getApplicationsEventListAsync(String startTimeUtc, String endTimeUtc) {
        return getApplicationsEventListWithServiceResponseAsync(startTimeUtc, endTimeUtc).map(new Func1<ServiceResponse<List<ApplicationEventInner>>, List<ApplicationEventInner>>() {
            @Override
            public List<ApplicationEventInner> call(ServiceResponse<List<ApplicationEventInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets all Applications-related events.
     * The response is list of ApplicationEvent objects.
     *
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ApplicationEventInner&gt; object
     */
    public Observable<ServiceResponse<List<ApplicationEventInner>>> getApplicationsEventListWithServiceResponseAsync(String startTimeUtc, String endTimeUtc) {
        if (startTimeUtc == null) {
            throw new IllegalArgumentException("Parameter startTimeUtc is required and cannot be null.");
        }
        if (endTimeUtc == null) {
            throw new IllegalArgumentException("Parameter endTimeUtc is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        final Long timeout = null;
        final String eventsTypesFilter = null;
        final Boolean excludeAnalysisEvents = null;
        final Boolean skipCorrelationLookup = null;
        return service.getApplicationsEventList(apiVersion, timeout, startTimeUtc, endTimeUtc, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ApplicationEventInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<ApplicationEventInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<ApplicationEventInner>> clientResponse = getApplicationsEventListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets all Applications-related events.
     * The response is list of ApplicationEvent objects.
     *
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param eventsTypesFilter This is a comma separated string specifying the types of FabricEvents that should only be included in the response.
     * @param excludeAnalysisEvents This param disables the retrieval of AnalysisEvents if true is passed.
     * @param skipCorrelationLookup This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ApplicationEventInner&gt; object if successful.
     */
    public List<ApplicationEventInner> getApplicationsEventList(String startTimeUtc, String endTimeUtc, Long timeout, String eventsTypesFilter, Boolean excludeAnalysisEvents, Boolean skipCorrelationLookup) {
        return getApplicationsEventListWithServiceResponseAsync(startTimeUtc, endTimeUtc, timeout, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup).toBlocking().single().body();
    }

    /**
     * Gets all Applications-related events.
     * The response is list of ApplicationEvent objects.
     *
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param eventsTypesFilter This is a comma separated string specifying the types of FabricEvents that should only be included in the response.
     * @param excludeAnalysisEvents This param disables the retrieval of AnalysisEvents if true is passed.
     * @param skipCorrelationLookup This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ApplicationEventInner>> getApplicationsEventListAsync(String startTimeUtc, String endTimeUtc, Long timeout, String eventsTypesFilter, Boolean excludeAnalysisEvents, Boolean skipCorrelationLookup, final ServiceCallback<List<ApplicationEventInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getApplicationsEventListWithServiceResponseAsync(startTimeUtc, endTimeUtc, timeout, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup), serviceCallback);
    }

    /**
     * Gets all Applications-related events.
     * The response is list of ApplicationEvent objects.
     *
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param eventsTypesFilter This is a comma separated string specifying the types of FabricEvents that should only be included in the response.
     * @param excludeAnalysisEvents This param disables the retrieval of AnalysisEvents if true is passed.
     * @param skipCorrelationLookup This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ApplicationEventInner&gt; object
     */
    public Observable<List<ApplicationEventInner>> getApplicationsEventListAsync(String startTimeUtc, String endTimeUtc, Long timeout, String eventsTypesFilter, Boolean excludeAnalysisEvents, Boolean skipCorrelationLookup) {
        return getApplicationsEventListWithServiceResponseAsync(startTimeUtc, endTimeUtc, timeout, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup).map(new Func1<ServiceResponse<List<ApplicationEventInner>>, List<ApplicationEventInner>>() {
            @Override
            public List<ApplicationEventInner> call(ServiceResponse<List<ApplicationEventInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets all Applications-related events.
     * The response is list of ApplicationEvent objects.
     *
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param eventsTypesFilter This is a comma separated string specifying the types of FabricEvents that should only be included in the response.
     * @param excludeAnalysisEvents This param disables the retrieval of AnalysisEvents if true is passed.
     * @param skipCorrelationLookup This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ApplicationEventInner&gt; object
     */
    public Observable<ServiceResponse<List<ApplicationEventInner>>> getApplicationsEventListWithServiceResponseAsync(String startTimeUtc, String endTimeUtc, Long timeout, String eventsTypesFilter, Boolean excludeAnalysisEvents, Boolean skipCorrelationLookup) {
        if (startTimeUtc == null) {
            throw new IllegalArgumentException("Parameter startTimeUtc is required and cannot be null.");
        }
        if (endTimeUtc == null) {
            throw new IllegalArgumentException("Parameter endTimeUtc is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        return service.getApplicationsEventList(apiVersion, timeout, startTimeUtc, endTimeUtc, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ApplicationEventInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<ApplicationEventInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<ApplicationEventInner>> clientResponse = getApplicationsEventListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<ApplicationEventInner>> getApplicationsEventListDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<ApplicationEventInner>, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<ApplicationEventInner>>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets a Service-related events.
     * The response is list of ServiceEvent objects.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ServiceEventInner&gt; object if successful.
     */
    public List<ServiceEventInner> getServiceEventList(String serviceId, String startTimeUtc, String endTimeUtc) {
        return getServiceEventListWithServiceResponseAsync(serviceId, startTimeUtc, endTimeUtc).toBlocking().single().body();
    }

    /**
     * Gets a Service-related events.
     * The response is list of ServiceEvent objects.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ServiceEventInner>> getServiceEventListAsync(String serviceId, String startTimeUtc, String endTimeUtc, final ServiceCallback<List<ServiceEventInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getServiceEventListWithServiceResponseAsync(serviceId, startTimeUtc, endTimeUtc), serviceCallback);
    }

    /**
     * Gets a Service-related events.
     * The response is list of ServiceEvent objects.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ServiceEventInner&gt; object
     */
    public Observable<List<ServiceEventInner>> getServiceEventListAsync(String serviceId, String startTimeUtc, String endTimeUtc) {
        return getServiceEventListWithServiceResponseAsync(serviceId, startTimeUtc, endTimeUtc).map(new Func1<ServiceResponse<List<ServiceEventInner>>, List<ServiceEventInner>>() {
            @Override
            public List<ServiceEventInner> call(ServiceResponse<List<ServiceEventInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a Service-related events.
     * The response is list of ServiceEvent objects.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ServiceEventInner&gt; object
     */
    public Observable<ServiceResponse<List<ServiceEventInner>>> getServiceEventListWithServiceResponseAsync(String serviceId, String startTimeUtc, String endTimeUtc) {
        if (serviceId == null) {
            throw new IllegalArgumentException("Parameter serviceId is required and cannot be null.");
        }
        if (startTimeUtc == null) {
            throw new IllegalArgumentException("Parameter startTimeUtc is required and cannot be null.");
        }
        if (endTimeUtc == null) {
            throw new IllegalArgumentException("Parameter endTimeUtc is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        final Long timeout = null;
        final String eventsTypesFilter = null;
        final Boolean excludeAnalysisEvents = null;
        final Boolean skipCorrelationLookup = null;
        return service.getServiceEventList(serviceId, apiVersion, timeout, startTimeUtc, endTimeUtc, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ServiceEventInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<ServiceEventInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<ServiceEventInner>> clientResponse = getServiceEventListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets a Service-related events.
     * The response is list of ServiceEvent objects.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param eventsTypesFilter This is a comma separated string specifying the types of FabricEvents that should only be included in the response.
     * @param excludeAnalysisEvents This param disables the retrieval of AnalysisEvents if true is passed.
     * @param skipCorrelationLookup This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ServiceEventInner&gt; object if successful.
     */
    public List<ServiceEventInner> getServiceEventList(String serviceId, String startTimeUtc, String endTimeUtc, Long timeout, String eventsTypesFilter, Boolean excludeAnalysisEvents, Boolean skipCorrelationLookup) {
        return getServiceEventListWithServiceResponseAsync(serviceId, startTimeUtc, endTimeUtc, timeout, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup).toBlocking().single().body();
    }

    /**
     * Gets a Service-related events.
     * The response is list of ServiceEvent objects.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param eventsTypesFilter This is a comma separated string specifying the types of FabricEvents that should only be included in the response.
     * @param excludeAnalysisEvents This param disables the retrieval of AnalysisEvents if true is passed.
     * @param skipCorrelationLookup This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ServiceEventInner>> getServiceEventListAsync(String serviceId, String startTimeUtc, String endTimeUtc, Long timeout, String eventsTypesFilter, Boolean excludeAnalysisEvents, Boolean skipCorrelationLookup, final ServiceCallback<List<ServiceEventInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getServiceEventListWithServiceResponseAsync(serviceId, startTimeUtc, endTimeUtc, timeout, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup), serviceCallback);
    }

    /**
     * Gets a Service-related events.
     * The response is list of ServiceEvent objects.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param eventsTypesFilter This is a comma separated string specifying the types of FabricEvents that should only be included in the response.
     * @param excludeAnalysisEvents This param disables the retrieval of AnalysisEvents if true is passed.
     * @param skipCorrelationLookup This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ServiceEventInner&gt; object
     */
    public Observable<List<ServiceEventInner>> getServiceEventListAsync(String serviceId, String startTimeUtc, String endTimeUtc, Long timeout, String eventsTypesFilter, Boolean excludeAnalysisEvents, Boolean skipCorrelationLookup) {
        return getServiceEventListWithServiceResponseAsync(serviceId, startTimeUtc, endTimeUtc, timeout, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup).map(new Func1<ServiceResponse<List<ServiceEventInner>>, List<ServiceEventInner>>() {
            @Override
            public List<ServiceEventInner> call(ServiceResponse<List<ServiceEventInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a Service-related events.
     * The response is list of ServiceEvent objects.
     *
     * @param serviceId The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.
     Starting from version 6.0, hierarchical names are delimited with the "~" character.
     For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param eventsTypesFilter This is a comma separated string specifying the types of FabricEvents that should only be included in the response.
     * @param excludeAnalysisEvents This param disables the retrieval of AnalysisEvents if true is passed.
     * @param skipCorrelationLookup This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ServiceEventInner&gt; object
     */
    public Observable<ServiceResponse<List<ServiceEventInner>>> getServiceEventListWithServiceResponseAsync(String serviceId, String startTimeUtc, String endTimeUtc, Long timeout, String eventsTypesFilter, Boolean excludeAnalysisEvents, Boolean skipCorrelationLookup) {
        if (serviceId == null) {
            throw new IllegalArgumentException("Parameter serviceId is required and cannot be null.");
        }
        if (startTimeUtc == null) {
            throw new IllegalArgumentException("Parameter startTimeUtc is required and cannot be null.");
        }
        if (endTimeUtc == null) {
            throw new IllegalArgumentException("Parameter endTimeUtc is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        return service.getServiceEventList(serviceId, apiVersion, timeout, startTimeUtc, endTimeUtc, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ServiceEventInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<ServiceEventInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<ServiceEventInner>> clientResponse = getServiceEventListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<ServiceEventInner>> getServiceEventListDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<ServiceEventInner>, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<ServiceEventInner>>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets all Services-related events.
     * The response is list of ServiceEvent objects.
     *
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ServiceEventInner&gt; object if successful.
     */
    public List<ServiceEventInner> getServicesEventList(String startTimeUtc, String endTimeUtc) {
        return getServicesEventListWithServiceResponseAsync(startTimeUtc, endTimeUtc).toBlocking().single().body();
    }

    /**
     * Gets all Services-related events.
     * The response is list of ServiceEvent objects.
     *
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ServiceEventInner>> getServicesEventListAsync(String startTimeUtc, String endTimeUtc, final ServiceCallback<List<ServiceEventInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getServicesEventListWithServiceResponseAsync(startTimeUtc, endTimeUtc), serviceCallback);
    }

    /**
     * Gets all Services-related events.
     * The response is list of ServiceEvent objects.
     *
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ServiceEventInner&gt; object
     */
    public Observable<List<ServiceEventInner>> getServicesEventListAsync(String startTimeUtc, String endTimeUtc) {
        return getServicesEventListWithServiceResponseAsync(startTimeUtc, endTimeUtc).map(new Func1<ServiceResponse<List<ServiceEventInner>>, List<ServiceEventInner>>() {
            @Override
            public List<ServiceEventInner> call(ServiceResponse<List<ServiceEventInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets all Services-related events.
     * The response is list of ServiceEvent objects.
     *
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ServiceEventInner&gt; object
     */
    public Observable<ServiceResponse<List<ServiceEventInner>>> getServicesEventListWithServiceResponseAsync(String startTimeUtc, String endTimeUtc) {
        if (startTimeUtc == null) {
            throw new IllegalArgumentException("Parameter startTimeUtc is required and cannot be null.");
        }
        if (endTimeUtc == null) {
            throw new IllegalArgumentException("Parameter endTimeUtc is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        final Long timeout = null;
        final String eventsTypesFilter = null;
        final Boolean excludeAnalysisEvents = null;
        final Boolean skipCorrelationLookup = null;
        return service.getServicesEventList(apiVersion, timeout, startTimeUtc, endTimeUtc, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ServiceEventInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<ServiceEventInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<ServiceEventInner>> clientResponse = getServicesEventListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets all Services-related events.
     * The response is list of ServiceEvent objects.
     *
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param eventsTypesFilter This is a comma separated string specifying the types of FabricEvents that should only be included in the response.
     * @param excludeAnalysisEvents This param disables the retrieval of AnalysisEvents if true is passed.
     * @param skipCorrelationLookup This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ServiceEventInner&gt; object if successful.
     */
    public List<ServiceEventInner> getServicesEventList(String startTimeUtc, String endTimeUtc, Long timeout, String eventsTypesFilter, Boolean excludeAnalysisEvents, Boolean skipCorrelationLookup) {
        return getServicesEventListWithServiceResponseAsync(startTimeUtc, endTimeUtc, timeout, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup).toBlocking().single().body();
    }

    /**
     * Gets all Services-related events.
     * The response is list of ServiceEvent objects.
     *
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param eventsTypesFilter This is a comma separated string specifying the types of FabricEvents that should only be included in the response.
     * @param excludeAnalysisEvents This param disables the retrieval of AnalysisEvents if true is passed.
     * @param skipCorrelationLookup This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ServiceEventInner>> getServicesEventListAsync(String startTimeUtc, String endTimeUtc, Long timeout, String eventsTypesFilter, Boolean excludeAnalysisEvents, Boolean skipCorrelationLookup, final ServiceCallback<List<ServiceEventInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getServicesEventListWithServiceResponseAsync(startTimeUtc, endTimeUtc, timeout, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup), serviceCallback);
    }

    /**
     * Gets all Services-related events.
     * The response is list of ServiceEvent objects.
     *
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param eventsTypesFilter This is a comma separated string specifying the types of FabricEvents that should only be included in the response.
     * @param excludeAnalysisEvents This param disables the retrieval of AnalysisEvents if true is passed.
     * @param skipCorrelationLookup This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ServiceEventInner&gt; object
     */
    public Observable<List<ServiceEventInner>> getServicesEventListAsync(String startTimeUtc, String endTimeUtc, Long timeout, String eventsTypesFilter, Boolean excludeAnalysisEvents, Boolean skipCorrelationLookup) {
        return getServicesEventListWithServiceResponseAsync(startTimeUtc, endTimeUtc, timeout, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup).map(new Func1<ServiceResponse<List<ServiceEventInner>>, List<ServiceEventInner>>() {
            @Override
            public List<ServiceEventInner> call(ServiceResponse<List<ServiceEventInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets all Services-related events.
     * The response is list of ServiceEvent objects.
     *
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param eventsTypesFilter This is a comma separated string specifying the types of FabricEvents that should only be included in the response.
     * @param excludeAnalysisEvents This param disables the retrieval of AnalysisEvents if true is passed.
     * @param skipCorrelationLookup This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ServiceEventInner&gt; object
     */
    public Observable<ServiceResponse<List<ServiceEventInner>>> getServicesEventListWithServiceResponseAsync(String startTimeUtc, String endTimeUtc, Long timeout, String eventsTypesFilter, Boolean excludeAnalysisEvents, Boolean skipCorrelationLookup) {
        if (startTimeUtc == null) {
            throw new IllegalArgumentException("Parameter startTimeUtc is required and cannot be null.");
        }
        if (endTimeUtc == null) {
            throw new IllegalArgumentException("Parameter endTimeUtc is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        return service.getServicesEventList(apiVersion, timeout, startTimeUtc, endTimeUtc, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ServiceEventInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<ServiceEventInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<ServiceEventInner>> clientResponse = getServicesEventListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<ServiceEventInner>> getServicesEventListDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<ServiceEventInner>, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<ServiceEventInner>>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets a Partition-related events.
     * The response is list of PartitionEvent objects.
     *
     * @param partitionId The identity of the partition.
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;PartitionEventInner&gt; object if successful.
     */
    public List<PartitionEventInner> getPartitionEventList(UUID partitionId, String startTimeUtc, String endTimeUtc) {
        return getPartitionEventListWithServiceResponseAsync(partitionId, startTimeUtc, endTimeUtc).toBlocking().single().body();
    }

    /**
     * Gets a Partition-related events.
     * The response is list of PartitionEvent objects.
     *
     * @param partitionId The identity of the partition.
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<PartitionEventInner>> getPartitionEventListAsync(UUID partitionId, String startTimeUtc, String endTimeUtc, final ServiceCallback<List<PartitionEventInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getPartitionEventListWithServiceResponseAsync(partitionId, startTimeUtc, endTimeUtc), serviceCallback);
    }

    /**
     * Gets a Partition-related events.
     * The response is list of PartitionEvent objects.
     *
     * @param partitionId The identity of the partition.
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PartitionEventInner&gt; object
     */
    public Observable<List<PartitionEventInner>> getPartitionEventListAsync(UUID partitionId, String startTimeUtc, String endTimeUtc) {
        return getPartitionEventListWithServiceResponseAsync(partitionId, startTimeUtc, endTimeUtc).map(new Func1<ServiceResponse<List<PartitionEventInner>>, List<PartitionEventInner>>() {
            @Override
            public List<PartitionEventInner> call(ServiceResponse<List<PartitionEventInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a Partition-related events.
     * The response is list of PartitionEvent objects.
     *
     * @param partitionId The identity of the partition.
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PartitionEventInner&gt; object
     */
    public Observable<ServiceResponse<List<PartitionEventInner>>> getPartitionEventListWithServiceResponseAsync(UUID partitionId, String startTimeUtc, String endTimeUtc) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        if (startTimeUtc == null) {
            throw new IllegalArgumentException("Parameter startTimeUtc is required and cannot be null.");
        }
        if (endTimeUtc == null) {
            throw new IllegalArgumentException("Parameter endTimeUtc is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        final Long timeout = null;
        final String eventsTypesFilter = null;
        final Boolean excludeAnalysisEvents = null;
        final Boolean skipCorrelationLookup = null;
        return service.getPartitionEventList(partitionId, apiVersion, timeout, startTimeUtc, endTimeUtc, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<PartitionEventInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<PartitionEventInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<PartitionEventInner>> clientResponse = getPartitionEventListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets a Partition-related events.
     * The response is list of PartitionEvent objects.
     *
     * @param partitionId The identity of the partition.
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param eventsTypesFilter This is a comma separated string specifying the types of FabricEvents that should only be included in the response.
     * @param excludeAnalysisEvents This param disables the retrieval of AnalysisEvents if true is passed.
     * @param skipCorrelationLookup This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;PartitionEventInner&gt; object if successful.
     */
    public List<PartitionEventInner> getPartitionEventList(UUID partitionId, String startTimeUtc, String endTimeUtc, Long timeout, String eventsTypesFilter, Boolean excludeAnalysisEvents, Boolean skipCorrelationLookup) {
        return getPartitionEventListWithServiceResponseAsync(partitionId, startTimeUtc, endTimeUtc, timeout, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup).toBlocking().single().body();
    }

    /**
     * Gets a Partition-related events.
     * The response is list of PartitionEvent objects.
     *
     * @param partitionId The identity of the partition.
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param eventsTypesFilter This is a comma separated string specifying the types of FabricEvents that should only be included in the response.
     * @param excludeAnalysisEvents This param disables the retrieval of AnalysisEvents if true is passed.
     * @param skipCorrelationLookup This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<PartitionEventInner>> getPartitionEventListAsync(UUID partitionId, String startTimeUtc, String endTimeUtc, Long timeout, String eventsTypesFilter, Boolean excludeAnalysisEvents, Boolean skipCorrelationLookup, final ServiceCallback<List<PartitionEventInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getPartitionEventListWithServiceResponseAsync(partitionId, startTimeUtc, endTimeUtc, timeout, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup), serviceCallback);
    }

    /**
     * Gets a Partition-related events.
     * The response is list of PartitionEvent objects.
     *
     * @param partitionId The identity of the partition.
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param eventsTypesFilter This is a comma separated string specifying the types of FabricEvents that should only be included in the response.
     * @param excludeAnalysisEvents This param disables the retrieval of AnalysisEvents if true is passed.
     * @param skipCorrelationLookup This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PartitionEventInner&gt; object
     */
    public Observable<List<PartitionEventInner>> getPartitionEventListAsync(UUID partitionId, String startTimeUtc, String endTimeUtc, Long timeout, String eventsTypesFilter, Boolean excludeAnalysisEvents, Boolean skipCorrelationLookup) {
        return getPartitionEventListWithServiceResponseAsync(partitionId, startTimeUtc, endTimeUtc, timeout, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup).map(new Func1<ServiceResponse<List<PartitionEventInner>>, List<PartitionEventInner>>() {
            @Override
            public List<PartitionEventInner> call(ServiceResponse<List<PartitionEventInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a Partition-related events.
     * The response is list of PartitionEvent objects.
     *
     * @param partitionId The identity of the partition.
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param eventsTypesFilter This is a comma separated string specifying the types of FabricEvents that should only be included in the response.
     * @param excludeAnalysisEvents This param disables the retrieval of AnalysisEvents if true is passed.
     * @param skipCorrelationLookup This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PartitionEventInner&gt; object
     */
    public Observable<ServiceResponse<List<PartitionEventInner>>> getPartitionEventListWithServiceResponseAsync(UUID partitionId, String startTimeUtc, String endTimeUtc, Long timeout, String eventsTypesFilter, Boolean excludeAnalysisEvents, Boolean skipCorrelationLookup) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        if (startTimeUtc == null) {
            throw new IllegalArgumentException("Parameter startTimeUtc is required and cannot be null.");
        }
        if (endTimeUtc == null) {
            throw new IllegalArgumentException("Parameter endTimeUtc is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        return service.getPartitionEventList(partitionId, apiVersion, timeout, startTimeUtc, endTimeUtc, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<PartitionEventInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<PartitionEventInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<PartitionEventInner>> clientResponse = getPartitionEventListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<PartitionEventInner>> getPartitionEventListDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<PartitionEventInner>, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<PartitionEventInner>>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets all Partitions-related events.
     * The response is list of PartitionEvent objects.
     *
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;PartitionEventInner&gt; object if successful.
     */
    public List<PartitionEventInner> getPartitionsEventList(String startTimeUtc, String endTimeUtc) {
        return getPartitionsEventListWithServiceResponseAsync(startTimeUtc, endTimeUtc).toBlocking().single().body();
    }

    /**
     * Gets all Partitions-related events.
     * The response is list of PartitionEvent objects.
     *
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<PartitionEventInner>> getPartitionsEventListAsync(String startTimeUtc, String endTimeUtc, final ServiceCallback<List<PartitionEventInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getPartitionsEventListWithServiceResponseAsync(startTimeUtc, endTimeUtc), serviceCallback);
    }

    /**
     * Gets all Partitions-related events.
     * The response is list of PartitionEvent objects.
     *
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PartitionEventInner&gt; object
     */
    public Observable<List<PartitionEventInner>> getPartitionsEventListAsync(String startTimeUtc, String endTimeUtc) {
        return getPartitionsEventListWithServiceResponseAsync(startTimeUtc, endTimeUtc).map(new Func1<ServiceResponse<List<PartitionEventInner>>, List<PartitionEventInner>>() {
            @Override
            public List<PartitionEventInner> call(ServiceResponse<List<PartitionEventInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets all Partitions-related events.
     * The response is list of PartitionEvent objects.
     *
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PartitionEventInner&gt; object
     */
    public Observable<ServiceResponse<List<PartitionEventInner>>> getPartitionsEventListWithServiceResponseAsync(String startTimeUtc, String endTimeUtc) {
        if (startTimeUtc == null) {
            throw new IllegalArgumentException("Parameter startTimeUtc is required and cannot be null.");
        }
        if (endTimeUtc == null) {
            throw new IllegalArgumentException("Parameter endTimeUtc is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        final Long timeout = null;
        final String eventsTypesFilter = null;
        final Boolean excludeAnalysisEvents = null;
        final Boolean skipCorrelationLookup = null;
        return service.getPartitionsEventList(apiVersion, timeout, startTimeUtc, endTimeUtc, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<PartitionEventInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<PartitionEventInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<PartitionEventInner>> clientResponse = getPartitionsEventListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets all Partitions-related events.
     * The response is list of PartitionEvent objects.
     *
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param eventsTypesFilter This is a comma separated string specifying the types of FabricEvents that should only be included in the response.
     * @param excludeAnalysisEvents This param disables the retrieval of AnalysisEvents if true is passed.
     * @param skipCorrelationLookup This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;PartitionEventInner&gt; object if successful.
     */
    public List<PartitionEventInner> getPartitionsEventList(String startTimeUtc, String endTimeUtc, Long timeout, String eventsTypesFilter, Boolean excludeAnalysisEvents, Boolean skipCorrelationLookup) {
        return getPartitionsEventListWithServiceResponseAsync(startTimeUtc, endTimeUtc, timeout, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup).toBlocking().single().body();
    }

    /**
     * Gets all Partitions-related events.
     * The response is list of PartitionEvent objects.
     *
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param eventsTypesFilter This is a comma separated string specifying the types of FabricEvents that should only be included in the response.
     * @param excludeAnalysisEvents This param disables the retrieval of AnalysisEvents if true is passed.
     * @param skipCorrelationLookup This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<PartitionEventInner>> getPartitionsEventListAsync(String startTimeUtc, String endTimeUtc, Long timeout, String eventsTypesFilter, Boolean excludeAnalysisEvents, Boolean skipCorrelationLookup, final ServiceCallback<List<PartitionEventInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getPartitionsEventListWithServiceResponseAsync(startTimeUtc, endTimeUtc, timeout, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup), serviceCallback);
    }

    /**
     * Gets all Partitions-related events.
     * The response is list of PartitionEvent objects.
     *
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param eventsTypesFilter This is a comma separated string specifying the types of FabricEvents that should only be included in the response.
     * @param excludeAnalysisEvents This param disables the retrieval of AnalysisEvents if true is passed.
     * @param skipCorrelationLookup This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PartitionEventInner&gt; object
     */
    public Observable<List<PartitionEventInner>> getPartitionsEventListAsync(String startTimeUtc, String endTimeUtc, Long timeout, String eventsTypesFilter, Boolean excludeAnalysisEvents, Boolean skipCorrelationLookup) {
        return getPartitionsEventListWithServiceResponseAsync(startTimeUtc, endTimeUtc, timeout, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup).map(new Func1<ServiceResponse<List<PartitionEventInner>>, List<PartitionEventInner>>() {
            @Override
            public List<PartitionEventInner> call(ServiceResponse<List<PartitionEventInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets all Partitions-related events.
     * The response is list of PartitionEvent objects.
     *
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param eventsTypesFilter This is a comma separated string specifying the types of FabricEvents that should only be included in the response.
     * @param excludeAnalysisEvents This param disables the retrieval of AnalysisEvents if true is passed.
     * @param skipCorrelationLookup This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PartitionEventInner&gt; object
     */
    public Observable<ServiceResponse<List<PartitionEventInner>>> getPartitionsEventListWithServiceResponseAsync(String startTimeUtc, String endTimeUtc, Long timeout, String eventsTypesFilter, Boolean excludeAnalysisEvents, Boolean skipCorrelationLookup) {
        if (startTimeUtc == null) {
            throw new IllegalArgumentException("Parameter startTimeUtc is required and cannot be null.");
        }
        if (endTimeUtc == null) {
            throw new IllegalArgumentException("Parameter endTimeUtc is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        return service.getPartitionsEventList(apiVersion, timeout, startTimeUtc, endTimeUtc, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<PartitionEventInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<PartitionEventInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<PartitionEventInner>> clientResponse = getPartitionsEventListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<PartitionEventInner>> getPartitionsEventListDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<PartitionEventInner>, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<PartitionEventInner>>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets a Partition Replica-related events.
     * The response is list of ReplicaEvent objects.
     *
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ReplicaEventInner&gt; object if successful.
     */
    public List<ReplicaEventInner> getPartitionReplicaEventList(UUID partitionId, String replicaId, String startTimeUtc, String endTimeUtc) {
        return getPartitionReplicaEventListWithServiceResponseAsync(partitionId, replicaId, startTimeUtc, endTimeUtc).toBlocking().single().body();
    }

    /**
     * Gets a Partition Replica-related events.
     * The response is list of ReplicaEvent objects.
     *
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ReplicaEventInner>> getPartitionReplicaEventListAsync(UUID partitionId, String replicaId, String startTimeUtc, String endTimeUtc, final ServiceCallback<List<ReplicaEventInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getPartitionReplicaEventListWithServiceResponseAsync(partitionId, replicaId, startTimeUtc, endTimeUtc), serviceCallback);
    }

    /**
     * Gets a Partition Replica-related events.
     * The response is list of ReplicaEvent objects.
     *
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ReplicaEventInner&gt; object
     */
    public Observable<List<ReplicaEventInner>> getPartitionReplicaEventListAsync(UUID partitionId, String replicaId, String startTimeUtc, String endTimeUtc) {
        return getPartitionReplicaEventListWithServiceResponseAsync(partitionId, replicaId, startTimeUtc, endTimeUtc).map(new Func1<ServiceResponse<List<ReplicaEventInner>>, List<ReplicaEventInner>>() {
            @Override
            public List<ReplicaEventInner> call(ServiceResponse<List<ReplicaEventInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a Partition Replica-related events.
     * The response is list of ReplicaEvent objects.
     *
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ReplicaEventInner&gt; object
     */
    public Observable<ServiceResponse<List<ReplicaEventInner>>> getPartitionReplicaEventListWithServiceResponseAsync(UUID partitionId, String replicaId, String startTimeUtc, String endTimeUtc) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        if (replicaId == null) {
            throw new IllegalArgumentException("Parameter replicaId is required and cannot be null.");
        }
        if (startTimeUtc == null) {
            throw new IllegalArgumentException("Parameter startTimeUtc is required and cannot be null.");
        }
        if (endTimeUtc == null) {
            throw new IllegalArgumentException("Parameter endTimeUtc is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        final Long timeout = null;
        final String eventsTypesFilter = null;
        final Boolean excludeAnalysisEvents = null;
        final Boolean skipCorrelationLookup = null;
        return service.getPartitionReplicaEventList(partitionId, replicaId, apiVersion, timeout, startTimeUtc, endTimeUtc, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ReplicaEventInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<ReplicaEventInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<ReplicaEventInner>> clientResponse = getPartitionReplicaEventListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets a Partition Replica-related events.
     * The response is list of ReplicaEvent objects.
     *
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param eventsTypesFilter This is a comma separated string specifying the types of FabricEvents that should only be included in the response.
     * @param excludeAnalysisEvents This param disables the retrieval of AnalysisEvents if true is passed.
     * @param skipCorrelationLookup This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ReplicaEventInner&gt; object if successful.
     */
    public List<ReplicaEventInner> getPartitionReplicaEventList(UUID partitionId, String replicaId, String startTimeUtc, String endTimeUtc, Long timeout, String eventsTypesFilter, Boolean excludeAnalysisEvents, Boolean skipCorrelationLookup) {
        return getPartitionReplicaEventListWithServiceResponseAsync(partitionId, replicaId, startTimeUtc, endTimeUtc, timeout, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup).toBlocking().single().body();
    }

    /**
     * Gets a Partition Replica-related events.
     * The response is list of ReplicaEvent objects.
     *
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param eventsTypesFilter This is a comma separated string specifying the types of FabricEvents that should only be included in the response.
     * @param excludeAnalysisEvents This param disables the retrieval of AnalysisEvents if true is passed.
     * @param skipCorrelationLookup This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ReplicaEventInner>> getPartitionReplicaEventListAsync(UUID partitionId, String replicaId, String startTimeUtc, String endTimeUtc, Long timeout, String eventsTypesFilter, Boolean excludeAnalysisEvents, Boolean skipCorrelationLookup, final ServiceCallback<List<ReplicaEventInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getPartitionReplicaEventListWithServiceResponseAsync(partitionId, replicaId, startTimeUtc, endTimeUtc, timeout, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup), serviceCallback);
    }

    /**
     * Gets a Partition Replica-related events.
     * The response is list of ReplicaEvent objects.
     *
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param eventsTypesFilter This is a comma separated string specifying the types of FabricEvents that should only be included in the response.
     * @param excludeAnalysisEvents This param disables the retrieval of AnalysisEvents if true is passed.
     * @param skipCorrelationLookup This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ReplicaEventInner&gt; object
     */
    public Observable<List<ReplicaEventInner>> getPartitionReplicaEventListAsync(UUID partitionId, String replicaId, String startTimeUtc, String endTimeUtc, Long timeout, String eventsTypesFilter, Boolean excludeAnalysisEvents, Boolean skipCorrelationLookup) {
        return getPartitionReplicaEventListWithServiceResponseAsync(partitionId, replicaId, startTimeUtc, endTimeUtc, timeout, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup).map(new Func1<ServiceResponse<List<ReplicaEventInner>>, List<ReplicaEventInner>>() {
            @Override
            public List<ReplicaEventInner> call(ServiceResponse<List<ReplicaEventInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a Partition Replica-related events.
     * The response is list of ReplicaEvent objects.
     *
     * @param partitionId The identity of the partition.
     * @param replicaId The identifier of the replica.
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param eventsTypesFilter This is a comma separated string specifying the types of FabricEvents that should only be included in the response.
     * @param excludeAnalysisEvents This param disables the retrieval of AnalysisEvents if true is passed.
     * @param skipCorrelationLookup This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ReplicaEventInner&gt; object
     */
    public Observable<ServiceResponse<List<ReplicaEventInner>>> getPartitionReplicaEventListWithServiceResponseAsync(UUID partitionId, String replicaId, String startTimeUtc, String endTimeUtc, Long timeout, String eventsTypesFilter, Boolean excludeAnalysisEvents, Boolean skipCorrelationLookup) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        if (replicaId == null) {
            throw new IllegalArgumentException("Parameter replicaId is required and cannot be null.");
        }
        if (startTimeUtc == null) {
            throw new IllegalArgumentException("Parameter startTimeUtc is required and cannot be null.");
        }
        if (endTimeUtc == null) {
            throw new IllegalArgumentException("Parameter endTimeUtc is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        return service.getPartitionReplicaEventList(partitionId, replicaId, apiVersion, timeout, startTimeUtc, endTimeUtc, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ReplicaEventInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<ReplicaEventInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<ReplicaEventInner>> clientResponse = getPartitionReplicaEventListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<ReplicaEventInner>> getPartitionReplicaEventListDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<ReplicaEventInner>, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<ReplicaEventInner>>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets all Replicas-related events for a Partition.
     * The response is list of ReplicaEvent objects.
     *
     * @param partitionId The identity of the partition.
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ReplicaEventInner&gt; object if successful.
     */
    public List<ReplicaEventInner> getPartitionReplicasEventList(UUID partitionId, String startTimeUtc, String endTimeUtc) {
        return getPartitionReplicasEventListWithServiceResponseAsync(partitionId, startTimeUtc, endTimeUtc).toBlocking().single().body();
    }

    /**
     * Gets all Replicas-related events for a Partition.
     * The response is list of ReplicaEvent objects.
     *
     * @param partitionId The identity of the partition.
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ReplicaEventInner>> getPartitionReplicasEventListAsync(UUID partitionId, String startTimeUtc, String endTimeUtc, final ServiceCallback<List<ReplicaEventInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getPartitionReplicasEventListWithServiceResponseAsync(partitionId, startTimeUtc, endTimeUtc), serviceCallback);
    }

    /**
     * Gets all Replicas-related events for a Partition.
     * The response is list of ReplicaEvent objects.
     *
     * @param partitionId The identity of the partition.
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ReplicaEventInner&gt; object
     */
    public Observable<List<ReplicaEventInner>> getPartitionReplicasEventListAsync(UUID partitionId, String startTimeUtc, String endTimeUtc) {
        return getPartitionReplicasEventListWithServiceResponseAsync(partitionId, startTimeUtc, endTimeUtc).map(new Func1<ServiceResponse<List<ReplicaEventInner>>, List<ReplicaEventInner>>() {
            @Override
            public List<ReplicaEventInner> call(ServiceResponse<List<ReplicaEventInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets all Replicas-related events for a Partition.
     * The response is list of ReplicaEvent objects.
     *
     * @param partitionId The identity of the partition.
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ReplicaEventInner&gt; object
     */
    public Observable<ServiceResponse<List<ReplicaEventInner>>> getPartitionReplicasEventListWithServiceResponseAsync(UUID partitionId, String startTimeUtc, String endTimeUtc) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        if (startTimeUtc == null) {
            throw new IllegalArgumentException("Parameter startTimeUtc is required and cannot be null.");
        }
        if (endTimeUtc == null) {
            throw new IllegalArgumentException("Parameter endTimeUtc is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        final Long timeout = null;
        final String eventsTypesFilter = null;
        final Boolean excludeAnalysisEvents = null;
        final Boolean skipCorrelationLookup = null;
        return service.getPartitionReplicasEventList(partitionId, apiVersion, timeout, startTimeUtc, endTimeUtc, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ReplicaEventInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<ReplicaEventInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<ReplicaEventInner>> clientResponse = getPartitionReplicasEventListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets all Replicas-related events for a Partition.
     * The response is list of ReplicaEvent objects.
     *
     * @param partitionId The identity of the partition.
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param eventsTypesFilter This is a comma separated string specifying the types of FabricEvents that should only be included in the response.
     * @param excludeAnalysisEvents This param disables the retrieval of AnalysisEvents if true is passed.
     * @param skipCorrelationLookup This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ReplicaEventInner&gt; object if successful.
     */
    public List<ReplicaEventInner> getPartitionReplicasEventList(UUID partitionId, String startTimeUtc, String endTimeUtc, Long timeout, String eventsTypesFilter, Boolean excludeAnalysisEvents, Boolean skipCorrelationLookup) {
        return getPartitionReplicasEventListWithServiceResponseAsync(partitionId, startTimeUtc, endTimeUtc, timeout, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup).toBlocking().single().body();
    }

    /**
     * Gets all Replicas-related events for a Partition.
     * The response is list of ReplicaEvent objects.
     *
     * @param partitionId The identity of the partition.
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param eventsTypesFilter This is a comma separated string specifying the types of FabricEvents that should only be included in the response.
     * @param excludeAnalysisEvents This param disables the retrieval of AnalysisEvents if true is passed.
     * @param skipCorrelationLookup This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ReplicaEventInner>> getPartitionReplicasEventListAsync(UUID partitionId, String startTimeUtc, String endTimeUtc, Long timeout, String eventsTypesFilter, Boolean excludeAnalysisEvents, Boolean skipCorrelationLookup, final ServiceCallback<List<ReplicaEventInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getPartitionReplicasEventListWithServiceResponseAsync(partitionId, startTimeUtc, endTimeUtc, timeout, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup), serviceCallback);
    }

    /**
     * Gets all Replicas-related events for a Partition.
     * The response is list of ReplicaEvent objects.
     *
     * @param partitionId The identity of the partition.
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param eventsTypesFilter This is a comma separated string specifying the types of FabricEvents that should only be included in the response.
     * @param excludeAnalysisEvents This param disables the retrieval of AnalysisEvents if true is passed.
     * @param skipCorrelationLookup This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ReplicaEventInner&gt; object
     */
    public Observable<List<ReplicaEventInner>> getPartitionReplicasEventListAsync(UUID partitionId, String startTimeUtc, String endTimeUtc, Long timeout, String eventsTypesFilter, Boolean excludeAnalysisEvents, Boolean skipCorrelationLookup) {
        return getPartitionReplicasEventListWithServiceResponseAsync(partitionId, startTimeUtc, endTimeUtc, timeout, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup).map(new Func1<ServiceResponse<List<ReplicaEventInner>>, List<ReplicaEventInner>>() {
            @Override
            public List<ReplicaEventInner> call(ServiceResponse<List<ReplicaEventInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets all Replicas-related events for a Partition.
     * The response is list of ReplicaEvent objects.
     *
     * @param partitionId The identity of the partition.
     * @param startTimeUtc The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param endTimeUtc The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param eventsTypesFilter This is a comma separated string specifying the types of FabricEvents that should only be included in the response.
     * @param excludeAnalysisEvents This param disables the retrieval of AnalysisEvents if true is passed.
     * @param skipCorrelationLookup This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ReplicaEventInner&gt; object
     */
    public Observable<ServiceResponse<List<ReplicaEventInner>>> getPartitionReplicasEventListWithServiceResponseAsync(UUID partitionId, String startTimeUtc, String endTimeUtc, Long timeout, String eventsTypesFilter, Boolean excludeAnalysisEvents, Boolean skipCorrelationLookup) {
        if (partitionId == null) {
            throw new IllegalArgumentException("Parameter partitionId is required and cannot be null.");
        }
        if (startTimeUtc == null) {
            throw new IllegalArgumentException("Parameter startTimeUtc is required and cannot be null.");
        }
        if (endTimeUtc == null) {
            throw new IllegalArgumentException("Parameter endTimeUtc is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        return service.getPartitionReplicasEventList(partitionId, apiVersion, timeout, startTimeUtc, endTimeUtc, eventsTypesFilter, excludeAnalysisEvents, skipCorrelationLookup, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ReplicaEventInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<ReplicaEventInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<ReplicaEventInner>> clientResponse = getPartitionReplicasEventListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<ReplicaEventInner>> getPartitionReplicasEventListDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<ReplicaEventInner>, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<ReplicaEventInner>>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets all correlated events for a given event.
     * The response is list of FabricEvents.
     *
     * @param eventInstanceId The EventInstanceId.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;FabricEventInner&gt; object if successful.
     */
    public List<FabricEventInner> getCorrelatedEventList(String eventInstanceId) {
        return getCorrelatedEventListWithServiceResponseAsync(eventInstanceId).toBlocking().single().body();
    }

    /**
     * Gets all correlated events for a given event.
     * The response is list of FabricEvents.
     *
     * @param eventInstanceId The EventInstanceId.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<FabricEventInner>> getCorrelatedEventListAsync(String eventInstanceId, final ServiceCallback<List<FabricEventInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getCorrelatedEventListWithServiceResponseAsync(eventInstanceId), serviceCallback);
    }

    /**
     * Gets all correlated events for a given event.
     * The response is list of FabricEvents.
     *
     * @param eventInstanceId The EventInstanceId.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;FabricEventInner&gt; object
     */
    public Observable<List<FabricEventInner>> getCorrelatedEventListAsync(String eventInstanceId) {
        return getCorrelatedEventListWithServiceResponseAsync(eventInstanceId).map(new Func1<ServiceResponse<List<FabricEventInner>>, List<FabricEventInner>>() {
            @Override
            public List<FabricEventInner> call(ServiceResponse<List<FabricEventInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets all correlated events for a given event.
     * The response is list of FabricEvents.
     *
     * @param eventInstanceId The EventInstanceId.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;FabricEventInner&gt; object
     */
    public Observable<ServiceResponse<List<FabricEventInner>>> getCorrelatedEventListWithServiceResponseAsync(String eventInstanceId) {
        if (eventInstanceId == null) {
            throw new IllegalArgumentException("Parameter eventInstanceId is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        final Long timeout = null;
        return service.getCorrelatedEventList(eventInstanceId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<FabricEventInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<FabricEventInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<FabricEventInner>> clientResponse = getCorrelatedEventListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets all correlated events for a given event.
     * The response is list of FabricEvents.
     *
     * @param eventInstanceId The EventInstanceId.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;FabricEventInner&gt; object if successful.
     */
    public List<FabricEventInner> getCorrelatedEventList(String eventInstanceId, Long timeout) {
        return getCorrelatedEventListWithServiceResponseAsync(eventInstanceId, timeout).toBlocking().single().body();
    }

    /**
     * Gets all correlated events for a given event.
     * The response is list of FabricEvents.
     *
     * @param eventInstanceId The EventInstanceId.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<FabricEventInner>> getCorrelatedEventListAsync(String eventInstanceId, Long timeout, final ServiceCallback<List<FabricEventInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getCorrelatedEventListWithServiceResponseAsync(eventInstanceId, timeout), serviceCallback);
    }

    /**
     * Gets all correlated events for a given event.
     * The response is list of FabricEvents.
     *
     * @param eventInstanceId The EventInstanceId.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;FabricEventInner&gt; object
     */
    public Observable<List<FabricEventInner>> getCorrelatedEventListAsync(String eventInstanceId, Long timeout) {
        return getCorrelatedEventListWithServiceResponseAsync(eventInstanceId, timeout).map(new Func1<ServiceResponse<List<FabricEventInner>>, List<FabricEventInner>>() {
            @Override
            public List<FabricEventInner> call(ServiceResponse<List<FabricEventInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets all correlated events for a given event.
     * The response is list of FabricEvents.
     *
     * @param eventInstanceId The EventInstanceId.
     * @param timeout The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;FabricEventInner&gt; object
     */
    public Observable<ServiceResponse<List<FabricEventInner>>> getCorrelatedEventListWithServiceResponseAsync(String eventInstanceId, Long timeout) {
        if (eventInstanceId == null) {
            throw new IllegalArgumentException("Parameter eventInstanceId is required and cannot be null.");
        }
        final String apiVersion = "6.2-preview";
        return service.getCorrelatedEventList(eventInstanceId, apiVersion, timeout, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<FabricEventInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<FabricEventInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<FabricEventInner>> clientResponse = getCorrelatedEventListDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<FabricEventInner>> getCorrelatedEventListDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<FabricEventInner>, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<FabricEventInner>>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Creates or updates an application resource.
     * Creates an application with the specified name and description. If an application with the same name already exists, then its description are updated to the one indicated in this request.
     *
     * @param applicationResourceName Service Fabric application resource name.
     * @param applicationResourceDescription Description for creating an application resource.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void createApplicationResource(String applicationResourceName, ApplicationResourceDescriptionInner applicationResourceDescription) {
        createApplicationResourceWithServiceResponseAsync(applicationResourceName, applicationResourceDescription).toBlocking().single().body();
    }

    /**
     * Creates or updates an application resource.
     * Creates an application with the specified name and description. If an application with the same name already exists, then its description are updated to the one indicated in this request.
     *
     * @param applicationResourceName Service Fabric application resource name.
     * @param applicationResourceDescription Description for creating an application resource.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> createApplicationResourceAsync(String applicationResourceName, ApplicationResourceDescriptionInner applicationResourceDescription, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(createApplicationResourceWithServiceResponseAsync(applicationResourceName, applicationResourceDescription), serviceCallback);
    }

    /**
     * Creates or updates an application resource.
     * Creates an application with the specified name and description. If an application with the same name already exists, then its description are updated to the one indicated in this request.
     *
     * @param applicationResourceName Service Fabric application resource name.
     * @param applicationResourceDescription Description for creating an application resource.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> createApplicationResourceAsync(String applicationResourceName, ApplicationResourceDescriptionInner applicationResourceDescription) {
        return createApplicationResourceWithServiceResponseAsync(applicationResourceName, applicationResourceDescription).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates or updates an application resource.
     * Creates an application with the specified name and description. If an application with the same name already exists, then its description are updated to the one indicated in this request.
     *
     * @param applicationResourceName Service Fabric application resource name.
     * @param applicationResourceDescription Description for creating an application resource.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> createApplicationResourceWithServiceResponseAsync(String applicationResourceName, ApplicationResourceDescriptionInner applicationResourceDescription) {
        if (applicationResourceName == null) {
            throw new IllegalArgumentException("Parameter applicationResourceName is required and cannot be null.");
        }
        if (applicationResourceDescription == null) {
            throw new IllegalArgumentException("Parameter applicationResourceDescription is required and cannot be null.");
        }
        Validator.validate(applicationResourceDescription);
        final String apiVersion = "6.3-preview";
        return service.createApplicationResource(applicationResourceName, apiVersion, applicationResourceDescription, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = createApplicationResourceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> createApplicationResourceDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(201, new TypeToken<Void>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the application with the given name.
     * Gets the application with the given name. This includes the information about the application's services and other runtime information.
     *
     * @param applicationResourceName Service Fabric application resource name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ApplicationResourceDescriptionInner object if successful.
     */
    public ApplicationResourceDescriptionInner getApplicationResource(String applicationResourceName) {
        return getApplicationResourceWithServiceResponseAsync(applicationResourceName).toBlocking().single().body();
    }

    /**
     * Gets the application with the given name.
     * Gets the application with the given name. This includes the information about the application's services and other runtime information.
     *
     * @param applicationResourceName Service Fabric application resource name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ApplicationResourceDescriptionInner> getApplicationResourceAsync(String applicationResourceName, final ServiceCallback<ApplicationResourceDescriptionInner> serviceCallback) {
        return ServiceFuture.fromResponse(getApplicationResourceWithServiceResponseAsync(applicationResourceName), serviceCallback);
    }

    /**
     * Gets the application with the given name.
     * Gets the application with the given name. This includes the information about the application's services and other runtime information.
     *
     * @param applicationResourceName Service Fabric application resource name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationResourceDescriptionInner object
     */
    public Observable<ApplicationResourceDescriptionInner> getApplicationResourceAsync(String applicationResourceName) {
        return getApplicationResourceWithServiceResponseAsync(applicationResourceName).map(new Func1<ServiceResponse<ApplicationResourceDescriptionInner>, ApplicationResourceDescriptionInner>() {
            @Override
            public ApplicationResourceDescriptionInner call(ServiceResponse<ApplicationResourceDescriptionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the application with the given name.
     * Gets the application with the given name. This includes the information about the application's services and other runtime information.
     *
     * @param applicationResourceName Service Fabric application resource name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationResourceDescriptionInner object
     */
    public Observable<ServiceResponse<ApplicationResourceDescriptionInner>> getApplicationResourceWithServiceResponseAsync(String applicationResourceName) {
        if (applicationResourceName == null) {
            throw new IllegalArgumentException("Parameter applicationResourceName is required and cannot be null.");
        }
        final String apiVersion = "6.3-preview";
        return service.getApplicationResource(applicationResourceName, apiVersion, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ApplicationResourceDescriptionInner>>>() {
                @Override
                public Observable<ServiceResponse<ApplicationResourceDescriptionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ApplicationResourceDescriptionInner> clientResponse = getApplicationResourceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ApplicationResourceDescriptionInner> getApplicationResourceDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ApplicationResourceDescriptionInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ApplicationResourceDescriptionInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Deletes the specified application.
     * Deletes the application identified by the name.
     *
     * @param applicationResourceName Service Fabric application resource name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteApplicationResource(String applicationResourceName) {
        deleteApplicationResourceWithServiceResponseAsync(applicationResourceName).toBlocking().single().body();
    }

    /**
     * Deletes the specified application.
     * Deletes the application identified by the name.
     *
     * @param applicationResourceName Service Fabric application resource name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteApplicationResourceAsync(String applicationResourceName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteApplicationResourceWithServiceResponseAsync(applicationResourceName), serviceCallback);
    }

    /**
     * Deletes the specified application.
     * Deletes the application identified by the name.
     *
     * @param applicationResourceName Service Fabric application resource name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteApplicationResourceAsync(String applicationResourceName) {
        return deleteApplicationResourceWithServiceResponseAsync(applicationResourceName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes the specified application.
     * Deletes the application identified by the name.
     *
     * @param applicationResourceName Service Fabric application resource name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteApplicationResourceWithServiceResponseAsync(String applicationResourceName) {
        if (applicationResourceName == null) {
            throw new IllegalArgumentException("Parameter applicationResourceName is required and cannot be null.");
        }
        final String apiVersion = "6.3-preview";
        return service.deleteApplicationResource(applicationResourceName, apiVersion, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteApplicationResourceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteApplicationResourceDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets all the services in the application resource.
     * The operation returns the service descriptions of all the services in the application resource.
     *
     * @param applicationResourceName Service Fabric application resource name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedServiceResourceDescriptionListInner object if successful.
     */
    public PagedServiceResourceDescriptionListInner getServices(String applicationResourceName) {
        return getServicesWithServiceResponseAsync(applicationResourceName).toBlocking().single().body();
    }

    /**
     * Gets all the services in the application resource.
     * The operation returns the service descriptions of all the services in the application resource.
     *
     * @param applicationResourceName Service Fabric application resource name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedServiceResourceDescriptionListInner> getServicesAsync(String applicationResourceName, final ServiceCallback<PagedServiceResourceDescriptionListInner> serviceCallback) {
        return ServiceFuture.fromResponse(getServicesWithServiceResponseAsync(applicationResourceName), serviceCallback);
    }

    /**
     * Gets all the services in the application resource.
     * The operation returns the service descriptions of all the services in the application resource.
     *
     * @param applicationResourceName Service Fabric application resource name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedServiceResourceDescriptionListInner object
     */
    public Observable<PagedServiceResourceDescriptionListInner> getServicesAsync(String applicationResourceName) {
        return getServicesWithServiceResponseAsync(applicationResourceName).map(new Func1<ServiceResponse<PagedServiceResourceDescriptionListInner>, PagedServiceResourceDescriptionListInner>() {
            @Override
            public PagedServiceResourceDescriptionListInner call(ServiceResponse<PagedServiceResourceDescriptionListInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets all the services in the application resource.
     * The operation returns the service descriptions of all the services in the application resource.
     *
     * @param applicationResourceName Service Fabric application resource name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedServiceResourceDescriptionListInner object
     */
    public Observable<ServiceResponse<PagedServiceResourceDescriptionListInner>> getServicesWithServiceResponseAsync(String applicationResourceName) {
        if (applicationResourceName == null) {
            throw new IllegalArgumentException("Parameter applicationResourceName is required and cannot be null.");
        }
        final String apiVersion = "6.3-preview";
        return service.getServices(applicationResourceName, apiVersion, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedServiceResourceDescriptionListInner>>>() {
                @Override
                public Observable<ServiceResponse<PagedServiceResourceDescriptionListInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedServiceResourceDescriptionListInner> clientResponse = getServicesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PagedServiceResourceDescriptionListInner> getServicesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<PagedServiceResourceDescriptionListInner, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PagedServiceResourceDescriptionListInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the description of the specified service in an application resource.
     * Gets the description of the service resource.
     *
     * @param applicationResourceName Service Fabric application resource name.
     * @param serviceResourceName Service Fabric service resource name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ServiceResourceDescriptionInner object if successful.
     */
    public ServiceResourceDescriptionInner getService(String applicationResourceName, String serviceResourceName) {
        return getServiceWithServiceResponseAsync(applicationResourceName, serviceResourceName).toBlocking().single().body();
    }

    /**
     * Gets the description of the specified service in an application resource.
     * Gets the description of the service resource.
     *
     * @param applicationResourceName Service Fabric application resource name.
     * @param serviceResourceName Service Fabric service resource name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ServiceResourceDescriptionInner> getServiceAsync(String applicationResourceName, String serviceResourceName, final ServiceCallback<ServiceResourceDescriptionInner> serviceCallback) {
        return ServiceFuture.fromResponse(getServiceWithServiceResponseAsync(applicationResourceName, serviceResourceName), serviceCallback);
    }

    /**
     * Gets the description of the specified service in an application resource.
     * Gets the description of the service resource.
     *
     * @param applicationResourceName Service Fabric application resource name.
     * @param serviceResourceName Service Fabric service resource name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServiceResourceDescriptionInner object
     */
    public Observable<ServiceResourceDescriptionInner> getServiceAsync(String applicationResourceName, String serviceResourceName) {
        return getServiceWithServiceResponseAsync(applicationResourceName, serviceResourceName).map(new Func1<ServiceResponse<ServiceResourceDescriptionInner>, ServiceResourceDescriptionInner>() {
            @Override
            public ServiceResourceDescriptionInner call(ServiceResponse<ServiceResourceDescriptionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the description of the specified service in an application resource.
     * Gets the description of the service resource.
     *
     * @param applicationResourceName Service Fabric application resource name.
     * @param serviceResourceName Service Fabric service resource name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServiceResourceDescriptionInner object
     */
    public Observable<ServiceResponse<ServiceResourceDescriptionInner>> getServiceWithServiceResponseAsync(String applicationResourceName, String serviceResourceName) {
        if (applicationResourceName == null) {
            throw new IllegalArgumentException("Parameter applicationResourceName is required and cannot be null.");
        }
        if (serviceResourceName == null) {
            throw new IllegalArgumentException("Parameter serviceResourceName is required and cannot be null.");
        }
        final String apiVersion = "6.3-preview";
        return service.getService(applicationResourceName, serviceResourceName, apiVersion, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ServiceResourceDescriptionInner>>>() {
                @Override
                public Observable<ServiceResponse<ServiceResourceDescriptionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ServiceResourceDescriptionInner> clientResponse = getServiceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ServiceResourceDescriptionInner> getServiceDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ServiceResourceDescriptionInner, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ServiceResourceDescriptionInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets replicas of a given service in an application resource.
     * Gets the information about all replicas of a given service of an application. The information includes the runtime properties of the replica instance.
     *
     * @param applicationResourceName Service Fabric application resource name.
     * @param serviceResourceName Service Fabric service resource name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedServiceResourceReplicaDescriptionListInner object if successful.
     */
    public PagedServiceResourceReplicaDescriptionListInner getReplicas(String applicationResourceName, String serviceResourceName) {
        return getReplicasWithServiceResponseAsync(applicationResourceName, serviceResourceName).toBlocking().single().body();
    }

    /**
     * Gets replicas of a given service in an application resource.
     * Gets the information about all replicas of a given service of an application. The information includes the runtime properties of the replica instance.
     *
     * @param applicationResourceName Service Fabric application resource name.
     * @param serviceResourceName Service Fabric service resource name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedServiceResourceReplicaDescriptionListInner> getReplicasAsync(String applicationResourceName, String serviceResourceName, final ServiceCallback<PagedServiceResourceReplicaDescriptionListInner> serviceCallback) {
        return ServiceFuture.fromResponse(getReplicasWithServiceResponseAsync(applicationResourceName, serviceResourceName), serviceCallback);
    }

    /**
     * Gets replicas of a given service in an application resource.
     * Gets the information about all replicas of a given service of an application. The information includes the runtime properties of the replica instance.
     *
     * @param applicationResourceName Service Fabric application resource name.
     * @param serviceResourceName Service Fabric service resource name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedServiceResourceReplicaDescriptionListInner object
     */
    public Observable<PagedServiceResourceReplicaDescriptionListInner> getReplicasAsync(String applicationResourceName, String serviceResourceName) {
        return getReplicasWithServiceResponseAsync(applicationResourceName, serviceResourceName).map(new Func1<ServiceResponse<PagedServiceResourceReplicaDescriptionListInner>, PagedServiceResourceReplicaDescriptionListInner>() {
            @Override
            public PagedServiceResourceReplicaDescriptionListInner call(ServiceResponse<PagedServiceResourceReplicaDescriptionListInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets replicas of a given service in an application resource.
     * Gets the information about all replicas of a given service of an application. The information includes the runtime properties of the replica instance.
     *
     * @param applicationResourceName Service Fabric application resource name.
     * @param serviceResourceName Service Fabric service resource name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedServiceResourceReplicaDescriptionListInner object
     */
    public Observable<ServiceResponse<PagedServiceResourceReplicaDescriptionListInner>> getReplicasWithServiceResponseAsync(String applicationResourceName, String serviceResourceName) {
        if (applicationResourceName == null) {
            throw new IllegalArgumentException("Parameter applicationResourceName is required and cannot be null.");
        }
        if (serviceResourceName == null) {
            throw new IllegalArgumentException("Parameter serviceResourceName is required and cannot be null.");
        }
        final String apiVersion = "6.3-preview";
        return service.getReplicas(applicationResourceName, serviceResourceName, apiVersion, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedServiceResourceReplicaDescriptionListInner>>>() {
                @Override
                public Observable<ServiceResponse<PagedServiceResourceReplicaDescriptionListInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedServiceResourceReplicaDescriptionListInner> clientResponse = getReplicasDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PagedServiceResourceReplicaDescriptionListInner> getReplicasDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<PagedServiceResourceReplicaDescriptionListInner, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PagedServiceResourceReplicaDescriptionListInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets a specific replica of a given service in an application resource.
     * Gets the information about the specified replica of a given service of an application. The information includes the runtime properties of the replica instance.
     *
     * @param applicationResourceName Service Fabric application resource name.
     * @param serviceResourceName Service Fabric service resource name.
     * @param replicaName Service Fabric replica name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ServiceResourceReplicaDescriptionInner object if successful.
     */
    public ServiceResourceReplicaDescriptionInner getReplica(String applicationResourceName, String serviceResourceName, String replicaName) {
        return getReplicaWithServiceResponseAsync(applicationResourceName, serviceResourceName, replicaName).toBlocking().single().body();
    }

    /**
     * Gets a specific replica of a given service in an application resource.
     * Gets the information about the specified replica of a given service of an application. The information includes the runtime properties of the replica instance.
     *
     * @param applicationResourceName Service Fabric application resource name.
     * @param serviceResourceName Service Fabric service resource name.
     * @param replicaName Service Fabric replica name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ServiceResourceReplicaDescriptionInner> getReplicaAsync(String applicationResourceName, String serviceResourceName, String replicaName, final ServiceCallback<ServiceResourceReplicaDescriptionInner> serviceCallback) {
        return ServiceFuture.fromResponse(getReplicaWithServiceResponseAsync(applicationResourceName, serviceResourceName, replicaName), serviceCallback);
    }

    /**
     * Gets a specific replica of a given service in an application resource.
     * Gets the information about the specified replica of a given service of an application. The information includes the runtime properties of the replica instance.
     *
     * @param applicationResourceName Service Fabric application resource name.
     * @param serviceResourceName Service Fabric service resource name.
     * @param replicaName Service Fabric replica name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServiceResourceReplicaDescriptionInner object
     */
    public Observable<ServiceResourceReplicaDescriptionInner> getReplicaAsync(String applicationResourceName, String serviceResourceName, String replicaName) {
        return getReplicaWithServiceResponseAsync(applicationResourceName, serviceResourceName, replicaName).map(new Func1<ServiceResponse<ServiceResourceReplicaDescriptionInner>, ServiceResourceReplicaDescriptionInner>() {
            @Override
            public ServiceResourceReplicaDescriptionInner call(ServiceResponse<ServiceResourceReplicaDescriptionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a specific replica of a given service in an application resource.
     * Gets the information about the specified replica of a given service of an application. The information includes the runtime properties of the replica instance.
     *
     * @param applicationResourceName Service Fabric application resource name.
     * @param serviceResourceName Service Fabric service resource name.
     * @param replicaName Service Fabric replica name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ServiceResourceReplicaDescriptionInner object
     */
    public Observable<ServiceResponse<ServiceResourceReplicaDescriptionInner>> getReplicaWithServiceResponseAsync(String applicationResourceName, String serviceResourceName, String replicaName) {
        if (applicationResourceName == null) {
            throw new IllegalArgumentException("Parameter applicationResourceName is required and cannot be null.");
        }
        if (serviceResourceName == null) {
            throw new IllegalArgumentException("Parameter serviceResourceName is required and cannot be null.");
        }
        if (replicaName == null) {
            throw new IllegalArgumentException("Parameter replicaName is required and cannot be null.");
        }
        final String apiVersion = "6.3-preview";
        return service.getReplica(applicationResourceName, serviceResourceName, replicaName, apiVersion, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ServiceResourceReplicaDescriptionInner>>>() {
                @Override
                public Observable<ServiceResponse<ServiceResourceReplicaDescriptionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ServiceResourceReplicaDescriptionInner> clientResponse = getReplicaDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ServiceResourceReplicaDescriptionInner> getReplicaDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ServiceResourceReplicaDescriptionInner, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ServiceResourceReplicaDescriptionInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates or updates a volume resource.
     * Creates a volume resource with the specified name and description. If a volume with the same name already exists, then its description is updated to the one indicated in this request.
     *
     * @param volumeResourceName Service Fabric volume resource name.
     * @param volumeResourceDescription Description for creating a volume resource.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void createVolumeResource(String volumeResourceName, VolumeResourceDescriptionInner volumeResourceDescription) {
        createVolumeResourceWithServiceResponseAsync(volumeResourceName, volumeResourceDescription).toBlocking().single().body();
    }

    /**
     * Creates or updates a volume resource.
     * Creates a volume resource with the specified name and description. If a volume with the same name already exists, then its description is updated to the one indicated in this request.
     *
     * @param volumeResourceName Service Fabric volume resource name.
     * @param volumeResourceDescription Description for creating a volume resource.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> createVolumeResourceAsync(String volumeResourceName, VolumeResourceDescriptionInner volumeResourceDescription, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(createVolumeResourceWithServiceResponseAsync(volumeResourceName, volumeResourceDescription), serviceCallback);
    }

    /**
     * Creates or updates a volume resource.
     * Creates a volume resource with the specified name and description. If a volume with the same name already exists, then its description is updated to the one indicated in this request.
     *
     * @param volumeResourceName Service Fabric volume resource name.
     * @param volumeResourceDescription Description for creating a volume resource.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> createVolumeResourceAsync(String volumeResourceName, VolumeResourceDescriptionInner volumeResourceDescription) {
        return createVolumeResourceWithServiceResponseAsync(volumeResourceName, volumeResourceDescription).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates or updates a volume resource.
     * Creates a volume resource with the specified name and description. If a volume with the same name already exists, then its description is updated to the one indicated in this request.
     *
     * @param volumeResourceName Service Fabric volume resource name.
     * @param volumeResourceDescription Description for creating a volume resource.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> createVolumeResourceWithServiceResponseAsync(String volumeResourceName, VolumeResourceDescriptionInner volumeResourceDescription) {
        if (volumeResourceName == null) {
            throw new IllegalArgumentException("Parameter volumeResourceName is required and cannot be null.");
        }
        if (volumeResourceDescription == null) {
            throw new IllegalArgumentException("Parameter volumeResourceDescription is required and cannot be null.");
        }
        Validator.validate(volumeResourceDescription);
        final String apiVersion = "6.3-preview";
        return service.createVolumeResource(volumeResourceName, apiVersion, volumeResourceDescription, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = createVolumeResourceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> createVolumeResourceDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(201, new TypeToken<Void>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Gets the volume resource.
     * Gets the information about the volume resource with a given name. This information includes the volume description and other runtime information.
     *
     * @param volumeResourceName Service Fabric volume resource name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the VolumeResourceDescriptionInner object if successful.
     */
    public VolumeResourceDescriptionInner getVolumeResource(String volumeResourceName) {
        return getVolumeResourceWithServiceResponseAsync(volumeResourceName).toBlocking().single().body();
    }

    /**
     * Gets the volume resource.
     * Gets the information about the volume resource with a given name. This information includes the volume description and other runtime information.
     *
     * @param volumeResourceName Service Fabric volume resource name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<VolumeResourceDescriptionInner> getVolumeResourceAsync(String volumeResourceName, final ServiceCallback<VolumeResourceDescriptionInner> serviceCallback) {
        return ServiceFuture.fromResponse(getVolumeResourceWithServiceResponseAsync(volumeResourceName), serviceCallback);
    }

    /**
     * Gets the volume resource.
     * Gets the information about the volume resource with a given name. This information includes the volume description and other runtime information.
     *
     * @param volumeResourceName Service Fabric volume resource name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VolumeResourceDescriptionInner object
     */
    public Observable<VolumeResourceDescriptionInner> getVolumeResourceAsync(String volumeResourceName) {
        return getVolumeResourceWithServiceResponseAsync(volumeResourceName).map(new Func1<ServiceResponse<VolumeResourceDescriptionInner>, VolumeResourceDescriptionInner>() {
            @Override
            public VolumeResourceDescriptionInner call(ServiceResponse<VolumeResourceDescriptionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the volume resource.
     * Gets the information about the volume resource with a given name. This information includes the volume description and other runtime information.
     *
     * @param volumeResourceName Service Fabric volume resource name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VolumeResourceDescriptionInner object
     */
    public Observable<ServiceResponse<VolumeResourceDescriptionInner>> getVolumeResourceWithServiceResponseAsync(String volumeResourceName) {
        if (volumeResourceName == null) {
            throw new IllegalArgumentException("Parameter volumeResourceName is required and cannot be null.");
        }
        final String apiVersion = "6.3-preview";
        return service.getVolumeResource(volumeResourceName, apiVersion, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VolumeResourceDescriptionInner>>>() {
                @Override
                public Observable<ServiceResponse<VolumeResourceDescriptionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VolumeResourceDescriptionInner> clientResponse = getVolumeResourceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VolumeResourceDescriptionInner> getVolumeResourceDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<VolumeResourceDescriptionInner, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<VolumeResourceDescriptionInner>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

    /**
     * Deletes the volume resource.
     * Deletes the volume identified by the name.
     *
     * @param volumeResourceName Service Fabric volume resource name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws FabricErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteVolumeResource(String volumeResourceName) {
        deleteVolumeResourceWithServiceResponseAsync(volumeResourceName).toBlocking().single().body();
    }

    /**
     * Deletes the volume resource.
     * Deletes the volume identified by the name.
     *
     * @param volumeResourceName Service Fabric volume resource name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteVolumeResourceAsync(String volumeResourceName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteVolumeResourceWithServiceResponseAsync(volumeResourceName), serviceCallback);
    }

    /**
     * Deletes the volume resource.
     * Deletes the volume identified by the name.
     *
     * @param volumeResourceName Service Fabric volume resource name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteVolumeResourceAsync(String volumeResourceName) {
        return deleteVolumeResourceWithServiceResponseAsync(volumeResourceName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes the volume resource.
     * Deletes the volume identified by the name.
     *
     * @param volumeResourceName Service Fabric volume resource name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteVolumeResourceWithServiceResponseAsync(String volumeResourceName) {
        if (volumeResourceName == null) {
            throw new IllegalArgumentException("Parameter volumeResourceName is required and cannot be null.");
        }
        final String apiVersion = "6.3-preview";
        return service.deleteVolumeResource(volumeResourceName, apiVersion, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteVolumeResourceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteVolumeResourceDelegate(Response<ResponseBody> response) throws FabricErrorException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, FabricErrorException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(FabricErrorException.class)
                .build(response);
    }

}
