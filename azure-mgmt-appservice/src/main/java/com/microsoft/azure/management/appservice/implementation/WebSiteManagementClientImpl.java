/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.management.appservice.implementation;

import com.google.common.reflect.TypeToken;
import com.microsoft.azure.AzureClient;
import com.microsoft.azure.AzureServiceCall;
import com.microsoft.azure.AzureServiceClient;
import com.microsoft.azure.CloudException;
import com.microsoft.azure.ListOperationCallback;
import com.microsoft.azure.management.appservice.CheckNameResourceTypes;
import com.microsoft.azure.management.appservice.ResourceNameAvailabilityRequest;
import com.microsoft.azure.management.appservice.SkuName;
import com.microsoft.azure.Page;
import com.microsoft.azure.PagedList;
import com.microsoft.rest.credentials.ServiceClientCredentials;
import com.microsoft.rest.RestClient;
import com.microsoft.rest.ServiceCall;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.List;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.http.Url;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * Initializes a new instance of the WebSiteManagementClientImpl class.
 */
public final class WebSiteManagementClientImpl extends AzureServiceClient {
    /** The Retrofit service to perform REST calls. */
    private WebSiteManagementClientService service;
    /** the {@link AzureClient} used for long running operations. */
    private AzureClient azureClient;

    /**
     * Gets the {@link AzureClient} used for long running operations.
     * @return the azure client;
     */
    public AzureClient getAzureClient() {
        return this.azureClient;
    }

    /** Your Azure subscription ID. This is a GUID-formatted string (e.g. 00000000-0000-0000-0000-000000000000). */
    private String subscriptionId;

    /**
     * Gets Your Azure subscription ID. This is a GUID-formatted string (e.g. 00000000-0000-0000-0000-000000000000).
     *
     * @return the subscriptionId value.
     */
    public String subscriptionId() {
        return this.subscriptionId;
    }

    /**
     * Sets Your Azure subscription ID. This is a GUID-formatted string (e.g. 00000000-0000-0000-0000-000000000000).
     *
     * @param subscriptionId the subscriptionId value.
     * @return the service client itself
     */
    public WebSiteManagementClientImpl withSubscriptionId(String subscriptionId) {
        this.subscriptionId = subscriptionId;
        return this;
    }

    /** Gets or sets the preferred language for the response. */
    private String acceptLanguage;

    /**
     * Gets Gets or sets the preferred language for the response.
     *
     * @return the acceptLanguage value.
     */
    public String acceptLanguage() {
        return this.acceptLanguage;
    }

    /**
     * Sets Gets or sets the preferred language for the response.
     *
     * @param acceptLanguage the acceptLanguage value.
     * @return the service client itself
     */
    public WebSiteManagementClientImpl withAcceptLanguage(String acceptLanguage) {
        this.acceptLanguage = acceptLanguage;
        return this;
    }

    /** Gets or sets the retry timeout in seconds for Long Running Operations. Default value is 30. */
    private int longRunningOperationRetryTimeout;

    /**
     * Gets Gets or sets the retry timeout in seconds for Long Running Operations. Default value is 30.
     *
     * @return the longRunningOperationRetryTimeout value.
     */
    public int longRunningOperationRetryTimeout() {
        return this.longRunningOperationRetryTimeout;
    }

    /**
     * Sets Gets or sets the retry timeout in seconds for Long Running Operations. Default value is 30.
     *
     * @param longRunningOperationRetryTimeout the longRunningOperationRetryTimeout value.
     * @return the service client itself
     */
    public WebSiteManagementClientImpl withLongRunningOperationRetryTimeout(int longRunningOperationRetryTimeout) {
        this.longRunningOperationRetryTimeout = longRunningOperationRetryTimeout;
        return this;
    }

    /** When set to true a unique x-ms-client-request-id value is generated and included in each request. Default is true. */
    private boolean generateClientRequestId;

    /**
     * Gets When set to true a unique x-ms-client-request-id value is generated and included in each request. Default is true.
     *
     * @return the generateClientRequestId value.
     */
    public boolean generateClientRequestId() {
        return this.generateClientRequestId;
    }

    /**
     * Sets When set to true a unique x-ms-client-request-id value is generated and included in each request. Default is true.
     *
     * @param generateClientRequestId the generateClientRequestId value.
     * @return the service client itself
     */
    public WebSiteManagementClientImpl withGenerateClientRequestId(boolean generateClientRequestId) {
        this.generateClientRequestId = generateClientRequestId;
        return this;
    }

    /**
     * The AppServiceCertificateOrdersInner object to access its operations.
     */
    private AppServiceCertificateOrdersInner appServiceCertificateOrders;

    /**
     * Gets the AppServiceCertificateOrdersInner object to access its operations.
     * @return the AppServiceCertificateOrdersInner object.
     */
    public AppServiceCertificateOrdersInner appServiceCertificateOrders() {
        return this.appServiceCertificateOrders;
    }

    /**
     * The AppServiceEnvironmentsInner object to access its operations.
     */
    private AppServiceEnvironmentsInner appServiceEnvironments;

    /**
     * Gets the AppServiceEnvironmentsInner object to access its operations.
     * @return the AppServiceEnvironmentsInner object.
     */
    public AppServiceEnvironmentsInner appServiceEnvironments() {
        return this.appServiceEnvironments;
    }

    /**
     * The AppServicePlansInner object to access its operations.
     */
    private AppServicePlansInner appServicePlans;

    /**
     * Gets the AppServicePlansInner object to access its operations.
     * @return the AppServicePlansInner object.
     */
    public AppServicePlansInner appServicePlans() {
        return this.appServicePlans;
    }

    /**
     * The CertificatesInner object to access its operations.
     */
    private CertificatesInner certificates;

    /**
     * Gets the CertificatesInner object to access its operations.
     * @return the CertificatesInner object.
     */
    public CertificatesInner certificates() {
        return this.certificates;
    }

    /**
     * The DomainsInner object to access its operations.
     */
    private DomainsInner domains;

    /**
     * Gets the DomainsInner object to access its operations.
     * @return the DomainsInner object.
     */
    public DomainsInner domains() {
        return this.domains;
    }

    /**
     * The RecommendationsInner object to access its operations.
     */
    private RecommendationsInner recommendations;

    /**
     * Gets the RecommendationsInner object to access its operations.
     * @return the RecommendationsInner object.
     */
    public RecommendationsInner recommendations() {
        return this.recommendations;
    }

    /**
     * The TopLevelDomainsInner object to access its operations.
     */
    private TopLevelDomainsInner topLevelDomains;

    /**
     * Gets the TopLevelDomainsInner object to access its operations.
     * @return the TopLevelDomainsInner object.
     */
    public TopLevelDomainsInner topLevelDomains() {
        return this.topLevelDomains;
    }

    /**
     * The WebAppsInner object to access its operations.
     */
    private WebAppsInner webApps;

    /**
     * Gets the WebAppsInner object to access its operations.
     * @return the WebAppsInner object.
     */
    public WebAppsInner webApps() {
        return this.webApps;
    }

    /**
     * The DeletedWebAppsInner object to access its operations.
     */
    private DeletedWebAppsInner deletedWebApps;

    /**
     * Gets the DeletedWebAppsInner object to access its operations.
     * @return the DeletedWebAppsInner object.
     */
    public DeletedWebAppsInner deletedWebApps() {
        return this.deletedWebApps;
    }

    /**
     * Initializes an instance of WebSiteManagementClient client.
     *
     * @param credentials the management credentials for Azure
     */
    public WebSiteManagementClientImpl(ServiceClientCredentials credentials) {
        this("https://management.azure.com", credentials);
    }

    /**
     * Initializes an instance of WebSiteManagementClient client.
     *
     * @param baseUrl the base URL of the host
     * @param credentials the management credentials for Azure
     */
    public WebSiteManagementClientImpl(String baseUrl, ServiceClientCredentials credentials) {
        super(baseUrl, credentials);
        initialize();
    }

    /**
     * Initializes an instance of WebSiteManagementClient client.
     *
     * @param restClient the REST client to connect to Azure.
     */
    public WebSiteManagementClientImpl(RestClient restClient) {
        super(restClient);
        initialize();
    }

    protected void initialize() {
        this.acceptLanguage = "en-US";
        this.longRunningOperationRetryTimeout = 30;
        this.generateClientRequestId = true;
        this.appServiceCertificateOrders = new AppServiceCertificateOrdersInner(restClient().retrofit(), this);
        this.appServiceEnvironments = new AppServiceEnvironmentsInner(restClient().retrofit(), this);
        this.appServicePlans = new AppServicePlansInner(restClient().retrofit(), this);
        this.certificates = new CertificatesInner(restClient().retrofit(), this);
        this.domains = new DomainsInner(restClient().retrofit(), this);
        this.recommendations = new RecommendationsInner(restClient().retrofit(), this);
        this.topLevelDomains = new TopLevelDomainsInner(restClient().retrofit(), this);
        this.webApps = new WebAppsInner(restClient().retrofit(), this);
        this.deletedWebApps = new DeletedWebAppsInner(restClient().retrofit(), this);
        this.azureClient = new AzureClient(this);
        initializeService();
    }

    /**
     * Gets the User-Agent header for the client.
     *
     * @return the user agent string.
     */
    @Override
    public String userAgent() {
        return String.format("Azure-SDK-For-Java/%s (%s)",
                getClass().getPackage().getImplementationVersion(),
                "WebSiteManagementClient, ");
    }

    private void initializeService() {
        service = restClient().retrofit().create(WebSiteManagementClientService.class);
    }

    /**
     * The interface defining all the services for WebSiteManagementClient to be
     * used by Retrofit to perform actually REST calls.
     */
    interface WebSiteManagementClientService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebSiteManagementClient listSourceControls" })
        @GET("providers/Microsoft.Web/sourcecontrols")
        Observable<Response<ResponseBody>> listSourceControls(@Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebSiteManagementClient updateSourceControl" })
        @PUT("providers/Microsoft.Web/sourcecontrols/{sourceControlType}")
        Observable<Response<ResponseBody>> updateSourceControl(@Path("sourceControlType") String sourceControlType, @Body SourceControlInner requestMessage, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebSiteManagementClient checkNameAvailability" })
        @POST("subscriptions/{subscriptionId}/providers/Microsoft.Web/checknameavailability")
        Observable<Response<ResponseBody>> checkNameAvailability(@Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body ResourceNameAvailabilityRequest request, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebSiteManagementClient listGeoRegions" })
        @POST("subscriptions/{subscriptionId}/providers/Microsoft.Web/geoRegions")
        Observable<Response<ResponseBody>> listGeoRegions(@Path("subscriptionId") String subscriptionId, @Query("sku") SkuName sku, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebSiteManagementClient listPremierAddOnOffers" })
        @GET("subscriptions/{subscriptionId}/providers/Microsoft.Web/premieraddonoffers")
        Observable<Response<ResponseBody>> listPremierAddOnOffers(@Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebSiteManagementClient getPublishingCredentials" })
        @GET("subscriptions/{subscriptionId}/providers/Microsoft.Web/publishingCredentials")
        Observable<Response<ResponseBody>> getPublishingCredentials(@Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebSiteManagementClient updatePublishingCredentials" })
        @PUT("subscriptions/{subscriptionId}/providers/Microsoft.Web/publishingCredentials")
        Observable<Response<ResponseBody>> updatePublishingCredentials(@Path("subscriptionId") String subscriptionId, @Body UserInner requestMessage, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebSiteManagementClient listSkus" })
        @GET("subscriptions/{subscriptionId}/providers/Microsoft.Web/skus")
        Observable<Response<ResponseBody>> listSkus(@Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebSiteManagementClient move" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/moveResources")
        Observable<Response<ResponseBody>> move(@Path("resourceGroupName") String resourceGroupName, @Path("subscriptionId") String subscriptionId, @Body CsmMoveResourceEnvelopeInner moveResourceEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebSiteManagementClient validate" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/validate")
        Observable<Response<ResponseBody>> validate(@Path("resourceGroupName") String resourceGroupName, @Path("subscriptionId") String subscriptionId, @Body ValidateRequestInner validateRequest, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebSiteManagementClient validateMove" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/validateMoveResources")
        Observable<Response<ResponseBody>> validateMove(@Path("resourceGroupName") String resourceGroupName, @Path("subscriptionId") String subscriptionId, @Body CsmMoveResourceEnvelopeInner moveResourceEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebSiteManagementClient listSourceControlsNext" })
        @GET
        Observable<Response<ResponseBody>> listSourceControlsNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebSiteManagementClient listGeoRegionsNext" })
        @GET
        Observable<Response<ResponseBody>> listGeoRegionsNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebSiteManagementClient listPremierAddOnOffersNext" })
        @GET
        Observable<Response<ResponseBody>> listPremierAddOnOffersNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

    }

    /**
     * Gets the source controls available for Azure websites.
     * Gets the source controls available for Azure websites.
     *
     * @return the PagedList&lt;SourceControlInner&gt; object if successful.
     */
    public PagedList<SourceControlInner> listSourceControls() {
        ServiceResponse<Page<SourceControlInner>> response = listSourceControlsSinglePageAsync().toBlocking().single();
        return new PagedList<SourceControlInner>(response.body()) {
            @Override
            public Page<SourceControlInner> nextPage(String nextPageLink) {
                return listSourceControlsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the source controls available for Azure websites.
     * Gets the source controls available for Azure websites.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SourceControlInner>> listSourceControlsAsync(final ListOperationCallback<SourceControlInner> serviceCallback) {
        return AzureServiceCall.fromPageResponse(
            listSourceControlsSinglePageAsync(),
            new Func1<String, Observable<ServiceResponse<Page<SourceControlInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SourceControlInner>>> call(String nextPageLink) {
                    return listSourceControlsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the source controls available for Azure websites.
     * Gets the source controls available for Azure websites.
     *
     * @return the observable to the PagedList&lt;SourceControlInner&gt; object
     */
    public Observable<Page<SourceControlInner>> listSourceControlsAsync() {
        return listSourceControlsWithServiceResponseAsync()
            .map(new Func1<ServiceResponse<Page<SourceControlInner>>, Page<SourceControlInner>>() {
                @Override
                public Page<SourceControlInner> call(ServiceResponse<Page<SourceControlInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the source controls available for Azure websites.
     * Gets the source controls available for Azure websites.
     *
     * @return the observable to the PagedList&lt;SourceControlInner&gt; object
     */
    public Observable<ServiceResponse<Page<SourceControlInner>>> listSourceControlsWithServiceResponseAsync() {
        return listSourceControlsSinglePageAsync()
            .concatMap(new Func1<ServiceResponse<Page<SourceControlInner>>, Observable<ServiceResponse<Page<SourceControlInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SourceControlInner>>> call(ServiceResponse<Page<SourceControlInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listSourceControlsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the source controls available for Azure websites.
     * Gets the source controls available for Azure websites.
     *
     * @return the PagedList&lt;SourceControlInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SourceControlInner>>> listSourceControlsSinglePageAsync() {
        final String apiVersion = "2016-03-01";
        return service.listSourceControls(apiVersion, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SourceControlInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SourceControlInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SourceControlInner>> result = listSourceControlsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SourceControlInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SourceControlInner>> listSourceControlsDelegate(Response<ResponseBody> response) throws CloudException, IOException {
        return this.restClient().responseBuilderFactory().<PageImpl<SourceControlInner>, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SourceControlInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates source control token.
     * Updates source control token.
     *
     * @param sourceControlType Type of source control
     * @param requestMessage Source control token information
     * @return the SourceControlInner object if successful.
     */
    public SourceControlInner updateSourceControl(String sourceControlType, SourceControlInner requestMessage) {
        return updateSourceControlWithServiceResponseAsync(sourceControlType, requestMessage).toBlocking().single().body();
    }

    /**
     * Updates source control token.
     * Updates source control token.
     *
     * @param sourceControlType Type of source control
     * @param requestMessage Source control token information
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SourceControlInner> updateSourceControlAsync(String sourceControlType, SourceControlInner requestMessage, final ServiceCallback<SourceControlInner> serviceCallback) {
        return ServiceCall.fromResponse(updateSourceControlWithServiceResponseAsync(sourceControlType, requestMessage), serviceCallback);
    }

    /**
     * Updates source control token.
     * Updates source control token.
     *
     * @param sourceControlType Type of source control
     * @param requestMessage Source control token information
     * @return the observable to the SourceControlInner object
     */
    public Observable<SourceControlInner> updateSourceControlAsync(String sourceControlType, SourceControlInner requestMessage) {
        return updateSourceControlWithServiceResponseAsync(sourceControlType, requestMessage).map(new Func1<ServiceResponse<SourceControlInner>, SourceControlInner>() {
            @Override
            public SourceControlInner call(ServiceResponse<SourceControlInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates source control token.
     * Updates source control token.
     *
     * @param sourceControlType Type of source control
     * @param requestMessage Source control token information
     * @return the observable to the SourceControlInner object
     */
    public Observable<ServiceResponse<SourceControlInner>> updateSourceControlWithServiceResponseAsync(String sourceControlType, SourceControlInner requestMessage) {
        if (sourceControlType == null) {
            throw new IllegalArgumentException("Parameter sourceControlType is required and cannot be null.");
        }
        if (requestMessage == null) {
            throw new IllegalArgumentException("Parameter requestMessage is required and cannot be null.");
        }
        Validator.validate(requestMessage);
        final String apiVersion = "2016-03-01";
        return service.updateSourceControl(sourceControlType, requestMessage, apiVersion, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SourceControlInner>>>() {
                @Override
                public Observable<ServiceResponse<SourceControlInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SourceControlInner> clientResponse = updateSourceControlDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SourceControlInner> updateSourceControlDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<SourceControlInner, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<SourceControlInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Check if a resource name is available.
     * Check if a resource name is available.
     *
     * @param name Resource name to verify.
     * @param type Resource type used for verification. Possible values include: 'Site', 'Slot', 'HostingEnvironment'
     * @return the ResourceNameAvailabilityInner object if successful.
     */
    public ResourceNameAvailabilityInner checkNameAvailability(String name, CheckNameResourceTypes type) {
        return checkNameAvailabilityWithServiceResponseAsync(name, type).toBlocking().single().body();
    }

    /**
     * Check if a resource name is available.
     * Check if a resource name is available.
     *
     * @param name Resource name to verify.
     * @param type Resource type used for verification. Possible values include: 'Site', 'Slot', 'HostingEnvironment'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<ResourceNameAvailabilityInner> checkNameAvailabilityAsync(String name, CheckNameResourceTypes type, final ServiceCallback<ResourceNameAvailabilityInner> serviceCallback) {
        return ServiceCall.fromResponse(checkNameAvailabilityWithServiceResponseAsync(name, type), serviceCallback);
    }

    /**
     * Check if a resource name is available.
     * Check if a resource name is available.
     *
     * @param name Resource name to verify.
     * @param type Resource type used for verification. Possible values include: 'Site', 'Slot', 'HostingEnvironment'
     * @return the observable to the ResourceNameAvailabilityInner object
     */
    public Observable<ResourceNameAvailabilityInner> checkNameAvailabilityAsync(String name, CheckNameResourceTypes type) {
        return checkNameAvailabilityWithServiceResponseAsync(name, type).map(new Func1<ServiceResponse<ResourceNameAvailabilityInner>, ResourceNameAvailabilityInner>() {
            @Override
            public ResourceNameAvailabilityInner call(ServiceResponse<ResourceNameAvailabilityInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Check if a resource name is available.
     * Check if a resource name is available.
     *
     * @param name Resource name to verify.
     * @param type Resource type used for verification. Possible values include: 'Site', 'Slot', 'HostingEnvironment'
     * @return the observable to the ResourceNameAvailabilityInner object
     */
    public Observable<ServiceResponse<ResourceNameAvailabilityInner>> checkNameAvailabilityWithServiceResponseAsync(String name, CheckNameResourceTypes type) {
        if (this.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.subscriptionId() is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (type == null) {
            throw new IllegalArgumentException("Parameter type is required and cannot be null.");
        }
        final String apiVersion = "2016-03-01";
        final Boolean isFqdn = null;
        ResourceNameAvailabilityRequest request = new ResourceNameAvailabilityRequest();
        request.withName(name);
        request.withType(type);
        request.withIsFqdn(null);
        return service.checkNameAvailability(this.subscriptionId(), apiVersion, this.acceptLanguage(), request, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ResourceNameAvailabilityInner>>>() {
                @Override
                public Observable<ServiceResponse<ResourceNameAvailabilityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ResourceNameAvailabilityInner> clientResponse = checkNameAvailabilityDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Check if a resource name is available.
     * Check if a resource name is available.
     *
     * @param name Resource name to verify.
     * @param type Resource type used for verification. Possible values include: 'Site', 'Slot', 'HostingEnvironment'
     * @param isFqdn Is fully qualified domain name.
     * @return the ResourceNameAvailabilityInner object if successful.
     */
    public ResourceNameAvailabilityInner checkNameAvailability(String name, CheckNameResourceTypes type, Boolean isFqdn) {
        return checkNameAvailabilityWithServiceResponseAsync(name, type, isFqdn).toBlocking().single().body();
    }

    /**
     * Check if a resource name is available.
     * Check if a resource name is available.
     *
     * @param name Resource name to verify.
     * @param type Resource type used for verification. Possible values include: 'Site', 'Slot', 'HostingEnvironment'
     * @param isFqdn Is fully qualified domain name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<ResourceNameAvailabilityInner> checkNameAvailabilityAsync(String name, CheckNameResourceTypes type, Boolean isFqdn, final ServiceCallback<ResourceNameAvailabilityInner> serviceCallback) {
        return ServiceCall.fromResponse(checkNameAvailabilityWithServiceResponseAsync(name, type, isFqdn), serviceCallback);
    }

    /**
     * Check if a resource name is available.
     * Check if a resource name is available.
     *
     * @param name Resource name to verify.
     * @param type Resource type used for verification. Possible values include: 'Site', 'Slot', 'HostingEnvironment'
     * @param isFqdn Is fully qualified domain name.
     * @return the observable to the ResourceNameAvailabilityInner object
     */
    public Observable<ResourceNameAvailabilityInner> checkNameAvailabilityAsync(String name, CheckNameResourceTypes type, Boolean isFqdn) {
        return checkNameAvailabilityWithServiceResponseAsync(name, type, isFqdn).map(new Func1<ServiceResponse<ResourceNameAvailabilityInner>, ResourceNameAvailabilityInner>() {
            @Override
            public ResourceNameAvailabilityInner call(ServiceResponse<ResourceNameAvailabilityInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Check if a resource name is available.
     * Check if a resource name is available.
     *
     * @param name Resource name to verify.
     * @param type Resource type used for verification. Possible values include: 'Site', 'Slot', 'HostingEnvironment'
     * @param isFqdn Is fully qualified domain name.
     * @return the observable to the ResourceNameAvailabilityInner object
     */
    public Observable<ServiceResponse<ResourceNameAvailabilityInner>> checkNameAvailabilityWithServiceResponseAsync(String name, CheckNameResourceTypes type, Boolean isFqdn) {
        if (this.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.subscriptionId() is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (type == null) {
            throw new IllegalArgumentException("Parameter type is required and cannot be null.");
        }
        final String apiVersion = "2016-03-01";
        ResourceNameAvailabilityRequest request = new ResourceNameAvailabilityRequest();
        request.withName(name);
        request.withType(type);
        request.withIsFqdn(isFqdn);
        return service.checkNameAvailability(this.subscriptionId(), apiVersion, this.acceptLanguage(), request, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ResourceNameAvailabilityInner>>>() {
                @Override
                public Observable<ServiceResponse<ResourceNameAvailabilityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ResourceNameAvailabilityInner> clientResponse = checkNameAvailabilityDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ResourceNameAvailabilityInner> checkNameAvailabilityDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ResourceNameAvailabilityInner, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ResourceNameAvailabilityInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get a list of available geographical regions.
     * Get a list of available geographical regions.
     *
     * @return the PagedList&lt;GeoRegionInner&gt; object if successful.
     */
    public PagedList<GeoRegionInner> listGeoRegions() {
        ServiceResponse<Page<GeoRegionInner>> response = listGeoRegionsSinglePageAsync().toBlocking().single();
        return new PagedList<GeoRegionInner>(response.body()) {
            @Override
            public Page<GeoRegionInner> nextPage(String nextPageLink) {
                return listGeoRegionsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get a list of available geographical regions.
     * Get a list of available geographical regions.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<GeoRegionInner>> listGeoRegionsAsync(final ListOperationCallback<GeoRegionInner> serviceCallback) {
        return AzureServiceCall.fromPageResponse(
            listGeoRegionsSinglePageAsync(),
            new Func1<String, Observable<ServiceResponse<Page<GeoRegionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<GeoRegionInner>>> call(String nextPageLink) {
                    return listGeoRegionsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get a list of available geographical regions.
     * Get a list of available geographical regions.
     *
     * @return the observable to the PagedList&lt;GeoRegionInner&gt; object
     */
    public Observable<Page<GeoRegionInner>> listGeoRegionsAsync() {
        return listGeoRegionsWithServiceResponseAsync()
            .map(new Func1<ServiceResponse<Page<GeoRegionInner>>, Page<GeoRegionInner>>() {
                @Override
                public Page<GeoRegionInner> call(ServiceResponse<Page<GeoRegionInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get a list of available geographical regions.
     * Get a list of available geographical regions.
     *
     * @return the observable to the PagedList&lt;GeoRegionInner&gt; object
     */
    public Observable<ServiceResponse<Page<GeoRegionInner>>> listGeoRegionsWithServiceResponseAsync() {
        return listGeoRegionsSinglePageAsync()
            .concatMap(new Func1<ServiceResponse<Page<GeoRegionInner>>, Observable<ServiceResponse<Page<GeoRegionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<GeoRegionInner>>> call(ServiceResponse<Page<GeoRegionInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listGeoRegionsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get a list of available geographical regions.
     * Get a list of available geographical regions.
     *
     * @return the PagedList&lt;GeoRegionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<GeoRegionInner>>> listGeoRegionsSinglePageAsync() {
        if (this.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-03-01";
        final SkuName sku = null;
        return service.listGeoRegions(this.subscriptionId(), sku, apiVersion, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<GeoRegionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<GeoRegionInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<GeoRegionInner>> result = listGeoRegionsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<GeoRegionInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get a list of available geographical regions.
     * Get a list of available geographical regions.
     *
     * @param sku Name of SKU used to filter the regions. Possible values include: 'Free', 'Shared', 'Basic', 'Standard', 'Premium', 'Dynamic'
     * @return the PagedList&lt;GeoRegionInner&gt; object if successful.
     */
    public PagedList<GeoRegionInner> listGeoRegions(final SkuName sku) {
        ServiceResponse<Page<GeoRegionInner>> response = listGeoRegionsSinglePageAsync(sku).toBlocking().single();
        return new PagedList<GeoRegionInner>(response.body()) {
            @Override
            public Page<GeoRegionInner> nextPage(String nextPageLink) {
                return listGeoRegionsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get a list of available geographical regions.
     * Get a list of available geographical regions.
     *
     * @param sku Name of SKU used to filter the regions. Possible values include: 'Free', 'Shared', 'Basic', 'Standard', 'Premium', 'Dynamic'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<GeoRegionInner>> listGeoRegionsAsync(final SkuName sku, final ListOperationCallback<GeoRegionInner> serviceCallback) {
        return AzureServiceCall.fromPageResponse(
            listGeoRegionsSinglePageAsync(sku),
            new Func1<String, Observable<ServiceResponse<Page<GeoRegionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<GeoRegionInner>>> call(String nextPageLink) {
                    return listGeoRegionsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get a list of available geographical regions.
     * Get a list of available geographical regions.
     *
     * @param sku Name of SKU used to filter the regions. Possible values include: 'Free', 'Shared', 'Basic', 'Standard', 'Premium', 'Dynamic'
     * @return the observable to the PagedList&lt;GeoRegionInner&gt; object
     */
    public Observable<Page<GeoRegionInner>> listGeoRegionsAsync(final SkuName sku) {
        return listGeoRegionsWithServiceResponseAsync(sku)
            .map(new Func1<ServiceResponse<Page<GeoRegionInner>>, Page<GeoRegionInner>>() {
                @Override
                public Page<GeoRegionInner> call(ServiceResponse<Page<GeoRegionInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get a list of available geographical regions.
     * Get a list of available geographical regions.
     *
     * @param sku Name of SKU used to filter the regions. Possible values include: 'Free', 'Shared', 'Basic', 'Standard', 'Premium', 'Dynamic'
     * @return the observable to the PagedList&lt;GeoRegionInner&gt; object
     */
    public Observable<ServiceResponse<Page<GeoRegionInner>>> listGeoRegionsWithServiceResponseAsync(final SkuName sku) {
        return listGeoRegionsSinglePageAsync(sku)
            .concatMap(new Func1<ServiceResponse<Page<GeoRegionInner>>, Observable<ServiceResponse<Page<GeoRegionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<GeoRegionInner>>> call(ServiceResponse<Page<GeoRegionInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listGeoRegionsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get a list of available geographical regions.
     * Get a list of available geographical regions.
     *
    ServiceResponse<PageImpl<GeoRegionInner>> * @param sku Name of SKU used to filter the regions. Possible values include: 'Free', 'Shared', 'Basic', 'Standard', 'Premium', 'Dynamic'
     * @return the PagedList&lt;GeoRegionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<GeoRegionInner>>> listGeoRegionsSinglePageAsync(final SkuName sku) {
        if (this.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-03-01";
        return service.listGeoRegions(this.subscriptionId(), sku, apiVersion, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<GeoRegionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<GeoRegionInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<GeoRegionInner>> result = listGeoRegionsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<GeoRegionInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<GeoRegionInner>> listGeoRegionsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<PageImpl<GeoRegionInner>, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PageImpl<GeoRegionInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List all premier add-on offers.
     * List all premier add-on offers.
     *
     * @return the PagedList&lt;PremierAddOnOfferInner&gt; object if successful.
     */
    public PagedList<PremierAddOnOfferInner> listPremierAddOnOffers() {
        ServiceResponse<Page<PremierAddOnOfferInner>> response = listPremierAddOnOffersSinglePageAsync().toBlocking().single();
        return new PagedList<PremierAddOnOfferInner>(response.body()) {
            @Override
            public Page<PremierAddOnOfferInner> nextPage(String nextPageLink) {
                return listPremierAddOnOffersNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List all premier add-on offers.
     * List all premier add-on offers.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<PremierAddOnOfferInner>> listPremierAddOnOffersAsync(final ListOperationCallback<PremierAddOnOfferInner> serviceCallback) {
        return AzureServiceCall.fromPageResponse(
            listPremierAddOnOffersSinglePageAsync(),
            new Func1<String, Observable<ServiceResponse<Page<PremierAddOnOfferInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PremierAddOnOfferInner>>> call(String nextPageLink) {
                    return listPremierAddOnOffersNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List all premier add-on offers.
     * List all premier add-on offers.
     *
     * @return the observable to the PagedList&lt;PremierAddOnOfferInner&gt; object
     */
    public Observable<Page<PremierAddOnOfferInner>> listPremierAddOnOffersAsync() {
        return listPremierAddOnOffersWithServiceResponseAsync()
            .map(new Func1<ServiceResponse<Page<PremierAddOnOfferInner>>, Page<PremierAddOnOfferInner>>() {
                @Override
                public Page<PremierAddOnOfferInner> call(ServiceResponse<Page<PremierAddOnOfferInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List all premier add-on offers.
     * List all premier add-on offers.
     *
     * @return the observable to the PagedList&lt;PremierAddOnOfferInner&gt; object
     */
    public Observable<ServiceResponse<Page<PremierAddOnOfferInner>>> listPremierAddOnOffersWithServiceResponseAsync() {
        return listPremierAddOnOffersSinglePageAsync()
            .concatMap(new Func1<ServiceResponse<Page<PremierAddOnOfferInner>>, Observable<ServiceResponse<Page<PremierAddOnOfferInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PremierAddOnOfferInner>>> call(ServiceResponse<Page<PremierAddOnOfferInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listPremierAddOnOffersNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List all premier add-on offers.
     * List all premier add-on offers.
     *
     * @return the PagedList&lt;PremierAddOnOfferInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<PremierAddOnOfferInner>>> listPremierAddOnOffersSinglePageAsync() {
        if (this.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-03-01";
        return service.listPremierAddOnOffers(this.subscriptionId(), apiVersion, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<PremierAddOnOfferInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PremierAddOnOfferInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<PremierAddOnOfferInner>> result = listPremierAddOnOffersDelegate(response);
                        return Observable.just(new ServiceResponse<Page<PremierAddOnOfferInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<PremierAddOnOfferInner>> listPremierAddOnOffersDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<PageImpl<PremierAddOnOfferInner>, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PageImpl<PremierAddOnOfferInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the publishing credentials for the subscription owner.
     * Get the publishing credentials for the subscription owner.
     *
     * @return the UserInner object if successful.
     */
    public UserInner getPublishingCredentials() {
        return getPublishingCredentialsWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get the publishing credentials for the subscription owner.
     * Get the publishing credentials for the subscription owner.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<UserInner> getPublishingCredentialsAsync(final ServiceCallback<UserInner> serviceCallback) {
        return ServiceCall.fromResponse(getPublishingCredentialsWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get the publishing credentials for the subscription owner.
     * Get the publishing credentials for the subscription owner.
     *
     * @return the observable to the UserInner object
     */
    public Observable<UserInner> getPublishingCredentialsAsync() {
        return getPublishingCredentialsWithServiceResponseAsync().map(new Func1<ServiceResponse<UserInner>, UserInner>() {
            @Override
            public UserInner call(ServiceResponse<UserInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get the publishing credentials for the subscription owner.
     * Get the publishing credentials for the subscription owner.
     *
     * @return the observable to the UserInner object
     */
    public Observable<ServiceResponse<UserInner>> getPublishingCredentialsWithServiceResponseAsync() {
        if (this.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-03-01";
        return service.getPublishingCredentials(this.subscriptionId(), apiVersion, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UserInner>>>() {
                @Override
                public Observable<ServiceResponse<UserInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UserInner> clientResponse = getPublishingCredentialsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<UserInner> getPublishingCredentialsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<UserInner, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<UserInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Update the publishing credentials for the subscription owner.
     * Update the publishing credentials for the subscription owner.
     *
     * @param requestMessage A request message with the new publishing credentials.
     * @return the UserInner object if successful.
     */
    public UserInner updatePublishingCredentials(UserInner requestMessage) {
        return updatePublishingCredentialsWithServiceResponseAsync(requestMessage).toBlocking().single().body();
    }

    /**
     * Update the publishing credentials for the subscription owner.
     * Update the publishing credentials for the subscription owner.
     *
     * @param requestMessage A request message with the new publishing credentials.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<UserInner> updatePublishingCredentialsAsync(UserInner requestMessage, final ServiceCallback<UserInner> serviceCallback) {
        return ServiceCall.fromResponse(updatePublishingCredentialsWithServiceResponseAsync(requestMessage), serviceCallback);
    }

    /**
     * Update the publishing credentials for the subscription owner.
     * Update the publishing credentials for the subscription owner.
     *
     * @param requestMessage A request message with the new publishing credentials.
     * @return the observable to the UserInner object
     */
    public Observable<UserInner> updatePublishingCredentialsAsync(UserInner requestMessage) {
        return updatePublishingCredentialsWithServiceResponseAsync(requestMessage).map(new Func1<ServiceResponse<UserInner>, UserInner>() {
            @Override
            public UserInner call(ServiceResponse<UserInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Update the publishing credentials for the subscription owner.
     * Update the publishing credentials for the subscription owner.
     *
     * @param requestMessage A request message with the new publishing credentials.
     * @return the observable to the UserInner object
     */
    public Observable<ServiceResponse<UserInner>> updatePublishingCredentialsWithServiceResponseAsync(UserInner requestMessage) {
        if (this.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.subscriptionId() is required and cannot be null.");
        }
        if (requestMessage == null) {
            throw new IllegalArgumentException("Parameter requestMessage is required and cannot be null.");
        }
        Validator.validate(requestMessage);
        final String apiVersion = "2016-03-01";
        return service.updatePublishingCredentials(this.subscriptionId(), requestMessage, apiVersion, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UserInner>>>() {
                @Override
                public Observable<ServiceResponse<UserInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UserInner> clientResponse = updatePublishingCredentialsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<UserInner> updatePublishingCredentialsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<UserInner, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<UserInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List all SKUs.
     * List all SKUs.
     *
     * @return the SkuInfosInner object if successful.
     */
    public SkuInfosInner listSkus() {
        return listSkusWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * List all SKUs.
     * List all SKUs.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SkuInfosInner> listSkusAsync(final ServiceCallback<SkuInfosInner> serviceCallback) {
        return ServiceCall.fromResponse(listSkusWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * List all SKUs.
     * List all SKUs.
     *
     * @return the observable to the SkuInfosInner object
     */
    public Observable<SkuInfosInner> listSkusAsync() {
        return listSkusWithServiceResponseAsync().map(new Func1<ServiceResponse<SkuInfosInner>, SkuInfosInner>() {
            @Override
            public SkuInfosInner call(ServiceResponse<SkuInfosInner> response) {
                return response.body();
            }
        });
    }

    /**
     * List all SKUs.
     * List all SKUs.
     *
     * @return the observable to the SkuInfosInner object
     */
    public Observable<ServiceResponse<SkuInfosInner>> listSkusWithServiceResponseAsync() {
        if (this.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-03-01";
        return service.listSkus(this.subscriptionId(), apiVersion, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SkuInfosInner>>>() {
                @Override
                public Observable<ServiceResponse<SkuInfosInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SkuInfosInner> clientResponse = listSkusDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SkuInfosInner> listSkusDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<SkuInfosInner, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<SkuInfosInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Move resources between resource groups.
     * Move resources between resource groups.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param moveResourceEnvelope Object that represents the resource to move.
     */
    public void move(String resourceGroupName, CsmMoveResourceEnvelopeInner moveResourceEnvelope) {
        moveWithServiceResponseAsync(resourceGroupName, moveResourceEnvelope).toBlocking().single().body();
    }

    /**
     * Move resources between resource groups.
     * Move resources between resource groups.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param moveResourceEnvelope Object that represents the resource to move.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> moveAsync(String resourceGroupName, CsmMoveResourceEnvelopeInner moveResourceEnvelope, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.fromResponse(moveWithServiceResponseAsync(resourceGroupName, moveResourceEnvelope), serviceCallback);
    }

    /**
     * Move resources between resource groups.
     * Move resources between resource groups.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param moveResourceEnvelope Object that represents the resource to move.
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> moveAsync(String resourceGroupName, CsmMoveResourceEnvelopeInner moveResourceEnvelope) {
        return moveWithServiceResponseAsync(resourceGroupName, moveResourceEnvelope).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Move resources between resource groups.
     * Move resources between resource groups.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param moveResourceEnvelope Object that represents the resource to move.
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> moveWithServiceResponseAsync(String resourceGroupName, CsmMoveResourceEnvelopeInner moveResourceEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.subscriptionId() is required and cannot be null.");
        }
        if (moveResourceEnvelope == null) {
            throw new IllegalArgumentException("Parameter moveResourceEnvelope is required and cannot be null.");
        }
        Validator.validate(moveResourceEnvelope);
        final String apiVersion = "2016-03-01";
        return service.move(resourceGroupName, this.subscriptionId(), moveResourceEnvelope, apiVersion, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = moveDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> moveDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Validate if a resource can be created.
     * Validate if a resource can be created.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param validateRequest Request with the resources to validate.
     * @return the ValidateResponseInner object if successful.
     */
    public ValidateResponseInner validate(String resourceGroupName, ValidateRequestInner validateRequest) {
        return validateWithServiceResponseAsync(resourceGroupName, validateRequest).toBlocking().single().body();
    }

    /**
     * Validate if a resource can be created.
     * Validate if a resource can be created.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param validateRequest Request with the resources to validate.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<ValidateResponseInner> validateAsync(String resourceGroupName, ValidateRequestInner validateRequest, final ServiceCallback<ValidateResponseInner> serviceCallback) {
        return ServiceCall.fromResponse(validateWithServiceResponseAsync(resourceGroupName, validateRequest), serviceCallback);
    }

    /**
     * Validate if a resource can be created.
     * Validate if a resource can be created.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param validateRequest Request with the resources to validate.
     * @return the observable to the ValidateResponseInner object
     */
    public Observable<ValidateResponseInner> validateAsync(String resourceGroupName, ValidateRequestInner validateRequest) {
        return validateWithServiceResponseAsync(resourceGroupName, validateRequest).map(new Func1<ServiceResponse<ValidateResponseInner>, ValidateResponseInner>() {
            @Override
            public ValidateResponseInner call(ServiceResponse<ValidateResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Validate if a resource can be created.
     * Validate if a resource can be created.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param validateRequest Request with the resources to validate.
     * @return the observable to the ValidateResponseInner object
     */
    public Observable<ServiceResponse<ValidateResponseInner>> validateWithServiceResponseAsync(String resourceGroupName, ValidateRequestInner validateRequest) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.subscriptionId() is required and cannot be null.");
        }
        if (validateRequest == null) {
            throw new IllegalArgumentException("Parameter validateRequest is required and cannot be null.");
        }
        Validator.validate(validateRequest);
        final String apiVersion = "2016-03-01";
        return service.validate(resourceGroupName, this.subscriptionId(), validateRequest, apiVersion, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ValidateResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<ValidateResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ValidateResponseInner> clientResponse = validateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ValidateResponseInner> validateDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ValidateResponseInner, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ValidateResponseInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Validate whether a resource can be moved.
     * Validate whether a resource can be moved.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param moveResourceEnvelope Object that represents the resource to move.
     */
    public void validateMove(String resourceGroupName, CsmMoveResourceEnvelopeInner moveResourceEnvelope) {
        validateMoveWithServiceResponseAsync(resourceGroupName, moveResourceEnvelope).toBlocking().single().body();
    }

    /**
     * Validate whether a resource can be moved.
     * Validate whether a resource can be moved.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param moveResourceEnvelope Object that represents the resource to move.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> validateMoveAsync(String resourceGroupName, CsmMoveResourceEnvelopeInner moveResourceEnvelope, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.fromResponse(validateMoveWithServiceResponseAsync(resourceGroupName, moveResourceEnvelope), serviceCallback);
    }

    /**
     * Validate whether a resource can be moved.
     * Validate whether a resource can be moved.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param moveResourceEnvelope Object that represents the resource to move.
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> validateMoveAsync(String resourceGroupName, CsmMoveResourceEnvelopeInner moveResourceEnvelope) {
        return validateMoveWithServiceResponseAsync(resourceGroupName, moveResourceEnvelope).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Validate whether a resource can be moved.
     * Validate whether a resource can be moved.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param moveResourceEnvelope Object that represents the resource to move.
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> validateMoveWithServiceResponseAsync(String resourceGroupName, CsmMoveResourceEnvelopeInner moveResourceEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.subscriptionId() is required and cannot be null.");
        }
        if (moveResourceEnvelope == null) {
            throw new IllegalArgumentException("Parameter moveResourceEnvelope is required and cannot be null.");
        }
        Validator.validate(moveResourceEnvelope);
        final String apiVersion = "2016-03-01";
        return service.validateMove(resourceGroupName, this.subscriptionId(), moveResourceEnvelope, apiVersion, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = validateMoveDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> validateMoveDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets the source controls available for Azure websites.
     * Gets the source controls available for Azure websites.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;SourceControlInner&gt; object if successful.
     */
    public PagedList<SourceControlInner> listSourceControlsNext(final String nextPageLink) {
        ServiceResponse<Page<SourceControlInner>> response = listSourceControlsNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<SourceControlInner>(response.body()) {
            @Override
            public Page<SourceControlInner> nextPage(String nextPageLink) {
                return listSourceControlsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the source controls available for Azure websites.
     * Gets the source controls available for Azure websites.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SourceControlInner>> listSourceControlsNextAsync(final String nextPageLink, final ServiceCall<List<SourceControlInner>> serviceCall, final ListOperationCallback<SourceControlInner> serviceCallback) {
        return AzureServiceCall.fromPageResponse(
            listSourceControlsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<SourceControlInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SourceControlInner>>> call(String nextPageLink) {
                    return listSourceControlsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the source controls available for Azure websites.
     * Gets the source controls available for Azure websites.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;SourceControlInner&gt; object
     */
    public Observable<Page<SourceControlInner>> listSourceControlsNextAsync(final String nextPageLink) {
        return listSourceControlsNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<SourceControlInner>>, Page<SourceControlInner>>() {
                @Override
                public Page<SourceControlInner> call(ServiceResponse<Page<SourceControlInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the source controls available for Azure websites.
     * Gets the source controls available for Azure websites.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;SourceControlInner&gt; object
     */
    public Observable<ServiceResponse<Page<SourceControlInner>>> listSourceControlsNextWithServiceResponseAsync(final String nextPageLink) {
        return listSourceControlsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<SourceControlInner>>, Observable<ServiceResponse<Page<SourceControlInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SourceControlInner>>> call(ServiceResponse<Page<SourceControlInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listSourceControlsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the source controls available for Azure websites.
     * Gets the source controls available for Azure websites.
     *
    ServiceResponse<PageImpl<SourceControlInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;SourceControlInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SourceControlInner>>> listSourceControlsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listSourceControlsNext(nextUrl, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SourceControlInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SourceControlInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SourceControlInner>> result = listSourceControlsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SourceControlInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SourceControlInner>> listSourceControlsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<PageImpl<SourceControlInner>, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SourceControlInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get a list of available geographical regions.
     * Get a list of available geographical regions.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;GeoRegionInner&gt; object if successful.
     */
    public PagedList<GeoRegionInner> listGeoRegionsNext(final String nextPageLink) {
        ServiceResponse<Page<GeoRegionInner>> response = listGeoRegionsNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<GeoRegionInner>(response.body()) {
            @Override
            public Page<GeoRegionInner> nextPage(String nextPageLink) {
                return listGeoRegionsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get a list of available geographical regions.
     * Get a list of available geographical regions.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<GeoRegionInner>> listGeoRegionsNextAsync(final String nextPageLink, final ServiceCall<List<GeoRegionInner>> serviceCall, final ListOperationCallback<GeoRegionInner> serviceCallback) {
        return AzureServiceCall.fromPageResponse(
            listGeoRegionsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<GeoRegionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<GeoRegionInner>>> call(String nextPageLink) {
                    return listGeoRegionsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get a list of available geographical regions.
     * Get a list of available geographical regions.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;GeoRegionInner&gt; object
     */
    public Observable<Page<GeoRegionInner>> listGeoRegionsNextAsync(final String nextPageLink) {
        return listGeoRegionsNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<GeoRegionInner>>, Page<GeoRegionInner>>() {
                @Override
                public Page<GeoRegionInner> call(ServiceResponse<Page<GeoRegionInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get a list of available geographical regions.
     * Get a list of available geographical regions.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;GeoRegionInner&gt; object
     */
    public Observable<ServiceResponse<Page<GeoRegionInner>>> listGeoRegionsNextWithServiceResponseAsync(final String nextPageLink) {
        return listGeoRegionsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<GeoRegionInner>>, Observable<ServiceResponse<Page<GeoRegionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<GeoRegionInner>>> call(ServiceResponse<Page<GeoRegionInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listGeoRegionsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get a list of available geographical regions.
     * Get a list of available geographical regions.
     *
    ServiceResponse<PageImpl<GeoRegionInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;GeoRegionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<GeoRegionInner>>> listGeoRegionsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listGeoRegionsNext(nextUrl, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<GeoRegionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<GeoRegionInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<GeoRegionInner>> result = listGeoRegionsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<GeoRegionInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<GeoRegionInner>> listGeoRegionsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<PageImpl<GeoRegionInner>, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PageImpl<GeoRegionInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List all premier add-on offers.
     * List all premier add-on offers.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;PremierAddOnOfferInner&gt; object if successful.
     */
    public PagedList<PremierAddOnOfferInner> listPremierAddOnOffersNext(final String nextPageLink) {
        ServiceResponse<Page<PremierAddOnOfferInner>> response = listPremierAddOnOffersNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<PremierAddOnOfferInner>(response.body()) {
            @Override
            public Page<PremierAddOnOfferInner> nextPage(String nextPageLink) {
                return listPremierAddOnOffersNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List all premier add-on offers.
     * List all premier add-on offers.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<PremierAddOnOfferInner>> listPremierAddOnOffersNextAsync(final String nextPageLink, final ServiceCall<List<PremierAddOnOfferInner>> serviceCall, final ListOperationCallback<PremierAddOnOfferInner> serviceCallback) {
        return AzureServiceCall.fromPageResponse(
            listPremierAddOnOffersNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<PremierAddOnOfferInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PremierAddOnOfferInner>>> call(String nextPageLink) {
                    return listPremierAddOnOffersNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List all premier add-on offers.
     * List all premier add-on offers.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;PremierAddOnOfferInner&gt; object
     */
    public Observable<Page<PremierAddOnOfferInner>> listPremierAddOnOffersNextAsync(final String nextPageLink) {
        return listPremierAddOnOffersNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<PremierAddOnOfferInner>>, Page<PremierAddOnOfferInner>>() {
                @Override
                public Page<PremierAddOnOfferInner> call(ServiceResponse<Page<PremierAddOnOfferInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List all premier add-on offers.
     * List all premier add-on offers.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;PremierAddOnOfferInner&gt; object
     */
    public Observable<ServiceResponse<Page<PremierAddOnOfferInner>>> listPremierAddOnOffersNextWithServiceResponseAsync(final String nextPageLink) {
        return listPremierAddOnOffersNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<PremierAddOnOfferInner>>, Observable<ServiceResponse<Page<PremierAddOnOfferInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PremierAddOnOfferInner>>> call(ServiceResponse<Page<PremierAddOnOfferInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listPremierAddOnOffersNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List all premier add-on offers.
     * List all premier add-on offers.
     *
    ServiceResponse<PageImpl<PremierAddOnOfferInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;PremierAddOnOfferInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<PremierAddOnOfferInner>>> listPremierAddOnOffersNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listPremierAddOnOffersNext(nextUrl, this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<PremierAddOnOfferInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PremierAddOnOfferInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<PremierAddOnOfferInner>> result = listPremierAddOnOffersNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<PremierAddOnOfferInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<PremierAddOnOfferInner>> listPremierAddOnOffersNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<PageImpl<PremierAddOnOfferInner>, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PageImpl<PremierAddOnOfferInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

}
