/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.management.appservice.implementation;

import com.microsoft.azure.management.resources.fluentcore.collection.InnerSupportsGet;
import com.microsoft.azure.management.resources.fluentcore.collection.InnerSupportsDelete;
import com.microsoft.azure.management.resources.fluentcore.collection.InnerSupportsListing;
import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.AzureServiceFuture;
import com.microsoft.azure.CloudException;
import com.microsoft.azure.ListOperationCallback;
import com.microsoft.azure.management.appservice.CsmPublishingProfileOptions;
import com.microsoft.azure.management.appservice.PublishingProfileFormat;
import com.microsoft.azure.Page;
import com.microsoft.azure.PagedList;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.InputStream;
import java.io.IOException;
import java.util.List;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.PATCH;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.http.Streaming;
import retrofit2.http.Url;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in WebApps.
 */
public class WebAppsInner implements InnerSupportsGet<SiteInner>, InnerSupportsDelete<Void>, InnerSupportsListing<SiteInner> {
    /** The Retrofit service to perform REST calls. */
    private WebAppsService service;
    /** The service client containing this operation class. */
    private WebSiteManagementClientImpl client;

    /**
     * Initializes an instance of WebAppsInner.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public WebAppsInner(Retrofit retrofit, WebSiteManagementClientImpl client) {
        this.service = retrofit.create(WebAppsService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for WebApps to be
     * used by Retrofit to perform actually REST calls.
     */
    interface WebAppsService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps list" })
        @GET("subscriptions/{subscriptionId}/providers/Microsoft.Web/sites")
        Observable<Response<ResponseBody>> list(@Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listByResourceGroup" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites")
        Observable<Response<ResponseBody>> listByResourceGroup(@Path("resourceGroupName") String resourceGroupName, @Path("subscriptionId") String subscriptionId, @Query("includeSlots") Boolean includeSlots, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps getByResourceGroup" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}")
        Observable<Response<ResponseBody>> getByResourceGroup(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps createOrUpdate" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}")
        Observable<Response<ResponseBody>> createOrUpdate(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body SiteInner siteEnvelope, @Query("skipDnsRegistration") Boolean skipDnsRegistration, @Query("skipCustomDomainVerification") Boolean skipCustomDomainVerification, @Query("forceDnsRegistration") Boolean forceDnsRegistration, @Query("ttlInSeconds") String ttlInSeconds, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps beginCreateOrUpdate" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}")
        Observable<Response<ResponseBody>> beginCreateOrUpdate(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body SiteInner siteEnvelope, @Query("skipDnsRegistration") Boolean skipDnsRegistration, @Query("skipCustomDomainVerification") Boolean skipCustomDomainVerification, @Query("forceDnsRegistration") Boolean forceDnsRegistration, @Query("ttlInSeconds") String ttlInSeconds, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps delete" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> delete(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("deleteMetrics") Boolean deleteMetrics, @Query("deleteEmptyServerFarm") Boolean deleteEmptyServerFarm, @Query("skipDnsRegistration") Boolean skipDnsRegistration, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps analyzeCustomHostname" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/analyzeCustomHostname")
        Observable<Response<ResponseBody>> analyzeCustomHostname(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("hostName") String hostName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps applySlotConfigToProduction" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/applySlotConfig")
        Observable<Response<ResponseBody>> applySlotConfigToProduction(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body CsmSlotEntityInner slotSwapEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps backup" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backup")
        Observable<Response<ResponseBody>> backup(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body BackupRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listBackups" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups")
        Observable<Response<ResponseBody>> listBackups(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps discoverRestore" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/discover")
        Observable<Response<ResponseBody>> discoverRestore(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body RestoreRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps getBackupStatus" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}")
        Observable<Response<ResponseBody>> getBackupStatus(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("backupId") String backupId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps deleteBackup" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteBackup(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("backupId") String backupId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listBackupStatusSecrets" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}/list")
        Observable<Response<ResponseBody>> listBackupStatusSecrets(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("backupId") String backupId, @Path("subscriptionId") String subscriptionId, @Body BackupRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps restore" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}/restore")
        Observable<Response<ResponseBody>> restore(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("backupId") String backupId, @Path("subscriptionId") String subscriptionId, @Body RestoreRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps beginRestore" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}/restore")
        Observable<Response<ResponseBody>> beginRestore(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("backupId") String backupId, @Path("subscriptionId") String subscriptionId, @Body RestoreRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps updateApplicationSettings" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/appsettings")
        Observable<Response<ResponseBody>> updateApplicationSettings(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body StringDictionaryInner appSettings, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listApplicationSettings" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/appsettings/list")
        Observable<Response<ResponseBody>> listApplicationSettings(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps updateAuthSettings" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/authsettings")
        Observable<Response<ResponseBody>> updateAuthSettings(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body SiteAuthSettingsInner siteAuthSettings, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps getAuthSettings" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/authsettings/list")
        Observable<Response<ResponseBody>> getAuthSettings(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps updateBackupConfiguration" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/backup")
        Observable<Response<ResponseBody>> updateBackupConfiguration(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body BackupRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps deleteBackupConfiguration" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/backup", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteBackupConfiguration(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps getBackupConfiguration" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/backup/list")
        Observable<Response<ResponseBody>> getBackupConfiguration(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps updateConnectionStrings" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/connectionstrings")
        Observable<Response<ResponseBody>> updateConnectionStrings(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body ConnectionStringDictionaryInner connectionStrings, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listConnectionStrings" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/connectionstrings/list")
        Observable<Response<ResponseBody>> listConnectionStrings(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps getDiagnosticLogsConfiguration" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/logs")
        Observable<Response<ResponseBody>> getDiagnosticLogsConfiguration(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps updateDiagnosticLogsConfig" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/logs")
        Observable<Response<ResponseBody>> updateDiagnosticLogsConfig(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body SiteLogsConfigInner siteLogsConfig, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps updateMetadata" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/metadata")
        Observable<Response<ResponseBody>> updateMetadata(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body StringDictionaryInner metadata, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listMetadata" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/metadata/list")
        Observable<Response<ResponseBody>> listMetadata(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listPublishingCredentials" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/publishingcredentials/list")
        Observable<Response<ResponseBody>> listPublishingCredentials(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps beginListPublishingCredentials" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/publishingcredentials/list")
        Observable<Response<ResponseBody>> beginListPublishingCredentials(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps updateSitePushSettings" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/pushsettings")
        Observable<Response<ResponseBody>> updateSitePushSettings(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body PushSettingsInner pushSettings, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listSitePushSettings" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/pushsettings/list")
        Observable<Response<ResponseBody>> listSitePushSettings(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listSlotConfigurationNames" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/slotConfigNames")
        Observable<Response<ResponseBody>> listSlotConfigurationNames(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps updateSlotConfigurationNames" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/slotConfigNames")
        Observable<Response<ResponseBody>> updateSlotConfigurationNames(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body SlotConfigNamesResourceInner slotConfigNames, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps getConfiguration" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web")
        Observable<Response<ResponseBody>> getConfiguration(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps createOrUpdateConfiguration" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web")
        Observable<Response<ResponseBody>> createOrUpdateConfiguration(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body SiteConfigResourceInner siteConfig, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps updateConfiguration" })
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web")
        Observable<Response<ResponseBody>> updateConfiguration(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body SiteConfigResourceInner siteConfig, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listConfigurationSnapshotInfo" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web/snapshots")
        Observable<Response<ResponseBody>> listConfigurationSnapshotInfo(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps getConfigurationSnapshot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web/snapshots/{snapshotId}")
        Observable<Response<ResponseBody>> getConfigurationSnapshot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("snapshotId") String snapshotId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps recoverSiteConfigurationSnapshot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web/snapshots/{snapshotId}/recover")
        Observable<Response<ResponseBody>> recoverSiteConfigurationSnapshot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("snapshotId") String snapshotId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listDeployments" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments")
        Observable<Response<ResponseBody>> listDeployments(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps getDeployment" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments/{id}")
        Observable<Response<ResponseBody>> getDeployment(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps createDeployment" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments/{id}")
        Observable<Response<ResponseBody>> createDeployment(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("subscriptionId") String subscriptionId, @Body DeploymentInner deployment, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps deleteDeployment" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments/{id}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteDeployment(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listDomainOwnershipIdentifiers" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers")
        Observable<Response<ResponseBody>> listDomainOwnershipIdentifiers(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps getDomainOwnershipIdentifier" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}")
        Observable<Response<ResponseBody>> getDomainOwnershipIdentifier(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("domainOwnershipIdentifierName") String domainOwnershipIdentifierName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps createOrUpdateDomainOwnershipIdentifier" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}")
        Observable<Response<ResponseBody>> createOrUpdateDomainOwnershipIdentifier(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("domainOwnershipIdentifierName") String domainOwnershipIdentifierName, @Path("subscriptionId") String subscriptionId, @Body IdentifierInner domainOwnershipIdentifier, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps deleteDomainOwnershipIdentifier" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteDomainOwnershipIdentifier(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("domainOwnershipIdentifierName") String domainOwnershipIdentifierName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps updateDomainOwnershipIdentifier" })
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}")
        Observable<Response<ResponseBody>> updateDomainOwnershipIdentifier(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("domainOwnershipIdentifierName") String domainOwnershipIdentifierName, @Path("subscriptionId") String subscriptionId, @Body IdentifierInner domainOwnershipIdentifier, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listHostNameBindings" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings")
        Observable<Response<ResponseBody>> listHostNameBindings(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps getHostNameBinding" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings/{hostName}")
        Observable<Response<ResponseBody>> getHostNameBinding(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("hostName") String hostName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps createOrUpdateHostNameBinding" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings/{hostName}")
        Observable<Response<ResponseBody>> createOrUpdateHostNameBinding(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("hostName") String hostName, @Path("subscriptionId") String subscriptionId, @Body HostNameBindingInner hostNameBinding, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps deleteHostNameBinding" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings/{hostName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteHostNameBinding(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("hostName") String hostName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps getHybridConnection" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}")
        Observable<Response<ResponseBody>> getHybridConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("namespaceName") String namespaceName, @Path("relayName") String relayName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps createOrUpdateHybridConnection" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}")
        Observable<Response<ResponseBody>> createOrUpdateHybridConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("namespaceName") String namespaceName, @Path("relayName") String relayName, @Path("subscriptionId") String subscriptionId, @Body HybridConnectionInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps deleteHybridConnection" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteHybridConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("namespaceName") String namespaceName, @Path("relayName") String relayName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps updateHybridConnection" })
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}")
        Observable<Response<ResponseBody>> updateHybridConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("namespaceName") String namespaceName, @Path("relayName") String relayName, @Path("subscriptionId") String subscriptionId, @Body HybridConnectionInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listHybridConnectionKeys" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}/listKeys")
        Observable<Response<ResponseBody>> listHybridConnectionKeys(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("namespaceName") String namespaceName, @Path("relayName") String relayName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listHybridConnections" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionRelays")
        Observable<Response<ResponseBody>> listHybridConnections(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listRelayServiceConnections" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection")
        Observable<Response<ResponseBody>> listRelayServiceConnections(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps getRelayServiceConnection" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}")
        Observable<Response<ResponseBody>> getRelayServiceConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("entityName") String entityName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps createOrUpdateRelayServiceConnection" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}")
        Observable<Response<ResponseBody>> createOrUpdateRelayServiceConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("entityName") String entityName, @Path("subscriptionId") String subscriptionId, @Body RelayServiceConnectionEntityInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps deleteRelayServiceConnection" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteRelayServiceConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("entityName") String entityName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps updateRelayServiceConnection" })
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}")
        Observable<Response<ResponseBody>> updateRelayServiceConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("entityName") String entityName, @Path("subscriptionId") String subscriptionId, @Body RelayServiceConnectionEntityInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listInstanceIdentifiers" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances")
        Observable<Response<ResponseBody>> listInstanceIdentifiers(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listInstanceDeployments" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/deployments")
        Observable<Response<ResponseBody>> listInstanceDeployments(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps getInstanceDeployment" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/deployments/{id}")
        Observable<Response<ResponseBody>> getInstanceDeployment(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps createInstanceDeployment" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/deployments/{id}")
        Observable<Response<ResponseBody>> createInstanceDeployment(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Body DeploymentInner deployment, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps deleteInstanceDeployment" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/deployments/{id}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteInstanceDeployment(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps isCloneable" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/iscloneable")
        Observable<Response<ResponseBody>> isCloneable(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listMetricDefinitions" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/metricdefinitions")
        Observable<Response<ResponseBody>> listMetricDefinitions(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listMetrics" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/metrics")
        Observable<Response<ResponseBody>> listMetrics(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("details") Boolean details, @Query(value = "$filter", encoded = true) String filter, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps migrateStorage" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/migrate")
        Observable<Response<ResponseBody>> migrateStorage(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("subscriptionName") String subscriptionName, @Body StorageMigrationOptionsInner migrationOptions, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps beginMigrateStorage" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/migrate")
        Observable<Response<ResponseBody>> beginMigrateStorage(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("subscriptionName") String subscriptionName, @Body StorageMigrationOptionsInner migrationOptions, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps migrateMySql" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/migratemysql")
        Observable<Response<ResponseBody>> migrateMySql(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body MigrateMySqlRequestInner migrationRequestEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps beginMigrateMySql" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/migratemysql")
        Observable<Response<ResponseBody>> beginMigrateMySql(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body MigrateMySqlRequestInner migrationRequestEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps getMigrateMySqlStatus" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/migratemysql/status")
        Observable<Response<ResponseBody>> getMigrateMySqlStatus(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listNetworkFeatures" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkFeatures/{view}")
        Observable<Response<ResponseBody>> listNetworkFeatures(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("view") String view, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps startWebSiteNetworkTrace" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTrace/start")
        Observable<Response<ResponseBody>> startWebSiteNetworkTrace(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("durationInSeconds") Integer durationInSeconds, @Query("maxFrameLength") Integer maxFrameLength, @Query("sasUrl") String sasUrl, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps stopWebSiteNetworkTrace" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTrace/stop")
        Observable<Response<ResponseBody>> stopWebSiteNetworkTrace(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps generateNewSitePublishingPassword" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/newpassword")
        Observable<Response<ResponseBody>> generateNewSitePublishingPassword(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listPerfMonCounters" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/perfcounters")
        Observable<Response<ResponseBody>> listPerfMonCounters(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query(value = "$filter", encoded = true) String filter, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps getSitePhpErrorLogFlag" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/phplogging")
        Observable<Response<ResponseBody>> getSitePhpErrorLogFlag(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listPremierAddOns" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons")
        Observable<Response<ResponseBody>> listPremierAddOns(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps getPremierAddOn" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons/{premierAddOnName}")
        Observable<Response<ResponseBody>> getPremierAddOn(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("premierAddOnName") String premierAddOnName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps addPremierAddOn" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons/{premierAddOnName}")
        Observable<Response<ResponseBody>> addPremierAddOn(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("premierAddOnName") String premierAddOnName, @Path("subscriptionId") String subscriptionId, @Body PremierAddOnInner premierAddOn, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps deletePremierAddOn" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons/{premierAddOnName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deletePremierAddOn(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("premierAddOnName") String premierAddOnName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listPublishingProfileXmlWithSecrets" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/publishxml")
        @Streaming
        Observable<Response<ResponseBody>> listPublishingProfileXmlWithSecrets(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body CsmPublishingProfileOptions publishingProfileOptions, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps recover" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/recover")
        Observable<Response<ResponseBody>> recover(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body CsmSiteRecoveryEntityInner recoveryEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps beginRecover" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/recover")
        Observable<Response<ResponseBody>> beginRecover(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body CsmSiteRecoveryEntityInner recoveryEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps resetProductionSlotConfig" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/resetSlotConfig")
        Observable<Response<ResponseBody>> resetProductionSlotConfig(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps restart" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/restart")
        Observable<Response<ResponseBody>> restart(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("softRestart") Boolean softRestart, @Query("synchronous") Boolean synchronous, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listSlots" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots")
        Observable<Response<ResponseBody>> listSlots(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps getSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}")
        Observable<Response<ResponseBody>> getSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps createOrUpdateSlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}")
        Observable<Response<ResponseBody>> createOrUpdateSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body SiteInner siteEnvelope, @Query("skipDnsRegistration") Boolean skipDnsRegistration, @Query("skipCustomDomainVerification") Boolean skipCustomDomainVerification, @Query("forceDnsRegistration") Boolean forceDnsRegistration, @Query("ttlInSeconds") String ttlInSeconds, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps beginCreateOrUpdateSlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}")
        Observable<Response<ResponseBody>> beginCreateOrUpdateSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body SiteInner siteEnvelope, @Query("skipDnsRegistration") Boolean skipDnsRegistration, @Query("skipCustomDomainVerification") Boolean skipCustomDomainVerification, @Query("forceDnsRegistration") Boolean forceDnsRegistration, @Query("ttlInSeconds") String ttlInSeconds, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps deleteSlot" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("deleteMetrics") Boolean deleteMetrics, @Query("deleteEmptyServerFarm") Boolean deleteEmptyServerFarm, @Query("skipDnsRegistration") Boolean skipDnsRegistration, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps analyzeCustomHostnameSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/analyzeCustomHostname")
        Observable<Response<ResponseBody>> analyzeCustomHostnameSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("hostName") String hostName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps applySlotConfigurationSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/applySlotConfig")
        Observable<Response<ResponseBody>> applySlotConfigurationSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body CsmSlotEntityInner slotSwapEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps backupSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backup")
        Observable<Response<ResponseBody>> backupSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body BackupRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listBackupsSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups")
        Observable<Response<ResponseBody>> listBackupsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps discoverRestoreSlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/discover")
        Observable<Response<ResponseBody>> discoverRestoreSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body RestoreRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps getBackupStatusSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}")
        Observable<Response<ResponseBody>> getBackupStatusSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("backupId") String backupId, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps deleteBackupSlot" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteBackupSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("backupId") String backupId, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listBackupStatusSecretsSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}/list")
        Observable<Response<ResponseBody>> listBackupStatusSecretsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("backupId") String backupId, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body BackupRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps restoreSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}/restore")
        Observable<Response<ResponseBody>> restoreSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("backupId") String backupId, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body RestoreRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps beginRestoreSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}/restore")
        Observable<Response<ResponseBody>> beginRestoreSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("backupId") String backupId, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body RestoreRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps updateApplicationSettingsSlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/appsettings")
        Observable<Response<ResponseBody>> updateApplicationSettingsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body StringDictionaryInner appSettings, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listApplicationSettingsSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/appsettings/list")
        Observable<Response<ResponseBody>> listApplicationSettingsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps updateAuthSettingsSlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/authsettings")
        Observable<Response<ResponseBody>> updateAuthSettingsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body SiteAuthSettingsInner siteAuthSettings, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps getAuthSettingsSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/authsettings/list")
        Observable<Response<ResponseBody>> getAuthSettingsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps updateBackupConfigurationSlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/backup")
        Observable<Response<ResponseBody>> updateBackupConfigurationSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body BackupRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps deleteBackupConfigurationSlot" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/backup", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteBackupConfigurationSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps getBackupConfigurationSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/backup/list")
        Observable<Response<ResponseBody>> getBackupConfigurationSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps updateConnectionStringsSlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/connectionstrings")
        Observable<Response<ResponseBody>> updateConnectionStringsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body ConnectionStringDictionaryInner connectionStrings, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listConnectionStringsSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/connectionstrings/list")
        Observable<Response<ResponseBody>> listConnectionStringsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps getDiagnosticLogsConfigurationSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/logs")
        Observable<Response<ResponseBody>> getDiagnosticLogsConfigurationSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps updateDiagnosticLogsConfigSlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/logs")
        Observable<Response<ResponseBody>> updateDiagnosticLogsConfigSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body SiteLogsConfigInner siteLogsConfig, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps updateMetadataSlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/metadata")
        Observable<Response<ResponseBody>> updateMetadataSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body StringDictionaryInner metadata, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listMetadataSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/metadata/list")
        Observable<Response<ResponseBody>> listMetadataSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listPublishingCredentialsSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/publishingcredentials/list")
        Observable<Response<ResponseBody>> listPublishingCredentialsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps beginListPublishingCredentialsSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/publishingcredentials/list")
        Observable<Response<ResponseBody>> beginListPublishingCredentialsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps updateSitePushSettingsSlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/pushsettings")
        Observable<Response<ResponseBody>> updateSitePushSettingsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body PushSettingsInner pushSettings, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listSitePushSettingsSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/pushsettings/list")
        Observable<Response<ResponseBody>> listSitePushSettingsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps getConfigurationSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web")
        Observable<Response<ResponseBody>> getConfigurationSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps createOrUpdateConfigurationSlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web")
        Observable<Response<ResponseBody>> createOrUpdateConfigurationSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body SiteConfigResourceInner siteConfig, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps updateConfigurationSlot" })
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web")
        Observable<Response<ResponseBody>> updateConfigurationSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body SiteConfigResourceInner siteConfig, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listConfigurationSnapshotInfoSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web/snapshots")
        Observable<Response<ResponseBody>> listConfigurationSnapshotInfoSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps getConfigurationSnapshotSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web/snapshots/{snapshotId}")
        Observable<Response<ResponseBody>> getConfigurationSnapshotSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("snapshotId") String snapshotId, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps recoverSiteConfigurationSnapshotSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web/snapshots/{snapshotId}/recover")
        Observable<Response<ResponseBody>> recoverSiteConfigurationSnapshotSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("snapshotId") String snapshotId, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listDeploymentsSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments")
        Observable<Response<ResponseBody>> listDeploymentsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps getDeploymentSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments/{id}")
        Observable<Response<ResponseBody>> getDeploymentSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps createDeploymentSlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments/{id}")
        Observable<Response<ResponseBody>> createDeploymentSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body DeploymentInner deployment, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps deleteDeploymentSlot" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments/{id}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteDeploymentSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listDomainOwnershipIdentifiersSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers")
        Observable<Response<ResponseBody>> listDomainOwnershipIdentifiersSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps getDomainOwnershipIdentifierSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}")
        Observable<Response<ResponseBody>> getDomainOwnershipIdentifierSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("domainOwnershipIdentifierName") String domainOwnershipIdentifierName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps createOrUpdateDomainOwnershipIdentifierSlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}")
        Observable<Response<ResponseBody>> createOrUpdateDomainOwnershipIdentifierSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("domainOwnershipIdentifierName") String domainOwnershipIdentifierName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body IdentifierInner domainOwnershipIdentifier, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps deleteDomainOwnershipIdentifierSlot" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteDomainOwnershipIdentifierSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("domainOwnershipIdentifierName") String domainOwnershipIdentifierName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps updateDomainOwnershipIdentifierSlot" })
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}")
        Observable<Response<ResponseBody>> updateDomainOwnershipIdentifierSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("domainOwnershipIdentifierName") String domainOwnershipIdentifierName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body IdentifierInner domainOwnershipIdentifier, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listHostNameBindingsSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings")
        Observable<Response<ResponseBody>> listHostNameBindingsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps getHostNameBindingSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings/{hostName}")
        Observable<Response<ResponseBody>> getHostNameBindingSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("hostName") String hostName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps createOrUpdateHostNameBindingSlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings/{hostName}")
        Observable<Response<ResponseBody>> createOrUpdateHostNameBindingSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("hostName") String hostName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body HostNameBindingInner hostNameBinding, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps deleteHostNameBindingSlot" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings/{hostName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteHostNameBindingSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("hostName") String hostName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps getHybridConnectionSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}")
        Observable<Response<ResponseBody>> getHybridConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("namespaceName") String namespaceName, @Path("relayName") String relayName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps createOrUpdateHybridConnectionSlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}")
        Observable<Response<ResponseBody>> createOrUpdateHybridConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("namespaceName") String namespaceName, @Path("relayName") String relayName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body HybridConnectionInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps deleteHybridConnectionSlot" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteHybridConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("namespaceName") String namespaceName, @Path("relayName") String relayName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps updateHybridConnectionSlot" })
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}")
        Observable<Response<ResponseBody>> updateHybridConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("namespaceName") String namespaceName, @Path("relayName") String relayName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body HybridConnectionInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listHybridConnectionKeysSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}/listKeys")
        Observable<Response<ResponseBody>> listHybridConnectionKeysSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("namespaceName") String namespaceName, @Path("relayName") String relayName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listHybridConnectionsSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionRelays")
        Observable<Response<ResponseBody>> listHybridConnectionsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listRelayServiceConnectionsSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection")
        Observable<Response<ResponseBody>> listRelayServiceConnectionsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps getRelayServiceConnectionSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}")
        Observable<Response<ResponseBody>> getRelayServiceConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("entityName") String entityName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps createOrUpdateRelayServiceConnectionSlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}")
        Observable<Response<ResponseBody>> createOrUpdateRelayServiceConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("entityName") String entityName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body RelayServiceConnectionEntityInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps deleteRelayServiceConnectionSlot" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteRelayServiceConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("entityName") String entityName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps updateRelayServiceConnectionSlot" })
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}")
        Observable<Response<ResponseBody>> updateRelayServiceConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("entityName") String entityName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body RelayServiceConnectionEntityInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listInstanceIdentifiersSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances")
        Observable<Response<ResponseBody>> listInstanceIdentifiersSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listInstanceDeploymentsSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/deployments")
        Observable<Response<ResponseBody>> listInstanceDeploymentsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps getInstanceDeploymentSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/deployments/{id}")
        Observable<Response<ResponseBody>> getInstanceDeploymentSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("slot") String slot, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps createInstanceDeploymentSlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/deployments/{id}")
        Observable<Response<ResponseBody>> createInstanceDeploymentSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("slot") String slot, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Body DeploymentInner deployment, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps deleteInstanceDeploymentSlot" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/deployments/{id}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteInstanceDeploymentSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("slot") String slot, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps isCloneableSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/iscloneable")
        Observable<Response<ResponseBody>> isCloneableSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listMetricDefinitionsSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/metricdefinitions")
        Observable<Response<ResponseBody>> listMetricDefinitionsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listMetricsSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/metrics")
        Observable<Response<ResponseBody>> listMetricsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("details") Boolean details, @Query(value = "$filter", encoded = true) String filter, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps getMigrateMySqlStatusSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/migratemysql/status")
        Observable<Response<ResponseBody>> getMigrateMySqlStatusSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listNetworkFeaturesSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkFeatures/{view}")
        Observable<Response<ResponseBody>> listNetworkFeaturesSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("view") String view, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps startWebSiteNetworkTraceSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTrace/start")
        Observable<Response<ResponseBody>> startWebSiteNetworkTraceSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("durationInSeconds") Integer durationInSeconds, @Query("maxFrameLength") Integer maxFrameLength, @Query("sasUrl") String sasUrl, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps stopWebSiteNetworkTraceSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTrace/stop")
        Observable<Response<ResponseBody>> stopWebSiteNetworkTraceSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps generateNewSitePublishingPasswordSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/newpassword")
        Observable<Response<ResponseBody>> generateNewSitePublishingPasswordSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listPerfMonCountersSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/perfcounters")
        Observable<Response<ResponseBody>> listPerfMonCountersSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query(value = "$filter", encoded = true) String filter, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps getSitePhpErrorLogFlagSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/phplogging")
        Observable<Response<ResponseBody>> getSitePhpErrorLogFlagSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listPremierAddOnsSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons")
        Observable<Response<ResponseBody>> listPremierAddOnsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps getPremierAddOnSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons/{premierAddOnName}")
        Observable<Response<ResponseBody>> getPremierAddOnSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("premierAddOnName") String premierAddOnName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps addPremierAddOnSlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons/{premierAddOnName}")
        Observable<Response<ResponseBody>> addPremierAddOnSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("premierAddOnName") String premierAddOnName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body PremierAddOnInner premierAddOn, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps deletePremierAddOnSlot" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons/{premierAddOnName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deletePremierAddOnSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("premierAddOnName") String premierAddOnName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listPublishingProfileXmlWithSecretsSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/publishxml")
        @Streaming
        Observable<Response<ResponseBody>> listPublishingProfileXmlWithSecretsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body CsmPublishingProfileOptions publishingProfileOptions, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps recoverSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/recover")
        Observable<Response<ResponseBody>> recoverSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body CsmSiteRecoveryEntityInner recoveryEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps beginRecoverSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/recover")
        Observable<Response<ResponseBody>> beginRecoverSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body CsmSiteRecoveryEntityInner recoveryEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps resetSlotConfigurationSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/resetSlotConfig")
        Observable<Response<ResponseBody>> resetSlotConfigurationSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps restartSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/restart")
        Observable<Response<ResponseBody>> restartSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("softRestart") Boolean softRestart, @Query("synchronous") Boolean synchronous, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listSlotDifferencesSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/slotsdiffs")
        Observable<Response<ResponseBody>> listSlotDifferencesSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body CsmSlotEntityInner slotSwapEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps swapSlotSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/slotsswap")
        Observable<Response<ResponseBody>> swapSlotSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body CsmSlotEntityInner slotSwapEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps beginSwapSlotSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/slotsswap")
        Observable<Response<ResponseBody>> beginSwapSlotSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body CsmSlotEntityInner slotSwapEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listSnapshotsSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/snapshots")
        Observable<Response<ResponseBody>> listSnapshotsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps getSourceControlSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web")
        Observable<Response<ResponseBody>> getSourceControlSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps createOrUpdateSourceControlSlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web")
        Observable<Response<ResponseBody>> createOrUpdateSourceControlSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body SiteSourceControlInner siteSourceControl, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps beginCreateOrUpdateSourceControlSlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web")
        Observable<Response<ResponseBody>> beginCreateOrUpdateSourceControlSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body SiteSourceControlInner siteSourceControl, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps deleteSourceControlSlot" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteSourceControlSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps startSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/start")
        Observable<Response<ResponseBody>> startSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps stopSlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/stop")
        Observable<Response<ResponseBody>> stopSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps syncRepositorySlot" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sync")
        Observable<Response<ResponseBody>> syncRepositorySlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listUsagesSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/usages")
        Observable<Response<ResponseBody>> listUsagesSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query(value = "$filter", encoded = true) String filter, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listVnetConnectionsSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections")
        Observable<Response<ResponseBody>> listVnetConnectionsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps getVnetConnectionSlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}")
        Observable<Response<ResponseBody>> getVnetConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps createOrUpdateVnetConnectionSlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}")
        Observable<Response<ResponseBody>> createOrUpdateVnetConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body VnetInfoInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps deleteVnetConnectionSlot" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteVnetConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps updateVnetConnectionSlot" })
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}")
        Observable<Response<ResponseBody>> updateVnetConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body VnetInfoInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps getVnetConnectionGatewaySlot" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}")
        Observable<Response<ResponseBody>> getVnetConnectionGatewaySlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("gatewayName") String gatewayName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps createOrUpdateVnetConnectionGatewaySlot" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}")
        Observable<Response<ResponseBody>> createOrUpdateVnetConnectionGatewaySlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("gatewayName") String gatewayName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body VnetGatewayInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps updateVnetConnectionGatewaySlot" })
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}")
        Observable<Response<ResponseBody>> updateVnetConnectionGatewaySlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("gatewayName") String gatewayName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body VnetGatewayInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listSlotDifferencesFromProduction" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slotsdiffs")
        Observable<Response<ResponseBody>> listSlotDifferencesFromProduction(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body CsmSlotEntityInner slotSwapEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps swapSlotWithProduction" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slotsswap")
        Observable<Response<ResponseBody>> swapSlotWithProduction(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body CsmSlotEntityInner slotSwapEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps beginSwapSlotWithProduction" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slotsswap")
        Observable<Response<ResponseBody>> beginSwapSlotWithProduction(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body CsmSlotEntityInner slotSwapEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listSnapshots" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/snapshots")
        Observable<Response<ResponseBody>> listSnapshots(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps getSourceControl" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web")
        Observable<Response<ResponseBody>> getSourceControl(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps createOrUpdateSourceControl" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web")
        Observable<Response<ResponseBody>> createOrUpdateSourceControl(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body SiteSourceControlInner siteSourceControl, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps beginCreateOrUpdateSourceControl" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web")
        Observable<Response<ResponseBody>> beginCreateOrUpdateSourceControl(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body SiteSourceControlInner siteSourceControl, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps deleteSourceControl" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteSourceControl(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps start" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/start")
        Observable<Response<ResponseBody>> start(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps stop" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/stop")
        Observable<Response<ResponseBody>> stop(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps syncRepository" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sync")
        Observable<Response<ResponseBody>> syncRepository(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listUsages" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/usages")
        Observable<Response<ResponseBody>> listUsages(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query(value = "$filter", encoded = true) String filter, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listVnetConnections" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections")
        Observable<Response<ResponseBody>> listVnetConnections(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps getVnetConnection" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}")
        Observable<Response<ResponseBody>> getVnetConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps createOrUpdateVnetConnection" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}")
        Observable<Response<ResponseBody>> createOrUpdateVnetConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("subscriptionId") String subscriptionId, @Body VnetInfoInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps deleteVnetConnection" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteVnetConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps updateVnetConnection" })
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}")
        Observable<Response<ResponseBody>> updateVnetConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("subscriptionId") String subscriptionId, @Body VnetInfoInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps getVnetConnectionGateway" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}")
        Observable<Response<ResponseBody>> getVnetConnectionGateway(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("gatewayName") String gatewayName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps createOrUpdateVnetConnectionGateway" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}")
        Observable<Response<ResponseBody>> createOrUpdateVnetConnectionGateway(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("gatewayName") String gatewayName, @Path("subscriptionId") String subscriptionId, @Body VnetGatewayInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps updateVnetConnectionGateway" })
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}")
        Observable<Response<ResponseBody>> updateVnetConnectionGateway(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("gatewayName") String gatewayName, @Path("subscriptionId") String subscriptionId, @Body VnetGatewayInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listNext" })
        @GET
        Observable<Response<ResponseBody>> listNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listByResourceGroupNext" })
        @GET
        Observable<Response<ResponseBody>> listByResourceGroupNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listBackupsNext" })
        @GET
        Observable<Response<ResponseBody>> listBackupsNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listDeploymentsNext" })
        @GET
        Observable<Response<ResponseBody>> listDeploymentsNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listDomainOwnershipIdentifiersNext" })
        @GET
        Observable<Response<ResponseBody>> listDomainOwnershipIdentifiersNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listHostNameBindingsNext" })
        @GET
        Observable<Response<ResponseBody>> listHostNameBindingsNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listInstanceIdentifiersNext" })
        @GET
        Observable<Response<ResponseBody>> listInstanceIdentifiersNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listInstanceDeploymentsNext" })
        @GET
        Observable<Response<ResponseBody>> listInstanceDeploymentsNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listMetricDefinitionsNext" })
        @GET
        Observable<Response<ResponseBody>> listMetricDefinitionsNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listMetricsNext" })
        @GET
        Observable<Response<ResponseBody>> listMetricsNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listPerfMonCountersNext" })
        @GET
        Observable<Response<ResponseBody>> listPerfMonCountersNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listSlotsNext" })
        @GET
        Observable<Response<ResponseBody>> listSlotsNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listBackupsSlotNext" })
        @GET
        Observable<Response<ResponseBody>> listBackupsSlotNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listDeploymentsSlotNext" })
        @GET
        Observable<Response<ResponseBody>> listDeploymentsSlotNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listDomainOwnershipIdentifiersSlotNext" })
        @GET
        Observable<Response<ResponseBody>> listDomainOwnershipIdentifiersSlotNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listHostNameBindingsSlotNext" })
        @GET
        Observable<Response<ResponseBody>> listHostNameBindingsSlotNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listInstanceIdentifiersSlotNext" })
        @GET
        Observable<Response<ResponseBody>> listInstanceIdentifiersSlotNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listInstanceDeploymentsSlotNext" })
        @GET
        Observable<Response<ResponseBody>> listInstanceDeploymentsSlotNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listMetricDefinitionsSlotNext" })
        @GET
        Observable<Response<ResponseBody>> listMetricDefinitionsSlotNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listMetricsSlotNext" })
        @GET
        Observable<Response<ResponseBody>> listMetricsSlotNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listPerfMonCountersSlotNext" })
        @GET
        Observable<Response<ResponseBody>> listPerfMonCountersSlotNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listSlotDifferencesSlotNext" })
        @GET
        Observable<Response<ResponseBody>> listSlotDifferencesSlotNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listSnapshotsSlotNext" })
        @GET
        Observable<Response<ResponseBody>> listSnapshotsSlotNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listUsagesSlotNext" })
        @GET
        Observable<Response<ResponseBody>> listUsagesSlotNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listSlotDifferencesFromProductionNext" })
        @GET
        Observable<Response<ResponseBody>> listSlotDifferencesFromProductionNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listSnapshotsNext" })
        @GET
        Observable<Response<ResponseBody>> listSnapshotsNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.appservice.WebApps listUsagesNext" })
        @GET
        Observable<Response<ResponseBody>> listUsagesNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

    }

    /**
     * Get all apps for a subscription.
     * Get all apps for a subscription.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SiteInner&gt; object if successful.
     */
    public PagedList<SiteInner> list() {
        ServiceResponse<Page<SiteInner>> response = listSinglePageAsync().toBlocking().single();
        return new PagedList<SiteInner>(response.body()) {
            @Override
            public Page<SiteInner> nextPage(String nextPageLink) {
                return listNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get all apps for a subscription.
     * Get all apps for a subscription.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SiteInner>> listAsync(final ListOperationCallback<SiteInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listSinglePageAsync(),
            new Func1<String, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(String nextPageLink) {
                    return listNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get all apps for a subscription.
     * Get all apps for a subscription.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<Page<SiteInner>> listAsync() {
        return listWithServiceResponseAsync()
            .map(new Func1<ServiceResponse<Page<SiteInner>>, Page<SiteInner>>() {
                @Override
                public Page<SiteInner> call(ServiceResponse<Page<SiteInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get all apps for a subscription.
     * Get all apps for a subscription.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInner>>> listWithServiceResponseAsync() {
        return listSinglePageAsync()
            .concatMap(new Func1<ServiceResponse<Page<SiteInner>>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(ServiceResponse<Page<SiteInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get all apps for a subscription.
     * Get all apps for a subscription.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInner>>> listSinglePageAsync() {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.list(this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInner>> result = listDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteInner>> listDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<SiteInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SiteInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets all web, mobile, and API apps in the specified resource group.
     * Gets all web, mobile, and API apps in the specified resource group.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SiteInner&gt; object if successful.
     */
    public PagedList<SiteInner> listByResourceGroup(final String resourceGroupName) {
        ServiceResponse<Page<SiteInner>> response = listByResourceGroupSinglePageAsync(resourceGroupName).toBlocking().single();
        return new PagedList<SiteInner>(response.body()) {
            @Override
            public Page<SiteInner> nextPage(String nextPageLink) {
                return listByResourceGroupNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets all web, mobile, and API apps in the specified resource group.
     * Gets all web, mobile, and API apps in the specified resource group.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SiteInner>> listByResourceGroupAsync(final String resourceGroupName, final ListOperationCallback<SiteInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByResourceGroupSinglePageAsync(resourceGroupName),
            new Func1<String, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(String nextPageLink) {
                    return listByResourceGroupNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets all web, mobile, and API apps in the specified resource group.
     * Gets all web, mobile, and API apps in the specified resource group.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<Page<SiteInner>> listByResourceGroupAsync(final String resourceGroupName) {
        return listByResourceGroupWithServiceResponseAsync(resourceGroupName)
            .map(new Func1<ServiceResponse<Page<SiteInner>>, Page<SiteInner>>() {
                @Override
                public Page<SiteInner> call(ServiceResponse<Page<SiteInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets all web, mobile, and API apps in the specified resource group.
     * Gets all web, mobile, and API apps in the specified resource group.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInner>>> listByResourceGroupWithServiceResponseAsync(final String resourceGroupName) {
        return listByResourceGroupSinglePageAsync(resourceGroupName)
            .concatMap(new Func1<ServiceResponse<Page<SiteInner>>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(ServiceResponse<Page<SiteInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByResourceGroupNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets all web, mobile, and API apps in the specified resource group.
     * Gets all web, mobile, and API apps in the specified resource group.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInner>>> listByResourceGroupSinglePageAsync(final String resourceGroupName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        final Boolean includeSlots = null;
        return service.listByResourceGroup(resourceGroupName, this.client.subscriptionId(), includeSlots, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInner>> result = listByResourceGroupDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets all web, mobile, and API apps in the specified resource group.
     * Gets all web, mobile, and API apps in the specified resource group.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param includeSlots Specify &lt;strong&gt;true&lt;/strong&gt; to include deployment slots in results. The default is false, which only gives you the production slot of all apps.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SiteInner&gt; object if successful.
     */
    public PagedList<SiteInner> listByResourceGroup(final String resourceGroupName, final Boolean includeSlots) {
        ServiceResponse<Page<SiteInner>> response = listByResourceGroupSinglePageAsync(resourceGroupName, includeSlots).toBlocking().single();
        return new PagedList<SiteInner>(response.body()) {
            @Override
            public Page<SiteInner> nextPage(String nextPageLink) {
                return listByResourceGroupNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets all web, mobile, and API apps in the specified resource group.
     * Gets all web, mobile, and API apps in the specified resource group.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param includeSlots Specify &lt;strong&gt;true&lt;/strong&gt; to include deployment slots in results. The default is false, which only gives you the production slot of all apps.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SiteInner>> listByResourceGroupAsync(final String resourceGroupName, final Boolean includeSlots, final ListOperationCallback<SiteInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByResourceGroupSinglePageAsync(resourceGroupName, includeSlots),
            new Func1<String, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(String nextPageLink) {
                    return listByResourceGroupNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets all web, mobile, and API apps in the specified resource group.
     * Gets all web, mobile, and API apps in the specified resource group.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param includeSlots Specify &lt;strong&gt;true&lt;/strong&gt; to include deployment slots in results. The default is false, which only gives you the production slot of all apps.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<Page<SiteInner>> listByResourceGroupAsync(final String resourceGroupName, final Boolean includeSlots) {
        return listByResourceGroupWithServiceResponseAsync(resourceGroupName, includeSlots)
            .map(new Func1<ServiceResponse<Page<SiteInner>>, Page<SiteInner>>() {
                @Override
                public Page<SiteInner> call(ServiceResponse<Page<SiteInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets all web, mobile, and API apps in the specified resource group.
     * Gets all web, mobile, and API apps in the specified resource group.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param includeSlots Specify &lt;strong&gt;true&lt;/strong&gt; to include deployment slots in results. The default is false, which only gives you the production slot of all apps.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInner>>> listByResourceGroupWithServiceResponseAsync(final String resourceGroupName, final Boolean includeSlots) {
        return listByResourceGroupSinglePageAsync(resourceGroupName, includeSlots)
            .concatMap(new Func1<ServiceResponse<Page<SiteInner>>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(ServiceResponse<Page<SiteInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByResourceGroupNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets all web, mobile, and API apps in the specified resource group.
     * Gets all web, mobile, and API apps in the specified resource group.
     *
    ServiceResponse<PageImpl<SiteInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<SiteInner>> * @param includeSlots Specify &lt;strong&gt;true&lt;/strong&gt; to include deployment slots in results. The default is false, which only gives you the production slot of all apps.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInner>>> listByResourceGroupSinglePageAsync(final String resourceGroupName, final Boolean includeSlots) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listByResourceGroup(resourceGroupName, this.client.subscriptionId(), includeSlots, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInner>> result = listByResourceGroupDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteInner>> listByResourceGroupDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<SiteInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SiteInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the details of a web, mobile, or API app.
     * Gets the details of a web, mobile, or API app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteInner object if successful.
     */
    public SiteInner getByResourceGroup(String resourceGroupName, String name) {
        return getByResourceGroupWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Gets the details of a web, mobile, or API app.
     * Gets the details of a web, mobile, or API app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteInner> getByResourceGroupAsync(String resourceGroupName, String name, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceFuture.fromResponse(getByResourceGroupWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the details of a web, mobile, or API app.
     * Gets the details of a web, mobile, or API app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteInner object
     */
    public Observable<SiteInner> getByResourceGroupAsync(String resourceGroupName, String name) {
        return getByResourceGroupWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<SiteInner>, SiteInner>() {
            @Override
            public SiteInner call(ServiceResponse<SiteInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the details of a web, mobile, or API app.
     * Gets the details of a web, mobile, or API app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteInner object
     */
    public Observable<ServiceResponse<SiteInner>> getByResourceGroupWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getByResourceGroup(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteInner> clientResponse = getByResourceGroupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteInner> getByResourceGroupDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteInner object if successful.
     */
    public SiteInner createOrUpdate(String resourceGroupName, String name, SiteInner siteEnvelope) {
        return createOrUpdateWithServiceResponseAsync(resourceGroupName, name, siteEnvelope).toBlocking().last().body();
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteInner> createOrUpdateAsync(String resourceGroupName, String name, SiteInner siteEnvelope, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateWithServiceResponseAsync(resourceGroupName, name, siteEnvelope), serviceCallback);
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<SiteInner> createOrUpdateAsync(String resourceGroupName, String name, SiteInner siteEnvelope) {
        return createOrUpdateWithServiceResponseAsync(resourceGroupName, name, siteEnvelope).map(new Func1<ServiceResponse<SiteInner>, SiteInner>() {
            @Override
            public SiteInner call(ServiceResponse<SiteInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<SiteInner>> createOrUpdateWithServiceResponseAsync(String resourceGroupName, String name, SiteInner siteEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteEnvelope == null) {
            throw new IllegalArgumentException("Parameter siteEnvelope is required and cannot be null.");
        }
        Validator.validate(siteEnvelope);
        final String apiVersion = "2016-08-01";
        final Boolean skipDnsRegistration = null;
        final Boolean skipCustomDomainVerification = null;
        final Boolean forceDnsRegistration = null;
        final String ttlInSeconds = null;
        Observable<Response<ResponseBody>> observable = service.createOrUpdate(resourceGroupName, name, this.client.subscriptionId(), siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds, apiVersion, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultAsync(observable, new TypeToken<SiteInner>() { }.getType());
    }
    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
      only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteInner object if successful.
     */
    public SiteInner createOrUpdate(String resourceGroupName, String name, SiteInner siteEnvelope, Boolean skipDnsRegistration, Boolean skipCustomDomainVerification, Boolean forceDnsRegistration, String ttlInSeconds) {
        return createOrUpdateWithServiceResponseAsync(resourceGroupName, name, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds).toBlocking().last().body();
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
      only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteInner> createOrUpdateAsync(String resourceGroupName, String name, SiteInner siteEnvelope, Boolean skipDnsRegistration, Boolean skipCustomDomainVerification, Boolean forceDnsRegistration, String ttlInSeconds, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateWithServiceResponseAsync(resourceGroupName, name, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds), serviceCallback);
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
      only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<SiteInner> createOrUpdateAsync(String resourceGroupName, String name, SiteInner siteEnvelope, Boolean skipDnsRegistration, Boolean skipCustomDomainVerification, Boolean forceDnsRegistration, String ttlInSeconds) {
        return createOrUpdateWithServiceResponseAsync(resourceGroupName, name, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds).map(new Func1<ServiceResponse<SiteInner>, SiteInner>() {
            @Override
            public SiteInner call(ServiceResponse<SiteInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
      only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<SiteInner>> createOrUpdateWithServiceResponseAsync(String resourceGroupName, String name, SiteInner siteEnvelope, Boolean skipDnsRegistration, Boolean skipCustomDomainVerification, Boolean forceDnsRegistration, String ttlInSeconds) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteEnvelope == null) {
            throw new IllegalArgumentException("Parameter siteEnvelope is required and cannot be null.");
        }
        Validator.validate(siteEnvelope);
        final String apiVersion = "2016-08-01";
        Observable<Response<ResponseBody>> observable = service.createOrUpdate(resourceGroupName, name, this.client.subscriptionId(), siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds, apiVersion, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultAsync(observable, new TypeToken<SiteInner>() { }.getType());
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteInner object if successful.
     */
    public SiteInner beginCreateOrUpdate(String resourceGroupName, String name, SiteInner siteEnvelope) {
        return beginCreateOrUpdateWithServiceResponseAsync(resourceGroupName, name, siteEnvelope).toBlocking().single().body();
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteInner> beginCreateOrUpdateAsync(String resourceGroupName, String name, SiteInner siteEnvelope, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginCreateOrUpdateWithServiceResponseAsync(resourceGroupName, name, siteEnvelope), serviceCallback);
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteInner object
     */
    public Observable<SiteInner> beginCreateOrUpdateAsync(String resourceGroupName, String name, SiteInner siteEnvelope) {
        return beginCreateOrUpdateWithServiceResponseAsync(resourceGroupName, name, siteEnvelope).map(new Func1<ServiceResponse<SiteInner>, SiteInner>() {
            @Override
            public SiteInner call(ServiceResponse<SiteInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteInner object
     */
    public Observable<ServiceResponse<SiteInner>> beginCreateOrUpdateWithServiceResponseAsync(String resourceGroupName, String name, SiteInner siteEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteEnvelope == null) {
            throw new IllegalArgumentException("Parameter siteEnvelope is required and cannot be null.");
        }
        Validator.validate(siteEnvelope);
        final String apiVersion = "2016-08-01";
        final Boolean skipDnsRegistration = null;
        final Boolean skipCustomDomainVerification = null;
        final Boolean forceDnsRegistration = null;
        final String ttlInSeconds = null;
        return service.beginCreateOrUpdate(resourceGroupName, name, this.client.subscriptionId(), siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteInner> clientResponse = beginCreateOrUpdateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
      only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteInner object if successful.
     */
    public SiteInner beginCreateOrUpdate(String resourceGroupName, String name, SiteInner siteEnvelope, Boolean skipDnsRegistration, Boolean skipCustomDomainVerification, Boolean forceDnsRegistration, String ttlInSeconds) {
        return beginCreateOrUpdateWithServiceResponseAsync(resourceGroupName, name, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds).toBlocking().single().body();
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
      only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteInner> beginCreateOrUpdateAsync(String resourceGroupName, String name, SiteInner siteEnvelope, Boolean skipDnsRegistration, Boolean skipCustomDomainVerification, Boolean forceDnsRegistration, String ttlInSeconds, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginCreateOrUpdateWithServiceResponseAsync(resourceGroupName, name, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds), serviceCallback);
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
      only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteInner object
     */
    public Observable<SiteInner> beginCreateOrUpdateAsync(String resourceGroupName, String name, SiteInner siteEnvelope, Boolean skipDnsRegistration, Boolean skipCustomDomainVerification, Boolean forceDnsRegistration, String ttlInSeconds) {
        return beginCreateOrUpdateWithServiceResponseAsync(resourceGroupName, name, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds).map(new Func1<ServiceResponse<SiteInner>, SiteInner>() {
            @Override
            public SiteInner call(ServiceResponse<SiteInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
      only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteInner object
     */
    public Observable<ServiceResponse<SiteInner>> beginCreateOrUpdateWithServiceResponseAsync(String resourceGroupName, String name, SiteInner siteEnvelope, Boolean skipDnsRegistration, Boolean skipCustomDomainVerification, Boolean forceDnsRegistration, String ttlInSeconds) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteEnvelope == null) {
            throw new IllegalArgumentException("Parameter siteEnvelope is required and cannot be null.");
        }
        Validator.validate(siteEnvelope);
        final String apiVersion = "2016-08-01";
        return service.beginCreateOrUpdate(resourceGroupName, name, this.client.subscriptionId(), siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteInner> clientResponse = beginCreateOrUpdateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteInner> beginCreateOrUpdateDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteInner>() { }.getType())
                .register(202, new TypeToken<SiteInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void delete(String resourceGroupName, String name) {
        deleteWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app to delete.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteAsync(String resourceGroupName, String name, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteAsync(String resourceGroupName, String name) {
        return deleteWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        final Boolean deleteMetrics = null;
        final Boolean deleteEmptyServerFarm = null;
        final Boolean skipDnsRegistration = null;
        return service.delete(resourceGroupName, name, this.client.subscriptionId(), deleteMetrics, deleteEmptyServerFarm, skipDnsRegistration, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app to delete.
     * @param deleteMetrics If true, web app metrics are also deleted
     * @param deleteEmptyServerFarm Specify true if the App Service plan will be empty after app deletion and you want to delete the empty App Service plan. By default, the empty App Service plan is not deleted.
     * @param skipDnsRegistration If true, DNS registration is skipped
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void delete(String resourceGroupName, String name, Boolean deleteMetrics, Boolean deleteEmptyServerFarm, Boolean skipDnsRegistration) {
        deleteWithServiceResponseAsync(resourceGroupName, name, deleteMetrics, deleteEmptyServerFarm, skipDnsRegistration).toBlocking().single().body();
    }

    /**
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app to delete.
     * @param deleteMetrics If true, web app metrics are also deleted
     * @param deleteEmptyServerFarm Specify true if the App Service plan will be empty after app deletion and you want to delete the empty App Service plan. By default, the empty App Service plan is not deleted.
     * @param skipDnsRegistration If true, DNS registration is skipped
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteAsync(String resourceGroupName, String name, Boolean deleteMetrics, Boolean deleteEmptyServerFarm, Boolean skipDnsRegistration, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteWithServiceResponseAsync(resourceGroupName, name, deleteMetrics, deleteEmptyServerFarm, skipDnsRegistration), serviceCallback);
    }

    /**
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app to delete.
     * @param deleteMetrics If true, web app metrics are also deleted
     * @param deleteEmptyServerFarm Specify true if the App Service plan will be empty after app deletion and you want to delete the empty App Service plan. By default, the empty App Service plan is not deleted.
     * @param skipDnsRegistration If true, DNS registration is skipped
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteAsync(String resourceGroupName, String name, Boolean deleteMetrics, Boolean deleteEmptyServerFarm, Boolean skipDnsRegistration) {
        return deleteWithServiceResponseAsync(resourceGroupName, name, deleteMetrics, deleteEmptyServerFarm, skipDnsRegistration).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app to delete.
     * @param deleteMetrics If true, web app metrics are also deleted
     * @param deleteEmptyServerFarm Specify true if the App Service plan will be empty after app deletion and you want to delete the empty App Service plan. By default, the empty App Service plan is not deleted.
     * @param skipDnsRegistration If true, DNS registration is skipped
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteWithServiceResponseAsync(String resourceGroupName, String name, Boolean deleteMetrics, Boolean deleteEmptyServerFarm, Boolean skipDnsRegistration) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.delete(resourceGroupName, name, this.client.subscriptionId(), deleteMetrics, deleteEmptyServerFarm, skipDnsRegistration, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Analyze a custom hostname.
     * Analyze a custom hostname.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the CustomHostnameAnalysisResultInner object if successful.
     */
    public CustomHostnameAnalysisResultInner analyzeCustomHostname(String resourceGroupName, String name) {
        return analyzeCustomHostnameWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Analyze a custom hostname.
     * Analyze a custom hostname.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<CustomHostnameAnalysisResultInner> analyzeCustomHostnameAsync(String resourceGroupName, String name, final ServiceCallback<CustomHostnameAnalysisResultInner> serviceCallback) {
        return ServiceFuture.fromResponse(analyzeCustomHostnameWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Analyze a custom hostname.
     * Analyze a custom hostname.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CustomHostnameAnalysisResultInner object
     */
    public Observable<CustomHostnameAnalysisResultInner> analyzeCustomHostnameAsync(String resourceGroupName, String name) {
        return analyzeCustomHostnameWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<CustomHostnameAnalysisResultInner>, CustomHostnameAnalysisResultInner>() {
            @Override
            public CustomHostnameAnalysisResultInner call(ServiceResponse<CustomHostnameAnalysisResultInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Analyze a custom hostname.
     * Analyze a custom hostname.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CustomHostnameAnalysisResultInner object
     */
    public Observable<ServiceResponse<CustomHostnameAnalysisResultInner>> analyzeCustomHostnameWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        final String hostName = null;
        return service.analyzeCustomHostname(resourceGroupName, name, this.client.subscriptionId(), hostName, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<CustomHostnameAnalysisResultInner>>>() {
                @Override
                public Observable<ServiceResponse<CustomHostnameAnalysisResultInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<CustomHostnameAnalysisResultInner> clientResponse = analyzeCustomHostnameDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Analyze a custom hostname.
     * Analyze a custom hostname.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param hostName Custom hostname
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the CustomHostnameAnalysisResultInner object if successful.
     */
    public CustomHostnameAnalysisResultInner analyzeCustomHostname(String resourceGroupName, String name, String hostName) {
        return analyzeCustomHostnameWithServiceResponseAsync(resourceGroupName, name, hostName).toBlocking().single().body();
    }

    /**
     * Analyze a custom hostname.
     * Analyze a custom hostname.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param hostName Custom hostname
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<CustomHostnameAnalysisResultInner> analyzeCustomHostnameAsync(String resourceGroupName, String name, String hostName, final ServiceCallback<CustomHostnameAnalysisResultInner> serviceCallback) {
        return ServiceFuture.fromResponse(analyzeCustomHostnameWithServiceResponseAsync(resourceGroupName, name, hostName), serviceCallback);
    }

    /**
     * Analyze a custom hostname.
     * Analyze a custom hostname.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param hostName Custom hostname
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CustomHostnameAnalysisResultInner object
     */
    public Observable<CustomHostnameAnalysisResultInner> analyzeCustomHostnameAsync(String resourceGroupName, String name, String hostName) {
        return analyzeCustomHostnameWithServiceResponseAsync(resourceGroupName, name, hostName).map(new Func1<ServiceResponse<CustomHostnameAnalysisResultInner>, CustomHostnameAnalysisResultInner>() {
            @Override
            public CustomHostnameAnalysisResultInner call(ServiceResponse<CustomHostnameAnalysisResultInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Analyze a custom hostname.
     * Analyze a custom hostname.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param hostName Custom hostname
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CustomHostnameAnalysisResultInner object
     */
    public Observable<ServiceResponse<CustomHostnameAnalysisResultInner>> analyzeCustomHostnameWithServiceResponseAsync(String resourceGroupName, String name, String hostName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.analyzeCustomHostname(resourceGroupName, name, this.client.subscriptionId(), hostName, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<CustomHostnameAnalysisResultInner>>>() {
                @Override
                public Observable<ServiceResponse<CustomHostnameAnalysisResultInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<CustomHostnameAnalysisResultInner> clientResponse = analyzeCustomHostnameDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<CustomHostnameAnalysisResultInner> analyzeCustomHostnameDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<CustomHostnameAnalysisResultInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<CustomHostnameAnalysisResultInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Applies the configuration settings from the target slot onto the current slot.
     * Applies the configuration settings from the target slot onto the current slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void applySlotConfigToProduction(String resourceGroupName, String name, CsmSlotEntityInner slotSwapEntity) {
        applySlotConfigToProductionWithServiceResponseAsync(resourceGroupName, name, slotSwapEntity).toBlocking().single().body();
    }

    /**
     * Applies the configuration settings from the target slot onto the current slot.
     * Applies the configuration settings from the target slot onto the current slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> applySlotConfigToProductionAsync(String resourceGroupName, String name, CsmSlotEntityInner slotSwapEntity, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(applySlotConfigToProductionWithServiceResponseAsync(resourceGroupName, name, slotSwapEntity), serviceCallback);
    }

    /**
     * Applies the configuration settings from the target slot onto the current slot.
     * Applies the configuration settings from the target slot onto the current slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> applySlotConfigToProductionAsync(String resourceGroupName, String name, CsmSlotEntityInner slotSwapEntity) {
        return applySlotConfigToProductionWithServiceResponseAsync(resourceGroupName, name, slotSwapEntity).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Applies the configuration settings from the target slot onto the current slot.
     * Applies the configuration settings from the target slot onto the current slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> applySlotConfigToProductionWithServiceResponseAsync(String resourceGroupName, String name, CsmSlotEntityInner slotSwapEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (slotSwapEntity == null) {
            throw new IllegalArgumentException("Parameter slotSwapEntity is required and cannot be null.");
        }
        Validator.validate(slotSwapEntity);
        final String apiVersion = "2016-08-01";
        return service.applySlotConfigToProduction(resourceGroupName, name, this.client.subscriptionId(), slotSwapEntity, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = applySlotConfigToProductionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> applySlotConfigToProductionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a backup of an app.
     * Creates a backup of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param request Backup configuration. You can use the JSON response from the POST action as input here.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BackupItemInner object if successful.
     */
    public BackupItemInner backup(String resourceGroupName, String name, BackupRequestInner request) {
        return backupWithServiceResponseAsync(resourceGroupName, name, request).toBlocking().single().body();
    }

    /**
     * Creates a backup of an app.
     * Creates a backup of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param request Backup configuration. You can use the JSON response from the POST action as input here.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BackupItemInner> backupAsync(String resourceGroupName, String name, BackupRequestInner request, final ServiceCallback<BackupItemInner> serviceCallback) {
        return ServiceFuture.fromResponse(backupWithServiceResponseAsync(resourceGroupName, name, request), serviceCallback);
    }

    /**
     * Creates a backup of an app.
     * Creates a backup of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param request Backup configuration. You can use the JSON response from the POST action as input here.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BackupItemInner object
     */
    public Observable<BackupItemInner> backupAsync(String resourceGroupName, String name, BackupRequestInner request) {
        return backupWithServiceResponseAsync(resourceGroupName, name, request).map(new Func1<ServiceResponse<BackupItemInner>, BackupItemInner>() {
            @Override
            public BackupItemInner call(ServiceResponse<BackupItemInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a backup of an app.
     * Creates a backup of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param request Backup configuration. You can use the JSON response from the POST action as input here.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BackupItemInner object
     */
    public Observable<ServiceResponse<BackupItemInner>> backupWithServiceResponseAsync(String resourceGroupName, String name, BackupRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        final String apiVersion = "2016-08-01";
        return service.backup(resourceGroupName, name, this.client.subscriptionId(), request, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupItemInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupItemInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupItemInner> clientResponse = backupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupItemInner> backupDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<BackupItemInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BackupItemInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets existing backups of an app.
     * Gets existing backups of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;BackupItemInner&gt; object if successful.
     */
    public PagedList<BackupItemInner> listBackups(final String resourceGroupName, final String name) {
        ServiceResponse<Page<BackupItemInner>> response = listBackupsSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<BackupItemInner>(response.body()) {
            @Override
            public Page<BackupItemInner> nextPage(String nextPageLink) {
                return listBackupsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets existing backups of an app.
     * Gets existing backups of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<BackupItemInner>> listBackupsAsync(final String resourceGroupName, final String name, final ListOperationCallback<BackupItemInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listBackupsSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(String nextPageLink) {
                    return listBackupsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets existing backups of an app.
     * Gets existing backups of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;BackupItemInner&gt; object
     */
    public Observable<Page<BackupItemInner>> listBackupsAsync(final String resourceGroupName, final String name) {
        return listBackupsWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<BackupItemInner>>, Page<BackupItemInner>>() {
                @Override
                public Page<BackupItemInner> call(ServiceResponse<Page<BackupItemInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets existing backups of an app.
     * Gets existing backups of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;BackupItemInner&gt; object
     */
    public Observable<ServiceResponse<Page<BackupItemInner>>> listBackupsWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return listBackupsSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<BackupItemInner>>, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(ServiceResponse<Page<BackupItemInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listBackupsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets existing backups of an app.
     * Gets existing backups of an app.
     *
    ServiceResponse<PageImpl<BackupItemInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<BackupItemInner>> * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;BackupItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<BackupItemInner>>> listBackupsSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listBackups(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<BackupItemInner>> result = listBackupsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<BackupItemInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<BackupItemInner>> listBackupsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<BackupItemInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<BackupItemInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Discovers an existing app backup that can be restored from a blob in Azure storage.
     * Discovers an existing app backup that can be restored from a blob in Azure storage.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param request A RestoreRequest object that includes Azure storage URL and blog name for discovery of backup.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RestoreRequestInner object if successful.
     */
    public RestoreRequestInner discoverRestore(String resourceGroupName, String name, RestoreRequestInner request) {
        return discoverRestoreWithServiceResponseAsync(resourceGroupName, name, request).toBlocking().single().body();
    }

    /**
     * Discovers an existing app backup that can be restored from a blob in Azure storage.
     * Discovers an existing app backup that can be restored from a blob in Azure storage.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param request A RestoreRequest object that includes Azure storage URL and blog name for discovery of backup.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RestoreRequestInner> discoverRestoreAsync(String resourceGroupName, String name, RestoreRequestInner request, final ServiceCallback<RestoreRequestInner> serviceCallback) {
        return ServiceFuture.fromResponse(discoverRestoreWithServiceResponseAsync(resourceGroupName, name, request), serviceCallback);
    }

    /**
     * Discovers an existing app backup that can be restored from a blob in Azure storage.
     * Discovers an existing app backup that can be restored from a blob in Azure storage.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param request A RestoreRequest object that includes Azure storage URL and blog name for discovery of backup.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RestoreRequestInner object
     */
    public Observable<RestoreRequestInner> discoverRestoreAsync(String resourceGroupName, String name, RestoreRequestInner request) {
        return discoverRestoreWithServiceResponseAsync(resourceGroupName, name, request).map(new Func1<ServiceResponse<RestoreRequestInner>, RestoreRequestInner>() {
            @Override
            public RestoreRequestInner call(ServiceResponse<RestoreRequestInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Discovers an existing app backup that can be restored from a blob in Azure storage.
     * Discovers an existing app backup that can be restored from a blob in Azure storage.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param request A RestoreRequest object that includes Azure storage URL and blog name for discovery of backup.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RestoreRequestInner object
     */
    public Observable<ServiceResponse<RestoreRequestInner>> discoverRestoreWithServiceResponseAsync(String resourceGroupName, String name, RestoreRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        final String apiVersion = "2016-08-01";
        return service.discoverRestore(resourceGroupName, name, this.client.subscriptionId(), request, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RestoreRequestInner>>>() {
                @Override
                public Observable<ServiceResponse<RestoreRequestInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RestoreRequestInner> clientResponse = discoverRestoreDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RestoreRequestInner> discoverRestoreDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<RestoreRequestInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<RestoreRequestInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets a backup of an app by its ID.
     * Gets a backup of an app by its ID.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BackupItemInner object if successful.
     */
    public BackupItemInner getBackupStatus(String resourceGroupName, String name, String backupId) {
        return getBackupStatusWithServiceResponseAsync(resourceGroupName, name, backupId).toBlocking().single().body();
    }

    /**
     * Gets a backup of an app by its ID.
     * Gets a backup of an app by its ID.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BackupItemInner> getBackupStatusAsync(String resourceGroupName, String name, String backupId, final ServiceCallback<BackupItemInner> serviceCallback) {
        return ServiceFuture.fromResponse(getBackupStatusWithServiceResponseAsync(resourceGroupName, name, backupId), serviceCallback);
    }

    /**
     * Gets a backup of an app by its ID.
     * Gets a backup of an app by its ID.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BackupItemInner object
     */
    public Observable<BackupItemInner> getBackupStatusAsync(String resourceGroupName, String name, String backupId) {
        return getBackupStatusWithServiceResponseAsync(resourceGroupName, name, backupId).map(new Func1<ServiceResponse<BackupItemInner>, BackupItemInner>() {
            @Override
            public BackupItemInner call(ServiceResponse<BackupItemInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a backup of an app by its ID.
     * Gets a backup of an app by its ID.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BackupItemInner object
     */
    public Observable<ServiceResponse<BackupItemInner>> getBackupStatusWithServiceResponseAsync(String resourceGroupName, String name, String backupId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (backupId == null) {
            throw new IllegalArgumentException("Parameter backupId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getBackupStatus(resourceGroupName, name, backupId, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupItemInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupItemInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupItemInner> clientResponse = getBackupStatusDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupItemInner> getBackupStatusDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<BackupItemInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BackupItemInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a backup of an app by its ID.
     * Deletes a backup of an app by its ID.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteBackup(String resourceGroupName, String name, String backupId) {
        deleteBackupWithServiceResponseAsync(resourceGroupName, name, backupId).toBlocking().single().body();
    }

    /**
     * Deletes a backup of an app by its ID.
     * Deletes a backup of an app by its ID.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteBackupAsync(String resourceGroupName, String name, String backupId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteBackupWithServiceResponseAsync(resourceGroupName, name, backupId), serviceCallback);
    }

    /**
     * Deletes a backup of an app by its ID.
     * Deletes a backup of an app by its ID.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteBackupAsync(String resourceGroupName, String name, String backupId) {
        return deleteBackupWithServiceResponseAsync(resourceGroupName, name, backupId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a backup of an app by its ID.
     * Deletes a backup of an app by its ID.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteBackupWithServiceResponseAsync(String resourceGroupName, String name, String backupId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (backupId == null) {
            throw new IllegalArgumentException("Parameter backupId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.deleteBackup(resourceGroupName, name, backupId, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteBackupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteBackupDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param backupId Id of backup
     * @param request Information on backup request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BackupItemInner object if successful.
     */
    public BackupItemInner listBackupStatusSecrets(String resourceGroupName, String name, String backupId, BackupRequestInner request) {
        return listBackupStatusSecretsWithServiceResponseAsync(resourceGroupName, name, backupId, request).toBlocking().single().body();
    }

    /**
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param backupId Id of backup
     * @param request Information on backup request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BackupItemInner> listBackupStatusSecretsAsync(String resourceGroupName, String name, String backupId, BackupRequestInner request, final ServiceCallback<BackupItemInner> serviceCallback) {
        return ServiceFuture.fromResponse(listBackupStatusSecretsWithServiceResponseAsync(resourceGroupName, name, backupId, request), serviceCallback);
    }

    /**
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param backupId Id of backup
     * @param request Information on backup request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BackupItemInner object
     */
    public Observable<BackupItemInner> listBackupStatusSecretsAsync(String resourceGroupName, String name, String backupId, BackupRequestInner request) {
        return listBackupStatusSecretsWithServiceResponseAsync(resourceGroupName, name, backupId, request).map(new Func1<ServiceResponse<BackupItemInner>, BackupItemInner>() {
            @Override
            public BackupItemInner call(ServiceResponse<BackupItemInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param backupId Id of backup
     * @param request Information on backup request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BackupItemInner object
     */
    public Observable<ServiceResponse<BackupItemInner>> listBackupStatusSecretsWithServiceResponseAsync(String resourceGroupName, String name, String backupId, BackupRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (backupId == null) {
            throw new IllegalArgumentException("Parameter backupId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        final String apiVersion = "2016-08-01";
        return service.listBackupStatusSecrets(resourceGroupName, name, backupId, this.client.subscriptionId(), request, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupItemInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupItemInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupItemInner> clientResponse = listBackupStatusSecretsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupItemInner> listBackupStatusSecretsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<BackupItemInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BackupItemInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Restores a specific backup to another app (or deployment slot, if specified).
     * Restores a specific backup to another app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param request Information on restore request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RestoreResponseInner object if successful.
     */
    public RestoreResponseInner restore(String resourceGroupName, String name, String backupId, RestoreRequestInner request) {
        return restoreWithServiceResponseAsync(resourceGroupName, name, backupId, request).toBlocking().last().body();
    }

    /**
     * Restores a specific backup to another app (or deployment slot, if specified).
     * Restores a specific backup to another app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param request Information on restore request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RestoreResponseInner> restoreAsync(String resourceGroupName, String name, String backupId, RestoreRequestInner request, final ServiceCallback<RestoreResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(restoreWithServiceResponseAsync(resourceGroupName, name, backupId, request), serviceCallback);
    }

    /**
     * Restores a specific backup to another app (or deployment slot, if specified).
     * Restores a specific backup to another app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param request Information on restore request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<RestoreResponseInner> restoreAsync(String resourceGroupName, String name, String backupId, RestoreRequestInner request) {
        return restoreWithServiceResponseAsync(resourceGroupName, name, backupId, request).map(new Func1<ServiceResponse<RestoreResponseInner>, RestoreResponseInner>() {
            @Override
            public RestoreResponseInner call(ServiceResponse<RestoreResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Restores a specific backup to another app (or deployment slot, if specified).
     * Restores a specific backup to another app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param request Information on restore request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<RestoreResponseInner>> restoreWithServiceResponseAsync(String resourceGroupName, String name, String backupId, RestoreRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (backupId == null) {
            throw new IllegalArgumentException("Parameter backupId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        final String apiVersion = "2016-08-01";
        Observable<Response<ResponseBody>> observable = service.restore(resourceGroupName, name, backupId, this.client.subscriptionId(), request, apiVersion, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<RestoreResponseInner>() { }.getType());
    }

    /**
     * Restores a specific backup to another app (or deployment slot, if specified).
     * Restores a specific backup to another app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param request Information on restore request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RestoreResponseInner object if successful.
     */
    public RestoreResponseInner beginRestore(String resourceGroupName, String name, String backupId, RestoreRequestInner request) {
        return beginRestoreWithServiceResponseAsync(resourceGroupName, name, backupId, request).toBlocking().single().body();
    }

    /**
     * Restores a specific backup to another app (or deployment slot, if specified).
     * Restores a specific backup to another app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param request Information on restore request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RestoreResponseInner> beginRestoreAsync(String resourceGroupName, String name, String backupId, RestoreRequestInner request, final ServiceCallback<RestoreResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginRestoreWithServiceResponseAsync(resourceGroupName, name, backupId, request), serviceCallback);
    }

    /**
     * Restores a specific backup to another app (or deployment slot, if specified).
     * Restores a specific backup to another app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param request Information on restore request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RestoreResponseInner object
     */
    public Observable<RestoreResponseInner> beginRestoreAsync(String resourceGroupName, String name, String backupId, RestoreRequestInner request) {
        return beginRestoreWithServiceResponseAsync(resourceGroupName, name, backupId, request).map(new Func1<ServiceResponse<RestoreResponseInner>, RestoreResponseInner>() {
            @Override
            public RestoreResponseInner call(ServiceResponse<RestoreResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Restores a specific backup to another app (or deployment slot, if specified).
     * Restores a specific backup to another app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param request Information on restore request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RestoreResponseInner object
     */
    public Observable<ServiceResponse<RestoreResponseInner>> beginRestoreWithServiceResponseAsync(String resourceGroupName, String name, String backupId, RestoreRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (backupId == null) {
            throw new IllegalArgumentException("Parameter backupId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        final String apiVersion = "2016-08-01";
        return service.beginRestore(resourceGroupName, name, backupId, this.client.subscriptionId(), request, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RestoreResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<RestoreResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RestoreResponseInner> clientResponse = beginRestoreDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RestoreResponseInner> beginRestoreDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<RestoreResponseInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<RestoreResponseInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Replaces the application settings of an app.
     * Replaces the application settings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param appSettings Application settings of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StringDictionaryInner object if successful.
     */
    public StringDictionaryInner updateApplicationSettings(String resourceGroupName, String name, StringDictionaryInner appSettings) {
        return updateApplicationSettingsWithServiceResponseAsync(resourceGroupName, name, appSettings).toBlocking().single().body();
    }

    /**
     * Replaces the application settings of an app.
     * Replaces the application settings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param appSettings Application settings of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StringDictionaryInner> updateApplicationSettingsAsync(String resourceGroupName, String name, StringDictionaryInner appSettings, final ServiceCallback<StringDictionaryInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateApplicationSettingsWithServiceResponseAsync(resourceGroupName, name, appSettings), serviceCallback);
    }

    /**
     * Replaces the application settings of an app.
     * Replaces the application settings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param appSettings Application settings of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<StringDictionaryInner> updateApplicationSettingsAsync(String resourceGroupName, String name, StringDictionaryInner appSettings) {
        return updateApplicationSettingsWithServiceResponseAsync(resourceGroupName, name, appSettings).map(new Func1<ServiceResponse<StringDictionaryInner>, StringDictionaryInner>() {
            @Override
            public StringDictionaryInner call(ServiceResponse<StringDictionaryInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Replaces the application settings of an app.
     * Replaces the application settings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param appSettings Application settings of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<ServiceResponse<StringDictionaryInner>> updateApplicationSettingsWithServiceResponseAsync(String resourceGroupName, String name, StringDictionaryInner appSettings) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (appSettings == null) {
            throw new IllegalArgumentException("Parameter appSettings is required and cannot be null.");
        }
        Validator.validate(appSettings);
        final String apiVersion = "2016-08-01";
        return service.updateApplicationSettings(resourceGroupName, name, this.client.subscriptionId(), appSettings, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<StringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StringDictionaryInner> clientResponse = updateApplicationSettingsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StringDictionaryInner> updateApplicationSettingsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<StringDictionaryInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<StringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the application settings of an app.
     * Gets the application settings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StringDictionaryInner object if successful.
     */
    public StringDictionaryInner listApplicationSettings(String resourceGroupName, String name) {
        return listApplicationSettingsWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Gets the application settings of an app.
     * Gets the application settings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StringDictionaryInner> listApplicationSettingsAsync(String resourceGroupName, String name, final ServiceCallback<StringDictionaryInner> serviceCallback) {
        return ServiceFuture.fromResponse(listApplicationSettingsWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the application settings of an app.
     * Gets the application settings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<StringDictionaryInner> listApplicationSettingsAsync(String resourceGroupName, String name) {
        return listApplicationSettingsWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<StringDictionaryInner>, StringDictionaryInner>() {
            @Override
            public StringDictionaryInner call(ServiceResponse<StringDictionaryInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the application settings of an app.
     * Gets the application settings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<ServiceResponse<StringDictionaryInner>> listApplicationSettingsWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listApplicationSettings(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<StringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StringDictionaryInner> clientResponse = listApplicationSettingsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StringDictionaryInner> listApplicationSettingsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<StringDictionaryInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<StringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the Authentication / Authorization settings associated with web app.
     * Updates the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param siteAuthSettings Auth settings associated with web app
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteAuthSettingsInner object if successful.
     */
    public SiteAuthSettingsInner updateAuthSettings(String resourceGroupName, String name, SiteAuthSettingsInner siteAuthSettings) {
        return updateAuthSettingsWithServiceResponseAsync(resourceGroupName, name, siteAuthSettings).toBlocking().single().body();
    }

    /**
     * Updates the Authentication / Authorization settings associated with web app.
     * Updates the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param siteAuthSettings Auth settings associated with web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteAuthSettingsInner> updateAuthSettingsAsync(String resourceGroupName, String name, SiteAuthSettingsInner siteAuthSettings, final ServiceCallback<SiteAuthSettingsInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateAuthSettingsWithServiceResponseAsync(resourceGroupName, name, siteAuthSettings), serviceCallback);
    }

    /**
     * Updates the Authentication / Authorization settings associated with web app.
     * Updates the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param siteAuthSettings Auth settings associated with web app
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteAuthSettingsInner object
     */
    public Observable<SiteAuthSettingsInner> updateAuthSettingsAsync(String resourceGroupName, String name, SiteAuthSettingsInner siteAuthSettings) {
        return updateAuthSettingsWithServiceResponseAsync(resourceGroupName, name, siteAuthSettings).map(new Func1<ServiceResponse<SiteAuthSettingsInner>, SiteAuthSettingsInner>() {
            @Override
            public SiteAuthSettingsInner call(ServiceResponse<SiteAuthSettingsInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the Authentication / Authorization settings associated with web app.
     * Updates the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param siteAuthSettings Auth settings associated with web app
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteAuthSettingsInner object
     */
    public Observable<ServiceResponse<SiteAuthSettingsInner>> updateAuthSettingsWithServiceResponseAsync(String resourceGroupName, String name, SiteAuthSettingsInner siteAuthSettings) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteAuthSettings == null) {
            throw new IllegalArgumentException("Parameter siteAuthSettings is required and cannot be null.");
        }
        Validator.validate(siteAuthSettings);
        final String apiVersion = "2016-08-01";
        return service.updateAuthSettings(resourceGroupName, name, this.client.subscriptionId(), siteAuthSettings, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteAuthSettingsInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteAuthSettingsInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteAuthSettingsInner> clientResponse = updateAuthSettingsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteAuthSettingsInner> updateAuthSettingsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteAuthSettingsInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteAuthSettingsInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the Authentication/Authorization settings of an app.
     * Gets the Authentication/Authorization settings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteAuthSettingsInner object if successful.
     */
    public SiteAuthSettingsInner getAuthSettings(String resourceGroupName, String name) {
        return getAuthSettingsWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Gets the Authentication/Authorization settings of an app.
     * Gets the Authentication/Authorization settings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteAuthSettingsInner> getAuthSettingsAsync(String resourceGroupName, String name, final ServiceCallback<SiteAuthSettingsInner> serviceCallback) {
        return ServiceFuture.fromResponse(getAuthSettingsWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the Authentication/Authorization settings of an app.
     * Gets the Authentication/Authorization settings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteAuthSettingsInner object
     */
    public Observable<SiteAuthSettingsInner> getAuthSettingsAsync(String resourceGroupName, String name) {
        return getAuthSettingsWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<SiteAuthSettingsInner>, SiteAuthSettingsInner>() {
            @Override
            public SiteAuthSettingsInner call(ServiceResponse<SiteAuthSettingsInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the Authentication/Authorization settings of an app.
     * Gets the Authentication/Authorization settings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteAuthSettingsInner object
     */
    public Observable<ServiceResponse<SiteAuthSettingsInner>> getAuthSettingsWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getAuthSettings(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteAuthSettingsInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteAuthSettingsInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteAuthSettingsInner> clientResponse = getAuthSettingsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteAuthSettingsInner> getAuthSettingsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteAuthSettingsInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteAuthSettingsInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the backup configuration of an app.
     * Updates the backup configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param request Edited backup configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BackupRequestInner object if successful.
     */
    public BackupRequestInner updateBackupConfiguration(String resourceGroupName, String name, BackupRequestInner request) {
        return updateBackupConfigurationWithServiceResponseAsync(resourceGroupName, name, request).toBlocking().single().body();
    }

    /**
     * Updates the backup configuration of an app.
     * Updates the backup configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param request Edited backup configuration.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BackupRequestInner> updateBackupConfigurationAsync(String resourceGroupName, String name, BackupRequestInner request, final ServiceCallback<BackupRequestInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateBackupConfigurationWithServiceResponseAsync(resourceGroupName, name, request), serviceCallback);
    }

    /**
     * Updates the backup configuration of an app.
     * Updates the backup configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param request Edited backup configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BackupRequestInner object
     */
    public Observable<BackupRequestInner> updateBackupConfigurationAsync(String resourceGroupName, String name, BackupRequestInner request) {
        return updateBackupConfigurationWithServiceResponseAsync(resourceGroupName, name, request).map(new Func1<ServiceResponse<BackupRequestInner>, BackupRequestInner>() {
            @Override
            public BackupRequestInner call(ServiceResponse<BackupRequestInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the backup configuration of an app.
     * Updates the backup configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param request Edited backup configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BackupRequestInner object
     */
    public Observable<ServiceResponse<BackupRequestInner>> updateBackupConfigurationWithServiceResponseAsync(String resourceGroupName, String name, BackupRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        final String apiVersion = "2016-08-01";
        return service.updateBackupConfiguration(resourceGroupName, name, this.client.subscriptionId(), request, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupRequestInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupRequestInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupRequestInner> clientResponse = updateBackupConfigurationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupRequestInner> updateBackupConfigurationDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<BackupRequestInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BackupRequestInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes the backup configuration of an app.
     * Deletes the backup configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteBackupConfiguration(String resourceGroupName, String name) {
        deleteBackupConfigurationWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Deletes the backup configuration of an app.
     * Deletes the backup configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteBackupConfigurationAsync(String resourceGroupName, String name, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteBackupConfigurationWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Deletes the backup configuration of an app.
     * Deletes the backup configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteBackupConfigurationAsync(String resourceGroupName, String name) {
        return deleteBackupConfigurationWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes the backup configuration of an app.
     * Deletes the backup configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteBackupConfigurationWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.deleteBackupConfiguration(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteBackupConfigurationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteBackupConfigurationDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the backup configuration of an app.
     * Gets the backup configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BackupRequestInner object if successful.
     */
    public BackupRequestInner getBackupConfiguration(String resourceGroupName, String name) {
        return getBackupConfigurationWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Gets the backup configuration of an app.
     * Gets the backup configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BackupRequestInner> getBackupConfigurationAsync(String resourceGroupName, String name, final ServiceCallback<BackupRequestInner> serviceCallback) {
        return ServiceFuture.fromResponse(getBackupConfigurationWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the backup configuration of an app.
     * Gets the backup configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BackupRequestInner object
     */
    public Observable<BackupRequestInner> getBackupConfigurationAsync(String resourceGroupName, String name) {
        return getBackupConfigurationWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<BackupRequestInner>, BackupRequestInner>() {
            @Override
            public BackupRequestInner call(ServiceResponse<BackupRequestInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the backup configuration of an app.
     * Gets the backup configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BackupRequestInner object
     */
    public Observable<ServiceResponse<BackupRequestInner>> getBackupConfigurationWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getBackupConfiguration(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupRequestInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupRequestInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupRequestInner> clientResponse = getBackupConfigurationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupRequestInner> getBackupConfigurationDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<BackupRequestInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BackupRequestInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Replaces the connection strings of an app.
     * Replaces the connection strings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param connectionStrings Connection strings of the app or deployment slot. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ConnectionStringDictionaryInner object if successful.
     */
    public ConnectionStringDictionaryInner updateConnectionStrings(String resourceGroupName, String name, ConnectionStringDictionaryInner connectionStrings) {
        return updateConnectionStringsWithServiceResponseAsync(resourceGroupName, name, connectionStrings).toBlocking().single().body();
    }

    /**
     * Replaces the connection strings of an app.
     * Replaces the connection strings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param connectionStrings Connection strings of the app or deployment slot. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ConnectionStringDictionaryInner> updateConnectionStringsAsync(String resourceGroupName, String name, ConnectionStringDictionaryInner connectionStrings, final ServiceCallback<ConnectionStringDictionaryInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateConnectionStringsWithServiceResponseAsync(resourceGroupName, name, connectionStrings), serviceCallback);
    }

    /**
     * Replaces the connection strings of an app.
     * Replaces the connection strings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param connectionStrings Connection strings of the app or deployment slot. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ConnectionStringDictionaryInner object
     */
    public Observable<ConnectionStringDictionaryInner> updateConnectionStringsAsync(String resourceGroupName, String name, ConnectionStringDictionaryInner connectionStrings) {
        return updateConnectionStringsWithServiceResponseAsync(resourceGroupName, name, connectionStrings).map(new Func1<ServiceResponse<ConnectionStringDictionaryInner>, ConnectionStringDictionaryInner>() {
            @Override
            public ConnectionStringDictionaryInner call(ServiceResponse<ConnectionStringDictionaryInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Replaces the connection strings of an app.
     * Replaces the connection strings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param connectionStrings Connection strings of the app or deployment slot. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ConnectionStringDictionaryInner object
     */
    public Observable<ServiceResponse<ConnectionStringDictionaryInner>> updateConnectionStringsWithServiceResponseAsync(String resourceGroupName, String name, ConnectionStringDictionaryInner connectionStrings) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionStrings == null) {
            throw new IllegalArgumentException("Parameter connectionStrings is required and cannot be null.");
        }
        Validator.validate(connectionStrings);
        final String apiVersion = "2016-08-01";
        return service.updateConnectionStrings(resourceGroupName, name, this.client.subscriptionId(), connectionStrings, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ConnectionStringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<ConnectionStringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ConnectionStringDictionaryInner> clientResponse = updateConnectionStringsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ConnectionStringDictionaryInner> updateConnectionStringsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ConnectionStringDictionaryInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ConnectionStringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the connection strings of an app.
     * Gets the connection strings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ConnectionStringDictionaryInner object if successful.
     */
    public ConnectionStringDictionaryInner listConnectionStrings(String resourceGroupName, String name) {
        return listConnectionStringsWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Gets the connection strings of an app.
     * Gets the connection strings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ConnectionStringDictionaryInner> listConnectionStringsAsync(String resourceGroupName, String name, final ServiceCallback<ConnectionStringDictionaryInner> serviceCallback) {
        return ServiceFuture.fromResponse(listConnectionStringsWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the connection strings of an app.
     * Gets the connection strings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ConnectionStringDictionaryInner object
     */
    public Observable<ConnectionStringDictionaryInner> listConnectionStringsAsync(String resourceGroupName, String name) {
        return listConnectionStringsWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<ConnectionStringDictionaryInner>, ConnectionStringDictionaryInner>() {
            @Override
            public ConnectionStringDictionaryInner call(ServiceResponse<ConnectionStringDictionaryInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the connection strings of an app.
     * Gets the connection strings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ConnectionStringDictionaryInner object
     */
    public Observable<ServiceResponse<ConnectionStringDictionaryInner>> listConnectionStringsWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listConnectionStrings(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ConnectionStringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<ConnectionStringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ConnectionStringDictionaryInner> clientResponse = listConnectionStringsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ConnectionStringDictionaryInner> listConnectionStringsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ConnectionStringDictionaryInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ConnectionStringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the logging configuration of an app.
     * Gets the logging configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteLogsConfigInner object if successful.
     */
    public SiteLogsConfigInner getDiagnosticLogsConfiguration(String resourceGroupName, String name) {
        return getDiagnosticLogsConfigurationWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Gets the logging configuration of an app.
     * Gets the logging configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteLogsConfigInner> getDiagnosticLogsConfigurationAsync(String resourceGroupName, String name, final ServiceCallback<SiteLogsConfigInner> serviceCallback) {
        return ServiceFuture.fromResponse(getDiagnosticLogsConfigurationWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the logging configuration of an app.
     * Gets the logging configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteLogsConfigInner object
     */
    public Observable<SiteLogsConfigInner> getDiagnosticLogsConfigurationAsync(String resourceGroupName, String name) {
        return getDiagnosticLogsConfigurationWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<SiteLogsConfigInner>, SiteLogsConfigInner>() {
            @Override
            public SiteLogsConfigInner call(ServiceResponse<SiteLogsConfigInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the logging configuration of an app.
     * Gets the logging configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteLogsConfigInner object
     */
    public Observable<ServiceResponse<SiteLogsConfigInner>> getDiagnosticLogsConfigurationWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getDiagnosticLogsConfiguration(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteLogsConfigInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteLogsConfigInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteLogsConfigInner> clientResponse = getDiagnosticLogsConfigurationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteLogsConfigInner> getDiagnosticLogsConfigurationDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteLogsConfigInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteLogsConfigInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the logging configuration of an app.
     * Updates the logging configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteLogsConfig A SiteLogsConfig JSON object that contains the logging configuration to change in the "properties" property.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteLogsConfigInner object if successful.
     */
    public SiteLogsConfigInner updateDiagnosticLogsConfig(String resourceGroupName, String name, SiteLogsConfigInner siteLogsConfig) {
        return updateDiagnosticLogsConfigWithServiceResponseAsync(resourceGroupName, name, siteLogsConfig).toBlocking().single().body();
    }

    /**
     * Updates the logging configuration of an app.
     * Updates the logging configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteLogsConfig A SiteLogsConfig JSON object that contains the logging configuration to change in the "properties" property.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteLogsConfigInner> updateDiagnosticLogsConfigAsync(String resourceGroupName, String name, SiteLogsConfigInner siteLogsConfig, final ServiceCallback<SiteLogsConfigInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateDiagnosticLogsConfigWithServiceResponseAsync(resourceGroupName, name, siteLogsConfig), serviceCallback);
    }

    /**
     * Updates the logging configuration of an app.
     * Updates the logging configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteLogsConfig A SiteLogsConfig JSON object that contains the logging configuration to change in the "properties" property.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteLogsConfigInner object
     */
    public Observable<SiteLogsConfigInner> updateDiagnosticLogsConfigAsync(String resourceGroupName, String name, SiteLogsConfigInner siteLogsConfig) {
        return updateDiagnosticLogsConfigWithServiceResponseAsync(resourceGroupName, name, siteLogsConfig).map(new Func1<ServiceResponse<SiteLogsConfigInner>, SiteLogsConfigInner>() {
            @Override
            public SiteLogsConfigInner call(ServiceResponse<SiteLogsConfigInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the logging configuration of an app.
     * Updates the logging configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteLogsConfig A SiteLogsConfig JSON object that contains the logging configuration to change in the "properties" property.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteLogsConfigInner object
     */
    public Observable<ServiceResponse<SiteLogsConfigInner>> updateDiagnosticLogsConfigWithServiceResponseAsync(String resourceGroupName, String name, SiteLogsConfigInner siteLogsConfig) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteLogsConfig == null) {
            throw new IllegalArgumentException("Parameter siteLogsConfig is required and cannot be null.");
        }
        Validator.validate(siteLogsConfig);
        final String apiVersion = "2016-08-01";
        return service.updateDiagnosticLogsConfig(resourceGroupName, name, this.client.subscriptionId(), siteLogsConfig, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteLogsConfigInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteLogsConfigInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteLogsConfigInner> clientResponse = updateDiagnosticLogsConfigDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteLogsConfigInner> updateDiagnosticLogsConfigDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteLogsConfigInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteLogsConfigInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Replaces the metadata of an app.
     * Replaces the metadata of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param metadata Edited metadata of the app or deployment slot. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StringDictionaryInner object if successful.
     */
    public StringDictionaryInner updateMetadata(String resourceGroupName, String name, StringDictionaryInner metadata) {
        return updateMetadataWithServiceResponseAsync(resourceGroupName, name, metadata).toBlocking().single().body();
    }

    /**
     * Replaces the metadata of an app.
     * Replaces the metadata of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param metadata Edited metadata of the app or deployment slot. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StringDictionaryInner> updateMetadataAsync(String resourceGroupName, String name, StringDictionaryInner metadata, final ServiceCallback<StringDictionaryInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateMetadataWithServiceResponseAsync(resourceGroupName, name, metadata), serviceCallback);
    }

    /**
     * Replaces the metadata of an app.
     * Replaces the metadata of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param metadata Edited metadata of the app or deployment slot. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<StringDictionaryInner> updateMetadataAsync(String resourceGroupName, String name, StringDictionaryInner metadata) {
        return updateMetadataWithServiceResponseAsync(resourceGroupName, name, metadata).map(new Func1<ServiceResponse<StringDictionaryInner>, StringDictionaryInner>() {
            @Override
            public StringDictionaryInner call(ServiceResponse<StringDictionaryInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Replaces the metadata of an app.
     * Replaces the metadata of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param metadata Edited metadata of the app or deployment slot. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<ServiceResponse<StringDictionaryInner>> updateMetadataWithServiceResponseAsync(String resourceGroupName, String name, StringDictionaryInner metadata) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (metadata == null) {
            throw new IllegalArgumentException("Parameter metadata is required and cannot be null.");
        }
        Validator.validate(metadata);
        final String apiVersion = "2016-08-01";
        return service.updateMetadata(resourceGroupName, name, this.client.subscriptionId(), metadata, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<StringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StringDictionaryInner> clientResponse = updateMetadataDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StringDictionaryInner> updateMetadataDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<StringDictionaryInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<StringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the metadata of an app.
     * Gets the metadata of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StringDictionaryInner object if successful.
     */
    public StringDictionaryInner listMetadata(String resourceGroupName, String name) {
        return listMetadataWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Gets the metadata of an app.
     * Gets the metadata of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StringDictionaryInner> listMetadataAsync(String resourceGroupName, String name, final ServiceCallback<StringDictionaryInner> serviceCallback) {
        return ServiceFuture.fromResponse(listMetadataWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the metadata of an app.
     * Gets the metadata of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<StringDictionaryInner> listMetadataAsync(String resourceGroupName, String name) {
        return listMetadataWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<StringDictionaryInner>, StringDictionaryInner>() {
            @Override
            public StringDictionaryInner call(ServiceResponse<StringDictionaryInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the metadata of an app.
     * Gets the metadata of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<ServiceResponse<StringDictionaryInner>> listMetadataWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listMetadata(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<StringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StringDictionaryInner> clientResponse = listMetadataDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StringDictionaryInner> listMetadataDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<StringDictionaryInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<StringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the Git/FTP publishing credentials of an app.
     * Gets the Git/FTP publishing credentials of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UserInner object if successful.
     */
    public UserInner listPublishingCredentials(String resourceGroupName, String name) {
        return listPublishingCredentialsWithServiceResponseAsync(resourceGroupName, name).toBlocking().last().body();
    }

    /**
     * Gets the Git/FTP publishing credentials of an app.
     * Gets the Git/FTP publishing credentials of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UserInner> listPublishingCredentialsAsync(String resourceGroupName, String name, final ServiceCallback<UserInner> serviceCallback) {
        return ServiceFuture.fromResponse(listPublishingCredentialsWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the Git/FTP publishing credentials of an app.
     * Gets the Git/FTP publishing credentials of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<UserInner> listPublishingCredentialsAsync(String resourceGroupName, String name) {
        return listPublishingCredentialsWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<UserInner>, UserInner>() {
            @Override
            public UserInner call(ServiceResponse<UserInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the Git/FTP publishing credentials of an app.
     * Gets the Git/FTP publishing credentials of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<UserInner>> listPublishingCredentialsWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        Observable<Response<ResponseBody>> observable = service.listPublishingCredentials(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<UserInner>() { }.getType());
    }

    /**
     * Gets the Git/FTP publishing credentials of an app.
     * Gets the Git/FTP publishing credentials of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UserInner object if successful.
     */
    public UserInner beginListPublishingCredentials(String resourceGroupName, String name) {
        return beginListPublishingCredentialsWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Gets the Git/FTP publishing credentials of an app.
     * Gets the Git/FTP publishing credentials of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UserInner> beginListPublishingCredentialsAsync(String resourceGroupName, String name, final ServiceCallback<UserInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginListPublishingCredentialsWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the Git/FTP publishing credentials of an app.
     * Gets the Git/FTP publishing credentials of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UserInner object
     */
    public Observable<UserInner> beginListPublishingCredentialsAsync(String resourceGroupName, String name) {
        return beginListPublishingCredentialsWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<UserInner>, UserInner>() {
            @Override
            public UserInner call(ServiceResponse<UserInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the Git/FTP publishing credentials of an app.
     * Gets the Git/FTP publishing credentials of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UserInner object
     */
    public Observable<ServiceResponse<UserInner>> beginListPublishingCredentialsWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.beginListPublishingCredentials(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UserInner>>>() {
                @Override
                public Observable<ServiceResponse<UserInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UserInner> clientResponse = beginListPublishingCredentialsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<UserInner> beginListPublishingCredentialsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<UserInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<UserInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the Push settings associated with web app.
     * Updates the Push settings associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param pushSettings Push settings associated with web app
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PushSettingsInner object if successful.
     */
    public PushSettingsInner updateSitePushSettings(String resourceGroupName, String name, PushSettingsInner pushSettings) {
        return updateSitePushSettingsWithServiceResponseAsync(resourceGroupName, name, pushSettings).toBlocking().single().body();
    }

    /**
     * Updates the Push settings associated with web app.
     * Updates the Push settings associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param pushSettings Push settings associated with web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PushSettingsInner> updateSitePushSettingsAsync(String resourceGroupName, String name, PushSettingsInner pushSettings, final ServiceCallback<PushSettingsInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateSitePushSettingsWithServiceResponseAsync(resourceGroupName, name, pushSettings), serviceCallback);
    }

    /**
     * Updates the Push settings associated with web app.
     * Updates the Push settings associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param pushSettings Push settings associated with web app
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PushSettingsInner object
     */
    public Observable<PushSettingsInner> updateSitePushSettingsAsync(String resourceGroupName, String name, PushSettingsInner pushSettings) {
        return updateSitePushSettingsWithServiceResponseAsync(resourceGroupName, name, pushSettings).map(new Func1<ServiceResponse<PushSettingsInner>, PushSettingsInner>() {
            @Override
            public PushSettingsInner call(ServiceResponse<PushSettingsInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the Push settings associated with web app.
     * Updates the Push settings associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param pushSettings Push settings associated with web app
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PushSettingsInner object
     */
    public Observable<ServiceResponse<PushSettingsInner>> updateSitePushSettingsWithServiceResponseAsync(String resourceGroupName, String name, PushSettingsInner pushSettings) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (pushSettings == null) {
            throw new IllegalArgumentException("Parameter pushSettings is required and cannot be null.");
        }
        Validator.validate(pushSettings);
        final String apiVersion = "2016-08-01";
        return service.updateSitePushSettings(resourceGroupName, name, this.client.subscriptionId(), pushSettings, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PushSettingsInner>>>() {
                @Override
                public Observable<ServiceResponse<PushSettingsInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PushSettingsInner> clientResponse = updateSitePushSettingsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PushSettingsInner> updateSitePushSettingsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PushSettingsInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PushSettingsInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the Push settings associated with web app.
     * Gets the Push settings associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PushSettingsInner object if successful.
     */
    public PushSettingsInner listSitePushSettings(String resourceGroupName, String name) {
        return listSitePushSettingsWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Gets the Push settings associated with web app.
     * Gets the Push settings associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PushSettingsInner> listSitePushSettingsAsync(String resourceGroupName, String name, final ServiceCallback<PushSettingsInner> serviceCallback) {
        return ServiceFuture.fromResponse(listSitePushSettingsWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the Push settings associated with web app.
     * Gets the Push settings associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PushSettingsInner object
     */
    public Observable<PushSettingsInner> listSitePushSettingsAsync(String resourceGroupName, String name) {
        return listSitePushSettingsWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<PushSettingsInner>, PushSettingsInner>() {
            @Override
            public PushSettingsInner call(ServiceResponse<PushSettingsInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the Push settings associated with web app.
     * Gets the Push settings associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PushSettingsInner object
     */
    public Observable<ServiceResponse<PushSettingsInner>> listSitePushSettingsWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listSitePushSettings(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PushSettingsInner>>>() {
                @Override
                public Observable<ServiceResponse<PushSettingsInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PushSettingsInner> clientResponse = listSitePushSettingsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PushSettingsInner> listSitePushSettingsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PushSettingsInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PushSettingsInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the names of app settings and connection strings that stick to the slot (not swapped).
     * Gets the names of app settings and connection strings that stick to the slot (not swapped).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SlotConfigNamesResourceInner object if successful.
     */
    public SlotConfigNamesResourceInner listSlotConfigurationNames(String resourceGroupName, String name) {
        return listSlotConfigurationNamesWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Gets the names of app settings and connection strings that stick to the slot (not swapped).
     * Gets the names of app settings and connection strings that stick to the slot (not swapped).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SlotConfigNamesResourceInner> listSlotConfigurationNamesAsync(String resourceGroupName, String name, final ServiceCallback<SlotConfigNamesResourceInner> serviceCallback) {
        return ServiceFuture.fromResponse(listSlotConfigurationNamesWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the names of app settings and connection strings that stick to the slot (not swapped).
     * Gets the names of app settings and connection strings that stick to the slot (not swapped).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SlotConfigNamesResourceInner object
     */
    public Observable<SlotConfigNamesResourceInner> listSlotConfigurationNamesAsync(String resourceGroupName, String name) {
        return listSlotConfigurationNamesWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<SlotConfigNamesResourceInner>, SlotConfigNamesResourceInner>() {
            @Override
            public SlotConfigNamesResourceInner call(ServiceResponse<SlotConfigNamesResourceInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the names of app settings and connection strings that stick to the slot (not swapped).
     * Gets the names of app settings and connection strings that stick to the slot (not swapped).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SlotConfigNamesResourceInner object
     */
    public Observable<ServiceResponse<SlotConfigNamesResourceInner>> listSlotConfigurationNamesWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listSlotConfigurationNames(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SlotConfigNamesResourceInner>>>() {
                @Override
                public Observable<ServiceResponse<SlotConfigNamesResourceInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SlotConfigNamesResourceInner> clientResponse = listSlotConfigurationNamesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SlotConfigNamesResourceInner> listSlotConfigurationNamesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SlotConfigNamesResourceInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SlotConfigNamesResourceInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the names of application settings and connection string that remain with the slot during swap operation.
     * Updates the names of application settings and connection string that remain with the slot during swap operation.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotConfigNames Names of application settings and connection strings. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SlotConfigNamesResourceInner object if successful.
     */
    public SlotConfigNamesResourceInner updateSlotConfigurationNames(String resourceGroupName, String name, SlotConfigNamesResourceInner slotConfigNames) {
        return updateSlotConfigurationNamesWithServiceResponseAsync(resourceGroupName, name, slotConfigNames).toBlocking().single().body();
    }

    /**
     * Updates the names of application settings and connection string that remain with the slot during swap operation.
     * Updates the names of application settings and connection string that remain with the slot during swap operation.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotConfigNames Names of application settings and connection strings. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SlotConfigNamesResourceInner> updateSlotConfigurationNamesAsync(String resourceGroupName, String name, SlotConfigNamesResourceInner slotConfigNames, final ServiceCallback<SlotConfigNamesResourceInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateSlotConfigurationNamesWithServiceResponseAsync(resourceGroupName, name, slotConfigNames), serviceCallback);
    }

    /**
     * Updates the names of application settings and connection string that remain with the slot during swap operation.
     * Updates the names of application settings and connection string that remain with the slot during swap operation.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotConfigNames Names of application settings and connection strings. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SlotConfigNamesResourceInner object
     */
    public Observable<SlotConfigNamesResourceInner> updateSlotConfigurationNamesAsync(String resourceGroupName, String name, SlotConfigNamesResourceInner slotConfigNames) {
        return updateSlotConfigurationNamesWithServiceResponseAsync(resourceGroupName, name, slotConfigNames).map(new Func1<ServiceResponse<SlotConfigNamesResourceInner>, SlotConfigNamesResourceInner>() {
            @Override
            public SlotConfigNamesResourceInner call(ServiceResponse<SlotConfigNamesResourceInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the names of application settings and connection string that remain with the slot during swap operation.
     * Updates the names of application settings and connection string that remain with the slot during swap operation.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotConfigNames Names of application settings and connection strings. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SlotConfigNamesResourceInner object
     */
    public Observable<ServiceResponse<SlotConfigNamesResourceInner>> updateSlotConfigurationNamesWithServiceResponseAsync(String resourceGroupName, String name, SlotConfigNamesResourceInner slotConfigNames) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (slotConfigNames == null) {
            throw new IllegalArgumentException("Parameter slotConfigNames is required and cannot be null.");
        }
        Validator.validate(slotConfigNames);
        final String apiVersion = "2016-08-01";
        return service.updateSlotConfigurationNames(resourceGroupName, name, this.client.subscriptionId(), slotConfigNames, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SlotConfigNamesResourceInner>>>() {
                @Override
                public Observable<ServiceResponse<SlotConfigNamesResourceInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SlotConfigNamesResourceInner> clientResponse = updateSlotConfigurationNamesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SlotConfigNamesResourceInner> updateSlotConfigurationNamesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SlotConfigNamesResourceInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SlotConfigNamesResourceInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the configuration of an app, such as platform version and bitness, default documents, virtual applications, Always On, etc.
     * Gets the configuration of an app, such as platform version and bitness, default documents, virtual applications, Always On, etc.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteConfigResourceInner object if successful.
     */
    public SiteConfigResourceInner getConfiguration(String resourceGroupName, String name) {
        return getConfigurationWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Gets the configuration of an app, such as platform version and bitness, default documents, virtual applications, Always On, etc.
     * Gets the configuration of an app, such as platform version and bitness, default documents, virtual applications, Always On, etc.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteConfigResourceInner> getConfigurationAsync(String resourceGroupName, String name, final ServiceCallback<SiteConfigResourceInner> serviceCallback) {
        return ServiceFuture.fromResponse(getConfigurationWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the configuration of an app, such as platform version and bitness, default documents, virtual applications, Always On, etc.
     * Gets the configuration of an app, such as platform version and bitness, default documents, virtual applications, Always On, etc.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteConfigResourceInner object
     */
    public Observable<SiteConfigResourceInner> getConfigurationAsync(String resourceGroupName, String name) {
        return getConfigurationWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<SiteConfigResourceInner>, SiteConfigResourceInner>() {
            @Override
            public SiteConfigResourceInner call(ServiceResponse<SiteConfigResourceInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the configuration of an app, such as platform version and bitness, default documents, virtual applications, Always On, etc.
     * Gets the configuration of an app, such as platform version and bitness, default documents, virtual applications, Always On, etc.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteConfigResourceInner object
     */
    public Observable<ServiceResponse<SiteConfigResourceInner>> getConfigurationWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getConfiguration(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteConfigResourceInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteConfigResourceInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteConfigResourceInner> clientResponse = getConfigurationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteConfigResourceInner> getConfigurationDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteConfigResourceInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteConfigResourceInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the configuration of an app.
     * Updates the configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteConfig JSON representation of a SiteConfig object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteConfigResourceInner object if successful.
     */
    public SiteConfigResourceInner createOrUpdateConfiguration(String resourceGroupName, String name, SiteConfigResourceInner siteConfig) {
        return createOrUpdateConfigurationWithServiceResponseAsync(resourceGroupName, name, siteConfig).toBlocking().single().body();
    }

    /**
     * Updates the configuration of an app.
     * Updates the configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteConfig JSON representation of a SiteConfig object. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteConfigResourceInner> createOrUpdateConfigurationAsync(String resourceGroupName, String name, SiteConfigResourceInner siteConfig, final ServiceCallback<SiteConfigResourceInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateConfigurationWithServiceResponseAsync(resourceGroupName, name, siteConfig), serviceCallback);
    }

    /**
     * Updates the configuration of an app.
     * Updates the configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteConfig JSON representation of a SiteConfig object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteConfigResourceInner object
     */
    public Observable<SiteConfigResourceInner> createOrUpdateConfigurationAsync(String resourceGroupName, String name, SiteConfigResourceInner siteConfig) {
        return createOrUpdateConfigurationWithServiceResponseAsync(resourceGroupName, name, siteConfig).map(new Func1<ServiceResponse<SiteConfigResourceInner>, SiteConfigResourceInner>() {
            @Override
            public SiteConfigResourceInner call(ServiceResponse<SiteConfigResourceInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the configuration of an app.
     * Updates the configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteConfig JSON representation of a SiteConfig object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteConfigResourceInner object
     */
    public Observable<ServiceResponse<SiteConfigResourceInner>> createOrUpdateConfigurationWithServiceResponseAsync(String resourceGroupName, String name, SiteConfigResourceInner siteConfig) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteConfig == null) {
            throw new IllegalArgumentException("Parameter siteConfig is required and cannot be null.");
        }
        Validator.validate(siteConfig);
        final String apiVersion = "2016-08-01";
        return service.createOrUpdateConfiguration(resourceGroupName, name, this.client.subscriptionId(), siteConfig, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteConfigResourceInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteConfigResourceInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteConfigResourceInner> clientResponse = createOrUpdateConfigurationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteConfigResourceInner> createOrUpdateConfigurationDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteConfigResourceInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteConfigResourceInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the configuration of an app.
     * Updates the configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteConfig JSON representation of a SiteConfig object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteConfigResourceInner object if successful.
     */
    public SiteConfigResourceInner updateConfiguration(String resourceGroupName, String name, SiteConfigResourceInner siteConfig) {
        return updateConfigurationWithServiceResponseAsync(resourceGroupName, name, siteConfig).toBlocking().single().body();
    }

    /**
     * Updates the configuration of an app.
     * Updates the configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteConfig JSON representation of a SiteConfig object. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteConfigResourceInner> updateConfigurationAsync(String resourceGroupName, String name, SiteConfigResourceInner siteConfig, final ServiceCallback<SiteConfigResourceInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateConfigurationWithServiceResponseAsync(resourceGroupName, name, siteConfig), serviceCallback);
    }

    /**
     * Updates the configuration of an app.
     * Updates the configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteConfig JSON representation of a SiteConfig object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteConfigResourceInner object
     */
    public Observable<SiteConfigResourceInner> updateConfigurationAsync(String resourceGroupName, String name, SiteConfigResourceInner siteConfig) {
        return updateConfigurationWithServiceResponseAsync(resourceGroupName, name, siteConfig).map(new Func1<ServiceResponse<SiteConfigResourceInner>, SiteConfigResourceInner>() {
            @Override
            public SiteConfigResourceInner call(ServiceResponse<SiteConfigResourceInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the configuration of an app.
     * Updates the configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteConfig JSON representation of a SiteConfig object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteConfigResourceInner object
     */
    public Observable<ServiceResponse<SiteConfigResourceInner>> updateConfigurationWithServiceResponseAsync(String resourceGroupName, String name, SiteConfigResourceInner siteConfig) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteConfig == null) {
            throw new IllegalArgumentException("Parameter siteConfig is required and cannot be null.");
        }
        Validator.validate(siteConfig);
        final String apiVersion = "2016-08-01";
        return service.updateConfiguration(resourceGroupName, name, this.client.subscriptionId(), siteConfig, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteConfigResourceInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteConfigResourceInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteConfigResourceInner> clientResponse = updateConfigurationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteConfigResourceInner> updateConfigurationDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteConfigResourceInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteConfigResourceInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;SiteConfigurationSnapshotInfoInner&gt; object if successful.
     */
    public List<SiteConfigurationSnapshotInfoInner> listConfigurationSnapshotInfo(String resourceGroupName, String name) {
        return listConfigurationSnapshotInfoWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SiteConfigurationSnapshotInfoInner>> listConfigurationSnapshotInfoAsync(String resourceGroupName, String name, final ServiceCallback<List<SiteConfigurationSnapshotInfoInner>> serviceCallback) {
        return ServiceFuture.fromResponse(listConfigurationSnapshotInfoWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;SiteConfigurationSnapshotInfoInner&gt; object
     */
    public Observable<List<SiteConfigurationSnapshotInfoInner>> listConfigurationSnapshotInfoAsync(String resourceGroupName, String name) {
        return listConfigurationSnapshotInfoWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<List<SiteConfigurationSnapshotInfoInner>>, List<SiteConfigurationSnapshotInfoInner>>() {
            @Override
            public List<SiteConfigurationSnapshotInfoInner> call(ServiceResponse<List<SiteConfigurationSnapshotInfoInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;SiteConfigurationSnapshotInfoInner&gt; object
     */
    public Observable<ServiceResponse<List<SiteConfigurationSnapshotInfoInner>>> listConfigurationSnapshotInfoWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listConfigurationSnapshotInfo(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<SiteConfigurationSnapshotInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<SiteConfigurationSnapshotInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<SiteConfigurationSnapshotInfoInner>> clientResponse = listConfigurationSnapshotInfoDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<SiteConfigurationSnapshotInfoInner>> listConfigurationSnapshotInfoDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<SiteConfigurationSnapshotInfoInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<SiteConfigurationSnapshotInfoInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets a snapshot of the configuration of an app at a previous point in time.
     * Gets a snapshot of the configuration of an app at a previous point in time.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param snapshotId The ID of the snapshot to read.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteConfigResourceInner object if successful.
     */
    public SiteConfigResourceInner getConfigurationSnapshot(String resourceGroupName, String name, String snapshotId) {
        return getConfigurationSnapshotWithServiceResponseAsync(resourceGroupName, name, snapshotId).toBlocking().single().body();
    }

    /**
     * Gets a snapshot of the configuration of an app at a previous point in time.
     * Gets a snapshot of the configuration of an app at a previous point in time.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param snapshotId The ID of the snapshot to read.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteConfigResourceInner> getConfigurationSnapshotAsync(String resourceGroupName, String name, String snapshotId, final ServiceCallback<SiteConfigResourceInner> serviceCallback) {
        return ServiceFuture.fromResponse(getConfigurationSnapshotWithServiceResponseAsync(resourceGroupName, name, snapshotId), serviceCallback);
    }

    /**
     * Gets a snapshot of the configuration of an app at a previous point in time.
     * Gets a snapshot of the configuration of an app at a previous point in time.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param snapshotId The ID of the snapshot to read.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteConfigResourceInner object
     */
    public Observable<SiteConfigResourceInner> getConfigurationSnapshotAsync(String resourceGroupName, String name, String snapshotId) {
        return getConfigurationSnapshotWithServiceResponseAsync(resourceGroupName, name, snapshotId).map(new Func1<ServiceResponse<SiteConfigResourceInner>, SiteConfigResourceInner>() {
            @Override
            public SiteConfigResourceInner call(ServiceResponse<SiteConfigResourceInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a snapshot of the configuration of an app at a previous point in time.
     * Gets a snapshot of the configuration of an app at a previous point in time.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param snapshotId The ID of the snapshot to read.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteConfigResourceInner object
     */
    public Observable<ServiceResponse<SiteConfigResourceInner>> getConfigurationSnapshotWithServiceResponseAsync(String resourceGroupName, String name, String snapshotId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (snapshotId == null) {
            throw new IllegalArgumentException("Parameter snapshotId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getConfigurationSnapshot(resourceGroupName, name, snapshotId, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteConfigResourceInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteConfigResourceInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteConfigResourceInner> clientResponse = getConfigurationSnapshotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteConfigResourceInner> getConfigurationSnapshotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteConfigResourceInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteConfigResourceInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Reverts the configuration of an app to a previous snapshot.
     * Reverts the configuration of an app to a previous snapshot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param snapshotId The ID of the snapshot to read.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void recoverSiteConfigurationSnapshot(String resourceGroupName, String name, String snapshotId) {
        recoverSiteConfigurationSnapshotWithServiceResponseAsync(resourceGroupName, name, snapshotId).toBlocking().single().body();
    }

    /**
     * Reverts the configuration of an app to a previous snapshot.
     * Reverts the configuration of an app to a previous snapshot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param snapshotId The ID of the snapshot to read.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> recoverSiteConfigurationSnapshotAsync(String resourceGroupName, String name, String snapshotId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(recoverSiteConfigurationSnapshotWithServiceResponseAsync(resourceGroupName, name, snapshotId), serviceCallback);
    }

    /**
     * Reverts the configuration of an app to a previous snapshot.
     * Reverts the configuration of an app to a previous snapshot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param snapshotId The ID of the snapshot to read.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> recoverSiteConfigurationSnapshotAsync(String resourceGroupName, String name, String snapshotId) {
        return recoverSiteConfigurationSnapshotWithServiceResponseAsync(resourceGroupName, name, snapshotId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Reverts the configuration of an app to a previous snapshot.
     * Reverts the configuration of an app to a previous snapshot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param snapshotId The ID of the snapshot to read.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> recoverSiteConfigurationSnapshotWithServiceResponseAsync(String resourceGroupName, String name, String snapshotId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (snapshotId == null) {
            throw new IllegalArgumentException("Parameter snapshotId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.recoverSiteConfigurationSnapshot(resourceGroupName, name, snapshotId, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = recoverSiteConfigurationSnapshotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> recoverSiteConfigurationSnapshotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;DeploymentInner&gt; object if successful.
     */
    public PagedList<DeploymentInner> listDeployments(final String resourceGroupName, final String name) {
        ServiceResponse<Page<DeploymentInner>> response = listDeploymentsSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<DeploymentInner>(response.body()) {
            @Override
            public Page<DeploymentInner> nextPage(String nextPageLink) {
                return listDeploymentsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<DeploymentInner>> listDeploymentsAsync(final String resourceGroupName, final String name, final ListOperationCallback<DeploymentInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listDeploymentsSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(String nextPageLink) {
                    return listDeploymentsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<Page<DeploymentInner>> listDeploymentsAsync(final String resourceGroupName, final String name) {
        return listDeploymentsWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<DeploymentInner>>, Page<DeploymentInner>>() {
                @Override
                public Page<DeploymentInner> call(ServiceResponse<Page<DeploymentInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> listDeploymentsWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return listDeploymentsSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<DeploymentInner>>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(ServiceResponse<Page<DeploymentInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listDeploymentsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     *
    ServiceResponse<PageImpl<DeploymentInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<DeploymentInner>> * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;DeploymentInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> listDeploymentsSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listDeployments(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<DeploymentInner>> result = listDeploymentsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<DeploymentInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<DeploymentInner>> listDeploymentsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<DeploymentInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<DeploymentInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     * Get a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the DeploymentInner object if successful.
     */
    public DeploymentInner getDeployment(String resourceGroupName, String name, String id) {
        return getDeploymentWithServiceResponseAsync(resourceGroupName, name, id).toBlocking().single().body();
    }

    /**
     * Get a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     * Get a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<DeploymentInner> getDeploymentAsync(String resourceGroupName, String name, String id, final ServiceCallback<DeploymentInner> serviceCallback) {
        return ServiceFuture.fromResponse(getDeploymentWithServiceResponseAsync(resourceGroupName, name, id), serviceCallback);
    }

    /**
     * Get a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     * Get a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeploymentInner object
     */
    public Observable<DeploymentInner> getDeploymentAsync(String resourceGroupName, String name, String id) {
        return getDeploymentWithServiceResponseAsync(resourceGroupName, name, id).map(new Func1<ServiceResponse<DeploymentInner>, DeploymentInner>() {
            @Override
            public DeploymentInner call(ServiceResponse<DeploymentInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     * Get a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeploymentInner object
     */
    public Observable<ServiceResponse<DeploymentInner>> getDeploymentWithServiceResponseAsync(String resourceGroupName, String name, String id) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getDeployment(resourceGroupName, name, id, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeploymentInner>>>() {
                @Override
                public Observable<ServiceResponse<DeploymentInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeploymentInner> clientResponse = getDeploymentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DeploymentInner> getDeploymentDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<DeploymentInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<DeploymentInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Create a deployment for an app, a specific deployment slot, and/or a specific scaled-out instance.
     * Create a deployment for an app, a specific deployment slot, and/or a specific scaled-out instance.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id ID of an existing deployment.
     * @param deployment Deployment details.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the DeploymentInner object if successful.
     */
    public DeploymentInner createDeployment(String resourceGroupName, String name, String id, DeploymentInner deployment) {
        return createDeploymentWithServiceResponseAsync(resourceGroupName, name, id, deployment).toBlocking().single().body();
    }

    /**
     * Create a deployment for an app, a specific deployment slot, and/or a specific scaled-out instance.
     * Create a deployment for an app, a specific deployment slot, and/or a specific scaled-out instance.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id ID of an existing deployment.
     * @param deployment Deployment details.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<DeploymentInner> createDeploymentAsync(String resourceGroupName, String name, String id, DeploymentInner deployment, final ServiceCallback<DeploymentInner> serviceCallback) {
        return ServiceFuture.fromResponse(createDeploymentWithServiceResponseAsync(resourceGroupName, name, id, deployment), serviceCallback);
    }

    /**
     * Create a deployment for an app, a specific deployment slot, and/or a specific scaled-out instance.
     * Create a deployment for an app, a specific deployment slot, and/or a specific scaled-out instance.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id ID of an existing deployment.
     * @param deployment Deployment details.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeploymentInner object
     */
    public Observable<DeploymentInner> createDeploymentAsync(String resourceGroupName, String name, String id, DeploymentInner deployment) {
        return createDeploymentWithServiceResponseAsync(resourceGroupName, name, id, deployment).map(new Func1<ServiceResponse<DeploymentInner>, DeploymentInner>() {
            @Override
            public DeploymentInner call(ServiceResponse<DeploymentInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Create a deployment for an app, a specific deployment slot, and/or a specific scaled-out instance.
     * Create a deployment for an app, a specific deployment slot, and/or a specific scaled-out instance.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id ID of an existing deployment.
     * @param deployment Deployment details.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeploymentInner object
     */
    public Observable<ServiceResponse<DeploymentInner>> createDeploymentWithServiceResponseAsync(String resourceGroupName, String name, String id, DeploymentInner deployment) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (deployment == null) {
            throw new IllegalArgumentException("Parameter deployment is required and cannot be null.");
        }
        Validator.validate(deployment);
        final String apiVersion = "2016-08-01";
        return service.createDeployment(resourceGroupName, name, id, this.client.subscriptionId(), deployment, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeploymentInner>>>() {
                @Override
                public Observable<ServiceResponse<DeploymentInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeploymentInner> clientResponse = createDeploymentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DeploymentInner> createDeploymentDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<DeploymentInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<DeploymentInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Delete a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     * Delete a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteDeployment(String resourceGroupName, String name, String id) {
        deleteDeploymentWithServiceResponseAsync(resourceGroupName, name, id).toBlocking().single().body();
    }

    /**
     * Delete a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     * Delete a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteDeploymentAsync(String resourceGroupName, String name, String id, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteDeploymentWithServiceResponseAsync(resourceGroupName, name, id), serviceCallback);
    }

    /**
     * Delete a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     * Delete a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteDeploymentAsync(String resourceGroupName, String name, String id) {
        return deleteDeploymentWithServiceResponseAsync(resourceGroupName, name, id).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     * Delete a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteDeploymentWithServiceResponseAsync(String resourceGroupName, String name, String id) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.deleteDeployment(resourceGroupName, name, id, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteDeploymentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteDeploymentDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Lists ownership identifiers for domain associated with web app.
     * Lists ownership identifiers for domain associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;IdentifierInner&gt; object if successful.
     */
    public PagedList<IdentifierInner> listDomainOwnershipIdentifiers(final String resourceGroupName, final String name) {
        ServiceResponse<Page<IdentifierInner>> response = listDomainOwnershipIdentifiersSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<IdentifierInner>(response.body()) {
            @Override
            public Page<IdentifierInner> nextPage(String nextPageLink) {
                return listDomainOwnershipIdentifiersNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists ownership identifiers for domain associated with web app.
     * Lists ownership identifiers for domain associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<IdentifierInner>> listDomainOwnershipIdentifiersAsync(final String resourceGroupName, final String name, final ListOperationCallback<IdentifierInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listDomainOwnershipIdentifiersSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<IdentifierInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<IdentifierInner>>> call(String nextPageLink) {
                    return listDomainOwnershipIdentifiersNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists ownership identifiers for domain associated with web app.
     * Lists ownership identifiers for domain associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;IdentifierInner&gt; object
     */
    public Observable<Page<IdentifierInner>> listDomainOwnershipIdentifiersAsync(final String resourceGroupName, final String name) {
        return listDomainOwnershipIdentifiersWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<IdentifierInner>>, Page<IdentifierInner>>() {
                @Override
                public Page<IdentifierInner> call(ServiceResponse<Page<IdentifierInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists ownership identifiers for domain associated with web app.
     * Lists ownership identifiers for domain associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;IdentifierInner&gt; object
     */
    public Observable<ServiceResponse<Page<IdentifierInner>>> listDomainOwnershipIdentifiersWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return listDomainOwnershipIdentifiersSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<IdentifierInner>>, Observable<ServiceResponse<Page<IdentifierInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<IdentifierInner>>> call(ServiceResponse<Page<IdentifierInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listDomainOwnershipIdentifiersNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists ownership identifiers for domain associated with web app.
     * Lists ownership identifiers for domain associated with web app.
     *
    ServiceResponse<PageImpl<IdentifierInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<IdentifierInner>> * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;IdentifierInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<IdentifierInner>>> listDomainOwnershipIdentifiersSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listDomainOwnershipIdentifiers(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<IdentifierInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<IdentifierInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<IdentifierInner>> result = listDomainOwnershipIdentifiersDelegate(response);
                        return Observable.just(new ServiceResponse<Page<IdentifierInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<IdentifierInner>> listDomainOwnershipIdentifiersDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<IdentifierInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<IdentifierInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get domain ownership identifier for web app.
     * Get domain ownership identifier for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IdentifierInner object if successful.
     */
    public IdentifierInner getDomainOwnershipIdentifier(String resourceGroupName, String name, String domainOwnershipIdentifierName) {
        return getDomainOwnershipIdentifierWithServiceResponseAsync(resourceGroupName, name, domainOwnershipIdentifierName).toBlocking().single().body();
    }

    /**
     * Get domain ownership identifier for web app.
     * Get domain ownership identifier for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IdentifierInner> getDomainOwnershipIdentifierAsync(String resourceGroupName, String name, String domainOwnershipIdentifierName, final ServiceCallback<IdentifierInner> serviceCallback) {
        return ServiceFuture.fromResponse(getDomainOwnershipIdentifierWithServiceResponseAsync(resourceGroupName, name, domainOwnershipIdentifierName), serviceCallback);
    }

    /**
     * Get domain ownership identifier for web app.
     * Get domain ownership identifier for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IdentifierInner object
     */
    public Observable<IdentifierInner> getDomainOwnershipIdentifierAsync(String resourceGroupName, String name, String domainOwnershipIdentifierName) {
        return getDomainOwnershipIdentifierWithServiceResponseAsync(resourceGroupName, name, domainOwnershipIdentifierName).map(new Func1<ServiceResponse<IdentifierInner>, IdentifierInner>() {
            @Override
            public IdentifierInner call(ServiceResponse<IdentifierInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get domain ownership identifier for web app.
     * Get domain ownership identifier for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IdentifierInner object
     */
    public Observable<ServiceResponse<IdentifierInner>> getDomainOwnershipIdentifierWithServiceResponseAsync(String resourceGroupName, String name, String domainOwnershipIdentifierName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (domainOwnershipIdentifierName == null) {
            throw new IllegalArgumentException("Parameter domainOwnershipIdentifierName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IdentifierInner>>>() {
                @Override
                public Observable<ServiceResponse<IdentifierInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IdentifierInner> clientResponse = getDomainOwnershipIdentifierDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<IdentifierInner> getDomainOwnershipIdentifierDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<IdentifierInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<IdentifierInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param domainOwnershipIdentifier A JSON representation of the domain ownership properties.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IdentifierInner object if successful.
     */
    public IdentifierInner createOrUpdateDomainOwnershipIdentifier(String resourceGroupName, String name, String domainOwnershipIdentifierName, IdentifierInner domainOwnershipIdentifier) {
        return createOrUpdateDomainOwnershipIdentifierWithServiceResponseAsync(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier).toBlocking().single().body();
    }

    /**
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param domainOwnershipIdentifier A JSON representation of the domain ownership properties.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IdentifierInner> createOrUpdateDomainOwnershipIdentifierAsync(String resourceGroupName, String name, String domainOwnershipIdentifierName, IdentifierInner domainOwnershipIdentifier, final ServiceCallback<IdentifierInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateDomainOwnershipIdentifierWithServiceResponseAsync(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier), serviceCallback);
    }

    /**
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param domainOwnershipIdentifier A JSON representation of the domain ownership properties.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IdentifierInner object
     */
    public Observable<IdentifierInner> createOrUpdateDomainOwnershipIdentifierAsync(String resourceGroupName, String name, String domainOwnershipIdentifierName, IdentifierInner domainOwnershipIdentifier) {
        return createOrUpdateDomainOwnershipIdentifierWithServiceResponseAsync(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier).map(new Func1<ServiceResponse<IdentifierInner>, IdentifierInner>() {
            @Override
            public IdentifierInner call(ServiceResponse<IdentifierInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param domainOwnershipIdentifier A JSON representation of the domain ownership properties.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IdentifierInner object
     */
    public Observable<ServiceResponse<IdentifierInner>> createOrUpdateDomainOwnershipIdentifierWithServiceResponseAsync(String resourceGroupName, String name, String domainOwnershipIdentifierName, IdentifierInner domainOwnershipIdentifier) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (domainOwnershipIdentifierName == null) {
            throw new IllegalArgumentException("Parameter domainOwnershipIdentifierName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (domainOwnershipIdentifier == null) {
            throw new IllegalArgumentException("Parameter domainOwnershipIdentifier is required and cannot be null.");
        }
        Validator.validate(domainOwnershipIdentifier);
        final String apiVersion = "2016-08-01";
        return service.createOrUpdateDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, this.client.subscriptionId(), domainOwnershipIdentifier, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IdentifierInner>>>() {
                @Override
                public Observable<ServiceResponse<IdentifierInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IdentifierInner> clientResponse = createOrUpdateDomainOwnershipIdentifierDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<IdentifierInner> createOrUpdateDomainOwnershipIdentifierDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<IdentifierInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<IdentifierInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a domain ownership identifier for a web app.
     * Deletes a domain ownership identifier for a web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteDomainOwnershipIdentifier(String resourceGroupName, String name, String domainOwnershipIdentifierName) {
        deleteDomainOwnershipIdentifierWithServiceResponseAsync(resourceGroupName, name, domainOwnershipIdentifierName).toBlocking().single().body();
    }

    /**
     * Deletes a domain ownership identifier for a web app.
     * Deletes a domain ownership identifier for a web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteDomainOwnershipIdentifierAsync(String resourceGroupName, String name, String domainOwnershipIdentifierName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteDomainOwnershipIdentifierWithServiceResponseAsync(resourceGroupName, name, domainOwnershipIdentifierName), serviceCallback);
    }

    /**
     * Deletes a domain ownership identifier for a web app.
     * Deletes a domain ownership identifier for a web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteDomainOwnershipIdentifierAsync(String resourceGroupName, String name, String domainOwnershipIdentifierName) {
        return deleteDomainOwnershipIdentifierWithServiceResponseAsync(resourceGroupName, name, domainOwnershipIdentifierName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a domain ownership identifier for a web app.
     * Deletes a domain ownership identifier for a web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteDomainOwnershipIdentifierWithServiceResponseAsync(String resourceGroupName, String name, String domainOwnershipIdentifierName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (domainOwnershipIdentifierName == null) {
            throw new IllegalArgumentException("Parameter domainOwnershipIdentifierName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.deleteDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteDomainOwnershipIdentifierDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteDomainOwnershipIdentifierDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param domainOwnershipIdentifier A JSON representation of the domain ownership properties.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IdentifierInner object if successful.
     */
    public IdentifierInner updateDomainOwnershipIdentifier(String resourceGroupName, String name, String domainOwnershipIdentifierName, IdentifierInner domainOwnershipIdentifier) {
        return updateDomainOwnershipIdentifierWithServiceResponseAsync(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier).toBlocking().single().body();
    }

    /**
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param domainOwnershipIdentifier A JSON representation of the domain ownership properties.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IdentifierInner> updateDomainOwnershipIdentifierAsync(String resourceGroupName, String name, String domainOwnershipIdentifierName, IdentifierInner domainOwnershipIdentifier, final ServiceCallback<IdentifierInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateDomainOwnershipIdentifierWithServiceResponseAsync(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier), serviceCallback);
    }

    /**
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param domainOwnershipIdentifier A JSON representation of the domain ownership properties.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IdentifierInner object
     */
    public Observable<IdentifierInner> updateDomainOwnershipIdentifierAsync(String resourceGroupName, String name, String domainOwnershipIdentifierName, IdentifierInner domainOwnershipIdentifier) {
        return updateDomainOwnershipIdentifierWithServiceResponseAsync(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier).map(new Func1<ServiceResponse<IdentifierInner>, IdentifierInner>() {
            @Override
            public IdentifierInner call(ServiceResponse<IdentifierInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param domainOwnershipIdentifier A JSON representation of the domain ownership properties.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IdentifierInner object
     */
    public Observable<ServiceResponse<IdentifierInner>> updateDomainOwnershipIdentifierWithServiceResponseAsync(String resourceGroupName, String name, String domainOwnershipIdentifierName, IdentifierInner domainOwnershipIdentifier) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (domainOwnershipIdentifierName == null) {
            throw new IllegalArgumentException("Parameter domainOwnershipIdentifierName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (domainOwnershipIdentifier == null) {
            throw new IllegalArgumentException("Parameter domainOwnershipIdentifier is required and cannot be null.");
        }
        Validator.validate(domainOwnershipIdentifier);
        final String apiVersion = "2016-08-01";
        return service.updateDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, this.client.subscriptionId(), domainOwnershipIdentifier, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IdentifierInner>>>() {
                @Override
                public Observable<ServiceResponse<IdentifierInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IdentifierInner> clientResponse = updateDomainOwnershipIdentifierDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<IdentifierInner> updateDomainOwnershipIdentifierDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<IdentifierInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<IdentifierInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get hostname bindings for an app or a deployment slot.
     * Get hostname bindings for an app or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;HostNameBindingInner&gt; object if successful.
     */
    public PagedList<HostNameBindingInner> listHostNameBindings(final String resourceGroupName, final String name) {
        ServiceResponse<Page<HostNameBindingInner>> response = listHostNameBindingsSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<HostNameBindingInner>(response.body()) {
            @Override
            public Page<HostNameBindingInner> nextPage(String nextPageLink) {
                return listHostNameBindingsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get hostname bindings for an app or a deployment slot.
     * Get hostname bindings for an app or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<HostNameBindingInner>> listHostNameBindingsAsync(final String resourceGroupName, final String name, final ListOperationCallback<HostNameBindingInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listHostNameBindingsSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(String nextPageLink) {
                    return listHostNameBindingsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get hostname bindings for an app or a deployment slot.
     * Get hostname bindings for an app or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;HostNameBindingInner&gt; object
     */
    public Observable<Page<HostNameBindingInner>> listHostNameBindingsAsync(final String resourceGroupName, final String name) {
        return listHostNameBindingsWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<HostNameBindingInner>>, Page<HostNameBindingInner>>() {
                @Override
                public Page<HostNameBindingInner> call(ServiceResponse<Page<HostNameBindingInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get hostname bindings for an app or a deployment slot.
     * Get hostname bindings for an app or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;HostNameBindingInner&gt; object
     */
    public Observable<ServiceResponse<Page<HostNameBindingInner>>> listHostNameBindingsWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return listHostNameBindingsSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<HostNameBindingInner>>, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(ServiceResponse<Page<HostNameBindingInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listHostNameBindingsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get hostname bindings for an app or a deployment slot.
     * Get hostname bindings for an app or a deployment slot.
     *
    ServiceResponse<PageImpl<HostNameBindingInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<HostNameBindingInner>> * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;HostNameBindingInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<HostNameBindingInner>>> listHostNameBindingsSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listHostNameBindings(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<HostNameBindingInner>> result = listHostNameBindingsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<HostNameBindingInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<HostNameBindingInner>> listHostNameBindingsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<HostNameBindingInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<HostNameBindingInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the named hostname binding for an app (or deployment slot, if specified).
     * Get the named hostname binding for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param hostName Hostname in the hostname binding.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HostNameBindingInner object if successful.
     */
    public HostNameBindingInner getHostNameBinding(String resourceGroupName, String name, String hostName) {
        return getHostNameBindingWithServiceResponseAsync(resourceGroupName, name, hostName).toBlocking().single().body();
    }

    /**
     * Get the named hostname binding for an app (or deployment slot, if specified).
     * Get the named hostname binding for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param hostName Hostname in the hostname binding.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HostNameBindingInner> getHostNameBindingAsync(String resourceGroupName, String name, String hostName, final ServiceCallback<HostNameBindingInner> serviceCallback) {
        return ServiceFuture.fromResponse(getHostNameBindingWithServiceResponseAsync(resourceGroupName, name, hostName), serviceCallback);
    }

    /**
     * Get the named hostname binding for an app (or deployment slot, if specified).
     * Get the named hostname binding for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param hostName Hostname in the hostname binding.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HostNameBindingInner object
     */
    public Observable<HostNameBindingInner> getHostNameBindingAsync(String resourceGroupName, String name, String hostName) {
        return getHostNameBindingWithServiceResponseAsync(resourceGroupName, name, hostName).map(new Func1<ServiceResponse<HostNameBindingInner>, HostNameBindingInner>() {
            @Override
            public HostNameBindingInner call(ServiceResponse<HostNameBindingInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get the named hostname binding for an app (or deployment slot, if specified).
     * Get the named hostname binding for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param hostName Hostname in the hostname binding.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HostNameBindingInner object
     */
    public Observable<ServiceResponse<HostNameBindingInner>> getHostNameBindingWithServiceResponseAsync(String resourceGroupName, String name, String hostName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (hostName == null) {
            throw new IllegalArgumentException("Parameter hostName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getHostNameBinding(resourceGroupName, name, hostName, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HostNameBindingInner>>>() {
                @Override
                public Observable<ServiceResponse<HostNameBindingInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HostNameBindingInner> clientResponse = getHostNameBindingDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HostNameBindingInner> getHostNameBindingDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<HostNameBindingInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<HostNameBindingInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a hostname binding for an app.
     * Creates a hostname binding for an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param hostName Hostname in the hostname binding.
     * @param hostNameBinding Binding details. This is the JSON representation of a HostNameBinding object.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HostNameBindingInner object if successful.
     */
    public HostNameBindingInner createOrUpdateHostNameBinding(String resourceGroupName, String name, String hostName, HostNameBindingInner hostNameBinding) {
        return createOrUpdateHostNameBindingWithServiceResponseAsync(resourceGroupName, name, hostName, hostNameBinding).toBlocking().single().body();
    }

    /**
     * Creates a hostname binding for an app.
     * Creates a hostname binding for an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param hostName Hostname in the hostname binding.
     * @param hostNameBinding Binding details. This is the JSON representation of a HostNameBinding object.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HostNameBindingInner> createOrUpdateHostNameBindingAsync(String resourceGroupName, String name, String hostName, HostNameBindingInner hostNameBinding, final ServiceCallback<HostNameBindingInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateHostNameBindingWithServiceResponseAsync(resourceGroupName, name, hostName, hostNameBinding), serviceCallback);
    }

    /**
     * Creates a hostname binding for an app.
     * Creates a hostname binding for an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param hostName Hostname in the hostname binding.
     * @param hostNameBinding Binding details. This is the JSON representation of a HostNameBinding object.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HostNameBindingInner object
     */
    public Observable<HostNameBindingInner> createOrUpdateHostNameBindingAsync(String resourceGroupName, String name, String hostName, HostNameBindingInner hostNameBinding) {
        return createOrUpdateHostNameBindingWithServiceResponseAsync(resourceGroupName, name, hostName, hostNameBinding).map(new Func1<ServiceResponse<HostNameBindingInner>, HostNameBindingInner>() {
            @Override
            public HostNameBindingInner call(ServiceResponse<HostNameBindingInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a hostname binding for an app.
     * Creates a hostname binding for an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param hostName Hostname in the hostname binding.
     * @param hostNameBinding Binding details. This is the JSON representation of a HostNameBinding object.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HostNameBindingInner object
     */
    public Observable<ServiceResponse<HostNameBindingInner>> createOrUpdateHostNameBindingWithServiceResponseAsync(String resourceGroupName, String name, String hostName, HostNameBindingInner hostNameBinding) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (hostName == null) {
            throw new IllegalArgumentException("Parameter hostName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (hostNameBinding == null) {
            throw new IllegalArgumentException("Parameter hostNameBinding is required and cannot be null.");
        }
        Validator.validate(hostNameBinding);
        final String apiVersion = "2016-08-01";
        return service.createOrUpdateHostNameBinding(resourceGroupName, name, hostName, this.client.subscriptionId(), hostNameBinding, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HostNameBindingInner>>>() {
                @Override
                public Observable<ServiceResponse<HostNameBindingInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HostNameBindingInner> clientResponse = createOrUpdateHostNameBindingDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HostNameBindingInner> createOrUpdateHostNameBindingDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<HostNameBindingInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<HostNameBindingInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a hostname binding for an app.
     * Deletes a hostname binding for an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param hostName Hostname in the hostname binding.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteHostNameBinding(String resourceGroupName, String name, String hostName) {
        deleteHostNameBindingWithServiceResponseAsync(resourceGroupName, name, hostName).toBlocking().single().body();
    }

    /**
     * Deletes a hostname binding for an app.
     * Deletes a hostname binding for an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param hostName Hostname in the hostname binding.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteHostNameBindingAsync(String resourceGroupName, String name, String hostName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteHostNameBindingWithServiceResponseAsync(resourceGroupName, name, hostName), serviceCallback);
    }

    /**
     * Deletes a hostname binding for an app.
     * Deletes a hostname binding for an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param hostName Hostname in the hostname binding.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteHostNameBindingAsync(String resourceGroupName, String name, String hostName) {
        return deleteHostNameBindingWithServiceResponseAsync(resourceGroupName, name, hostName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a hostname binding for an app.
     * Deletes a hostname binding for an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param hostName Hostname in the hostname binding.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteHostNameBindingWithServiceResponseAsync(String resourceGroupName, String name, String hostName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (hostName == null) {
            throw new IllegalArgumentException("Parameter hostName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.deleteHostNameBinding(resourceGroupName, name, hostName, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteHostNameBindingDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteHostNameBindingDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HybridConnectionInner object if successful.
     */
    public HybridConnectionInner getHybridConnection(String resourceGroupName, String name, String namespaceName, String relayName) {
        return getHybridConnectionWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName).toBlocking().single().body();
    }

    /**
     * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HybridConnectionInner> getHybridConnectionAsync(String resourceGroupName, String name, String namespaceName, String relayName, final ServiceCallback<HybridConnectionInner> serviceCallback) {
        return ServiceFuture.fromResponse(getHybridConnectionWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName), serviceCallback);
    }

    /**
     * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<HybridConnectionInner> getHybridConnectionAsync(String resourceGroupName, String name, String namespaceName, String relayName) {
        return getHybridConnectionWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName).map(new Func1<ServiceResponse<HybridConnectionInner>, HybridConnectionInner>() {
            @Override
            public HybridConnectionInner call(ServiceResponse<HybridConnectionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<ServiceResponse<HybridConnectionInner>> getHybridConnectionWithServiceResponseAsync(String resourceGroupName, String name, String namespaceName, String relayName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (namespaceName == null) {
            throw new IllegalArgumentException("Parameter namespaceName is required and cannot be null.");
        }
        if (relayName == null) {
            throw new IllegalArgumentException("Parameter relayName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getHybridConnection(resourceGroupName, name, namespaceName, relayName, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HybridConnectionInner>>>() {
                @Override
                public Observable<ServiceResponse<HybridConnectionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HybridConnectionInner> clientResponse = getHybridConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HybridConnectionInner> getHybridConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<HybridConnectionInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<HybridConnectionInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new Hybrid Connection using a Service Bus relay.
     * Creates a new Hybrid Connection using a Service Bus relay.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param connectionEnvelope The details of the hybrid connection
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HybridConnectionInner object if successful.
     */
    public HybridConnectionInner createOrUpdateHybridConnection(String resourceGroupName, String name, String namespaceName, String relayName, HybridConnectionInner connectionEnvelope) {
        return createOrUpdateHybridConnectionWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, connectionEnvelope).toBlocking().single().body();
    }

    /**
     * Creates a new Hybrid Connection using a Service Bus relay.
     * Creates a new Hybrid Connection using a Service Bus relay.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param connectionEnvelope The details of the hybrid connection
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HybridConnectionInner> createOrUpdateHybridConnectionAsync(String resourceGroupName, String name, String namespaceName, String relayName, HybridConnectionInner connectionEnvelope, final ServiceCallback<HybridConnectionInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateHybridConnectionWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, connectionEnvelope), serviceCallback);
    }

    /**
     * Creates a new Hybrid Connection using a Service Bus relay.
     * Creates a new Hybrid Connection using a Service Bus relay.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param connectionEnvelope The details of the hybrid connection
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<HybridConnectionInner> createOrUpdateHybridConnectionAsync(String resourceGroupName, String name, String namespaceName, String relayName, HybridConnectionInner connectionEnvelope) {
        return createOrUpdateHybridConnectionWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, connectionEnvelope).map(new Func1<ServiceResponse<HybridConnectionInner>, HybridConnectionInner>() {
            @Override
            public HybridConnectionInner call(ServiceResponse<HybridConnectionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new Hybrid Connection using a Service Bus relay.
     * Creates a new Hybrid Connection using a Service Bus relay.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param connectionEnvelope The details of the hybrid connection
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<ServiceResponse<HybridConnectionInner>> createOrUpdateHybridConnectionWithServiceResponseAsync(String resourceGroupName, String name, String namespaceName, String relayName, HybridConnectionInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (namespaceName == null) {
            throw new IllegalArgumentException("Parameter namespaceName is required and cannot be null.");
        }
        if (relayName == null) {
            throw new IllegalArgumentException("Parameter relayName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        final String apiVersion = "2016-08-01";
        return service.createOrUpdateHybridConnection(resourceGroupName, name, namespaceName, relayName, this.client.subscriptionId(), connectionEnvelope, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HybridConnectionInner>>>() {
                @Override
                public Observable<ServiceResponse<HybridConnectionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HybridConnectionInner> clientResponse = createOrUpdateHybridConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HybridConnectionInner> createOrUpdateHybridConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<HybridConnectionInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<HybridConnectionInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Removes a Hybrid Connection from this site.
     * Removes a Hybrid Connection from this site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteHybridConnection(String resourceGroupName, String name, String namespaceName, String relayName) {
        deleteHybridConnectionWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName).toBlocking().single().body();
    }

    /**
     * Removes a Hybrid Connection from this site.
     * Removes a Hybrid Connection from this site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteHybridConnectionAsync(String resourceGroupName, String name, String namespaceName, String relayName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteHybridConnectionWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName), serviceCallback);
    }

    /**
     * Removes a Hybrid Connection from this site.
     * Removes a Hybrid Connection from this site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteHybridConnectionAsync(String resourceGroupName, String name, String namespaceName, String relayName) {
        return deleteHybridConnectionWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Removes a Hybrid Connection from this site.
     * Removes a Hybrid Connection from this site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteHybridConnectionWithServiceResponseAsync(String resourceGroupName, String name, String namespaceName, String relayName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (namespaceName == null) {
            throw new IllegalArgumentException("Parameter namespaceName is required and cannot be null.");
        }
        if (relayName == null) {
            throw new IllegalArgumentException("Parameter relayName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.deleteHybridConnection(resourceGroupName, name, namespaceName, relayName, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteHybridConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteHybridConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new Hybrid Connection using a Service Bus relay.
     * Creates a new Hybrid Connection using a Service Bus relay.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param connectionEnvelope The details of the hybrid connection
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HybridConnectionInner object if successful.
     */
    public HybridConnectionInner updateHybridConnection(String resourceGroupName, String name, String namespaceName, String relayName, HybridConnectionInner connectionEnvelope) {
        return updateHybridConnectionWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, connectionEnvelope).toBlocking().single().body();
    }

    /**
     * Creates a new Hybrid Connection using a Service Bus relay.
     * Creates a new Hybrid Connection using a Service Bus relay.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param connectionEnvelope The details of the hybrid connection
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HybridConnectionInner> updateHybridConnectionAsync(String resourceGroupName, String name, String namespaceName, String relayName, HybridConnectionInner connectionEnvelope, final ServiceCallback<HybridConnectionInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateHybridConnectionWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, connectionEnvelope), serviceCallback);
    }

    /**
     * Creates a new Hybrid Connection using a Service Bus relay.
     * Creates a new Hybrid Connection using a Service Bus relay.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param connectionEnvelope The details of the hybrid connection
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<HybridConnectionInner> updateHybridConnectionAsync(String resourceGroupName, String name, String namespaceName, String relayName, HybridConnectionInner connectionEnvelope) {
        return updateHybridConnectionWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, connectionEnvelope).map(new Func1<ServiceResponse<HybridConnectionInner>, HybridConnectionInner>() {
            @Override
            public HybridConnectionInner call(ServiceResponse<HybridConnectionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new Hybrid Connection using a Service Bus relay.
     * Creates a new Hybrid Connection using a Service Bus relay.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param connectionEnvelope The details of the hybrid connection
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<ServiceResponse<HybridConnectionInner>> updateHybridConnectionWithServiceResponseAsync(String resourceGroupName, String name, String namespaceName, String relayName, HybridConnectionInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (namespaceName == null) {
            throw new IllegalArgumentException("Parameter namespaceName is required and cannot be null.");
        }
        if (relayName == null) {
            throw new IllegalArgumentException("Parameter relayName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        final String apiVersion = "2016-08-01";
        return service.updateHybridConnection(resourceGroupName, name, namespaceName, relayName, this.client.subscriptionId(), connectionEnvelope, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HybridConnectionInner>>>() {
                @Override
                public Observable<ServiceResponse<HybridConnectionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HybridConnectionInner> clientResponse = updateHybridConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HybridConnectionInner> updateHybridConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<HybridConnectionInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<HybridConnectionInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the send key name and value for a Hybrid Connection.
     * Gets the send key name and value for a Hybrid Connection.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HybridConnectionKeyInner object if successful.
     */
    public HybridConnectionKeyInner listHybridConnectionKeys(String resourceGroupName, String name, String namespaceName, String relayName) {
        return listHybridConnectionKeysWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName).toBlocking().single().body();
    }

    /**
     * Gets the send key name and value for a Hybrid Connection.
     * Gets the send key name and value for a Hybrid Connection.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HybridConnectionKeyInner> listHybridConnectionKeysAsync(String resourceGroupName, String name, String namespaceName, String relayName, final ServiceCallback<HybridConnectionKeyInner> serviceCallback) {
        return ServiceFuture.fromResponse(listHybridConnectionKeysWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName), serviceCallback);
    }

    /**
     * Gets the send key name and value for a Hybrid Connection.
     * Gets the send key name and value for a Hybrid Connection.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HybridConnectionKeyInner object
     */
    public Observable<HybridConnectionKeyInner> listHybridConnectionKeysAsync(String resourceGroupName, String name, String namespaceName, String relayName) {
        return listHybridConnectionKeysWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName).map(new Func1<ServiceResponse<HybridConnectionKeyInner>, HybridConnectionKeyInner>() {
            @Override
            public HybridConnectionKeyInner call(ServiceResponse<HybridConnectionKeyInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the send key name and value for a Hybrid Connection.
     * Gets the send key name and value for a Hybrid Connection.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HybridConnectionKeyInner object
     */
    public Observable<ServiceResponse<HybridConnectionKeyInner>> listHybridConnectionKeysWithServiceResponseAsync(String resourceGroupName, String name, String namespaceName, String relayName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (namespaceName == null) {
            throw new IllegalArgumentException("Parameter namespaceName is required and cannot be null.");
        }
        if (relayName == null) {
            throw new IllegalArgumentException("Parameter relayName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listHybridConnectionKeys(resourceGroupName, name, namespaceName, relayName, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HybridConnectionKeyInner>>>() {
                @Override
                public Observable<ServiceResponse<HybridConnectionKeyInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HybridConnectionKeyInner> clientResponse = listHybridConnectionKeysDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HybridConnectionKeyInner> listHybridConnectionKeysDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<HybridConnectionKeyInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<HybridConnectionKeyInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves all Service Bus Hybrid Connections used by this Web App.
     * Retrieves all Service Bus Hybrid Connections used by this Web App.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HybridConnectionInner object if successful.
     */
    public HybridConnectionInner listHybridConnections(String resourceGroupName, String name) {
        return listHybridConnectionsWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Retrieves all Service Bus Hybrid Connections used by this Web App.
     * Retrieves all Service Bus Hybrid Connections used by this Web App.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HybridConnectionInner> listHybridConnectionsAsync(String resourceGroupName, String name, final ServiceCallback<HybridConnectionInner> serviceCallback) {
        return ServiceFuture.fromResponse(listHybridConnectionsWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Retrieves all Service Bus Hybrid Connections used by this Web App.
     * Retrieves all Service Bus Hybrid Connections used by this Web App.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<HybridConnectionInner> listHybridConnectionsAsync(String resourceGroupName, String name) {
        return listHybridConnectionsWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<HybridConnectionInner>, HybridConnectionInner>() {
            @Override
            public HybridConnectionInner call(ServiceResponse<HybridConnectionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Retrieves all Service Bus Hybrid Connections used by this Web App.
     * Retrieves all Service Bus Hybrid Connections used by this Web App.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<ServiceResponse<HybridConnectionInner>> listHybridConnectionsWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listHybridConnections(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HybridConnectionInner>>>() {
                @Override
                public Observable<ServiceResponse<HybridConnectionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HybridConnectionInner> clientResponse = listHybridConnectionsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HybridConnectionInner> listHybridConnectionsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<HybridConnectionInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<HybridConnectionInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets hybrid connections configured for an app (or deployment slot, if specified).
     * Gets hybrid connections configured for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RelayServiceConnectionEntityInner object if successful.
     */
    public RelayServiceConnectionEntityInner listRelayServiceConnections(String resourceGroupName, String name) {
        return listRelayServiceConnectionsWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Gets hybrid connections configured for an app (or deployment slot, if specified).
     * Gets hybrid connections configured for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RelayServiceConnectionEntityInner> listRelayServiceConnectionsAsync(String resourceGroupName, String name, final ServiceCallback<RelayServiceConnectionEntityInner> serviceCallback) {
        return ServiceFuture.fromResponse(listRelayServiceConnectionsWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets hybrid connections configured for an app (or deployment slot, if specified).
     * Gets hybrid connections configured for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<RelayServiceConnectionEntityInner> listRelayServiceConnectionsAsync(String resourceGroupName, String name) {
        return listRelayServiceConnectionsWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<RelayServiceConnectionEntityInner>, RelayServiceConnectionEntityInner>() {
            @Override
            public RelayServiceConnectionEntityInner call(ServiceResponse<RelayServiceConnectionEntityInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets hybrid connections configured for an app (or deployment slot, if specified).
     * Gets hybrid connections configured for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> listRelayServiceConnectionsWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listRelayServiceConnections(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RelayServiceConnectionEntityInner>>>() {
                @Override
                public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RelayServiceConnectionEntityInner> clientResponse = listRelayServiceConnectionsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RelayServiceConnectionEntityInner> listRelayServiceConnectionsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<RelayServiceConnectionEntityInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<RelayServiceConnectionEntityInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets a hybrid connection configuration by its name.
     * Gets a hybrid connection configuration by its name.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RelayServiceConnectionEntityInner object if successful.
     */
    public RelayServiceConnectionEntityInner getRelayServiceConnection(String resourceGroupName, String name, String entityName) {
        return getRelayServiceConnectionWithServiceResponseAsync(resourceGroupName, name, entityName).toBlocking().single().body();
    }

    /**
     * Gets a hybrid connection configuration by its name.
     * Gets a hybrid connection configuration by its name.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RelayServiceConnectionEntityInner> getRelayServiceConnectionAsync(String resourceGroupName, String name, String entityName, final ServiceCallback<RelayServiceConnectionEntityInner> serviceCallback) {
        return ServiceFuture.fromResponse(getRelayServiceConnectionWithServiceResponseAsync(resourceGroupName, name, entityName), serviceCallback);
    }

    /**
     * Gets a hybrid connection configuration by its name.
     * Gets a hybrid connection configuration by its name.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<RelayServiceConnectionEntityInner> getRelayServiceConnectionAsync(String resourceGroupName, String name, String entityName) {
        return getRelayServiceConnectionWithServiceResponseAsync(resourceGroupName, name, entityName).map(new Func1<ServiceResponse<RelayServiceConnectionEntityInner>, RelayServiceConnectionEntityInner>() {
            @Override
            public RelayServiceConnectionEntityInner call(ServiceResponse<RelayServiceConnectionEntityInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a hybrid connection configuration by its name.
     * Gets a hybrid connection configuration by its name.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> getRelayServiceConnectionWithServiceResponseAsync(String resourceGroupName, String name, String entityName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getRelayServiceConnection(resourceGroupName, name, entityName, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RelayServiceConnectionEntityInner>>>() {
                @Override
                public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RelayServiceConnectionEntityInner> clientResponse = getRelayServiceConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RelayServiceConnectionEntityInner> getRelayServiceConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<RelayServiceConnectionEntityInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<RelayServiceConnectionEntityInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param connectionEnvelope Details of the hybrid connection configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RelayServiceConnectionEntityInner object if successful.
     */
    public RelayServiceConnectionEntityInner createOrUpdateRelayServiceConnection(String resourceGroupName, String name, String entityName, RelayServiceConnectionEntityInner connectionEnvelope) {
        return createOrUpdateRelayServiceConnectionWithServiceResponseAsync(resourceGroupName, name, entityName, connectionEnvelope).toBlocking().single().body();
    }

    /**
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param connectionEnvelope Details of the hybrid connection configuration.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RelayServiceConnectionEntityInner> createOrUpdateRelayServiceConnectionAsync(String resourceGroupName, String name, String entityName, RelayServiceConnectionEntityInner connectionEnvelope, final ServiceCallback<RelayServiceConnectionEntityInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateRelayServiceConnectionWithServiceResponseAsync(resourceGroupName, name, entityName, connectionEnvelope), serviceCallback);
    }

    /**
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param connectionEnvelope Details of the hybrid connection configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<RelayServiceConnectionEntityInner> createOrUpdateRelayServiceConnectionAsync(String resourceGroupName, String name, String entityName, RelayServiceConnectionEntityInner connectionEnvelope) {
        return createOrUpdateRelayServiceConnectionWithServiceResponseAsync(resourceGroupName, name, entityName, connectionEnvelope).map(new Func1<ServiceResponse<RelayServiceConnectionEntityInner>, RelayServiceConnectionEntityInner>() {
            @Override
            public RelayServiceConnectionEntityInner call(ServiceResponse<RelayServiceConnectionEntityInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param connectionEnvelope Details of the hybrid connection configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> createOrUpdateRelayServiceConnectionWithServiceResponseAsync(String resourceGroupName, String name, String entityName, RelayServiceConnectionEntityInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        final String apiVersion = "2016-08-01";
        return service.createOrUpdateRelayServiceConnection(resourceGroupName, name, entityName, this.client.subscriptionId(), connectionEnvelope, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RelayServiceConnectionEntityInner>>>() {
                @Override
                public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RelayServiceConnectionEntityInner> clientResponse = createOrUpdateRelayServiceConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RelayServiceConnectionEntityInner> createOrUpdateRelayServiceConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<RelayServiceConnectionEntityInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<RelayServiceConnectionEntityInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a relay service connection by its name.
     * Deletes a relay service connection by its name.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteRelayServiceConnection(String resourceGroupName, String name, String entityName) {
        deleteRelayServiceConnectionWithServiceResponseAsync(resourceGroupName, name, entityName).toBlocking().single().body();
    }

    /**
     * Deletes a relay service connection by its name.
     * Deletes a relay service connection by its name.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteRelayServiceConnectionAsync(String resourceGroupName, String name, String entityName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteRelayServiceConnectionWithServiceResponseAsync(resourceGroupName, name, entityName), serviceCallback);
    }

    /**
     * Deletes a relay service connection by its name.
     * Deletes a relay service connection by its name.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteRelayServiceConnectionAsync(String resourceGroupName, String name, String entityName) {
        return deleteRelayServiceConnectionWithServiceResponseAsync(resourceGroupName, name, entityName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a relay service connection by its name.
     * Deletes a relay service connection by its name.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteRelayServiceConnectionWithServiceResponseAsync(String resourceGroupName, String name, String entityName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.deleteRelayServiceConnection(resourceGroupName, name, entityName, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteRelayServiceConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteRelayServiceConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param connectionEnvelope Details of the hybrid connection configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RelayServiceConnectionEntityInner object if successful.
     */
    public RelayServiceConnectionEntityInner updateRelayServiceConnection(String resourceGroupName, String name, String entityName, RelayServiceConnectionEntityInner connectionEnvelope) {
        return updateRelayServiceConnectionWithServiceResponseAsync(resourceGroupName, name, entityName, connectionEnvelope).toBlocking().single().body();
    }

    /**
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param connectionEnvelope Details of the hybrid connection configuration.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RelayServiceConnectionEntityInner> updateRelayServiceConnectionAsync(String resourceGroupName, String name, String entityName, RelayServiceConnectionEntityInner connectionEnvelope, final ServiceCallback<RelayServiceConnectionEntityInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateRelayServiceConnectionWithServiceResponseAsync(resourceGroupName, name, entityName, connectionEnvelope), serviceCallback);
    }

    /**
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param connectionEnvelope Details of the hybrid connection configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<RelayServiceConnectionEntityInner> updateRelayServiceConnectionAsync(String resourceGroupName, String name, String entityName, RelayServiceConnectionEntityInner connectionEnvelope) {
        return updateRelayServiceConnectionWithServiceResponseAsync(resourceGroupName, name, entityName, connectionEnvelope).map(new Func1<ServiceResponse<RelayServiceConnectionEntityInner>, RelayServiceConnectionEntityInner>() {
            @Override
            public RelayServiceConnectionEntityInner call(ServiceResponse<RelayServiceConnectionEntityInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param connectionEnvelope Details of the hybrid connection configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> updateRelayServiceConnectionWithServiceResponseAsync(String resourceGroupName, String name, String entityName, RelayServiceConnectionEntityInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        final String apiVersion = "2016-08-01";
        return service.updateRelayServiceConnection(resourceGroupName, name, entityName, this.client.subscriptionId(), connectionEnvelope, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RelayServiceConnectionEntityInner>>>() {
                @Override
                public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RelayServiceConnectionEntityInner> clientResponse = updateRelayServiceConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RelayServiceConnectionEntityInner> updateRelayServiceConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<RelayServiceConnectionEntityInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<RelayServiceConnectionEntityInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets all scale-out instances of an app.
     * Gets all scale-out instances of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SiteInstanceInner&gt; object if successful.
     */
    public PagedList<SiteInstanceInner> listInstanceIdentifiers(final String resourceGroupName, final String name) {
        ServiceResponse<Page<SiteInstanceInner>> response = listInstanceIdentifiersSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<SiteInstanceInner>(response.body()) {
            @Override
            public Page<SiteInstanceInner> nextPage(String nextPageLink) {
                return listInstanceIdentifiersNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets all scale-out instances of an app.
     * Gets all scale-out instances of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SiteInstanceInner>> listInstanceIdentifiersAsync(final String resourceGroupName, final String name, final ListOperationCallback<SiteInstanceInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listInstanceIdentifiersSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(String nextPageLink) {
                    return listInstanceIdentifiersNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets all scale-out instances of an app.
     * Gets all scale-out instances of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteInstanceInner&gt; object
     */
    public Observable<Page<SiteInstanceInner>> listInstanceIdentifiersAsync(final String resourceGroupName, final String name) {
        return listInstanceIdentifiersWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<SiteInstanceInner>>, Page<SiteInstanceInner>>() {
                @Override
                public Page<SiteInstanceInner> call(ServiceResponse<Page<SiteInstanceInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets all scale-out instances of an app.
     * Gets all scale-out instances of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteInstanceInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInstanceInner>>> listInstanceIdentifiersWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return listInstanceIdentifiersSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<SiteInstanceInner>>, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(ServiceResponse<Page<SiteInstanceInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listInstanceIdentifiersNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets all scale-out instances of an app.
     * Gets all scale-out instances of an app.
     *
    ServiceResponse<PageImpl<SiteInstanceInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<SiteInstanceInner>> * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SiteInstanceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInstanceInner>>> listInstanceIdentifiersSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listInstanceIdentifiers(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInstanceInner>> result = listInstanceIdentifiersDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInstanceInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteInstanceInner>> listInstanceIdentifiersDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<SiteInstanceInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SiteInstanceInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param instanceId The ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances"
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;DeploymentInner&gt; object if successful.
     */
    public PagedList<DeploymentInner> listInstanceDeployments(final String resourceGroupName, final String name, final String instanceId) {
        ServiceResponse<Page<DeploymentInner>> response = listInstanceDeploymentsSinglePageAsync(resourceGroupName, name, instanceId).toBlocking().single();
        return new PagedList<DeploymentInner>(response.body()) {
            @Override
            public Page<DeploymentInner> nextPage(String nextPageLink) {
                return listInstanceDeploymentsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param instanceId The ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances"
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<DeploymentInner>> listInstanceDeploymentsAsync(final String resourceGroupName, final String name, final String instanceId, final ListOperationCallback<DeploymentInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listInstanceDeploymentsSinglePageAsync(resourceGroupName, name, instanceId),
            new Func1<String, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(String nextPageLink) {
                    return listInstanceDeploymentsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param instanceId The ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances"
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<Page<DeploymentInner>> listInstanceDeploymentsAsync(final String resourceGroupName, final String name, final String instanceId) {
        return listInstanceDeploymentsWithServiceResponseAsync(resourceGroupName, name, instanceId)
            .map(new Func1<ServiceResponse<Page<DeploymentInner>>, Page<DeploymentInner>>() {
                @Override
                public Page<DeploymentInner> call(ServiceResponse<Page<DeploymentInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param instanceId The ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances"
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> listInstanceDeploymentsWithServiceResponseAsync(final String resourceGroupName, final String name, final String instanceId) {
        return listInstanceDeploymentsSinglePageAsync(resourceGroupName, name, instanceId)
            .concatMap(new Func1<ServiceResponse<Page<DeploymentInner>>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(ServiceResponse<Page<DeploymentInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listInstanceDeploymentsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     *
    ServiceResponse<PageImpl<DeploymentInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<DeploymentInner>> * @param name Name of the app.
    ServiceResponse<PageImpl<DeploymentInner>> * @param instanceId The ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances"
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;DeploymentInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> listInstanceDeploymentsSinglePageAsync(final String resourceGroupName, final String name, final String instanceId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listInstanceDeployments(resourceGroupName, name, instanceId, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<DeploymentInner>> result = listInstanceDeploymentsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<DeploymentInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<DeploymentInner>> listInstanceDeploymentsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<DeploymentInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<DeploymentInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     * Get a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances"
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the DeploymentInner object if successful.
     */
    public DeploymentInner getInstanceDeployment(String resourceGroupName, String name, String id, String instanceId) {
        return getInstanceDeploymentWithServiceResponseAsync(resourceGroupName, name, id, instanceId).toBlocking().single().body();
    }

    /**
     * Get a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     * Get a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances"
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<DeploymentInner> getInstanceDeploymentAsync(String resourceGroupName, String name, String id, String instanceId, final ServiceCallback<DeploymentInner> serviceCallback) {
        return ServiceFuture.fromResponse(getInstanceDeploymentWithServiceResponseAsync(resourceGroupName, name, id, instanceId), serviceCallback);
    }

    /**
     * Get a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     * Get a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances"
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeploymentInner object
     */
    public Observable<DeploymentInner> getInstanceDeploymentAsync(String resourceGroupName, String name, String id, String instanceId) {
        return getInstanceDeploymentWithServiceResponseAsync(resourceGroupName, name, id, instanceId).map(new Func1<ServiceResponse<DeploymentInner>, DeploymentInner>() {
            @Override
            public DeploymentInner call(ServiceResponse<DeploymentInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     * Get a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances"
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeploymentInner object
     */
    public Observable<ServiceResponse<DeploymentInner>> getInstanceDeploymentWithServiceResponseAsync(String resourceGroupName, String name, String id, String instanceId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getInstanceDeployment(resourceGroupName, name, id, instanceId, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeploymentInner>>>() {
                @Override
                public Observable<ServiceResponse<DeploymentInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeploymentInner> clientResponse = getInstanceDeploymentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DeploymentInner> getInstanceDeploymentDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<DeploymentInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<DeploymentInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Create a deployment for an app, a specific deployment slot, and/or a specific scaled-out instance.
     * Create a deployment for an app, a specific deployment slot, and/or a specific scaled-out instance.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id ID of an existing deployment.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances"
     * @param deployment Deployment details.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the DeploymentInner object if successful.
     */
    public DeploymentInner createInstanceDeployment(String resourceGroupName, String name, String id, String instanceId, DeploymentInner deployment) {
        return createInstanceDeploymentWithServiceResponseAsync(resourceGroupName, name, id, instanceId, deployment).toBlocking().single().body();
    }

    /**
     * Create a deployment for an app, a specific deployment slot, and/or a specific scaled-out instance.
     * Create a deployment for an app, a specific deployment slot, and/or a specific scaled-out instance.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id ID of an existing deployment.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances"
     * @param deployment Deployment details.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<DeploymentInner> createInstanceDeploymentAsync(String resourceGroupName, String name, String id, String instanceId, DeploymentInner deployment, final ServiceCallback<DeploymentInner> serviceCallback) {
        return ServiceFuture.fromResponse(createInstanceDeploymentWithServiceResponseAsync(resourceGroupName, name, id, instanceId, deployment), serviceCallback);
    }

    /**
     * Create a deployment for an app, a specific deployment slot, and/or a specific scaled-out instance.
     * Create a deployment for an app, a specific deployment slot, and/or a specific scaled-out instance.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id ID of an existing deployment.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances"
     * @param deployment Deployment details.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeploymentInner object
     */
    public Observable<DeploymentInner> createInstanceDeploymentAsync(String resourceGroupName, String name, String id, String instanceId, DeploymentInner deployment) {
        return createInstanceDeploymentWithServiceResponseAsync(resourceGroupName, name, id, instanceId, deployment).map(new Func1<ServiceResponse<DeploymentInner>, DeploymentInner>() {
            @Override
            public DeploymentInner call(ServiceResponse<DeploymentInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Create a deployment for an app, a specific deployment slot, and/or a specific scaled-out instance.
     * Create a deployment for an app, a specific deployment slot, and/or a specific scaled-out instance.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id ID of an existing deployment.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances"
     * @param deployment Deployment details.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeploymentInner object
     */
    public Observable<ServiceResponse<DeploymentInner>> createInstanceDeploymentWithServiceResponseAsync(String resourceGroupName, String name, String id, String instanceId, DeploymentInner deployment) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (deployment == null) {
            throw new IllegalArgumentException("Parameter deployment is required and cannot be null.");
        }
        Validator.validate(deployment);
        final String apiVersion = "2016-08-01";
        return service.createInstanceDeployment(resourceGroupName, name, id, instanceId, this.client.subscriptionId(), deployment, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeploymentInner>>>() {
                @Override
                public Observable<ServiceResponse<DeploymentInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeploymentInner> clientResponse = createInstanceDeploymentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DeploymentInner> createInstanceDeploymentDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<DeploymentInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<DeploymentInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Delete a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     * Delete a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances"
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteInstanceDeployment(String resourceGroupName, String name, String id, String instanceId) {
        deleteInstanceDeploymentWithServiceResponseAsync(resourceGroupName, name, id, instanceId).toBlocking().single().body();
    }

    /**
     * Delete a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     * Delete a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances"
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteInstanceDeploymentAsync(String resourceGroupName, String name, String id, String instanceId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteInstanceDeploymentWithServiceResponseAsync(resourceGroupName, name, id, instanceId), serviceCallback);
    }

    /**
     * Delete a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     * Delete a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances"
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteInstanceDeploymentAsync(String resourceGroupName, String name, String id, String instanceId) {
        return deleteInstanceDeploymentWithServiceResponseAsync(resourceGroupName, name, id, instanceId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     * Delete a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances"
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteInstanceDeploymentWithServiceResponseAsync(String resourceGroupName, String name, String id, String instanceId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.deleteInstanceDeployment(resourceGroupName, name, id, instanceId, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteInstanceDeploymentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteInstanceDeploymentDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Shows whether an app can be cloned to another resource group or subscription.
     * Shows whether an app can be cloned to another resource group or subscription.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteCloneabilityInner object if successful.
     */
    public SiteCloneabilityInner isCloneable(String resourceGroupName, String name) {
        return isCloneableWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Shows whether an app can be cloned to another resource group or subscription.
     * Shows whether an app can be cloned to another resource group or subscription.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteCloneabilityInner> isCloneableAsync(String resourceGroupName, String name, final ServiceCallback<SiteCloneabilityInner> serviceCallback) {
        return ServiceFuture.fromResponse(isCloneableWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Shows whether an app can be cloned to another resource group or subscription.
     * Shows whether an app can be cloned to another resource group or subscription.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteCloneabilityInner object
     */
    public Observable<SiteCloneabilityInner> isCloneableAsync(String resourceGroupName, String name) {
        return isCloneableWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<SiteCloneabilityInner>, SiteCloneabilityInner>() {
            @Override
            public SiteCloneabilityInner call(ServiceResponse<SiteCloneabilityInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Shows whether an app can be cloned to another resource group or subscription.
     * Shows whether an app can be cloned to another resource group or subscription.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteCloneabilityInner object
     */
    public Observable<ServiceResponse<SiteCloneabilityInner>> isCloneableWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.isCloneable(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteCloneabilityInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteCloneabilityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteCloneabilityInner> clientResponse = isCloneableDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteCloneabilityInner> isCloneableDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteCloneabilityInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteCloneabilityInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets all metric definitions of an app (or deployment slot, if specified).
     * Gets all metric definitions of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ResourceMetricDefinitionInner&gt; object if successful.
     */
    public PagedList<ResourceMetricDefinitionInner> listMetricDefinitions(final String resourceGroupName, final String name) {
        ServiceResponse<Page<ResourceMetricDefinitionInner>> response = listMetricDefinitionsSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<ResourceMetricDefinitionInner>(response.body()) {
            @Override
            public Page<ResourceMetricDefinitionInner> nextPage(String nextPageLink) {
                return listMetricDefinitionsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets all metric definitions of an app (or deployment slot, if specified).
     * Gets all metric definitions of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ResourceMetricDefinitionInner>> listMetricDefinitionsAsync(final String resourceGroupName, final String name, final ListOperationCallback<ResourceMetricDefinitionInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listMetricDefinitionsSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>> call(String nextPageLink) {
                    return listMetricDefinitionsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets all metric definitions of an app (or deployment slot, if specified).
     * Gets all metric definitions of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ResourceMetricDefinitionInner&gt; object
     */
    public Observable<Page<ResourceMetricDefinitionInner>> listMetricDefinitionsAsync(final String resourceGroupName, final String name) {
        return listMetricDefinitionsWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<ResourceMetricDefinitionInner>>, Page<ResourceMetricDefinitionInner>>() {
                @Override
                public Page<ResourceMetricDefinitionInner> call(ServiceResponse<Page<ResourceMetricDefinitionInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets all metric definitions of an app (or deployment slot, if specified).
     * Gets all metric definitions of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ResourceMetricDefinitionInner&gt; object
     */
    public Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>> listMetricDefinitionsWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return listMetricDefinitionsSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<ResourceMetricDefinitionInner>>, Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>> call(ServiceResponse<Page<ResourceMetricDefinitionInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listMetricDefinitionsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets all metric definitions of an app (or deployment slot, if specified).
     * Gets all metric definitions of an app (or deployment slot, if specified).
     *
    ServiceResponse<PageImpl<ResourceMetricDefinitionInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<ResourceMetricDefinitionInner>> * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ResourceMetricDefinitionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>> listMetricDefinitionsSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listMetricDefinitions(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ResourceMetricDefinitionInner>> result = listMetricDefinitionsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ResourceMetricDefinitionInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ResourceMetricDefinitionInner>> listMetricDefinitionsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ResourceMetricDefinitionInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ResourceMetricDefinitionInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ResourceMetricInner&gt; object if successful.
     */
    public PagedList<ResourceMetricInner> listMetrics(final String resourceGroupName, final String name) {
        ServiceResponse<Page<ResourceMetricInner>> response = listMetricsSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<ResourceMetricInner>(response.body()) {
            @Override
            public Page<ResourceMetricInner> nextPage(String nextPageLink) {
                return listMetricsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ResourceMetricInner>> listMetricsAsync(final String resourceGroupName, final String name, final ListOperationCallback<ResourceMetricInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listMetricsSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(String nextPageLink) {
                    return listMetricsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<Page<ResourceMetricInner>> listMetricsAsync(final String resourceGroupName, final String name) {
        return listMetricsWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Page<ResourceMetricInner>>() {
                @Override
                public Page<ResourceMetricInner> call(ServiceResponse<Page<ResourceMetricInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> listMetricsWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return listMetricsSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(ServiceResponse<Page<ResourceMetricInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listMetricsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ResourceMetricInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> listMetricsSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        final Boolean details = null;
        final String filter = null;
        return service.listMetrics(resourceGroupName, name, this.client.subscriptionId(), details, filter, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ResourceMetricInner>> result = listMetricsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ResourceMetricInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param details Specify "true" to include metric details in the response. It is "false" by default.
     * @param filter Return only metrics specified in the filter (using OData syntax). For example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ResourceMetricInner&gt; object if successful.
     */
    public PagedList<ResourceMetricInner> listMetrics(final String resourceGroupName, final String name, final Boolean details, final String filter) {
        ServiceResponse<Page<ResourceMetricInner>> response = listMetricsSinglePageAsync(resourceGroupName, name, details, filter).toBlocking().single();
        return new PagedList<ResourceMetricInner>(response.body()) {
            @Override
            public Page<ResourceMetricInner> nextPage(String nextPageLink) {
                return listMetricsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param details Specify "true" to include metric details in the response. It is "false" by default.
     * @param filter Return only metrics specified in the filter (using OData syntax). For example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ResourceMetricInner>> listMetricsAsync(final String resourceGroupName, final String name, final Boolean details, final String filter, final ListOperationCallback<ResourceMetricInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listMetricsSinglePageAsync(resourceGroupName, name, details, filter),
            new Func1<String, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(String nextPageLink) {
                    return listMetricsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param details Specify "true" to include metric details in the response. It is "false" by default.
     * @param filter Return only metrics specified in the filter (using OData syntax). For example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<Page<ResourceMetricInner>> listMetricsAsync(final String resourceGroupName, final String name, final Boolean details, final String filter) {
        return listMetricsWithServiceResponseAsync(resourceGroupName, name, details, filter)
            .map(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Page<ResourceMetricInner>>() {
                @Override
                public Page<ResourceMetricInner> call(ServiceResponse<Page<ResourceMetricInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param details Specify "true" to include metric details in the response. It is "false" by default.
     * @param filter Return only metrics specified in the filter (using OData syntax). For example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> listMetricsWithServiceResponseAsync(final String resourceGroupName, final String name, final Boolean details, final String filter) {
        return listMetricsSinglePageAsync(resourceGroupName, name, details, filter)
            .concatMap(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(ServiceResponse<Page<ResourceMetricInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listMetricsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param name Name of the app.
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param details Specify "true" to include metric details in the response. It is "false" by default.
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param filter Return only metrics specified in the filter (using OData syntax). For example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ResourceMetricInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> listMetricsSinglePageAsync(final String resourceGroupName, final String name, final Boolean details, final String filter) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listMetrics(resourceGroupName, name, this.client.subscriptionId(), details, filter, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ResourceMetricInner>> result = listMetricsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ResourceMetricInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ResourceMetricInner>> listMetricsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ResourceMetricInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ResourceMetricInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Restores a web app.
     * Restores a web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param subscriptionName Azure subscription
     * @param migrationOptions Migration migrationOptions
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StorageMigrationResponseInner object if successful.
     */
    public StorageMigrationResponseInner migrateStorage(String resourceGroupName, String name, String subscriptionName, StorageMigrationOptionsInner migrationOptions) {
        return migrateStorageWithServiceResponseAsync(resourceGroupName, name, subscriptionName, migrationOptions).toBlocking().last().body();
    }

    /**
     * Restores a web app.
     * Restores a web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param subscriptionName Azure subscription
     * @param migrationOptions Migration migrationOptions
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StorageMigrationResponseInner> migrateStorageAsync(String resourceGroupName, String name, String subscriptionName, StorageMigrationOptionsInner migrationOptions, final ServiceCallback<StorageMigrationResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(migrateStorageWithServiceResponseAsync(resourceGroupName, name, subscriptionName, migrationOptions), serviceCallback);
    }

    /**
     * Restores a web app.
     * Restores a web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param subscriptionName Azure subscription
     * @param migrationOptions Migration migrationOptions
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<StorageMigrationResponseInner> migrateStorageAsync(String resourceGroupName, String name, String subscriptionName, StorageMigrationOptionsInner migrationOptions) {
        return migrateStorageWithServiceResponseAsync(resourceGroupName, name, subscriptionName, migrationOptions).map(new Func1<ServiceResponse<StorageMigrationResponseInner>, StorageMigrationResponseInner>() {
            @Override
            public StorageMigrationResponseInner call(ServiceResponse<StorageMigrationResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Restores a web app.
     * Restores a web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param subscriptionName Azure subscription
     * @param migrationOptions Migration migrationOptions
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<StorageMigrationResponseInner>> migrateStorageWithServiceResponseAsync(String resourceGroupName, String name, String subscriptionName, StorageMigrationOptionsInner migrationOptions) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (subscriptionName == null) {
            throw new IllegalArgumentException("Parameter subscriptionName is required and cannot be null.");
        }
        if (migrationOptions == null) {
            throw new IllegalArgumentException("Parameter migrationOptions is required and cannot be null.");
        }
        Validator.validate(migrationOptions);
        final String apiVersion = "2016-08-01";
        Observable<Response<ResponseBody>> observable = service.migrateStorage(resourceGroupName, name, this.client.subscriptionId(), subscriptionName, migrationOptions, apiVersion, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultAsync(observable, new TypeToken<StorageMigrationResponseInner>() { }.getType());
    }

    /**
     * Restores a web app.
     * Restores a web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param subscriptionName Azure subscription
     * @param migrationOptions Migration migrationOptions
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StorageMigrationResponseInner object if successful.
     */
    public StorageMigrationResponseInner beginMigrateStorage(String resourceGroupName, String name, String subscriptionName, StorageMigrationOptionsInner migrationOptions) {
        return beginMigrateStorageWithServiceResponseAsync(resourceGroupName, name, subscriptionName, migrationOptions).toBlocking().single().body();
    }

    /**
     * Restores a web app.
     * Restores a web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param subscriptionName Azure subscription
     * @param migrationOptions Migration migrationOptions
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StorageMigrationResponseInner> beginMigrateStorageAsync(String resourceGroupName, String name, String subscriptionName, StorageMigrationOptionsInner migrationOptions, final ServiceCallback<StorageMigrationResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginMigrateStorageWithServiceResponseAsync(resourceGroupName, name, subscriptionName, migrationOptions), serviceCallback);
    }

    /**
     * Restores a web app.
     * Restores a web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param subscriptionName Azure subscription
     * @param migrationOptions Migration migrationOptions
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StorageMigrationResponseInner object
     */
    public Observable<StorageMigrationResponseInner> beginMigrateStorageAsync(String resourceGroupName, String name, String subscriptionName, StorageMigrationOptionsInner migrationOptions) {
        return beginMigrateStorageWithServiceResponseAsync(resourceGroupName, name, subscriptionName, migrationOptions).map(new Func1<ServiceResponse<StorageMigrationResponseInner>, StorageMigrationResponseInner>() {
            @Override
            public StorageMigrationResponseInner call(ServiceResponse<StorageMigrationResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Restores a web app.
     * Restores a web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param subscriptionName Azure subscription
     * @param migrationOptions Migration migrationOptions
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StorageMigrationResponseInner object
     */
    public Observable<ServiceResponse<StorageMigrationResponseInner>> beginMigrateStorageWithServiceResponseAsync(String resourceGroupName, String name, String subscriptionName, StorageMigrationOptionsInner migrationOptions) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (subscriptionName == null) {
            throw new IllegalArgumentException("Parameter subscriptionName is required and cannot be null.");
        }
        if (migrationOptions == null) {
            throw new IllegalArgumentException("Parameter migrationOptions is required and cannot be null.");
        }
        Validator.validate(migrationOptions);
        final String apiVersion = "2016-08-01";
        return service.beginMigrateStorage(resourceGroupName, name, this.client.subscriptionId(), subscriptionName, migrationOptions, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StorageMigrationResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<StorageMigrationResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StorageMigrationResponseInner> clientResponse = beginMigrateStorageDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StorageMigrationResponseInner> beginMigrateStorageDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<StorageMigrationResponseInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<StorageMigrationResponseInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Migrates a local (in-app) MySql database to a remote MySql database.
     * Migrates a local (in-app) MySql database to a remote MySql database.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param migrationRequestEnvelope MySql migration options
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationInner object if successful.
     */
    public OperationInner migrateMySql(String resourceGroupName, String name, MigrateMySqlRequestInner migrationRequestEnvelope) {
        return migrateMySqlWithServiceResponseAsync(resourceGroupName, name, migrationRequestEnvelope).toBlocking().last().body();
    }

    /**
     * Migrates a local (in-app) MySql database to a remote MySql database.
     * Migrates a local (in-app) MySql database to a remote MySql database.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param migrationRequestEnvelope MySql migration options
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationInner> migrateMySqlAsync(String resourceGroupName, String name, MigrateMySqlRequestInner migrationRequestEnvelope, final ServiceCallback<OperationInner> serviceCallback) {
        return ServiceFuture.fromResponse(migrateMySqlWithServiceResponseAsync(resourceGroupName, name, migrationRequestEnvelope), serviceCallback);
    }

    /**
     * Migrates a local (in-app) MySql database to a remote MySql database.
     * Migrates a local (in-app) MySql database to a remote MySql database.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param migrationRequestEnvelope MySql migration options
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationInner> migrateMySqlAsync(String resourceGroupName, String name, MigrateMySqlRequestInner migrationRequestEnvelope) {
        return migrateMySqlWithServiceResponseAsync(resourceGroupName, name, migrationRequestEnvelope).map(new Func1<ServiceResponse<OperationInner>, OperationInner>() {
            @Override
            public OperationInner call(ServiceResponse<OperationInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Migrates a local (in-app) MySql database to a remote MySql database.
     * Migrates a local (in-app) MySql database to a remote MySql database.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param migrationRequestEnvelope MySql migration options
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<OperationInner>> migrateMySqlWithServiceResponseAsync(String resourceGroupName, String name, MigrateMySqlRequestInner migrationRequestEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (migrationRequestEnvelope == null) {
            throw new IllegalArgumentException("Parameter migrationRequestEnvelope is required and cannot be null.");
        }
        Validator.validate(migrationRequestEnvelope);
        final String apiVersion = "2016-08-01";
        Observable<Response<ResponseBody>> observable = service.migrateMySql(resourceGroupName, name, this.client.subscriptionId(), migrationRequestEnvelope, apiVersion, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<OperationInner>() { }.getType());
    }

    /**
     * Migrates a local (in-app) MySql database to a remote MySql database.
     * Migrates a local (in-app) MySql database to a remote MySql database.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param migrationRequestEnvelope MySql migration options
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationInner object if successful.
     */
    public OperationInner beginMigrateMySql(String resourceGroupName, String name, MigrateMySqlRequestInner migrationRequestEnvelope) {
        return beginMigrateMySqlWithServiceResponseAsync(resourceGroupName, name, migrationRequestEnvelope).toBlocking().single().body();
    }

    /**
     * Migrates a local (in-app) MySql database to a remote MySql database.
     * Migrates a local (in-app) MySql database to a remote MySql database.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param migrationRequestEnvelope MySql migration options
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationInner> beginMigrateMySqlAsync(String resourceGroupName, String name, MigrateMySqlRequestInner migrationRequestEnvelope, final ServiceCallback<OperationInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginMigrateMySqlWithServiceResponseAsync(resourceGroupName, name, migrationRequestEnvelope), serviceCallback);
    }

    /**
     * Migrates a local (in-app) MySql database to a remote MySql database.
     * Migrates a local (in-app) MySql database to a remote MySql database.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param migrationRequestEnvelope MySql migration options
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationInner object
     */
    public Observable<OperationInner> beginMigrateMySqlAsync(String resourceGroupName, String name, MigrateMySqlRequestInner migrationRequestEnvelope) {
        return beginMigrateMySqlWithServiceResponseAsync(resourceGroupName, name, migrationRequestEnvelope).map(new Func1<ServiceResponse<OperationInner>, OperationInner>() {
            @Override
            public OperationInner call(ServiceResponse<OperationInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Migrates a local (in-app) MySql database to a remote MySql database.
     * Migrates a local (in-app) MySql database to a remote MySql database.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param migrationRequestEnvelope MySql migration options
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationInner object
     */
    public Observable<ServiceResponse<OperationInner>> beginMigrateMySqlWithServiceResponseAsync(String resourceGroupName, String name, MigrateMySqlRequestInner migrationRequestEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (migrationRequestEnvelope == null) {
            throw new IllegalArgumentException("Parameter migrationRequestEnvelope is required and cannot be null.");
        }
        Validator.validate(migrationRequestEnvelope);
        final String apiVersion = "2016-08-01";
        return service.beginMigrateMySql(resourceGroupName, name, this.client.subscriptionId(), migrationRequestEnvelope, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationInner>>>() {
                @Override
                public Observable<ServiceResponse<OperationInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationInner> clientResponse = beginMigrateMySqlDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationInner> beginMigrateMySqlDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Returns the status of MySql in app migration, if one is active, and whether or not MySql in app is enabled.
     * Returns the status of MySql in app migration, if one is active, and whether or not MySql in app is enabled.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MigrateMySqlStatusInner object if successful.
     */
    public MigrateMySqlStatusInner getMigrateMySqlStatus(String resourceGroupName, String name) {
        return getMigrateMySqlStatusWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Returns the status of MySql in app migration, if one is active, and whether or not MySql in app is enabled.
     * Returns the status of MySql in app migration, if one is active, and whether or not MySql in app is enabled.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MigrateMySqlStatusInner> getMigrateMySqlStatusAsync(String resourceGroupName, String name, final ServiceCallback<MigrateMySqlStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(getMigrateMySqlStatusWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Returns the status of MySql in app migration, if one is active, and whether or not MySql in app is enabled.
     * Returns the status of MySql in app migration, if one is active, and whether or not MySql in app is enabled.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MigrateMySqlStatusInner object
     */
    public Observable<MigrateMySqlStatusInner> getMigrateMySqlStatusAsync(String resourceGroupName, String name) {
        return getMigrateMySqlStatusWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<MigrateMySqlStatusInner>, MigrateMySqlStatusInner>() {
            @Override
            public MigrateMySqlStatusInner call(ServiceResponse<MigrateMySqlStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Returns the status of MySql in app migration, if one is active, and whether or not MySql in app is enabled.
     * Returns the status of MySql in app migration, if one is active, and whether or not MySql in app is enabled.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MigrateMySqlStatusInner object
     */
    public Observable<ServiceResponse<MigrateMySqlStatusInner>> getMigrateMySqlStatusWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getMigrateMySqlStatus(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<MigrateMySqlStatusInner>>>() {
                @Override
                public Observable<ServiceResponse<MigrateMySqlStatusInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<MigrateMySqlStatusInner> clientResponse = getMigrateMySqlStatusDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<MigrateMySqlStatusInner> getMigrateMySqlStatusDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<MigrateMySqlStatusInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<MigrateMySqlStatusInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets all network features used by the app (or deployment slot, if specified).
     * Gets all network features used by the app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param view The type of view. This can either be "summary" or "detailed".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the NetworkFeaturesInner object if successful.
     */
    public NetworkFeaturesInner listNetworkFeatures(String resourceGroupName, String name, String view) {
        return listNetworkFeaturesWithServiceResponseAsync(resourceGroupName, name, view).toBlocking().single().body();
    }

    /**
     * Gets all network features used by the app (or deployment slot, if specified).
     * Gets all network features used by the app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param view The type of view. This can either be "summary" or "detailed".
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<NetworkFeaturesInner> listNetworkFeaturesAsync(String resourceGroupName, String name, String view, final ServiceCallback<NetworkFeaturesInner> serviceCallback) {
        return ServiceFuture.fromResponse(listNetworkFeaturesWithServiceResponseAsync(resourceGroupName, name, view), serviceCallback);
    }

    /**
     * Gets all network features used by the app (or deployment slot, if specified).
     * Gets all network features used by the app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param view The type of view. This can either be "summary" or "detailed".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the NetworkFeaturesInner object
     */
    public Observable<NetworkFeaturesInner> listNetworkFeaturesAsync(String resourceGroupName, String name, String view) {
        return listNetworkFeaturesWithServiceResponseAsync(resourceGroupName, name, view).map(new Func1<ServiceResponse<NetworkFeaturesInner>, NetworkFeaturesInner>() {
            @Override
            public NetworkFeaturesInner call(ServiceResponse<NetworkFeaturesInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets all network features used by the app (or deployment slot, if specified).
     * Gets all network features used by the app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param view The type of view. This can either be "summary" or "detailed".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the NetworkFeaturesInner object
     */
    public Observable<ServiceResponse<NetworkFeaturesInner>> listNetworkFeaturesWithServiceResponseAsync(String resourceGroupName, String name, String view) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (view == null) {
            throw new IllegalArgumentException("Parameter view is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listNetworkFeatures(resourceGroupName, name, view, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<NetworkFeaturesInner>>>() {
                @Override
                public Observable<ServiceResponse<NetworkFeaturesInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<NetworkFeaturesInner> clientResponse = listNetworkFeaturesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<NetworkFeaturesInner> listNetworkFeaturesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<NetworkFeaturesInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<NetworkFeaturesInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Start capturing network packets for the site.
     * Start capturing network packets for the site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the String object if successful.
     */
    public String startWebSiteNetworkTrace(String resourceGroupName, String name) {
        return startWebSiteNetworkTraceWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Start capturing network packets for the site.
     * Start capturing network packets for the site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<String> startWebSiteNetworkTraceAsync(String resourceGroupName, String name, final ServiceCallback<String> serviceCallback) {
        return ServiceFuture.fromResponse(startWebSiteNetworkTraceWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Start capturing network packets for the site.
     * Start capturing network packets for the site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the String object
     */
    public Observable<String> startWebSiteNetworkTraceAsync(String resourceGroupName, String name) {
        return startWebSiteNetworkTraceWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<String>, String>() {
            @Override
            public String call(ServiceResponse<String> response) {
                return response.body();
            }
        });
    }

    /**
     * Start capturing network packets for the site.
     * Start capturing network packets for the site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the String object
     */
    public Observable<ServiceResponse<String>> startWebSiteNetworkTraceWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        final Integer durationInSeconds = null;
        final Integer maxFrameLength = null;
        final String sasUrl = null;
        return service.startWebSiteNetworkTrace(resourceGroupName, name, this.client.subscriptionId(), durationInSeconds, maxFrameLength, sasUrl, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<String>>>() {
                @Override
                public Observable<ServiceResponse<String>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<String> clientResponse = startWebSiteNetworkTraceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Start capturing network packets for the site.
     * Start capturing network packets for the site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param durationInSeconds The duration to keep capturing in seconds.
     * @param maxFrameLength The maximum frame length in bytes (Optional).
     * @param sasUrl The Blob URL to store capture file.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the String object if successful.
     */
    public String startWebSiteNetworkTrace(String resourceGroupName, String name, Integer durationInSeconds, Integer maxFrameLength, String sasUrl) {
        return startWebSiteNetworkTraceWithServiceResponseAsync(resourceGroupName, name, durationInSeconds, maxFrameLength, sasUrl).toBlocking().single().body();
    }

    /**
     * Start capturing network packets for the site.
     * Start capturing network packets for the site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param durationInSeconds The duration to keep capturing in seconds.
     * @param maxFrameLength The maximum frame length in bytes (Optional).
     * @param sasUrl The Blob URL to store capture file.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<String> startWebSiteNetworkTraceAsync(String resourceGroupName, String name, Integer durationInSeconds, Integer maxFrameLength, String sasUrl, final ServiceCallback<String> serviceCallback) {
        return ServiceFuture.fromResponse(startWebSiteNetworkTraceWithServiceResponseAsync(resourceGroupName, name, durationInSeconds, maxFrameLength, sasUrl), serviceCallback);
    }

    /**
     * Start capturing network packets for the site.
     * Start capturing network packets for the site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param durationInSeconds The duration to keep capturing in seconds.
     * @param maxFrameLength The maximum frame length in bytes (Optional).
     * @param sasUrl The Blob URL to store capture file.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the String object
     */
    public Observable<String> startWebSiteNetworkTraceAsync(String resourceGroupName, String name, Integer durationInSeconds, Integer maxFrameLength, String sasUrl) {
        return startWebSiteNetworkTraceWithServiceResponseAsync(resourceGroupName, name, durationInSeconds, maxFrameLength, sasUrl).map(new Func1<ServiceResponse<String>, String>() {
            @Override
            public String call(ServiceResponse<String> response) {
                return response.body();
            }
        });
    }

    /**
     * Start capturing network packets for the site.
     * Start capturing network packets for the site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param durationInSeconds The duration to keep capturing in seconds.
     * @param maxFrameLength The maximum frame length in bytes (Optional).
     * @param sasUrl The Blob URL to store capture file.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the String object
     */
    public Observable<ServiceResponse<String>> startWebSiteNetworkTraceWithServiceResponseAsync(String resourceGroupName, String name, Integer durationInSeconds, Integer maxFrameLength, String sasUrl) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.startWebSiteNetworkTrace(resourceGroupName, name, this.client.subscriptionId(), durationInSeconds, maxFrameLength, sasUrl, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<String>>>() {
                @Override
                public Observable<ServiceResponse<String>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<String> clientResponse = startWebSiteNetworkTraceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<String> startWebSiteNetworkTraceDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<String, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<String>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Stop ongoing capturing network packets for the site.
     * Stop ongoing capturing network packets for the site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the String object if successful.
     */
    public String stopWebSiteNetworkTrace(String resourceGroupName, String name) {
        return stopWebSiteNetworkTraceWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Stop ongoing capturing network packets for the site.
     * Stop ongoing capturing network packets for the site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<String> stopWebSiteNetworkTraceAsync(String resourceGroupName, String name, final ServiceCallback<String> serviceCallback) {
        return ServiceFuture.fromResponse(stopWebSiteNetworkTraceWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Stop ongoing capturing network packets for the site.
     * Stop ongoing capturing network packets for the site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the String object
     */
    public Observable<String> stopWebSiteNetworkTraceAsync(String resourceGroupName, String name) {
        return stopWebSiteNetworkTraceWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<String>, String>() {
            @Override
            public String call(ServiceResponse<String> response) {
                return response.body();
            }
        });
    }

    /**
     * Stop ongoing capturing network packets for the site.
     * Stop ongoing capturing network packets for the site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the String object
     */
    public Observable<ServiceResponse<String>> stopWebSiteNetworkTraceWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.stopWebSiteNetworkTrace(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<String>>>() {
                @Override
                public Observable<ServiceResponse<String>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<String> clientResponse = stopWebSiteNetworkTraceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<String> stopWebSiteNetworkTraceDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<String, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<String>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Generates a new publishing password for an app (or deployment slot, if specified).
     * Generates a new publishing password for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void generateNewSitePublishingPassword(String resourceGroupName, String name) {
        generateNewSitePublishingPasswordWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Generates a new publishing password for an app (or deployment slot, if specified).
     * Generates a new publishing password for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> generateNewSitePublishingPasswordAsync(String resourceGroupName, String name, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(generateNewSitePublishingPasswordWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Generates a new publishing password for an app (or deployment slot, if specified).
     * Generates a new publishing password for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> generateNewSitePublishingPasswordAsync(String resourceGroupName, String name) {
        return generateNewSitePublishingPasswordWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Generates a new publishing password for an app (or deployment slot, if specified).
     * Generates a new publishing password for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> generateNewSitePublishingPasswordWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.generateNewSitePublishingPassword(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = generateNewSitePublishingPasswordDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> generateNewSitePublishingPasswordDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;PerfMonResponseInner&gt; object if successful.
     */
    public PagedList<PerfMonResponseInner> listPerfMonCounters(final String resourceGroupName, final String name) {
        ServiceResponse<Page<PerfMonResponseInner>> response = listPerfMonCountersSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<PerfMonResponseInner>(response.body()) {
            @Override
            public Page<PerfMonResponseInner> nextPage(String nextPageLink) {
                return listPerfMonCountersNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<PerfMonResponseInner>> listPerfMonCountersAsync(final String resourceGroupName, final String name, final ListOperationCallback<PerfMonResponseInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listPerfMonCountersSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(String nextPageLink) {
                    return listPerfMonCountersNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;PerfMonResponseInner&gt; object
     */
    public Observable<Page<PerfMonResponseInner>> listPerfMonCountersAsync(final String resourceGroupName, final String name) {
        return listPerfMonCountersWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<PerfMonResponseInner>>, Page<PerfMonResponseInner>>() {
                @Override
                public Page<PerfMonResponseInner> call(ServiceResponse<Page<PerfMonResponseInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;PerfMonResponseInner&gt; object
     */
    public Observable<ServiceResponse<Page<PerfMonResponseInner>>> listPerfMonCountersWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return listPerfMonCountersSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<PerfMonResponseInner>>, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(ServiceResponse<Page<PerfMonResponseInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listPerfMonCountersNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;PerfMonResponseInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<PerfMonResponseInner>>> listPerfMonCountersSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        final String filter = null;
        return service.listPerfMonCounters(resourceGroupName, name, this.client.subscriptionId(), filter, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<PerfMonResponseInner>> result = listPerfMonCountersDelegate(response);
                        return Observable.just(new ServiceResponse<Page<PerfMonResponseInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;PerfMonResponseInner&gt; object if successful.
     */
    public PagedList<PerfMonResponseInner> listPerfMonCounters(final String resourceGroupName, final String name, final String filter) {
        ServiceResponse<Page<PerfMonResponseInner>> response = listPerfMonCountersSinglePageAsync(resourceGroupName, name, filter).toBlocking().single();
        return new PagedList<PerfMonResponseInner>(response.body()) {
            @Override
            public Page<PerfMonResponseInner> nextPage(String nextPageLink) {
                return listPerfMonCountersNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<PerfMonResponseInner>> listPerfMonCountersAsync(final String resourceGroupName, final String name, final String filter, final ListOperationCallback<PerfMonResponseInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listPerfMonCountersSinglePageAsync(resourceGroupName, name, filter),
            new Func1<String, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(String nextPageLink) {
                    return listPerfMonCountersNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;PerfMonResponseInner&gt; object
     */
    public Observable<Page<PerfMonResponseInner>> listPerfMonCountersAsync(final String resourceGroupName, final String name, final String filter) {
        return listPerfMonCountersWithServiceResponseAsync(resourceGroupName, name, filter)
            .map(new Func1<ServiceResponse<Page<PerfMonResponseInner>>, Page<PerfMonResponseInner>>() {
                @Override
                public Page<PerfMonResponseInner> call(ServiceResponse<Page<PerfMonResponseInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;PerfMonResponseInner&gt; object
     */
    public Observable<ServiceResponse<Page<PerfMonResponseInner>>> listPerfMonCountersWithServiceResponseAsync(final String resourceGroupName, final String name, final String filter) {
        return listPerfMonCountersSinglePageAsync(resourceGroupName, name, filter)
            .concatMap(new Func1<ServiceResponse<Page<PerfMonResponseInner>>, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(ServiceResponse<Page<PerfMonResponseInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listPerfMonCountersNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
    ServiceResponse<PageImpl<PerfMonResponseInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<PerfMonResponseInner>> * @param name Name of web app
    ServiceResponse<PageImpl<PerfMonResponseInner>> * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;PerfMonResponseInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<PerfMonResponseInner>>> listPerfMonCountersSinglePageAsync(final String resourceGroupName, final String name, final String filter) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listPerfMonCounters(resourceGroupName, name, this.client.subscriptionId(), filter, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<PerfMonResponseInner>> result = listPerfMonCountersDelegate(response);
                        return Observable.just(new ServiceResponse<Page<PerfMonResponseInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<PerfMonResponseInner>> listPerfMonCountersDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<PerfMonResponseInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<PerfMonResponseInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets web app's event logs.
     * Gets web app's event logs.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SitePhpErrorLogFlagInner object if successful.
     */
    public SitePhpErrorLogFlagInner getSitePhpErrorLogFlag(String resourceGroupName, String name) {
        return getSitePhpErrorLogFlagWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Gets web app's event logs.
     * Gets web app's event logs.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SitePhpErrorLogFlagInner> getSitePhpErrorLogFlagAsync(String resourceGroupName, String name, final ServiceCallback<SitePhpErrorLogFlagInner> serviceCallback) {
        return ServiceFuture.fromResponse(getSitePhpErrorLogFlagWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets web app's event logs.
     * Gets web app's event logs.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SitePhpErrorLogFlagInner object
     */
    public Observable<SitePhpErrorLogFlagInner> getSitePhpErrorLogFlagAsync(String resourceGroupName, String name) {
        return getSitePhpErrorLogFlagWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<SitePhpErrorLogFlagInner>, SitePhpErrorLogFlagInner>() {
            @Override
            public SitePhpErrorLogFlagInner call(ServiceResponse<SitePhpErrorLogFlagInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets web app's event logs.
     * Gets web app's event logs.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SitePhpErrorLogFlagInner object
     */
    public Observable<ServiceResponse<SitePhpErrorLogFlagInner>> getSitePhpErrorLogFlagWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getSitePhpErrorLogFlag(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SitePhpErrorLogFlagInner>>>() {
                @Override
                public Observable<ServiceResponse<SitePhpErrorLogFlagInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SitePhpErrorLogFlagInner> clientResponse = getSitePhpErrorLogFlagDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SitePhpErrorLogFlagInner> getSitePhpErrorLogFlagDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SitePhpErrorLogFlagInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SitePhpErrorLogFlagInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the premier add-ons of an app.
     * Gets the premier add-ons of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PremierAddOnInner object if successful.
     */
    public PremierAddOnInner listPremierAddOns(String resourceGroupName, String name) {
        return listPremierAddOnsWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Gets the premier add-ons of an app.
     * Gets the premier add-ons of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PremierAddOnInner> listPremierAddOnsAsync(String resourceGroupName, String name, final ServiceCallback<PremierAddOnInner> serviceCallback) {
        return ServiceFuture.fromResponse(listPremierAddOnsWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the premier add-ons of an app.
     * Gets the premier add-ons of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PremierAddOnInner object
     */
    public Observable<PremierAddOnInner> listPremierAddOnsAsync(String resourceGroupName, String name) {
        return listPremierAddOnsWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<PremierAddOnInner>, PremierAddOnInner>() {
            @Override
            public PremierAddOnInner call(ServiceResponse<PremierAddOnInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the premier add-ons of an app.
     * Gets the premier add-ons of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PremierAddOnInner object
     */
    public Observable<ServiceResponse<PremierAddOnInner>> listPremierAddOnsWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listPremierAddOns(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PremierAddOnInner>>>() {
                @Override
                public Observable<ServiceResponse<PremierAddOnInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PremierAddOnInner> clientResponse = listPremierAddOnsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PremierAddOnInner> listPremierAddOnsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PremierAddOnInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PremierAddOnInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets a named add-on of an app.
     * Gets a named add-on of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PremierAddOnInner object if successful.
     */
    public PremierAddOnInner getPremierAddOn(String resourceGroupName, String name, String premierAddOnName) {
        return getPremierAddOnWithServiceResponseAsync(resourceGroupName, name, premierAddOnName).toBlocking().single().body();
    }

    /**
     * Gets a named add-on of an app.
     * Gets a named add-on of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PremierAddOnInner> getPremierAddOnAsync(String resourceGroupName, String name, String premierAddOnName, final ServiceCallback<PremierAddOnInner> serviceCallback) {
        return ServiceFuture.fromResponse(getPremierAddOnWithServiceResponseAsync(resourceGroupName, name, premierAddOnName), serviceCallback);
    }

    /**
     * Gets a named add-on of an app.
     * Gets a named add-on of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PremierAddOnInner object
     */
    public Observable<PremierAddOnInner> getPremierAddOnAsync(String resourceGroupName, String name, String premierAddOnName) {
        return getPremierAddOnWithServiceResponseAsync(resourceGroupName, name, premierAddOnName).map(new Func1<ServiceResponse<PremierAddOnInner>, PremierAddOnInner>() {
            @Override
            public PremierAddOnInner call(ServiceResponse<PremierAddOnInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a named add-on of an app.
     * Gets a named add-on of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PremierAddOnInner object
     */
    public Observable<ServiceResponse<PremierAddOnInner>> getPremierAddOnWithServiceResponseAsync(String resourceGroupName, String name, String premierAddOnName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (premierAddOnName == null) {
            throw new IllegalArgumentException("Parameter premierAddOnName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getPremierAddOn(resourceGroupName, name, premierAddOnName, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PremierAddOnInner>>>() {
                @Override
                public Observable<ServiceResponse<PremierAddOnInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PremierAddOnInner> clientResponse = getPremierAddOnDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PremierAddOnInner> getPremierAddOnDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PremierAddOnInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PremierAddOnInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates a named add-on of an app.
     * Updates a named add-on of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param premierAddOn A JSON representation of the edited premier add-on.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PremierAddOnInner object if successful.
     */
    public PremierAddOnInner addPremierAddOn(String resourceGroupName, String name, String premierAddOnName, PremierAddOnInner premierAddOn) {
        return addPremierAddOnWithServiceResponseAsync(resourceGroupName, name, premierAddOnName, premierAddOn).toBlocking().single().body();
    }

    /**
     * Updates a named add-on of an app.
     * Updates a named add-on of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param premierAddOn A JSON representation of the edited premier add-on.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PremierAddOnInner> addPremierAddOnAsync(String resourceGroupName, String name, String premierAddOnName, PremierAddOnInner premierAddOn, final ServiceCallback<PremierAddOnInner> serviceCallback) {
        return ServiceFuture.fromResponse(addPremierAddOnWithServiceResponseAsync(resourceGroupName, name, premierAddOnName, premierAddOn), serviceCallback);
    }

    /**
     * Updates a named add-on of an app.
     * Updates a named add-on of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param premierAddOn A JSON representation of the edited premier add-on.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PremierAddOnInner object
     */
    public Observable<PremierAddOnInner> addPremierAddOnAsync(String resourceGroupName, String name, String premierAddOnName, PremierAddOnInner premierAddOn) {
        return addPremierAddOnWithServiceResponseAsync(resourceGroupName, name, premierAddOnName, premierAddOn).map(new Func1<ServiceResponse<PremierAddOnInner>, PremierAddOnInner>() {
            @Override
            public PremierAddOnInner call(ServiceResponse<PremierAddOnInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates a named add-on of an app.
     * Updates a named add-on of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param premierAddOn A JSON representation of the edited premier add-on.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PremierAddOnInner object
     */
    public Observable<ServiceResponse<PremierAddOnInner>> addPremierAddOnWithServiceResponseAsync(String resourceGroupName, String name, String premierAddOnName, PremierAddOnInner premierAddOn) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (premierAddOnName == null) {
            throw new IllegalArgumentException("Parameter premierAddOnName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (premierAddOn == null) {
            throw new IllegalArgumentException("Parameter premierAddOn is required and cannot be null.");
        }
        Validator.validate(premierAddOn);
        final String apiVersion = "2016-08-01";
        return service.addPremierAddOn(resourceGroupName, name, premierAddOnName, this.client.subscriptionId(), premierAddOn, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PremierAddOnInner>>>() {
                @Override
                public Observable<ServiceResponse<PremierAddOnInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PremierAddOnInner> clientResponse = addPremierAddOnDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PremierAddOnInner> addPremierAddOnDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PremierAddOnInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PremierAddOnInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Delete a premier add-on from an app.
     * Delete a premier add-on from an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deletePremierAddOn(String resourceGroupName, String name, String premierAddOnName) {
        deletePremierAddOnWithServiceResponseAsync(resourceGroupName, name, premierAddOnName).toBlocking().single().body();
    }

    /**
     * Delete a premier add-on from an app.
     * Delete a premier add-on from an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deletePremierAddOnAsync(String resourceGroupName, String name, String premierAddOnName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deletePremierAddOnWithServiceResponseAsync(resourceGroupName, name, premierAddOnName), serviceCallback);
    }

    /**
     * Delete a premier add-on from an app.
     * Delete a premier add-on from an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deletePremierAddOnAsync(String resourceGroupName, String name, String premierAddOnName) {
        return deletePremierAddOnWithServiceResponseAsync(resourceGroupName, name, premierAddOnName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete a premier add-on from an app.
     * Delete a premier add-on from an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deletePremierAddOnWithServiceResponseAsync(String resourceGroupName, String name, String premierAddOnName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (premierAddOnName == null) {
            throw new IllegalArgumentException("Parameter premierAddOnName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.deletePremierAddOn(resourceGroupName, name, premierAddOnName, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deletePremierAddOnDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deletePremierAddOnDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the publishing profile for an app (or deployment slot, if specified).
     * Gets the publishing profile for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the InputStream object if successful.
     */
    public InputStream listPublishingProfileXmlWithSecrets(String resourceGroupName, String name) {
        return listPublishingProfileXmlWithSecretsWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Gets the publishing profile for an app (or deployment slot, if specified).
     * Gets the publishing profile for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<InputStream> listPublishingProfileXmlWithSecretsAsync(String resourceGroupName, String name, final ServiceCallback<InputStream> serviceCallback) {
        return ServiceFuture.fromResponse(listPublishingProfileXmlWithSecretsWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the publishing profile for an app (or deployment slot, if specified).
     * Gets the publishing profile for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the InputStream object
     */
    public Observable<InputStream> listPublishingProfileXmlWithSecretsAsync(String resourceGroupName, String name) {
        return listPublishingProfileXmlWithSecretsWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<InputStream>, InputStream>() {
            @Override
            public InputStream call(ServiceResponse<InputStream> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the publishing profile for an app (or deployment slot, if specified).
     * Gets the publishing profile for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the InputStream object
     */
    public Observable<ServiceResponse<InputStream>> listPublishingProfileXmlWithSecretsWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        final PublishingProfileFormat format = null;
        CsmPublishingProfileOptions publishingProfileOptions = new CsmPublishingProfileOptions();
        publishingProfileOptions.withFormat(null);
        return service.listPublishingProfileXmlWithSecrets(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), publishingProfileOptions, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<InputStream>>>() {
                @Override
                public Observable<ServiceResponse<InputStream>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<InputStream> clientResponse = listPublishingProfileXmlWithSecretsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the publishing profile for an app (or deployment slot, if specified).
     * Gets the publishing profile for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param format Name of the format. Valid values are:
      FileZilla3
      WebDeploy -- default
      Ftp. Possible values include: 'FileZilla3', 'WebDeploy', 'Ftp'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the InputStream object if successful.
     */
    public InputStream listPublishingProfileXmlWithSecrets(String resourceGroupName, String name, PublishingProfileFormat format) {
        return listPublishingProfileXmlWithSecretsWithServiceResponseAsync(resourceGroupName, name, format).toBlocking().single().body();
    }

    /**
     * Gets the publishing profile for an app (or deployment slot, if specified).
     * Gets the publishing profile for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param format Name of the format. Valid values are:
      FileZilla3
      WebDeploy -- default
      Ftp. Possible values include: 'FileZilla3', 'WebDeploy', 'Ftp'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<InputStream> listPublishingProfileXmlWithSecretsAsync(String resourceGroupName, String name, PublishingProfileFormat format, final ServiceCallback<InputStream> serviceCallback) {
        return ServiceFuture.fromResponse(listPublishingProfileXmlWithSecretsWithServiceResponseAsync(resourceGroupName, name, format), serviceCallback);
    }

    /**
     * Gets the publishing profile for an app (or deployment slot, if specified).
     * Gets the publishing profile for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param format Name of the format. Valid values are:
      FileZilla3
      WebDeploy -- default
      Ftp. Possible values include: 'FileZilla3', 'WebDeploy', 'Ftp'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the InputStream object
     */
    public Observable<InputStream> listPublishingProfileXmlWithSecretsAsync(String resourceGroupName, String name, PublishingProfileFormat format) {
        return listPublishingProfileXmlWithSecretsWithServiceResponseAsync(resourceGroupName, name, format).map(new Func1<ServiceResponse<InputStream>, InputStream>() {
            @Override
            public InputStream call(ServiceResponse<InputStream> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the publishing profile for an app (or deployment slot, if specified).
     * Gets the publishing profile for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param format Name of the format. Valid values are:
      FileZilla3
      WebDeploy -- default
      Ftp. Possible values include: 'FileZilla3', 'WebDeploy', 'Ftp'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the InputStream object
     */
    public Observable<ServiceResponse<InputStream>> listPublishingProfileXmlWithSecretsWithServiceResponseAsync(String resourceGroupName, String name, PublishingProfileFormat format) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        CsmPublishingProfileOptions publishingProfileOptions = new CsmPublishingProfileOptions();
        publishingProfileOptions.withFormat(format);
        return service.listPublishingProfileXmlWithSecrets(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), publishingProfileOptions, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<InputStream>>>() {
                @Override
                public Observable<ServiceResponse<InputStream>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<InputStream> clientResponse = listPublishingProfileXmlWithSecretsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<InputStream> listPublishingProfileXmlWithSecretsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<InputStream, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<InputStream>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Recovers a deleted web app.
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RecoverResponseInner object if successful.
     */
    public RecoverResponseInner recover(String resourceGroupName, String name, CsmSiteRecoveryEntityInner recoveryEntity) {
        return recoverWithServiceResponseAsync(resourceGroupName, name, recoveryEntity).toBlocking().last().body();
    }

    /**
     * Recovers a deleted web app.
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RecoverResponseInner> recoverAsync(String resourceGroupName, String name, CsmSiteRecoveryEntityInner recoveryEntity, final ServiceCallback<RecoverResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(recoverWithServiceResponseAsync(resourceGroupName, name, recoveryEntity), serviceCallback);
    }

    /**
     * Recovers a deleted web app.
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<RecoverResponseInner> recoverAsync(String resourceGroupName, String name, CsmSiteRecoveryEntityInner recoveryEntity) {
        return recoverWithServiceResponseAsync(resourceGroupName, name, recoveryEntity).map(new Func1<ServiceResponse<RecoverResponseInner>, RecoverResponseInner>() {
            @Override
            public RecoverResponseInner call(ServiceResponse<RecoverResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Recovers a deleted web app.
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<RecoverResponseInner>> recoverWithServiceResponseAsync(String resourceGroupName, String name, CsmSiteRecoveryEntityInner recoveryEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (recoveryEntity == null) {
            throw new IllegalArgumentException("Parameter recoveryEntity is required and cannot be null.");
        }
        Validator.validate(recoveryEntity);
        final String apiVersion = "2016-08-01";
        Observable<Response<ResponseBody>> observable = service.recover(resourceGroupName, name, this.client.subscriptionId(), recoveryEntity, apiVersion, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<RecoverResponseInner>() { }.getType());
    }

    /**
     * Recovers a deleted web app.
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RecoverResponseInner object if successful.
     */
    public RecoverResponseInner beginRecover(String resourceGroupName, String name, CsmSiteRecoveryEntityInner recoveryEntity) {
        return beginRecoverWithServiceResponseAsync(resourceGroupName, name, recoveryEntity).toBlocking().single().body();
    }

    /**
     * Recovers a deleted web app.
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RecoverResponseInner> beginRecoverAsync(String resourceGroupName, String name, CsmSiteRecoveryEntityInner recoveryEntity, final ServiceCallback<RecoverResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginRecoverWithServiceResponseAsync(resourceGroupName, name, recoveryEntity), serviceCallback);
    }

    /**
     * Recovers a deleted web app.
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RecoverResponseInner object
     */
    public Observable<RecoverResponseInner> beginRecoverAsync(String resourceGroupName, String name, CsmSiteRecoveryEntityInner recoveryEntity) {
        return beginRecoverWithServiceResponseAsync(resourceGroupName, name, recoveryEntity).map(new Func1<ServiceResponse<RecoverResponseInner>, RecoverResponseInner>() {
            @Override
            public RecoverResponseInner call(ServiceResponse<RecoverResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Recovers a deleted web app.
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RecoverResponseInner object
     */
    public Observable<ServiceResponse<RecoverResponseInner>> beginRecoverWithServiceResponseAsync(String resourceGroupName, String name, CsmSiteRecoveryEntityInner recoveryEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (recoveryEntity == null) {
            throw new IllegalArgumentException("Parameter recoveryEntity is required and cannot be null.");
        }
        Validator.validate(recoveryEntity);
        final String apiVersion = "2016-08-01";
        return service.beginRecover(resourceGroupName, name, this.client.subscriptionId(), recoveryEntity, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RecoverResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<RecoverResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RecoverResponseInner> clientResponse = beginRecoverDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RecoverResponseInner> beginRecoverDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<RecoverResponseInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<RecoverResponseInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Resets the configuration settings of the current slot if they were previously modified by calling the API with POST.
     * Resets the configuration settings of the current slot if they were previously modified by calling the API with POST.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void resetProductionSlotConfig(String resourceGroupName, String name) {
        resetProductionSlotConfigWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Resets the configuration settings of the current slot if they were previously modified by calling the API with POST.
     * Resets the configuration settings of the current slot if they were previously modified by calling the API with POST.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> resetProductionSlotConfigAsync(String resourceGroupName, String name, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(resetProductionSlotConfigWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Resets the configuration settings of the current slot if they were previously modified by calling the API with POST.
     * Resets the configuration settings of the current slot if they were previously modified by calling the API with POST.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> resetProductionSlotConfigAsync(String resourceGroupName, String name) {
        return resetProductionSlotConfigWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Resets the configuration settings of the current slot if they were previously modified by calling the API with POST.
     * Resets the configuration settings of the current slot if they were previously modified by calling the API with POST.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> resetProductionSlotConfigWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.resetProductionSlotConfig(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = resetProductionSlotConfigDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> resetProductionSlotConfigDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Restarts an app (or deployment slot, if specified).
     * Restarts an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void restart(String resourceGroupName, String name) {
        restartWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Restarts an app (or deployment slot, if specified).
     * Restarts an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> restartAsync(String resourceGroupName, String name, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(restartWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Restarts an app (or deployment slot, if specified).
     * Restarts an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> restartAsync(String resourceGroupName, String name) {
        return restartWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Restarts an app (or deployment slot, if specified).
     * Restarts an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> restartWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        final Boolean softRestart = null;
        final Boolean synchronous = null;
        return service.restart(resourceGroupName, name, this.client.subscriptionId(), softRestart, synchronous, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = restartDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Restarts an app (or deployment slot, if specified).
     * Restarts an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param softRestart Specify true to apply the configuration settings and restarts the app only if necessary. By default, the API always restarts and reprovisions the app.
     * @param synchronous Specify true to block until the app is restarted. By default, it is set to false, and the API responds immediately (asynchronous).
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void restart(String resourceGroupName, String name, Boolean softRestart, Boolean synchronous) {
        restartWithServiceResponseAsync(resourceGroupName, name, softRestart, synchronous).toBlocking().single().body();
    }

    /**
     * Restarts an app (or deployment slot, if specified).
     * Restarts an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param softRestart Specify true to apply the configuration settings and restarts the app only if necessary. By default, the API always restarts and reprovisions the app.
     * @param synchronous Specify true to block until the app is restarted. By default, it is set to false, and the API responds immediately (asynchronous).
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> restartAsync(String resourceGroupName, String name, Boolean softRestart, Boolean synchronous, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(restartWithServiceResponseAsync(resourceGroupName, name, softRestart, synchronous), serviceCallback);
    }

    /**
     * Restarts an app (or deployment slot, if specified).
     * Restarts an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param softRestart Specify true to apply the configuration settings and restarts the app only if necessary. By default, the API always restarts and reprovisions the app.
     * @param synchronous Specify true to block until the app is restarted. By default, it is set to false, and the API responds immediately (asynchronous).
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> restartAsync(String resourceGroupName, String name, Boolean softRestart, Boolean synchronous) {
        return restartWithServiceResponseAsync(resourceGroupName, name, softRestart, synchronous).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Restarts an app (or deployment slot, if specified).
     * Restarts an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param softRestart Specify true to apply the configuration settings and restarts the app only if necessary. By default, the API always restarts and reprovisions the app.
     * @param synchronous Specify true to block until the app is restarted. By default, it is set to false, and the API responds immediately (asynchronous).
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> restartWithServiceResponseAsync(String resourceGroupName, String name, Boolean softRestart, Boolean synchronous) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.restart(resourceGroupName, name, this.client.subscriptionId(), softRestart, synchronous, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = restartDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> restartDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets an app's deployment slots.
     * Gets an app's deployment slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SiteInner&gt; object if successful.
     */
    public PagedList<SiteInner> listSlots(final String resourceGroupName, final String name) {
        ServiceResponse<Page<SiteInner>> response = listSlotsSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<SiteInner>(response.body()) {
            @Override
            public Page<SiteInner> nextPage(String nextPageLink) {
                return listSlotsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets an app's deployment slots.
     * Gets an app's deployment slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SiteInner>> listSlotsAsync(final String resourceGroupName, final String name, final ListOperationCallback<SiteInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listSlotsSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(String nextPageLink) {
                    return listSlotsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets an app's deployment slots.
     * Gets an app's deployment slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<Page<SiteInner>> listSlotsAsync(final String resourceGroupName, final String name) {
        return listSlotsWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<SiteInner>>, Page<SiteInner>>() {
                @Override
                public Page<SiteInner> call(ServiceResponse<Page<SiteInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets an app's deployment slots.
     * Gets an app's deployment slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInner>>> listSlotsWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return listSlotsSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<SiteInner>>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(ServiceResponse<Page<SiteInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listSlotsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets an app's deployment slots.
     * Gets an app's deployment slots.
     *
    ServiceResponse<PageImpl<SiteInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<SiteInner>> * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInner>>> listSlotsSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listSlots(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInner>> result = listSlotsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteInner>> listSlotsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<SiteInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SiteInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the details of a web, mobile, or API app.
     * Gets the details of a web, mobile, or API app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. By default, this API returns the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteInner object if successful.
     */
    public SiteInner getSlot(String resourceGroupName, String name, String slot) {
        return getSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Gets the details of a web, mobile, or API app.
     * Gets the details of a web, mobile, or API app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. By default, this API returns the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteInner> getSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceFuture.fromResponse(getSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the details of a web, mobile, or API app.
     * Gets the details of a web, mobile, or API app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. By default, this API returns the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteInner object
     */
    public Observable<SiteInner> getSlotAsync(String resourceGroupName, String name, String slot) {
        return getSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<SiteInner>, SiteInner>() {
            @Override
            public SiteInner call(ServiceResponse<SiteInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the details of a web, mobile, or API app.
     * Gets the details of a web, mobile, or API app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. By default, this API returns the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteInner object
     */
    public Observable<ServiceResponse<SiteInner>> getSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteInner> clientResponse = getSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteInner> getSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param slot Name of the deployment slot to create or update. By default, this API attempts to create or modify the production slot.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteInner object if successful.
     */
    public SiteInner createOrUpdateSlot(String resourceGroupName, String name, String slot, SiteInner siteEnvelope) {
        return createOrUpdateSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope).toBlocking().last().body();
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param slot Name of the deployment slot to create or update. By default, this API attempts to create or modify the production slot.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteInner> createOrUpdateSlotAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope), serviceCallback);
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param slot Name of the deployment slot to create or update. By default, this API attempts to create or modify the production slot.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<SiteInner> createOrUpdateSlotAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope) {
        return createOrUpdateSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope).map(new Func1<ServiceResponse<SiteInner>, SiteInner>() {
            @Override
            public SiteInner call(ServiceResponse<SiteInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param slot Name of the deployment slot to create or update. By default, this API attempts to create or modify the production slot.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<SiteInner>> createOrUpdateSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteEnvelope == null) {
            throw new IllegalArgumentException("Parameter siteEnvelope is required and cannot be null.");
        }
        Validator.validate(siteEnvelope);
        final String apiVersion = "2016-08-01";
        final Boolean skipDnsRegistration = null;
        final Boolean skipCustomDomainVerification = null;
        final Boolean forceDnsRegistration = null;
        final String ttlInSeconds = null;
        Observable<Response<ResponseBody>> observable = service.createOrUpdateSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds, apiVersion, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultAsync(observable, new TypeToken<SiteInner>() { }.getType());
    }
    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param slot Name of the deployment slot to create or update. By default, this API attempts to create or modify the production slot.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
      only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteInner object if successful.
     */
    public SiteInner createOrUpdateSlot(String resourceGroupName, String name, String slot, SiteInner siteEnvelope, Boolean skipDnsRegistration, Boolean skipCustomDomainVerification, Boolean forceDnsRegistration, String ttlInSeconds) {
        return createOrUpdateSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds).toBlocking().last().body();
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param slot Name of the deployment slot to create or update. By default, this API attempts to create or modify the production slot.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
      only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteInner> createOrUpdateSlotAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope, Boolean skipDnsRegistration, Boolean skipCustomDomainVerification, Boolean forceDnsRegistration, String ttlInSeconds, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds), serviceCallback);
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param slot Name of the deployment slot to create or update. By default, this API attempts to create or modify the production slot.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
      only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<SiteInner> createOrUpdateSlotAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope, Boolean skipDnsRegistration, Boolean skipCustomDomainVerification, Boolean forceDnsRegistration, String ttlInSeconds) {
        return createOrUpdateSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds).map(new Func1<ServiceResponse<SiteInner>, SiteInner>() {
            @Override
            public SiteInner call(ServiceResponse<SiteInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param slot Name of the deployment slot to create or update. By default, this API attempts to create or modify the production slot.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
      only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<SiteInner>> createOrUpdateSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope, Boolean skipDnsRegistration, Boolean skipCustomDomainVerification, Boolean forceDnsRegistration, String ttlInSeconds) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteEnvelope == null) {
            throw new IllegalArgumentException("Parameter siteEnvelope is required and cannot be null.");
        }
        Validator.validate(siteEnvelope);
        final String apiVersion = "2016-08-01";
        Observable<Response<ResponseBody>> observable = service.createOrUpdateSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds, apiVersion, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultAsync(observable, new TypeToken<SiteInner>() { }.getType());
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param slot Name of the deployment slot to create or update. By default, this API attempts to create or modify the production slot.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteInner object if successful.
     */
    public SiteInner beginCreateOrUpdateSlot(String resourceGroupName, String name, String slot, SiteInner siteEnvelope) {
        return beginCreateOrUpdateSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope).toBlocking().single().body();
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param slot Name of the deployment slot to create or update. By default, this API attempts to create or modify the production slot.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteInner> beginCreateOrUpdateSlotAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginCreateOrUpdateSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope), serviceCallback);
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param slot Name of the deployment slot to create or update. By default, this API attempts to create or modify the production slot.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteInner object
     */
    public Observable<SiteInner> beginCreateOrUpdateSlotAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope) {
        return beginCreateOrUpdateSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope).map(new Func1<ServiceResponse<SiteInner>, SiteInner>() {
            @Override
            public SiteInner call(ServiceResponse<SiteInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param slot Name of the deployment slot to create or update. By default, this API attempts to create or modify the production slot.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteInner object
     */
    public Observable<ServiceResponse<SiteInner>> beginCreateOrUpdateSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteEnvelope == null) {
            throw new IllegalArgumentException("Parameter siteEnvelope is required and cannot be null.");
        }
        Validator.validate(siteEnvelope);
        final String apiVersion = "2016-08-01";
        final Boolean skipDnsRegistration = null;
        final Boolean skipCustomDomainVerification = null;
        final Boolean forceDnsRegistration = null;
        final String ttlInSeconds = null;
        return service.beginCreateOrUpdateSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteInner> clientResponse = beginCreateOrUpdateSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param slot Name of the deployment slot to create or update. By default, this API attempts to create or modify the production slot.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
      only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteInner object if successful.
     */
    public SiteInner beginCreateOrUpdateSlot(String resourceGroupName, String name, String slot, SiteInner siteEnvelope, Boolean skipDnsRegistration, Boolean skipCustomDomainVerification, Boolean forceDnsRegistration, String ttlInSeconds) {
        return beginCreateOrUpdateSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds).toBlocking().single().body();
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param slot Name of the deployment slot to create or update. By default, this API attempts to create or modify the production slot.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
      only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteInner> beginCreateOrUpdateSlotAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope, Boolean skipDnsRegistration, Boolean skipCustomDomainVerification, Boolean forceDnsRegistration, String ttlInSeconds, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginCreateOrUpdateSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds), serviceCallback);
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param slot Name of the deployment slot to create or update. By default, this API attempts to create or modify the production slot.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
      only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteInner object
     */
    public Observable<SiteInner> beginCreateOrUpdateSlotAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope, Boolean skipDnsRegistration, Boolean skipCustomDomainVerification, Boolean forceDnsRegistration, String ttlInSeconds) {
        return beginCreateOrUpdateSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds).map(new Func1<ServiceResponse<SiteInner>, SiteInner>() {
            @Override
            public SiteInner call(ServiceResponse<SiteInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     * Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
     * @param slot Name of the deployment slot to create or update. By default, this API attempts to create or modify the production slot.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
      only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteInner object
     */
    public Observable<ServiceResponse<SiteInner>> beginCreateOrUpdateSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope, Boolean skipDnsRegistration, Boolean skipCustomDomainVerification, Boolean forceDnsRegistration, String ttlInSeconds) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteEnvelope == null) {
            throw new IllegalArgumentException("Parameter siteEnvelope is required and cannot be null.");
        }
        Validator.validate(siteEnvelope);
        final String apiVersion = "2016-08-01";
        return service.beginCreateOrUpdateSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteInner> clientResponse = beginCreateOrUpdateSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteInner> beginCreateOrUpdateSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteInner>() { }.getType())
                .register(202, new TypeToken<SiteInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app to delete.
     * @param slot Name of the deployment slot to delete. By default, the API deletes the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteSlot(String resourceGroupName, String name, String slot) {
        deleteSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app to delete.
     * @param slot Name of the deployment slot to delete. By default, the API deletes the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app to delete.
     * @param slot Name of the deployment slot to delete. By default, the API deletes the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteSlotAsync(String resourceGroupName, String name, String slot) {
        return deleteSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app to delete.
     * @param slot Name of the deployment slot to delete. By default, the API deletes the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        final Boolean deleteMetrics = null;
        final Boolean deleteEmptyServerFarm = null;
        final Boolean skipDnsRegistration = null;
        return service.deleteSlot(resourceGroupName, name, slot, this.client.subscriptionId(), deleteMetrics, deleteEmptyServerFarm, skipDnsRegistration, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app to delete.
     * @param slot Name of the deployment slot to delete. By default, the API deletes the production slot.
     * @param deleteMetrics If true, web app metrics are also deleted
     * @param deleteEmptyServerFarm Specify true if the App Service plan will be empty after app deletion and you want to delete the empty App Service plan. By default, the empty App Service plan is not deleted.
     * @param skipDnsRegistration If true, DNS registration is skipped
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteSlot(String resourceGroupName, String name, String slot, Boolean deleteMetrics, Boolean deleteEmptyServerFarm, Boolean skipDnsRegistration) {
        deleteSlotWithServiceResponseAsync(resourceGroupName, name, slot, deleteMetrics, deleteEmptyServerFarm, skipDnsRegistration).toBlocking().single().body();
    }

    /**
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app to delete.
     * @param slot Name of the deployment slot to delete. By default, the API deletes the production slot.
     * @param deleteMetrics If true, web app metrics are also deleted
     * @param deleteEmptyServerFarm Specify true if the App Service plan will be empty after app deletion and you want to delete the empty App Service plan. By default, the empty App Service plan is not deleted.
     * @param skipDnsRegistration If true, DNS registration is skipped
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteSlotAsync(String resourceGroupName, String name, String slot, Boolean deleteMetrics, Boolean deleteEmptyServerFarm, Boolean skipDnsRegistration, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteSlotWithServiceResponseAsync(resourceGroupName, name, slot, deleteMetrics, deleteEmptyServerFarm, skipDnsRegistration), serviceCallback);
    }

    /**
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app to delete.
     * @param slot Name of the deployment slot to delete. By default, the API deletes the production slot.
     * @param deleteMetrics If true, web app metrics are also deleted
     * @param deleteEmptyServerFarm Specify true if the App Service plan will be empty after app deletion and you want to delete the empty App Service plan. By default, the empty App Service plan is not deleted.
     * @param skipDnsRegistration If true, DNS registration is skipped
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteSlotAsync(String resourceGroupName, String name, String slot, Boolean deleteMetrics, Boolean deleteEmptyServerFarm, Boolean skipDnsRegistration) {
        return deleteSlotWithServiceResponseAsync(resourceGroupName, name, slot, deleteMetrics, deleteEmptyServerFarm, skipDnsRegistration).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     * Deletes a web, mobile, or API app, or one of the deployment slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app to delete.
     * @param slot Name of the deployment slot to delete. By default, the API deletes the production slot.
     * @param deleteMetrics If true, web app metrics are also deleted
     * @param deleteEmptyServerFarm Specify true if the App Service plan will be empty after app deletion and you want to delete the empty App Service plan. By default, the empty App Service plan is not deleted.
     * @param skipDnsRegistration If true, DNS registration is skipped
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, Boolean deleteMetrics, Boolean deleteEmptyServerFarm, Boolean skipDnsRegistration) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.deleteSlot(resourceGroupName, name, slot, this.client.subscriptionId(), deleteMetrics, deleteEmptyServerFarm, skipDnsRegistration, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Analyze a custom hostname.
     * Analyze a custom hostname.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the CustomHostnameAnalysisResultInner object if successful.
     */
    public CustomHostnameAnalysisResultInner analyzeCustomHostnameSlot(String resourceGroupName, String name, String slot) {
        return analyzeCustomHostnameSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Analyze a custom hostname.
     * Analyze a custom hostname.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<CustomHostnameAnalysisResultInner> analyzeCustomHostnameSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<CustomHostnameAnalysisResultInner> serviceCallback) {
        return ServiceFuture.fromResponse(analyzeCustomHostnameSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Analyze a custom hostname.
     * Analyze a custom hostname.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CustomHostnameAnalysisResultInner object
     */
    public Observable<CustomHostnameAnalysisResultInner> analyzeCustomHostnameSlotAsync(String resourceGroupName, String name, String slot) {
        return analyzeCustomHostnameSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<CustomHostnameAnalysisResultInner>, CustomHostnameAnalysisResultInner>() {
            @Override
            public CustomHostnameAnalysisResultInner call(ServiceResponse<CustomHostnameAnalysisResultInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Analyze a custom hostname.
     * Analyze a custom hostname.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CustomHostnameAnalysisResultInner object
     */
    public Observable<ServiceResponse<CustomHostnameAnalysisResultInner>> analyzeCustomHostnameSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        final String hostName = null;
        return service.analyzeCustomHostnameSlot(resourceGroupName, name, slot, this.client.subscriptionId(), hostName, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<CustomHostnameAnalysisResultInner>>>() {
                @Override
                public Observable<ServiceResponse<CustomHostnameAnalysisResultInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<CustomHostnameAnalysisResultInner> clientResponse = analyzeCustomHostnameSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Analyze a custom hostname.
     * Analyze a custom hostname.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param hostName Custom hostname
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the CustomHostnameAnalysisResultInner object if successful.
     */
    public CustomHostnameAnalysisResultInner analyzeCustomHostnameSlot(String resourceGroupName, String name, String slot, String hostName) {
        return analyzeCustomHostnameSlotWithServiceResponseAsync(resourceGroupName, name, slot, hostName).toBlocking().single().body();
    }

    /**
     * Analyze a custom hostname.
     * Analyze a custom hostname.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param hostName Custom hostname
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<CustomHostnameAnalysisResultInner> analyzeCustomHostnameSlotAsync(String resourceGroupName, String name, String slot, String hostName, final ServiceCallback<CustomHostnameAnalysisResultInner> serviceCallback) {
        return ServiceFuture.fromResponse(analyzeCustomHostnameSlotWithServiceResponseAsync(resourceGroupName, name, slot, hostName), serviceCallback);
    }

    /**
     * Analyze a custom hostname.
     * Analyze a custom hostname.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param hostName Custom hostname
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CustomHostnameAnalysisResultInner object
     */
    public Observable<CustomHostnameAnalysisResultInner> analyzeCustomHostnameSlotAsync(String resourceGroupName, String name, String slot, String hostName) {
        return analyzeCustomHostnameSlotWithServiceResponseAsync(resourceGroupName, name, slot, hostName).map(new Func1<ServiceResponse<CustomHostnameAnalysisResultInner>, CustomHostnameAnalysisResultInner>() {
            @Override
            public CustomHostnameAnalysisResultInner call(ServiceResponse<CustomHostnameAnalysisResultInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Analyze a custom hostname.
     * Analyze a custom hostname.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param hostName Custom hostname
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CustomHostnameAnalysisResultInner object
     */
    public Observable<ServiceResponse<CustomHostnameAnalysisResultInner>> analyzeCustomHostnameSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, String hostName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.analyzeCustomHostnameSlot(resourceGroupName, name, slot, this.client.subscriptionId(), hostName, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<CustomHostnameAnalysisResultInner>>>() {
                @Override
                public Observable<ServiceResponse<CustomHostnameAnalysisResultInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<CustomHostnameAnalysisResultInner> clientResponse = analyzeCustomHostnameSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<CustomHostnameAnalysisResultInner> analyzeCustomHostnameSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<CustomHostnameAnalysisResultInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<CustomHostnameAnalysisResultInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Applies the configuration settings from the target slot onto the current slot.
     * Applies the configuration settings from the target slot onto the current slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the source slot. If a slot is not specified, the production slot is used as the source slot.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void applySlotConfigurationSlot(String resourceGroupName, String name, String slot, CsmSlotEntityInner slotSwapEntity) {
        applySlotConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot, slotSwapEntity).toBlocking().single().body();
    }

    /**
     * Applies the configuration settings from the target slot onto the current slot.
     * Applies the configuration settings from the target slot onto the current slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the source slot. If a slot is not specified, the production slot is used as the source slot.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> applySlotConfigurationSlotAsync(String resourceGroupName, String name, String slot, CsmSlotEntityInner slotSwapEntity, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(applySlotConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot, slotSwapEntity), serviceCallback);
    }

    /**
     * Applies the configuration settings from the target slot onto the current slot.
     * Applies the configuration settings from the target slot onto the current slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the source slot. If a slot is not specified, the production slot is used as the source slot.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> applySlotConfigurationSlotAsync(String resourceGroupName, String name, String slot, CsmSlotEntityInner slotSwapEntity) {
        return applySlotConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot, slotSwapEntity).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Applies the configuration settings from the target slot onto the current slot.
     * Applies the configuration settings from the target slot onto the current slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the source slot. If a slot is not specified, the production slot is used as the source slot.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> applySlotConfigurationSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, CsmSlotEntityInner slotSwapEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (slotSwapEntity == null) {
            throw new IllegalArgumentException("Parameter slotSwapEntity is required and cannot be null.");
        }
        Validator.validate(slotSwapEntity);
        final String apiVersion = "2016-08-01";
        return service.applySlotConfigurationSlot(resourceGroupName, name, slot, this.client.subscriptionId(), slotSwapEntity, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = applySlotConfigurationSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> applySlotConfigurationSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a backup of an app.
     * Creates a backup of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will create a backup for the production slot.
     * @param request Backup configuration. You can use the JSON response from the POST action as input here.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BackupItemInner object if successful.
     */
    public BackupItemInner backupSlot(String resourceGroupName, String name, String slot, BackupRequestInner request) {
        return backupSlotWithServiceResponseAsync(resourceGroupName, name, slot, request).toBlocking().single().body();
    }

    /**
     * Creates a backup of an app.
     * Creates a backup of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will create a backup for the production slot.
     * @param request Backup configuration. You can use the JSON response from the POST action as input here.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BackupItemInner> backupSlotAsync(String resourceGroupName, String name, String slot, BackupRequestInner request, final ServiceCallback<BackupItemInner> serviceCallback) {
        return ServiceFuture.fromResponse(backupSlotWithServiceResponseAsync(resourceGroupName, name, slot, request), serviceCallback);
    }

    /**
     * Creates a backup of an app.
     * Creates a backup of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will create a backup for the production slot.
     * @param request Backup configuration. You can use the JSON response from the POST action as input here.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BackupItemInner object
     */
    public Observable<BackupItemInner> backupSlotAsync(String resourceGroupName, String name, String slot, BackupRequestInner request) {
        return backupSlotWithServiceResponseAsync(resourceGroupName, name, slot, request).map(new Func1<ServiceResponse<BackupItemInner>, BackupItemInner>() {
            @Override
            public BackupItemInner call(ServiceResponse<BackupItemInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a backup of an app.
     * Creates a backup of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will create a backup for the production slot.
     * @param request Backup configuration. You can use the JSON response from the POST action as input here.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BackupItemInner object
     */
    public Observable<ServiceResponse<BackupItemInner>> backupSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, BackupRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        final String apiVersion = "2016-08-01";
        return service.backupSlot(resourceGroupName, name, slot, this.client.subscriptionId(), request, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupItemInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupItemInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupItemInner> clientResponse = backupSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupItemInner> backupSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<BackupItemInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BackupItemInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets existing backups of an app.
     * Gets existing backups of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get backups of the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;BackupItemInner&gt; object if successful.
     */
    public PagedList<BackupItemInner> listBackupsSlot(final String resourceGroupName, final String name, final String slot) {
        ServiceResponse<Page<BackupItemInner>> response = listBackupsSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        return new PagedList<BackupItemInner>(response.body()) {
            @Override
            public Page<BackupItemInner> nextPage(String nextPageLink) {
                return listBackupsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets existing backups of an app.
     * Gets existing backups of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get backups of the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<BackupItemInner>> listBackupsSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<BackupItemInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listBackupsSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(String nextPageLink) {
                    return listBackupsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets existing backups of an app.
     * Gets existing backups of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get backups of the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;BackupItemInner&gt; object
     */
    public Observable<Page<BackupItemInner>> listBackupsSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return listBackupsSlotWithServiceResponseAsync(resourceGroupName, name, slot)
            .map(new Func1<ServiceResponse<Page<BackupItemInner>>, Page<BackupItemInner>>() {
                @Override
                public Page<BackupItemInner> call(ServiceResponse<Page<BackupItemInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets existing backups of an app.
     * Gets existing backups of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get backups of the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;BackupItemInner&gt; object
     */
    public Observable<ServiceResponse<Page<BackupItemInner>>> listBackupsSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot) {
        return listBackupsSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<BackupItemInner>>, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(ServiceResponse<Page<BackupItemInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listBackupsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets existing backups of an app.
     * Gets existing backups of an app.
     *
    ServiceResponse<PageImpl<BackupItemInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<BackupItemInner>> * @param name Name of the app.
    ServiceResponse<PageImpl<BackupItemInner>> * @param slot Name of the deployment slot. If a slot is not specified, the API will get backups of the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;BackupItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<BackupItemInner>>> listBackupsSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listBackupsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<BackupItemInner>> result = listBackupsSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<BackupItemInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<BackupItemInner>> listBackupsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<BackupItemInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<BackupItemInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Discovers an existing app backup that can be restored from a blob in Azure storage.
     * Discovers an existing app backup that can be restored from a blob in Azure storage.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will perform discovery for the production slot.
     * @param request A RestoreRequest object that includes Azure storage URL and blog name for discovery of backup.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RestoreRequestInner object if successful.
     */
    public RestoreRequestInner discoverRestoreSlot(String resourceGroupName, String name, String slot, RestoreRequestInner request) {
        return discoverRestoreSlotWithServiceResponseAsync(resourceGroupName, name, slot, request).toBlocking().single().body();
    }

    /**
     * Discovers an existing app backup that can be restored from a blob in Azure storage.
     * Discovers an existing app backup that can be restored from a blob in Azure storage.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will perform discovery for the production slot.
     * @param request A RestoreRequest object that includes Azure storage URL and blog name for discovery of backup.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RestoreRequestInner> discoverRestoreSlotAsync(String resourceGroupName, String name, String slot, RestoreRequestInner request, final ServiceCallback<RestoreRequestInner> serviceCallback) {
        return ServiceFuture.fromResponse(discoverRestoreSlotWithServiceResponseAsync(resourceGroupName, name, slot, request), serviceCallback);
    }

    /**
     * Discovers an existing app backup that can be restored from a blob in Azure storage.
     * Discovers an existing app backup that can be restored from a blob in Azure storage.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will perform discovery for the production slot.
     * @param request A RestoreRequest object that includes Azure storage URL and blog name for discovery of backup.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RestoreRequestInner object
     */
    public Observable<RestoreRequestInner> discoverRestoreSlotAsync(String resourceGroupName, String name, String slot, RestoreRequestInner request) {
        return discoverRestoreSlotWithServiceResponseAsync(resourceGroupName, name, slot, request).map(new Func1<ServiceResponse<RestoreRequestInner>, RestoreRequestInner>() {
            @Override
            public RestoreRequestInner call(ServiceResponse<RestoreRequestInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Discovers an existing app backup that can be restored from a blob in Azure storage.
     * Discovers an existing app backup that can be restored from a blob in Azure storage.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will perform discovery for the production slot.
     * @param request A RestoreRequest object that includes Azure storage URL and blog name for discovery of backup.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RestoreRequestInner object
     */
    public Observable<ServiceResponse<RestoreRequestInner>> discoverRestoreSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, RestoreRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        final String apiVersion = "2016-08-01";
        return service.discoverRestoreSlot(resourceGroupName, name, slot, this.client.subscriptionId(), request, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RestoreRequestInner>>>() {
                @Override
                public Observable<ServiceResponse<RestoreRequestInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RestoreRequestInner> clientResponse = discoverRestoreSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RestoreRequestInner> discoverRestoreSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<RestoreRequestInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<RestoreRequestInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets a backup of an app by its ID.
     * Gets a backup of an app by its ID.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get a backup of the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BackupItemInner object if successful.
     */
    public BackupItemInner getBackupStatusSlot(String resourceGroupName, String name, String backupId, String slot) {
        return getBackupStatusSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot).toBlocking().single().body();
    }

    /**
     * Gets a backup of an app by its ID.
     * Gets a backup of an app by its ID.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get a backup of the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BackupItemInner> getBackupStatusSlotAsync(String resourceGroupName, String name, String backupId, String slot, final ServiceCallback<BackupItemInner> serviceCallback) {
        return ServiceFuture.fromResponse(getBackupStatusSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot), serviceCallback);
    }

    /**
     * Gets a backup of an app by its ID.
     * Gets a backup of an app by its ID.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get a backup of the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BackupItemInner object
     */
    public Observable<BackupItemInner> getBackupStatusSlotAsync(String resourceGroupName, String name, String backupId, String slot) {
        return getBackupStatusSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot).map(new Func1<ServiceResponse<BackupItemInner>, BackupItemInner>() {
            @Override
            public BackupItemInner call(ServiceResponse<BackupItemInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a backup of an app by its ID.
     * Gets a backup of an app by its ID.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get a backup of the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BackupItemInner object
     */
    public Observable<ServiceResponse<BackupItemInner>> getBackupStatusSlotWithServiceResponseAsync(String resourceGroupName, String name, String backupId, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (backupId == null) {
            throw new IllegalArgumentException("Parameter backupId is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getBackupStatusSlot(resourceGroupName, name, backupId, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupItemInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupItemInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupItemInner> clientResponse = getBackupStatusSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupItemInner> getBackupStatusSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<BackupItemInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BackupItemInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a backup of an app by its ID.
     * Deletes a backup of an app by its ID.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete a backup of the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteBackupSlot(String resourceGroupName, String name, String backupId, String slot) {
        deleteBackupSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot).toBlocking().single().body();
    }

    /**
     * Deletes a backup of an app by its ID.
     * Deletes a backup of an app by its ID.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete a backup of the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteBackupSlotAsync(String resourceGroupName, String name, String backupId, String slot, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteBackupSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot), serviceCallback);
    }

    /**
     * Deletes a backup of an app by its ID.
     * Deletes a backup of an app by its ID.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete a backup of the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteBackupSlotAsync(String resourceGroupName, String name, String backupId, String slot) {
        return deleteBackupSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a backup of an app by its ID.
     * Deletes a backup of an app by its ID.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete a backup of the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteBackupSlotWithServiceResponseAsync(String resourceGroupName, String name, String backupId, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (backupId == null) {
            throw new IllegalArgumentException("Parameter backupId is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.deleteBackupSlot(resourceGroupName, name, backupId, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteBackupSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteBackupSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param backupId Id of backup
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on backup request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BackupItemInner object if successful.
     */
    public BackupItemInner listBackupStatusSecretsSlot(String resourceGroupName, String name, String backupId, String slot, BackupRequestInner request) {
        return listBackupStatusSecretsSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot, request).toBlocking().single().body();
    }

    /**
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param backupId Id of backup
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on backup request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BackupItemInner> listBackupStatusSecretsSlotAsync(String resourceGroupName, String name, String backupId, String slot, BackupRequestInner request, final ServiceCallback<BackupItemInner> serviceCallback) {
        return ServiceFuture.fromResponse(listBackupStatusSecretsSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot, request), serviceCallback);
    }

    /**
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param backupId Id of backup
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on backup request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BackupItemInner object
     */
    public Observable<BackupItemInner> listBackupStatusSecretsSlotAsync(String resourceGroupName, String name, String backupId, String slot, BackupRequestInner request) {
        return listBackupStatusSecretsSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot, request).map(new Func1<ServiceResponse<BackupItemInner>, BackupItemInner>() {
            @Override
            public BackupItemInner call(ServiceResponse<BackupItemInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param backupId Id of backup
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on backup request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BackupItemInner object
     */
    public Observable<ServiceResponse<BackupItemInner>> listBackupStatusSecretsSlotWithServiceResponseAsync(String resourceGroupName, String name, String backupId, String slot, BackupRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (backupId == null) {
            throw new IllegalArgumentException("Parameter backupId is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        final String apiVersion = "2016-08-01";
        return service.listBackupStatusSecretsSlot(resourceGroupName, name, backupId, slot, this.client.subscriptionId(), request, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupItemInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupItemInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupItemInner> clientResponse = listBackupStatusSecretsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupItemInner> listBackupStatusSecretsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<BackupItemInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BackupItemInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Restores a specific backup to another app (or deployment slot, if specified).
     * Restores a specific backup to another app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will restore a backup of the production slot.
     * @param request Information on restore request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RestoreResponseInner object if successful.
     */
    public RestoreResponseInner restoreSlot(String resourceGroupName, String name, String backupId, String slot, RestoreRequestInner request) {
        return restoreSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot, request).toBlocking().last().body();
    }

    /**
     * Restores a specific backup to another app (or deployment slot, if specified).
     * Restores a specific backup to another app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will restore a backup of the production slot.
     * @param request Information on restore request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RestoreResponseInner> restoreSlotAsync(String resourceGroupName, String name, String backupId, String slot, RestoreRequestInner request, final ServiceCallback<RestoreResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(restoreSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot, request), serviceCallback);
    }

    /**
     * Restores a specific backup to another app (or deployment slot, if specified).
     * Restores a specific backup to another app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will restore a backup of the production slot.
     * @param request Information on restore request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<RestoreResponseInner> restoreSlotAsync(String resourceGroupName, String name, String backupId, String slot, RestoreRequestInner request) {
        return restoreSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot, request).map(new Func1<ServiceResponse<RestoreResponseInner>, RestoreResponseInner>() {
            @Override
            public RestoreResponseInner call(ServiceResponse<RestoreResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Restores a specific backup to another app (or deployment slot, if specified).
     * Restores a specific backup to another app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will restore a backup of the production slot.
     * @param request Information on restore request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<RestoreResponseInner>> restoreSlotWithServiceResponseAsync(String resourceGroupName, String name, String backupId, String slot, RestoreRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (backupId == null) {
            throw new IllegalArgumentException("Parameter backupId is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        final String apiVersion = "2016-08-01";
        Observable<Response<ResponseBody>> observable = service.restoreSlot(resourceGroupName, name, backupId, slot, this.client.subscriptionId(), request, apiVersion, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<RestoreResponseInner>() { }.getType());
    }

    /**
     * Restores a specific backup to another app (or deployment slot, if specified).
     * Restores a specific backup to another app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will restore a backup of the production slot.
     * @param request Information on restore request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RestoreResponseInner object if successful.
     */
    public RestoreResponseInner beginRestoreSlot(String resourceGroupName, String name, String backupId, String slot, RestoreRequestInner request) {
        return beginRestoreSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot, request).toBlocking().single().body();
    }

    /**
     * Restores a specific backup to another app (or deployment slot, if specified).
     * Restores a specific backup to another app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will restore a backup of the production slot.
     * @param request Information on restore request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RestoreResponseInner> beginRestoreSlotAsync(String resourceGroupName, String name, String backupId, String slot, RestoreRequestInner request, final ServiceCallback<RestoreResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginRestoreSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot, request), serviceCallback);
    }

    /**
     * Restores a specific backup to another app (or deployment slot, if specified).
     * Restores a specific backup to another app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will restore a backup of the production slot.
     * @param request Information on restore request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RestoreResponseInner object
     */
    public Observable<RestoreResponseInner> beginRestoreSlotAsync(String resourceGroupName, String name, String backupId, String slot, RestoreRequestInner request) {
        return beginRestoreSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot, request).map(new Func1<ServiceResponse<RestoreResponseInner>, RestoreResponseInner>() {
            @Override
            public RestoreResponseInner call(ServiceResponse<RestoreResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Restores a specific backup to another app (or deployment slot, if specified).
     * Restores a specific backup to another app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will restore a backup of the production slot.
     * @param request Information on restore request
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RestoreResponseInner object
     */
    public Observable<ServiceResponse<RestoreResponseInner>> beginRestoreSlotWithServiceResponseAsync(String resourceGroupName, String name, String backupId, String slot, RestoreRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (backupId == null) {
            throw new IllegalArgumentException("Parameter backupId is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        final String apiVersion = "2016-08-01";
        return service.beginRestoreSlot(resourceGroupName, name, backupId, slot, this.client.subscriptionId(), request, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RestoreResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<RestoreResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RestoreResponseInner> clientResponse = beginRestoreSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RestoreResponseInner> beginRestoreSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<RestoreResponseInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<RestoreResponseInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Replaces the application settings of an app.
     * Replaces the application settings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the application settings for the production slot.
     * @param appSettings Application settings of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StringDictionaryInner object if successful.
     */
    public StringDictionaryInner updateApplicationSettingsSlot(String resourceGroupName, String name, String slot, StringDictionaryInner appSettings) {
        return updateApplicationSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot, appSettings).toBlocking().single().body();
    }

    /**
     * Replaces the application settings of an app.
     * Replaces the application settings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the application settings for the production slot.
     * @param appSettings Application settings of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StringDictionaryInner> updateApplicationSettingsSlotAsync(String resourceGroupName, String name, String slot, StringDictionaryInner appSettings, final ServiceCallback<StringDictionaryInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateApplicationSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot, appSettings), serviceCallback);
    }

    /**
     * Replaces the application settings of an app.
     * Replaces the application settings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the application settings for the production slot.
     * @param appSettings Application settings of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<StringDictionaryInner> updateApplicationSettingsSlotAsync(String resourceGroupName, String name, String slot, StringDictionaryInner appSettings) {
        return updateApplicationSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot, appSettings).map(new Func1<ServiceResponse<StringDictionaryInner>, StringDictionaryInner>() {
            @Override
            public StringDictionaryInner call(ServiceResponse<StringDictionaryInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Replaces the application settings of an app.
     * Replaces the application settings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the application settings for the production slot.
     * @param appSettings Application settings of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<ServiceResponse<StringDictionaryInner>> updateApplicationSettingsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, StringDictionaryInner appSettings) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (appSettings == null) {
            throw new IllegalArgumentException("Parameter appSettings is required and cannot be null.");
        }
        Validator.validate(appSettings);
        final String apiVersion = "2016-08-01";
        return service.updateApplicationSettingsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), appSettings, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<StringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StringDictionaryInner> clientResponse = updateApplicationSettingsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StringDictionaryInner> updateApplicationSettingsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<StringDictionaryInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<StringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the application settings of an app.
     * Gets the application settings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the application settings for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StringDictionaryInner object if successful.
     */
    public StringDictionaryInner listApplicationSettingsSlot(String resourceGroupName, String name, String slot) {
        return listApplicationSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Gets the application settings of an app.
     * Gets the application settings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the application settings for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StringDictionaryInner> listApplicationSettingsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<StringDictionaryInner> serviceCallback) {
        return ServiceFuture.fromResponse(listApplicationSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the application settings of an app.
     * Gets the application settings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the application settings for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<StringDictionaryInner> listApplicationSettingsSlotAsync(String resourceGroupName, String name, String slot) {
        return listApplicationSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<StringDictionaryInner>, StringDictionaryInner>() {
            @Override
            public StringDictionaryInner call(ServiceResponse<StringDictionaryInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the application settings of an app.
     * Gets the application settings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the application settings for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<ServiceResponse<StringDictionaryInner>> listApplicationSettingsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listApplicationSettingsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<StringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StringDictionaryInner> clientResponse = listApplicationSettingsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StringDictionaryInner> listApplicationSettingsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<StringDictionaryInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<StringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the Authentication / Authorization settings associated with web app.
     * Updates the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteAuthSettings Auth settings associated with web app
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteAuthSettingsInner object if successful.
     */
    public SiteAuthSettingsInner updateAuthSettingsSlot(String resourceGroupName, String name, String slot, SiteAuthSettingsInner siteAuthSettings) {
        return updateAuthSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteAuthSettings).toBlocking().single().body();
    }

    /**
     * Updates the Authentication / Authorization settings associated with web app.
     * Updates the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteAuthSettings Auth settings associated with web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteAuthSettingsInner> updateAuthSettingsSlotAsync(String resourceGroupName, String name, String slot, SiteAuthSettingsInner siteAuthSettings, final ServiceCallback<SiteAuthSettingsInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateAuthSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteAuthSettings), serviceCallback);
    }

    /**
     * Updates the Authentication / Authorization settings associated with web app.
     * Updates the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteAuthSettings Auth settings associated with web app
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteAuthSettingsInner object
     */
    public Observable<SiteAuthSettingsInner> updateAuthSettingsSlotAsync(String resourceGroupName, String name, String slot, SiteAuthSettingsInner siteAuthSettings) {
        return updateAuthSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteAuthSettings).map(new Func1<ServiceResponse<SiteAuthSettingsInner>, SiteAuthSettingsInner>() {
            @Override
            public SiteAuthSettingsInner call(ServiceResponse<SiteAuthSettingsInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the Authentication / Authorization settings associated with web app.
     * Updates the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteAuthSettings Auth settings associated with web app
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteAuthSettingsInner object
     */
    public Observable<ServiceResponse<SiteAuthSettingsInner>> updateAuthSettingsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, SiteAuthSettingsInner siteAuthSettings) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteAuthSettings == null) {
            throw new IllegalArgumentException("Parameter siteAuthSettings is required and cannot be null.");
        }
        Validator.validate(siteAuthSettings);
        final String apiVersion = "2016-08-01";
        return service.updateAuthSettingsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteAuthSettings, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteAuthSettingsInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteAuthSettingsInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteAuthSettingsInner> clientResponse = updateAuthSettingsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteAuthSettingsInner> updateAuthSettingsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteAuthSettingsInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteAuthSettingsInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the Authentication/Authorization settings of an app.
     * Gets the Authentication/Authorization settings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the settings for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteAuthSettingsInner object if successful.
     */
    public SiteAuthSettingsInner getAuthSettingsSlot(String resourceGroupName, String name, String slot) {
        return getAuthSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Gets the Authentication/Authorization settings of an app.
     * Gets the Authentication/Authorization settings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the settings for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteAuthSettingsInner> getAuthSettingsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<SiteAuthSettingsInner> serviceCallback) {
        return ServiceFuture.fromResponse(getAuthSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the Authentication/Authorization settings of an app.
     * Gets the Authentication/Authorization settings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the settings for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteAuthSettingsInner object
     */
    public Observable<SiteAuthSettingsInner> getAuthSettingsSlotAsync(String resourceGroupName, String name, String slot) {
        return getAuthSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<SiteAuthSettingsInner>, SiteAuthSettingsInner>() {
            @Override
            public SiteAuthSettingsInner call(ServiceResponse<SiteAuthSettingsInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the Authentication/Authorization settings of an app.
     * Gets the Authentication/Authorization settings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the settings for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteAuthSettingsInner object
     */
    public Observable<ServiceResponse<SiteAuthSettingsInner>> getAuthSettingsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getAuthSettingsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteAuthSettingsInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteAuthSettingsInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteAuthSettingsInner> clientResponse = getAuthSettingsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteAuthSettingsInner> getAuthSettingsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteAuthSettingsInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteAuthSettingsInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the backup configuration of an app.
     * Updates the backup configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the backup configuration for the production slot.
     * @param request Edited backup configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BackupRequestInner object if successful.
     */
    public BackupRequestInner updateBackupConfigurationSlot(String resourceGroupName, String name, String slot, BackupRequestInner request) {
        return updateBackupConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot, request).toBlocking().single().body();
    }

    /**
     * Updates the backup configuration of an app.
     * Updates the backup configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the backup configuration for the production slot.
     * @param request Edited backup configuration.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BackupRequestInner> updateBackupConfigurationSlotAsync(String resourceGroupName, String name, String slot, BackupRequestInner request, final ServiceCallback<BackupRequestInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateBackupConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot, request), serviceCallback);
    }

    /**
     * Updates the backup configuration of an app.
     * Updates the backup configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the backup configuration for the production slot.
     * @param request Edited backup configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BackupRequestInner object
     */
    public Observable<BackupRequestInner> updateBackupConfigurationSlotAsync(String resourceGroupName, String name, String slot, BackupRequestInner request) {
        return updateBackupConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot, request).map(new Func1<ServiceResponse<BackupRequestInner>, BackupRequestInner>() {
            @Override
            public BackupRequestInner call(ServiceResponse<BackupRequestInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the backup configuration of an app.
     * Updates the backup configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the backup configuration for the production slot.
     * @param request Edited backup configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BackupRequestInner object
     */
    public Observable<ServiceResponse<BackupRequestInner>> updateBackupConfigurationSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, BackupRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        final String apiVersion = "2016-08-01";
        return service.updateBackupConfigurationSlot(resourceGroupName, name, slot, this.client.subscriptionId(), request, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupRequestInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupRequestInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupRequestInner> clientResponse = updateBackupConfigurationSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupRequestInner> updateBackupConfigurationSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<BackupRequestInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BackupRequestInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes the backup configuration of an app.
     * Deletes the backup configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the backup configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteBackupConfigurationSlot(String resourceGroupName, String name, String slot) {
        deleteBackupConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Deletes the backup configuration of an app.
     * Deletes the backup configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the backup configuration for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteBackupConfigurationSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteBackupConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Deletes the backup configuration of an app.
     * Deletes the backup configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the backup configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteBackupConfigurationSlotAsync(String resourceGroupName, String name, String slot) {
        return deleteBackupConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes the backup configuration of an app.
     * Deletes the backup configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the backup configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteBackupConfigurationSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.deleteBackupConfigurationSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteBackupConfigurationSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteBackupConfigurationSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the backup configuration of an app.
     * Gets the backup configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the backup configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BackupRequestInner object if successful.
     */
    public BackupRequestInner getBackupConfigurationSlot(String resourceGroupName, String name, String slot) {
        return getBackupConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Gets the backup configuration of an app.
     * Gets the backup configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the backup configuration for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BackupRequestInner> getBackupConfigurationSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<BackupRequestInner> serviceCallback) {
        return ServiceFuture.fromResponse(getBackupConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the backup configuration of an app.
     * Gets the backup configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the backup configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BackupRequestInner object
     */
    public Observable<BackupRequestInner> getBackupConfigurationSlotAsync(String resourceGroupName, String name, String slot) {
        return getBackupConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<BackupRequestInner>, BackupRequestInner>() {
            @Override
            public BackupRequestInner call(ServiceResponse<BackupRequestInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the backup configuration of an app.
     * Gets the backup configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the backup configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BackupRequestInner object
     */
    public Observable<ServiceResponse<BackupRequestInner>> getBackupConfigurationSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getBackupConfigurationSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupRequestInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupRequestInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupRequestInner> clientResponse = getBackupConfigurationSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupRequestInner> getBackupConfigurationSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<BackupRequestInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<BackupRequestInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Replaces the connection strings of an app.
     * Replaces the connection strings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the connection settings for the production slot.
     * @param connectionStrings Connection strings of the app or deployment slot. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ConnectionStringDictionaryInner object if successful.
     */
    public ConnectionStringDictionaryInner updateConnectionStringsSlot(String resourceGroupName, String name, String slot, ConnectionStringDictionaryInner connectionStrings) {
        return updateConnectionStringsSlotWithServiceResponseAsync(resourceGroupName, name, slot, connectionStrings).toBlocking().single().body();
    }

    /**
     * Replaces the connection strings of an app.
     * Replaces the connection strings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the connection settings for the production slot.
     * @param connectionStrings Connection strings of the app or deployment slot. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ConnectionStringDictionaryInner> updateConnectionStringsSlotAsync(String resourceGroupName, String name, String slot, ConnectionStringDictionaryInner connectionStrings, final ServiceCallback<ConnectionStringDictionaryInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateConnectionStringsSlotWithServiceResponseAsync(resourceGroupName, name, slot, connectionStrings), serviceCallback);
    }

    /**
     * Replaces the connection strings of an app.
     * Replaces the connection strings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the connection settings for the production slot.
     * @param connectionStrings Connection strings of the app or deployment slot. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ConnectionStringDictionaryInner object
     */
    public Observable<ConnectionStringDictionaryInner> updateConnectionStringsSlotAsync(String resourceGroupName, String name, String slot, ConnectionStringDictionaryInner connectionStrings) {
        return updateConnectionStringsSlotWithServiceResponseAsync(resourceGroupName, name, slot, connectionStrings).map(new Func1<ServiceResponse<ConnectionStringDictionaryInner>, ConnectionStringDictionaryInner>() {
            @Override
            public ConnectionStringDictionaryInner call(ServiceResponse<ConnectionStringDictionaryInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Replaces the connection strings of an app.
     * Replaces the connection strings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the connection settings for the production slot.
     * @param connectionStrings Connection strings of the app or deployment slot. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ConnectionStringDictionaryInner object
     */
    public Observable<ServiceResponse<ConnectionStringDictionaryInner>> updateConnectionStringsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, ConnectionStringDictionaryInner connectionStrings) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionStrings == null) {
            throw new IllegalArgumentException("Parameter connectionStrings is required and cannot be null.");
        }
        Validator.validate(connectionStrings);
        final String apiVersion = "2016-08-01";
        return service.updateConnectionStringsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), connectionStrings, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ConnectionStringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<ConnectionStringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ConnectionStringDictionaryInner> clientResponse = updateConnectionStringsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ConnectionStringDictionaryInner> updateConnectionStringsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ConnectionStringDictionaryInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ConnectionStringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the connection strings of an app.
     * Gets the connection strings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the connection settings for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ConnectionStringDictionaryInner object if successful.
     */
    public ConnectionStringDictionaryInner listConnectionStringsSlot(String resourceGroupName, String name, String slot) {
        return listConnectionStringsSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Gets the connection strings of an app.
     * Gets the connection strings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the connection settings for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ConnectionStringDictionaryInner> listConnectionStringsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<ConnectionStringDictionaryInner> serviceCallback) {
        return ServiceFuture.fromResponse(listConnectionStringsSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the connection strings of an app.
     * Gets the connection strings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the connection settings for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ConnectionStringDictionaryInner object
     */
    public Observable<ConnectionStringDictionaryInner> listConnectionStringsSlotAsync(String resourceGroupName, String name, String slot) {
        return listConnectionStringsSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<ConnectionStringDictionaryInner>, ConnectionStringDictionaryInner>() {
            @Override
            public ConnectionStringDictionaryInner call(ServiceResponse<ConnectionStringDictionaryInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the connection strings of an app.
     * Gets the connection strings of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the connection settings for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ConnectionStringDictionaryInner object
     */
    public Observable<ServiceResponse<ConnectionStringDictionaryInner>> listConnectionStringsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listConnectionStringsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ConnectionStringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<ConnectionStringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ConnectionStringDictionaryInner> clientResponse = listConnectionStringsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ConnectionStringDictionaryInner> listConnectionStringsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ConnectionStringDictionaryInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ConnectionStringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the logging configuration of an app.
     * Gets the logging configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the logging configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteLogsConfigInner object if successful.
     */
    public SiteLogsConfigInner getDiagnosticLogsConfigurationSlot(String resourceGroupName, String name, String slot) {
        return getDiagnosticLogsConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Gets the logging configuration of an app.
     * Gets the logging configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the logging configuration for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteLogsConfigInner> getDiagnosticLogsConfigurationSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<SiteLogsConfigInner> serviceCallback) {
        return ServiceFuture.fromResponse(getDiagnosticLogsConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the logging configuration of an app.
     * Gets the logging configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the logging configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteLogsConfigInner object
     */
    public Observable<SiteLogsConfigInner> getDiagnosticLogsConfigurationSlotAsync(String resourceGroupName, String name, String slot) {
        return getDiagnosticLogsConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<SiteLogsConfigInner>, SiteLogsConfigInner>() {
            @Override
            public SiteLogsConfigInner call(ServiceResponse<SiteLogsConfigInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the logging configuration of an app.
     * Gets the logging configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the logging configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteLogsConfigInner object
     */
    public Observable<ServiceResponse<SiteLogsConfigInner>> getDiagnosticLogsConfigurationSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getDiagnosticLogsConfigurationSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteLogsConfigInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteLogsConfigInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteLogsConfigInner> clientResponse = getDiagnosticLogsConfigurationSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteLogsConfigInner> getDiagnosticLogsConfigurationSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteLogsConfigInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteLogsConfigInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the logging configuration of an app.
     * Updates the logging configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the logging configuration for the production slot.
     * @param siteLogsConfig A SiteLogsConfig JSON object that contains the logging configuration to change in the "properties" property.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteLogsConfigInner object if successful.
     */
    public SiteLogsConfigInner updateDiagnosticLogsConfigSlot(String resourceGroupName, String name, String slot, SiteLogsConfigInner siteLogsConfig) {
        return updateDiagnosticLogsConfigSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteLogsConfig).toBlocking().single().body();
    }

    /**
     * Updates the logging configuration of an app.
     * Updates the logging configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the logging configuration for the production slot.
     * @param siteLogsConfig A SiteLogsConfig JSON object that contains the logging configuration to change in the "properties" property.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteLogsConfigInner> updateDiagnosticLogsConfigSlotAsync(String resourceGroupName, String name, String slot, SiteLogsConfigInner siteLogsConfig, final ServiceCallback<SiteLogsConfigInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateDiagnosticLogsConfigSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteLogsConfig), serviceCallback);
    }

    /**
     * Updates the logging configuration of an app.
     * Updates the logging configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the logging configuration for the production slot.
     * @param siteLogsConfig A SiteLogsConfig JSON object that contains the logging configuration to change in the "properties" property.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteLogsConfigInner object
     */
    public Observable<SiteLogsConfigInner> updateDiagnosticLogsConfigSlotAsync(String resourceGroupName, String name, String slot, SiteLogsConfigInner siteLogsConfig) {
        return updateDiagnosticLogsConfigSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteLogsConfig).map(new Func1<ServiceResponse<SiteLogsConfigInner>, SiteLogsConfigInner>() {
            @Override
            public SiteLogsConfigInner call(ServiceResponse<SiteLogsConfigInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the logging configuration of an app.
     * Updates the logging configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the logging configuration for the production slot.
     * @param siteLogsConfig A SiteLogsConfig JSON object that contains the logging configuration to change in the "properties" property.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteLogsConfigInner object
     */
    public Observable<ServiceResponse<SiteLogsConfigInner>> updateDiagnosticLogsConfigSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, SiteLogsConfigInner siteLogsConfig) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteLogsConfig == null) {
            throw new IllegalArgumentException("Parameter siteLogsConfig is required and cannot be null.");
        }
        Validator.validate(siteLogsConfig);
        final String apiVersion = "2016-08-01";
        return service.updateDiagnosticLogsConfigSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteLogsConfig, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteLogsConfigInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteLogsConfigInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteLogsConfigInner> clientResponse = updateDiagnosticLogsConfigSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteLogsConfigInner> updateDiagnosticLogsConfigSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteLogsConfigInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteLogsConfigInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Replaces the metadata of an app.
     * Replaces the metadata of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the metadata for the production slot.
     * @param metadata Edited metadata of the app or deployment slot. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StringDictionaryInner object if successful.
     */
    public StringDictionaryInner updateMetadataSlot(String resourceGroupName, String name, String slot, StringDictionaryInner metadata) {
        return updateMetadataSlotWithServiceResponseAsync(resourceGroupName, name, slot, metadata).toBlocking().single().body();
    }

    /**
     * Replaces the metadata of an app.
     * Replaces the metadata of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the metadata for the production slot.
     * @param metadata Edited metadata of the app or deployment slot. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StringDictionaryInner> updateMetadataSlotAsync(String resourceGroupName, String name, String slot, StringDictionaryInner metadata, final ServiceCallback<StringDictionaryInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateMetadataSlotWithServiceResponseAsync(resourceGroupName, name, slot, metadata), serviceCallback);
    }

    /**
     * Replaces the metadata of an app.
     * Replaces the metadata of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the metadata for the production slot.
     * @param metadata Edited metadata of the app or deployment slot. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<StringDictionaryInner> updateMetadataSlotAsync(String resourceGroupName, String name, String slot, StringDictionaryInner metadata) {
        return updateMetadataSlotWithServiceResponseAsync(resourceGroupName, name, slot, metadata).map(new Func1<ServiceResponse<StringDictionaryInner>, StringDictionaryInner>() {
            @Override
            public StringDictionaryInner call(ServiceResponse<StringDictionaryInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Replaces the metadata of an app.
     * Replaces the metadata of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the metadata for the production slot.
     * @param metadata Edited metadata of the app or deployment slot. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<ServiceResponse<StringDictionaryInner>> updateMetadataSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, StringDictionaryInner metadata) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (metadata == null) {
            throw new IllegalArgumentException("Parameter metadata is required and cannot be null.");
        }
        Validator.validate(metadata);
        final String apiVersion = "2016-08-01";
        return service.updateMetadataSlot(resourceGroupName, name, slot, this.client.subscriptionId(), metadata, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<StringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StringDictionaryInner> clientResponse = updateMetadataSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StringDictionaryInner> updateMetadataSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<StringDictionaryInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<StringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the metadata of an app.
     * Gets the metadata of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the metadata for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StringDictionaryInner object if successful.
     */
    public StringDictionaryInner listMetadataSlot(String resourceGroupName, String name, String slot) {
        return listMetadataSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Gets the metadata of an app.
     * Gets the metadata of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the metadata for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StringDictionaryInner> listMetadataSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<StringDictionaryInner> serviceCallback) {
        return ServiceFuture.fromResponse(listMetadataSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the metadata of an app.
     * Gets the metadata of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the metadata for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<StringDictionaryInner> listMetadataSlotAsync(String resourceGroupName, String name, String slot) {
        return listMetadataSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<StringDictionaryInner>, StringDictionaryInner>() {
            @Override
            public StringDictionaryInner call(ServiceResponse<StringDictionaryInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the metadata of an app.
     * Gets the metadata of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the metadata for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<ServiceResponse<StringDictionaryInner>> listMetadataSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listMetadataSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<StringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StringDictionaryInner> clientResponse = listMetadataSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StringDictionaryInner> listMetadataSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<StringDictionaryInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<StringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the Git/FTP publishing credentials of an app.
     * Gets the Git/FTP publishing credentials of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the publishing credentials for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UserInner object if successful.
     */
    public UserInner listPublishingCredentialsSlot(String resourceGroupName, String name, String slot) {
        return listPublishingCredentialsSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().last().body();
    }

    /**
     * Gets the Git/FTP publishing credentials of an app.
     * Gets the Git/FTP publishing credentials of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the publishing credentials for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UserInner> listPublishingCredentialsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<UserInner> serviceCallback) {
        return ServiceFuture.fromResponse(listPublishingCredentialsSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the Git/FTP publishing credentials of an app.
     * Gets the Git/FTP publishing credentials of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the publishing credentials for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<UserInner> listPublishingCredentialsSlotAsync(String resourceGroupName, String name, String slot) {
        return listPublishingCredentialsSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<UserInner>, UserInner>() {
            @Override
            public UserInner call(ServiceResponse<UserInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the Git/FTP publishing credentials of an app.
     * Gets the Git/FTP publishing credentials of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the publishing credentials for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<UserInner>> listPublishingCredentialsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        Observable<Response<ResponseBody>> observable = service.listPublishingCredentialsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<UserInner>() { }.getType());
    }

    /**
     * Gets the Git/FTP publishing credentials of an app.
     * Gets the Git/FTP publishing credentials of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the publishing credentials for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UserInner object if successful.
     */
    public UserInner beginListPublishingCredentialsSlot(String resourceGroupName, String name, String slot) {
        return beginListPublishingCredentialsSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Gets the Git/FTP publishing credentials of an app.
     * Gets the Git/FTP publishing credentials of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the publishing credentials for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UserInner> beginListPublishingCredentialsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<UserInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginListPublishingCredentialsSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the Git/FTP publishing credentials of an app.
     * Gets the Git/FTP publishing credentials of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the publishing credentials for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UserInner object
     */
    public Observable<UserInner> beginListPublishingCredentialsSlotAsync(String resourceGroupName, String name, String slot) {
        return beginListPublishingCredentialsSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<UserInner>, UserInner>() {
            @Override
            public UserInner call(ServiceResponse<UserInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the Git/FTP publishing credentials of an app.
     * Gets the Git/FTP publishing credentials of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the publishing credentials for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UserInner object
     */
    public Observable<ServiceResponse<UserInner>> beginListPublishingCredentialsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.beginListPublishingCredentialsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UserInner>>>() {
                @Override
                public Observable<ServiceResponse<UserInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UserInner> clientResponse = beginListPublishingCredentialsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<UserInner> beginListPublishingCredentialsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<UserInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<UserInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the Push settings associated with web app.
     * Updates the Push settings associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param pushSettings Push settings associated with web app
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PushSettingsInner object if successful.
     */
    public PushSettingsInner updateSitePushSettingsSlot(String resourceGroupName, String name, String slot, PushSettingsInner pushSettings) {
        return updateSitePushSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot, pushSettings).toBlocking().single().body();
    }

    /**
     * Updates the Push settings associated with web app.
     * Updates the Push settings associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param pushSettings Push settings associated with web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PushSettingsInner> updateSitePushSettingsSlotAsync(String resourceGroupName, String name, String slot, PushSettingsInner pushSettings, final ServiceCallback<PushSettingsInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateSitePushSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot, pushSettings), serviceCallback);
    }

    /**
     * Updates the Push settings associated with web app.
     * Updates the Push settings associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param pushSettings Push settings associated with web app
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PushSettingsInner object
     */
    public Observable<PushSettingsInner> updateSitePushSettingsSlotAsync(String resourceGroupName, String name, String slot, PushSettingsInner pushSettings) {
        return updateSitePushSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot, pushSettings).map(new Func1<ServiceResponse<PushSettingsInner>, PushSettingsInner>() {
            @Override
            public PushSettingsInner call(ServiceResponse<PushSettingsInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the Push settings associated with web app.
     * Updates the Push settings associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param pushSettings Push settings associated with web app
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PushSettingsInner object
     */
    public Observable<ServiceResponse<PushSettingsInner>> updateSitePushSettingsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, PushSettingsInner pushSettings) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (pushSettings == null) {
            throw new IllegalArgumentException("Parameter pushSettings is required and cannot be null.");
        }
        Validator.validate(pushSettings);
        final String apiVersion = "2016-08-01";
        return service.updateSitePushSettingsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), pushSettings, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PushSettingsInner>>>() {
                @Override
                public Observable<ServiceResponse<PushSettingsInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PushSettingsInner> clientResponse = updateSitePushSettingsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PushSettingsInner> updateSitePushSettingsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PushSettingsInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PushSettingsInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the Push settings associated with web app.
     * Gets the Push settings associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PushSettingsInner object if successful.
     */
    public PushSettingsInner listSitePushSettingsSlot(String resourceGroupName, String name, String slot) {
        return listSitePushSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Gets the Push settings associated with web app.
     * Gets the Push settings associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PushSettingsInner> listSitePushSettingsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<PushSettingsInner> serviceCallback) {
        return ServiceFuture.fromResponse(listSitePushSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the Push settings associated with web app.
     * Gets the Push settings associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PushSettingsInner object
     */
    public Observable<PushSettingsInner> listSitePushSettingsSlotAsync(String resourceGroupName, String name, String slot) {
        return listSitePushSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<PushSettingsInner>, PushSettingsInner>() {
            @Override
            public PushSettingsInner call(ServiceResponse<PushSettingsInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the Push settings associated with web app.
     * Gets the Push settings associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PushSettingsInner object
     */
    public Observable<ServiceResponse<PushSettingsInner>> listSitePushSettingsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listSitePushSettingsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PushSettingsInner>>>() {
                @Override
                public Observable<ServiceResponse<PushSettingsInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PushSettingsInner> clientResponse = listSitePushSettingsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PushSettingsInner> listSitePushSettingsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PushSettingsInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PushSettingsInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the configuration of an app, such as platform version and bitness, default documents, virtual applications, Always On, etc.
     * Gets the configuration of an app, such as platform version and bitness, default documents, virtual applications, Always On, etc.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteConfigResourceInner object if successful.
     */
    public SiteConfigResourceInner getConfigurationSlot(String resourceGroupName, String name, String slot) {
        return getConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Gets the configuration of an app, such as platform version and bitness, default documents, virtual applications, Always On, etc.
     * Gets the configuration of an app, such as platform version and bitness, default documents, virtual applications, Always On, etc.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return configuration for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteConfigResourceInner> getConfigurationSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<SiteConfigResourceInner> serviceCallback) {
        return ServiceFuture.fromResponse(getConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the configuration of an app, such as platform version and bitness, default documents, virtual applications, Always On, etc.
     * Gets the configuration of an app, such as platform version and bitness, default documents, virtual applications, Always On, etc.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteConfigResourceInner object
     */
    public Observable<SiteConfigResourceInner> getConfigurationSlotAsync(String resourceGroupName, String name, String slot) {
        return getConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<SiteConfigResourceInner>, SiteConfigResourceInner>() {
            @Override
            public SiteConfigResourceInner call(ServiceResponse<SiteConfigResourceInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the configuration of an app, such as platform version and bitness, default documents, virtual applications, Always On, etc.
     * Gets the configuration of an app, such as platform version and bitness, default documents, virtual applications, Always On, etc.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteConfigResourceInner object
     */
    public Observable<ServiceResponse<SiteConfigResourceInner>> getConfigurationSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getConfigurationSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteConfigResourceInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteConfigResourceInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteConfigResourceInner> clientResponse = getConfigurationSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteConfigResourceInner> getConfigurationSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteConfigResourceInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteConfigResourceInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the configuration of an app.
     * Updates the configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update configuration for the production slot.
     * @param siteConfig JSON representation of a SiteConfig object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteConfigResourceInner object if successful.
     */
    public SiteConfigResourceInner createOrUpdateConfigurationSlot(String resourceGroupName, String name, String slot, SiteConfigResourceInner siteConfig) {
        return createOrUpdateConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteConfig).toBlocking().single().body();
    }

    /**
     * Updates the configuration of an app.
     * Updates the configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update configuration for the production slot.
     * @param siteConfig JSON representation of a SiteConfig object. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteConfigResourceInner> createOrUpdateConfigurationSlotAsync(String resourceGroupName, String name, String slot, SiteConfigResourceInner siteConfig, final ServiceCallback<SiteConfigResourceInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteConfig), serviceCallback);
    }

    /**
     * Updates the configuration of an app.
     * Updates the configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update configuration for the production slot.
     * @param siteConfig JSON representation of a SiteConfig object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteConfigResourceInner object
     */
    public Observable<SiteConfigResourceInner> createOrUpdateConfigurationSlotAsync(String resourceGroupName, String name, String slot, SiteConfigResourceInner siteConfig) {
        return createOrUpdateConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteConfig).map(new Func1<ServiceResponse<SiteConfigResourceInner>, SiteConfigResourceInner>() {
            @Override
            public SiteConfigResourceInner call(ServiceResponse<SiteConfigResourceInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the configuration of an app.
     * Updates the configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update configuration for the production slot.
     * @param siteConfig JSON representation of a SiteConfig object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteConfigResourceInner object
     */
    public Observable<ServiceResponse<SiteConfigResourceInner>> createOrUpdateConfigurationSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, SiteConfigResourceInner siteConfig) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteConfig == null) {
            throw new IllegalArgumentException("Parameter siteConfig is required and cannot be null.");
        }
        Validator.validate(siteConfig);
        final String apiVersion = "2016-08-01";
        return service.createOrUpdateConfigurationSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteConfig, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteConfigResourceInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteConfigResourceInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteConfigResourceInner> clientResponse = createOrUpdateConfigurationSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteConfigResourceInner> createOrUpdateConfigurationSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteConfigResourceInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteConfigResourceInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the configuration of an app.
     * Updates the configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update configuration for the production slot.
     * @param siteConfig JSON representation of a SiteConfig object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteConfigResourceInner object if successful.
     */
    public SiteConfigResourceInner updateConfigurationSlot(String resourceGroupName, String name, String slot, SiteConfigResourceInner siteConfig) {
        return updateConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteConfig).toBlocking().single().body();
    }

    /**
     * Updates the configuration of an app.
     * Updates the configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update configuration for the production slot.
     * @param siteConfig JSON representation of a SiteConfig object. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteConfigResourceInner> updateConfigurationSlotAsync(String resourceGroupName, String name, String slot, SiteConfigResourceInner siteConfig, final ServiceCallback<SiteConfigResourceInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteConfig), serviceCallback);
    }

    /**
     * Updates the configuration of an app.
     * Updates the configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update configuration for the production slot.
     * @param siteConfig JSON representation of a SiteConfig object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteConfigResourceInner object
     */
    public Observable<SiteConfigResourceInner> updateConfigurationSlotAsync(String resourceGroupName, String name, String slot, SiteConfigResourceInner siteConfig) {
        return updateConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteConfig).map(new Func1<ServiceResponse<SiteConfigResourceInner>, SiteConfigResourceInner>() {
            @Override
            public SiteConfigResourceInner call(ServiceResponse<SiteConfigResourceInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the configuration of an app.
     * Updates the configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update configuration for the production slot.
     * @param siteConfig JSON representation of a SiteConfig object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteConfigResourceInner object
     */
    public Observable<ServiceResponse<SiteConfigResourceInner>> updateConfigurationSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, SiteConfigResourceInner siteConfig) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteConfig == null) {
            throw new IllegalArgumentException("Parameter siteConfig is required and cannot be null.");
        }
        Validator.validate(siteConfig);
        final String apiVersion = "2016-08-01";
        return service.updateConfigurationSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteConfig, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteConfigResourceInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteConfigResourceInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteConfigResourceInner> clientResponse = updateConfigurationSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteConfigResourceInner> updateConfigurationSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteConfigResourceInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteConfigResourceInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;SiteConfigurationSnapshotInfoInner&gt; object if successful.
     */
    public List<SiteConfigurationSnapshotInfoInner> listConfigurationSnapshotInfoSlot(String resourceGroupName, String name, String slot) {
        return listConfigurationSnapshotInfoSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return configuration for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SiteConfigurationSnapshotInfoInner>> listConfigurationSnapshotInfoSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<List<SiteConfigurationSnapshotInfoInner>> serviceCallback) {
        return ServiceFuture.fromResponse(listConfigurationSnapshotInfoSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;SiteConfigurationSnapshotInfoInner&gt; object
     */
    public Observable<List<SiteConfigurationSnapshotInfoInner>> listConfigurationSnapshotInfoSlotAsync(String resourceGroupName, String name, String slot) {
        return listConfigurationSnapshotInfoSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<List<SiteConfigurationSnapshotInfoInner>>, List<SiteConfigurationSnapshotInfoInner>>() {
            @Override
            public List<SiteConfigurationSnapshotInfoInner> call(ServiceResponse<List<SiteConfigurationSnapshotInfoInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     * Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp and the ID of the snapshot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;SiteConfigurationSnapshotInfoInner&gt; object
     */
    public Observable<ServiceResponse<List<SiteConfigurationSnapshotInfoInner>>> listConfigurationSnapshotInfoSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listConfigurationSnapshotInfoSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<SiteConfigurationSnapshotInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<SiteConfigurationSnapshotInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<SiteConfigurationSnapshotInfoInner>> clientResponse = listConfigurationSnapshotInfoSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<SiteConfigurationSnapshotInfoInner>> listConfigurationSnapshotInfoSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<SiteConfigurationSnapshotInfoInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<SiteConfigurationSnapshotInfoInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets a snapshot of the configuration of an app at a previous point in time.
     * Gets a snapshot of the configuration of an app at a previous point in time.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param snapshotId The ID of the snapshot to read.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteConfigResourceInner object if successful.
     */
    public SiteConfigResourceInner getConfigurationSnapshotSlot(String resourceGroupName, String name, String snapshotId, String slot) {
        return getConfigurationSnapshotSlotWithServiceResponseAsync(resourceGroupName, name, snapshotId, slot).toBlocking().single().body();
    }

    /**
     * Gets a snapshot of the configuration of an app at a previous point in time.
     * Gets a snapshot of the configuration of an app at a previous point in time.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param snapshotId The ID of the snapshot to read.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return configuration for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteConfigResourceInner> getConfigurationSnapshotSlotAsync(String resourceGroupName, String name, String snapshotId, String slot, final ServiceCallback<SiteConfigResourceInner> serviceCallback) {
        return ServiceFuture.fromResponse(getConfigurationSnapshotSlotWithServiceResponseAsync(resourceGroupName, name, snapshotId, slot), serviceCallback);
    }

    /**
     * Gets a snapshot of the configuration of an app at a previous point in time.
     * Gets a snapshot of the configuration of an app at a previous point in time.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param snapshotId The ID of the snapshot to read.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteConfigResourceInner object
     */
    public Observable<SiteConfigResourceInner> getConfigurationSnapshotSlotAsync(String resourceGroupName, String name, String snapshotId, String slot) {
        return getConfigurationSnapshotSlotWithServiceResponseAsync(resourceGroupName, name, snapshotId, slot).map(new Func1<ServiceResponse<SiteConfigResourceInner>, SiteConfigResourceInner>() {
            @Override
            public SiteConfigResourceInner call(ServiceResponse<SiteConfigResourceInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a snapshot of the configuration of an app at a previous point in time.
     * Gets a snapshot of the configuration of an app at a previous point in time.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param snapshotId The ID of the snapshot to read.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteConfigResourceInner object
     */
    public Observable<ServiceResponse<SiteConfigResourceInner>> getConfigurationSnapshotSlotWithServiceResponseAsync(String resourceGroupName, String name, String snapshotId, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (snapshotId == null) {
            throw new IllegalArgumentException("Parameter snapshotId is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getConfigurationSnapshotSlot(resourceGroupName, name, snapshotId, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteConfigResourceInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteConfigResourceInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteConfigResourceInner> clientResponse = getConfigurationSnapshotSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteConfigResourceInner> getConfigurationSnapshotSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteConfigResourceInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteConfigResourceInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Reverts the configuration of an app to a previous snapshot.
     * Reverts the configuration of an app to a previous snapshot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param snapshotId The ID of the snapshot to read.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void recoverSiteConfigurationSnapshotSlot(String resourceGroupName, String name, String snapshotId, String slot) {
        recoverSiteConfigurationSnapshotSlotWithServiceResponseAsync(resourceGroupName, name, snapshotId, slot).toBlocking().single().body();
    }

    /**
     * Reverts the configuration of an app to a previous snapshot.
     * Reverts the configuration of an app to a previous snapshot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param snapshotId The ID of the snapshot to read.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return configuration for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> recoverSiteConfigurationSnapshotSlotAsync(String resourceGroupName, String name, String snapshotId, String slot, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(recoverSiteConfigurationSnapshotSlotWithServiceResponseAsync(resourceGroupName, name, snapshotId, slot), serviceCallback);
    }

    /**
     * Reverts the configuration of an app to a previous snapshot.
     * Reverts the configuration of an app to a previous snapshot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param snapshotId The ID of the snapshot to read.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> recoverSiteConfigurationSnapshotSlotAsync(String resourceGroupName, String name, String snapshotId, String slot) {
        return recoverSiteConfigurationSnapshotSlotWithServiceResponseAsync(resourceGroupName, name, snapshotId, slot).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Reverts the configuration of an app to a previous snapshot.
     * Reverts the configuration of an app to a previous snapshot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param snapshotId The ID of the snapshot to read.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> recoverSiteConfigurationSnapshotSlotWithServiceResponseAsync(String resourceGroupName, String name, String snapshotId, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (snapshotId == null) {
            throw new IllegalArgumentException("Parameter snapshotId is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.recoverSiteConfigurationSnapshotSlot(resourceGroupName, name, snapshotId, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = recoverSiteConfigurationSnapshotSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> recoverSiteConfigurationSnapshotSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;DeploymentInner&gt; object if successful.
     */
    public PagedList<DeploymentInner> listDeploymentsSlot(final String resourceGroupName, final String name, final String slot) {
        ServiceResponse<Page<DeploymentInner>> response = listDeploymentsSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        return new PagedList<DeploymentInner>(response.body()) {
            @Override
            public Page<DeploymentInner> nextPage(String nextPageLink) {
                return listDeploymentsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<DeploymentInner>> listDeploymentsSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<DeploymentInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listDeploymentsSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(String nextPageLink) {
                    return listDeploymentsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<Page<DeploymentInner>> listDeploymentsSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return listDeploymentsSlotWithServiceResponseAsync(resourceGroupName, name, slot)
            .map(new Func1<ServiceResponse<Page<DeploymentInner>>, Page<DeploymentInner>>() {
                @Override
                public Page<DeploymentInner> call(ServiceResponse<Page<DeploymentInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> listDeploymentsSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot) {
        return listDeploymentsSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<DeploymentInner>>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(ServiceResponse<Page<DeploymentInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listDeploymentsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     *
    ServiceResponse<PageImpl<DeploymentInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<DeploymentInner>> * @param name Name of the app.
    ServiceResponse<PageImpl<DeploymentInner>> * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;DeploymentInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> listDeploymentsSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listDeploymentsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<DeploymentInner>> result = listDeploymentsSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<DeploymentInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<DeploymentInner>> listDeploymentsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<DeploymentInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<DeploymentInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     * Get a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the DeploymentInner object if successful.
     */
    public DeploymentInner getDeploymentSlot(String resourceGroupName, String name, String id, String slot) {
        return getDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot).toBlocking().single().body();
    }

    /**
     * Get a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     * Get a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets a deployment for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<DeploymentInner> getDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot, final ServiceCallback<DeploymentInner> serviceCallback) {
        return ServiceFuture.fromResponse(getDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot), serviceCallback);
    }

    /**
     * Get a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     * Get a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeploymentInner object
     */
    public Observable<DeploymentInner> getDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot) {
        return getDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot).map(new Func1<ServiceResponse<DeploymentInner>, DeploymentInner>() {
            @Override
            public DeploymentInner call(ServiceResponse<DeploymentInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     * Get a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeploymentInner object
     */
    public Observable<ServiceResponse<DeploymentInner>> getDeploymentSlotWithServiceResponseAsync(String resourceGroupName, String name, String id, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getDeploymentSlot(resourceGroupName, name, id, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeploymentInner>>>() {
                @Override
                public Observable<ServiceResponse<DeploymentInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeploymentInner> clientResponse = getDeploymentSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DeploymentInner> getDeploymentSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<DeploymentInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<DeploymentInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Create a deployment for an app, a specific deployment slot, and/or a specific scaled-out instance.
     * Create a deployment for an app, a specific deployment slot, and/or a specific scaled-out instance.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id ID of an existing deployment.
     * @param slot Name of the deployment slot. If a slot is not specified, the API creates a deployment for the production slot.
     * @param deployment Deployment details.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the DeploymentInner object if successful.
     */
    public DeploymentInner createDeploymentSlot(String resourceGroupName, String name, String id, String slot, DeploymentInner deployment) {
        return createDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot, deployment).toBlocking().single().body();
    }

    /**
     * Create a deployment for an app, a specific deployment slot, and/or a specific scaled-out instance.
     * Create a deployment for an app, a specific deployment slot, and/or a specific scaled-out instance.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id ID of an existing deployment.
     * @param slot Name of the deployment slot. If a slot is not specified, the API creates a deployment for the production slot.
     * @param deployment Deployment details.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<DeploymentInner> createDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot, DeploymentInner deployment, final ServiceCallback<DeploymentInner> serviceCallback) {
        return ServiceFuture.fromResponse(createDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot, deployment), serviceCallback);
    }

    /**
     * Create a deployment for an app, a specific deployment slot, and/or a specific scaled-out instance.
     * Create a deployment for an app, a specific deployment slot, and/or a specific scaled-out instance.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id ID of an existing deployment.
     * @param slot Name of the deployment slot. If a slot is not specified, the API creates a deployment for the production slot.
     * @param deployment Deployment details.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeploymentInner object
     */
    public Observable<DeploymentInner> createDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot, DeploymentInner deployment) {
        return createDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot, deployment).map(new Func1<ServiceResponse<DeploymentInner>, DeploymentInner>() {
            @Override
            public DeploymentInner call(ServiceResponse<DeploymentInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Create a deployment for an app, a specific deployment slot, and/or a specific scaled-out instance.
     * Create a deployment for an app, a specific deployment slot, and/or a specific scaled-out instance.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id ID of an existing deployment.
     * @param slot Name of the deployment slot. If a slot is not specified, the API creates a deployment for the production slot.
     * @param deployment Deployment details.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeploymentInner object
     */
    public Observable<ServiceResponse<DeploymentInner>> createDeploymentSlotWithServiceResponseAsync(String resourceGroupName, String name, String id, String slot, DeploymentInner deployment) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (deployment == null) {
            throw new IllegalArgumentException("Parameter deployment is required and cannot be null.");
        }
        Validator.validate(deployment);
        final String apiVersion = "2016-08-01";
        return service.createDeploymentSlot(resourceGroupName, name, id, slot, this.client.subscriptionId(), deployment, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeploymentInner>>>() {
                @Override
                public Observable<ServiceResponse<DeploymentInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeploymentInner> clientResponse = createDeploymentSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DeploymentInner> createDeploymentSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<DeploymentInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<DeploymentInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Delete a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     * Delete a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteDeploymentSlot(String resourceGroupName, String name, String id, String slot) {
        deleteDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot).toBlocking().single().body();
    }

    /**
     * Delete a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     * Delete a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot), serviceCallback);
    }

    /**
     * Delete a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     * Delete a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot) {
        return deleteDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     * Delete a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteDeploymentSlotWithServiceResponseAsync(String resourceGroupName, String name, String id, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.deleteDeploymentSlot(resourceGroupName, name, id, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteDeploymentSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteDeploymentSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Lists ownership identifiers for domain associated with web app.
     * Lists ownership identifiers for domain associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;IdentifierInner&gt; object if successful.
     */
    public PagedList<IdentifierInner> listDomainOwnershipIdentifiersSlot(final String resourceGroupName, final String name, final String slot) {
        ServiceResponse<Page<IdentifierInner>> response = listDomainOwnershipIdentifiersSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        return new PagedList<IdentifierInner>(response.body()) {
            @Override
            public Page<IdentifierInner> nextPage(String nextPageLink) {
                return listDomainOwnershipIdentifiersSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists ownership identifiers for domain associated with web app.
     * Lists ownership identifiers for domain associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<IdentifierInner>> listDomainOwnershipIdentifiersSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<IdentifierInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listDomainOwnershipIdentifiersSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<IdentifierInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<IdentifierInner>>> call(String nextPageLink) {
                    return listDomainOwnershipIdentifiersSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists ownership identifiers for domain associated with web app.
     * Lists ownership identifiers for domain associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;IdentifierInner&gt; object
     */
    public Observable<Page<IdentifierInner>> listDomainOwnershipIdentifiersSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return listDomainOwnershipIdentifiersSlotWithServiceResponseAsync(resourceGroupName, name, slot)
            .map(new Func1<ServiceResponse<Page<IdentifierInner>>, Page<IdentifierInner>>() {
                @Override
                public Page<IdentifierInner> call(ServiceResponse<Page<IdentifierInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists ownership identifiers for domain associated with web app.
     * Lists ownership identifiers for domain associated with web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;IdentifierInner&gt; object
     */
    public Observable<ServiceResponse<Page<IdentifierInner>>> listDomainOwnershipIdentifiersSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot) {
        return listDomainOwnershipIdentifiersSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<IdentifierInner>>, Observable<ServiceResponse<Page<IdentifierInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<IdentifierInner>>> call(ServiceResponse<Page<IdentifierInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listDomainOwnershipIdentifiersSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists ownership identifiers for domain associated with web app.
     * Lists ownership identifiers for domain associated with web app.
     *
    ServiceResponse<PageImpl<IdentifierInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<IdentifierInner>> * @param name Name of the app.
    ServiceResponse<PageImpl<IdentifierInner>> * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;IdentifierInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<IdentifierInner>>> listDomainOwnershipIdentifiersSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listDomainOwnershipIdentifiersSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<IdentifierInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<IdentifierInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<IdentifierInner>> result = listDomainOwnershipIdentifiersSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<IdentifierInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<IdentifierInner>> listDomainOwnershipIdentifiersSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<IdentifierInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<IdentifierInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get domain ownership identifier for web app.
     * Get domain ownership identifier for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IdentifierInner object if successful.
     */
    public IdentifierInner getDomainOwnershipIdentifierSlot(String resourceGroupName, String name, String domainOwnershipIdentifierName, String slot) {
        return getDomainOwnershipIdentifierSlotWithServiceResponseAsync(resourceGroupName, name, domainOwnershipIdentifierName, slot).toBlocking().single().body();
    }

    /**
     * Get domain ownership identifier for web app.
     * Get domain ownership identifier for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IdentifierInner> getDomainOwnershipIdentifierSlotAsync(String resourceGroupName, String name, String domainOwnershipIdentifierName, String slot, final ServiceCallback<IdentifierInner> serviceCallback) {
        return ServiceFuture.fromResponse(getDomainOwnershipIdentifierSlotWithServiceResponseAsync(resourceGroupName, name, domainOwnershipIdentifierName, slot), serviceCallback);
    }

    /**
     * Get domain ownership identifier for web app.
     * Get domain ownership identifier for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IdentifierInner object
     */
    public Observable<IdentifierInner> getDomainOwnershipIdentifierSlotAsync(String resourceGroupName, String name, String domainOwnershipIdentifierName, String slot) {
        return getDomainOwnershipIdentifierSlotWithServiceResponseAsync(resourceGroupName, name, domainOwnershipIdentifierName, slot).map(new Func1<ServiceResponse<IdentifierInner>, IdentifierInner>() {
            @Override
            public IdentifierInner call(ServiceResponse<IdentifierInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get domain ownership identifier for web app.
     * Get domain ownership identifier for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IdentifierInner object
     */
    public Observable<ServiceResponse<IdentifierInner>> getDomainOwnershipIdentifierSlotWithServiceResponseAsync(String resourceGroupName, String name, String domainOwnershipIdentifierName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (domainOwnershipIdentifierName == null) {
            throw new IllegalArgumentException("Parameter domainOwnershipIdentifierName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IdentifierInner>>>() {
                @Override
                public Observable<ServiceResponse<IdentifierInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IdentifierInner> clientResponse = getDomainOwnershipIdentifierSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<IdentifierInner> getDomainOwnershipIdentifierSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<IdentifierInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<IdentifierInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @param domainOwnershipIdentifier A JSON representation of the domain ownership properties.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IdentifierInner object if successful.
     */
    public IdentifierInner createOrUpdateDomainOwnershipIdentifierSlot(String resourceGroupName, String name, String domainOwnershipIdentifierName, String slot, IdentifierInner domainOwnershipIdentifier) {
        return createOrUpdateDomainOwnershipIdentifierSlotWithServiceResponseAsync(resourceGroupName, name, domainOwnershipIdentifierName, slot, domainOwnershipIdentifier).toBlocking().single().body();
    }

    /**
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @param domainOwnershipIdentifier A JSON representation of the domain ownership properties.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IdentifierInner> createOrUpdateDomainOwnershipIdentifierSlotAsync(String resourceGroupName, String name, String domainOwnershipIdentifierName, String slot, IdentifierInner domainOwnershipIdentifier, final ServiceCallback<IdentifierInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateDomainOwnershipIdentifierSlotWithServiceResponseAsync(resourceGroupName, name, domainOwnershipIdentifierName, slot, domainOwnershipIdentifier), serviceCallback);
    }

    /**
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @param domainOwnershipIdentifier A JSON representation of the domain ownership properties.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IdentifierInner object
     */
    public Observable<IdentifierInner> createOrUpdateDomainOwnershipIdentifierSlotAsync(String resourceGroupName, String name, String domainOwnershipIdentifierName, String slot, IdentifierInner domainOwnershipIdentifier) {
        return createOrUpdateDomainOwnershipIdentifierSlotWithServiceResponseAsync(resourceGroupName, name, domainOwnershipIdentifierName, slot, domainOwnershipIdentifier).map(new Func1<ServiceResponse<IdentifierInner>, IdentifierInner>() {
            @Override
            public IdentifierInner call(ServiceResponse<IdentifierInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @param domainOwnershipIdentifier A JSON representation of the domain ownership properties.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IdentifierInner object
     */
    public Observable<ServiceResponse<IdentifierInner>> createOrUpdateDomainOwnershipIdentifierSlotWithServiceResponseAsync(String resourceGroupName, String name, String domainOwnershipIdentifierName, String slot, IdentifierInner domainOwnershipIdentifier) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (domainOwnershipIdentifierName == null) {
            throw new IllegalArgumentException("Parameter domainOwnershipIdentifierName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (domainOwnershipIdentifier == null) {
            throw new IllegalArgumentException("Parameter domainOwnershipIdentifier is required and cannot be null.");
        }
        Validator.validate(domainOwnershipIdentifier);
        final String apiVersion = "2016-08-01";
        return service.createOrUpdateDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, slot, this.client.subscriptionId(), domainOwnershipIdentifier, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IdentifierInner>>>() {
                @Override
                public Observable<ServiceResponse<IdentifierInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IdentifierInner> clientResponse = createOrUpdateDomainOwnershipIdentifierSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<IdentifierInner> createOrUpdateDomainOwnershipIdentifierSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<IdentifierInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<IdentifierInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a domain ownership identifier for a web app.
     * Deletes a domain ownership identifier for a web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteDomainOwnershipIdentifierSlot(String resourceGroupName, String name, String domainOwnershipIdentifierName, String slot) {
        deleteDomainOwnershipIdentifierSlotWithServiceResponseAsync(resourceGroupName, name, domainOwnershipIdentifierName, slot).toBlocking().single().body();
    }

    /**
     * Deletes a domain ownership identifier for a web app.
     * Deletes a domain ownership identifier for a web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteDomainOwnershipIdentifierSlotAsync(String resourceGroupName, String name, String domainOwnershipIdentifierName, String slot, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteDomainOwnershipIdentifierSlotWithServiceResponseAsync(resourceGroupName, name, domainOwnershipIdentifierName, slot), serviceCallback);
    }

    /**
     * Deletes a domain ownership identifier for a web app.
     * Deletes a domain ownership identifier for a web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteDomainOwnershipIdentifierSlotAsync(String resourceGroupName, String name, String domainOwnershipIdentifierName, String slot) {
        return deleteDomainOwnershipIdentifierSlotWithServiceResponseAsync(resourceGroupName, name, domainOwnershipIdentifierName, slot).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a domain ownership identifier for a web app.
     * Deletes a domain ownership identifier for a web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteDomainOwnershipIdentifierSlotWithServiceResponseAsync(String resourceGroupName, String name, String domainOwnershipIdentifierName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (domainOwnershipIdentifierName == null) {
            throw new IllegalArgumentException("Parameter domainOwnershipIdentifierName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.deleteDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteDomainOwnershipIdentifierSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteDomainOwnershipIdentifierSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @param domainOwnershipIdentifier A JSON representation of the domain ownership properties.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IdentifierInner object if successful.
     */
    public IdentifierInner updateDomainOwnershipIdentifierSlot(String resourceGroupName, String name, String domainOwnershipIdentifierName, String slot, IdentifierInner domainOwnershipIdentifier) {
        return updateDomainOwnershipIdentifierSlotWithServiceResponseAsync(resourceGroupName, name, domainOwnershipIdentifierName, slot, domainOwnershipIdentifier).toBlocking().single().body();
    }

    /**
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @param domainOwnershipIdentifier A JSON representation of the domain ownership properties.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IdentifierInner> updateDomainOwnershipIdentifierSlotAsync(String resourceGroupName, String name, String domainOwnershipIdentifierName, String slot, IdentifierInner domainOwnershipIdentifier, final ServiceCallback<IdentifierInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateDomainOwnershipIdentifierSlotWithServiceResponseAsync(resourceGroupName, name, domainOwnershipIdentifierName, slot, domainOwnershipIdentifier), serviceCallback);
    }

    /**
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @param domainOwnershipIdentifier A JSON representation of the domain ownership properties.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IdentifierInner object
     */
    public Observable<IdentifierInner> updateDomainOwnershipIdentifierSlotAsync(String resourceGroupName, String name, String domainOwnershipIdentifierName, String slot, IdentifierInner domainOwnershipIdentifier) {
        return updateDomainOwnershipIdentifierSlotWithServiceResponseAsync(resourceGroupName, name, domainOwnershipIdentifierName, slot, domainOwnershipIdentifier).map(new Func1<ServiceResponse<IdentifierInner>, IdentifierInner>() {
            @Override
            public IdentifierInner call(ServiceResponse<IdentifierInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     * Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @param domainOwnershipIdentifier A JSON representation of the domain ownership properties.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IdentifierInner object
     */
    public Observable<ServiceResponse<IdentifierInner>> updateDomainOwnershipIdentifierSlotWithServiceResponseAsync(String resourceGroupName, String name, String domainOwnershipIdentifierName, String slot, IdentifierInner domainOwnershipIdentifier) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (domainOwnershipIdentifierName == null) {
            throw new IllegalArgumentException("Parameter domainOwnershipIdentifierName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (domainOwnershipIdentifier == null) {
            throw new IllegalArgumentException("Parameter domainOwnershipIdentifier is required and cannot be null.");
        }
        Validator.validate(domainOwnershipIdentifier);
        final String apiVersion = "2016-08-01";
        return service.updateDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, slot, this.client.subscriptionId(), domainOwnershipIdentifier, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IdentifierInner>>>() {
                @Override
                public Observable<ServiceResponse<IdentifierInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IdentifierInner> clientResponse = updateDomainOwnershipIdentifierSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<IdentifierInner> updateDomainOwnershipIdentifierSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<IdentifierInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<IdentifierInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get hostname bindings for an app or a deployment slot.
     * Get hostname bindings for an app or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets hostname bindings for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;HostNameBindingInner&gt; object if successful.
     */
    public PagedList<HostNameBindingInner> listHostNameBindingsSlot(final String resourceGroupName, final String name, final String slot) {
        ServiceResponse<Page<HostNameBindingInner>> response = listHostNameBindingsSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        return new PagedList<HostNameBindingInner>(response.body()) {
            @Override
            public Page<HostNameBindingInner> nextPage(String nextPageLink) {
                return listHostNameBindingsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get hostname bindings for an app or a deployment slot.
     * Get hostname bindings for an app or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets hostname bindings for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<HostNameBindingInner>> listHostNameBindingsSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<HostNameBindingInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listHostNameBindingsSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(String nextPageLink) {
                    return listHostNameBindingsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get hostname bindings for an app or a deployment slot.
     * Get hostname bindings for an app or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets hostname bindings for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;HostNameBindingInner&gt; object
     */
    public Observable<Page<HostNameBindingInner>> listHostNameBindingsSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return listHostNameBindingsSlotWithServiceResponseAsync(resourceGroupName, name, slot)
            .map(new Func1<ServiceResponse<Page<HostNameBindingInner>>, Page<HostNameBindingInner>>() {
                @Override
                public Page<HostNameBindingInner> call(ServiceResponse<Page<HostNameBindingInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get hostname bindings for an app or a deployment slot.
     * Get hostname bindings for an app or a deployment slot.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets hostname bindings for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;HostNameBindingInner&gt; object
     */
    public Observable<ServiceResponse<Page<HostNameBindingInner>>> listHostNameBindingsSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot) {
        return listHostNameBindingsSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<HostNameBindingInner>>, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(ServiceResponse<Page<HostNameBindingInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listHostNameBindingsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get hostname bindings for an app or a deployment slot.
     * Get hostname bindings for an app or a deployment slot.
     *
    ServiceResponse<PageImpl<HostNameBindingInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<HostNameBindingInner>> * @param name Name of the app.
    ServiceResponse<PageImpl<HostNameBindingInner>> * @param slot Name of the deployment slot. If a slot is not specified, the API gets hostname bindings for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;HostNameBindingInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<HostNameBindingInner>>> listHostNameBindingsSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listHostNameBindingsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<HostNameBindingInner>> result = listHostNameBindingsSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<HostNameBindingInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<HostNameBindingInner>> listHostNameBindingsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<HostNameBindingInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<HostNameBindingInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the named hostname binding for an app (or deployment slot, if specified).
     * Get the named hostname binding for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API the named binding for the production slot.
     * @param hostName Hostname in the hostname binding.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HostNameBindingInner object if successful.
     */
    public HostNameBindingInner getHostNameBindingSlot(String resourceGroupName, String name, String slot, String hostName) {
        return getHostNameBindingSlotWithServiceResponseAsync(resourceGroupName, name, slot, hostName).toBlocking().single().body();
    }

    /**
     * Get the named hostname binding for an app (or deployment slot, if specified).
     * Get the named hostname binding for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API the named binding for the production slot.
     * @param hostName Hostname in the hostname binding.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HostNameBindingInner> getHostNameBindingSlotAsync(String resourceGroupName, String name, String slot, String hostName, final ServiceCallback<HostNameBindingInner> serviceCallback) {
        return ServiceFuture.fromResponse(getHostNameBindingSlotWithServiceResponseAsync(resourceGroupName, name, slot, hostName), serviceCallback);
    }

    /**
     * Get the named hostname binding for an app (or deployment slot, if specified).
     * Get the named hostname binding for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API the named binding for the production slot.
     * @param hostName Hostname in the hostname binding.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HostNameBindingInner object
     */
    public Observable<HostNameBindingInner> getHostNameBindingSlotAsync(String resourceGroupName, String name, String slot, String hostName) {
        return getHostNameBindingSlotWithServiceResponseAsync(resourceGroupName, name, slot, hostName).map(new Func1<ServiceResponse<HostNameBindingInner>, HostNameBindingInner>() {
            @Override
            public HostNameBindingInner call(ServiceResponse<HostNameBindingInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get the named hostname binding for an app (or deployment slot, if specified).
     * Get the named hostname binding for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API the named binding for the production slot.
     * @param hostName Hostname in the hostname binding.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HostNameBindingInner object
     */
    public Observable<ServiceResponse<HostNameBindingInner>> getHostNameBindingSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, String hostName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (hostName == null) {
            throw new IllegalArgumentException("Parameter hostName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getHostNameBindingSlot(resourceGroupName, name, slot, hostName, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HostNameBindingInner>>>() {
                @Override
                public Observable<ServiceResponse<HostNameBindingInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HostNameBindingInner> clientResponse = getHostNameBindingSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HostNameBindingInner> getHostNameBindingSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<HostNameBindingInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<HostNameBindingInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a hostname binding for an app.
     * Creates a hostname binding for an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param hostName Hostname in the hostname binding.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will create a binding for the production slot.
     * @param hostNameBinding Binding details. This is the JSON representation of a HostNameBinding object.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HostNameBindingInner object if successful.
     */
    public HostNameBindingInner createOrUpdateHostNameBindingSlot(String resourceGroupName, String name, String hostName, String slot, HostNameBindingInner hostNameBinding) {
        return createOrUpdateHostNameBindingSlotWithServiceResponseAsync(resourceGroupName, name, hostName, slot, hostNameBinding).toBlocking().single().body();
    }

    /**
     * Creates a hostname binding for an app.
     * Creates a hostname binding for an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param hostName Hostname in the hostname binding.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will create a binding for the production slot.
     * @param hostNameBinding Binding details. This is the JSON representation of a HostNameBinding object.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HostNameBindingInner> createOrUpdateHostNameBindingSlotAsync(String resourceGroupName, String name, String hostName, String slot, HostNameBindingInner hostNameBinding, final ServiceCallback<HostNameBindingInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateHostNameBindingSlotWithServiceResponseAsync(resourceGroupName, name, hostName, slot, hostNameBinding), serviceCallback);
    }

    /**
     * Creates a hostname binding for an app.
     * Creates a hostname binding for an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param hostName Hostname in the hostname binding.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will create a binding for the production slot.
     * @param hostNameBinding Binding details. This is the JSON representation of a HostNameBinding object.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HostNameBindingInner object
     */
    public Observable<HostNameBindingInner> createOrUpdateHostNameBindingSlotAsync(String resourceGroupName, String name, String hostName, String slot, HostNameBindingInner hostNameBinding) {
        return createOrUpdateHostNameBindingSlotWithServiceResponseAsync(resourceGroupName, name, hostName, slot, hostNameBinding).map(new Func1<ServiceResponse<HostNameBindingInner>, HostNameBindingInner>() {
            @Override
            public HostNameBindingInner call(ServiceResponse<HostNameBindingInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a hostname binding for an app.
     * Creates a hostname binding for an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param hostName Hostname in the hostname binding.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will create a binding for the production slot.
     * @param hostNameBinding Binding details. This is the JSON representation of a HostNameBinding object.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HostNameBindingInner object
     */
    public Observable<ServiceResponse<HostNameBindingInner>> createOrUpdateHostNameBindingSlotWithServiceResponseAsync(String resourceGroupName, String name, String hostName, String slot, HostNameBindingInner hostNameBinding) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (hostName == null) {
            throw new IllegalArgumentException("Parameter hostName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (hostNameBinding == null) {
            throw new IllegalArgumentException("Parameter hostNameBinding is required and cannot be null.");
        }
        Validator.validate(hostNameBinding);
        final String apiVersion = "2016-08-01";
        return service.createOrUpdateHostNameBindingSlot(resourceGroupName, name, hostName, slot, this.client.subscriptionId(), hostNameBinding, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HostNameBindingInner>>>() {
                @Override
                public Observable<ServiceResponse<HostNameBindingInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HostNameBindingInner> clientResponse = createOrUpdateHostNameBindingSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HostNameBindingInner> createOrUpdateHostNameBindingSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<HostNameBindingInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<HostNameBindingInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a hostname binding for an app.
     * Deletes a hostname binding for an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @param hostName Hostname in the hostname binding.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteHostNameBindingSlot(String resourceGroupName, String name, String slot, String hostName) {
        deleteHostNameBindingSlotWithServiceResponseAsync(resourceGroupName, name, slot, hostName).toBlocking().single().body();
    }

    /**
     * Deletes a hostname binding for an app.
     * Deletes a hostname binding for an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @param hostName Hostname in the hostname binding.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteHostNameBindingSlotAsync(String resourceGroupName, String name, String slot, String hostName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteHostNameBindingSlotWithServiceResponseAsync(resourceGroupName, name, slot, hostName), serviceCallback);
    }

    /**
     * Deletes a hostname binding for an app.
     * Deletes a hostname binding for an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @param hostName Hostname in the hostname binding.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteHostNameBindingSlotAsync(String resourceGroupName, String name, String slot, String hostName) {
        return deleteHostNameBindingSlotWithServiceResponseAsync(resourceGroupName, name, slot, hostName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a hostname binding for an app.
     * Deletes a hostname binding for an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding for the production slot.
     * @param hostName Hostname in the hostname binding.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteHostNameBindingSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, String hostName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (hostName == null) {
            throw new IllegalArgumentException("Parameter hostName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.deleteHostNameBindingSlot(resourceGroupName, name, slot, hostName, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteHostNameBindingSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteHostNameBindingSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param slot The name of the slot for the web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HybridConnectionInner object if successful.
     */
    public HybridConnectionInner getHybridConnectionSlot(String resourceGroupName, String name, String namespaceName, String relayName, String slot) {
        return getHybridConnectionSlotWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, slot).toBlocking().single().body();
    }

    /**
     * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param slot The name of the slot for the web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HybridConnectionInner> getHybridConnectionSlotAsync(String resourceGroupName, String name, String namespaceName, String relayName, String slot, final ServiceCallback<HybridConnectionInner> serviceCallback) {
        return ServiceFuture.fromResponse(getHybridConnectionSlotWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, slot), serviceCallback);
    }

    /**
     * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param slot The name of the slot for the web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<HybridConnectionInner> getHybridConnectionSlotAsync(String resourceGroupName, String name, String namespaceName, String relayName, String slot) {
        return getHybridConnectionSlotWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, slot).map(new Func1<ServiceResponse<HybridConnectionInner>, HybridConnectionInner>() {
            @Override
            public HybridConnectionInner call(ServiceResponse<HybridConnectionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param slot The name of the slot for the web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<ServiceResponse<HybridConnectionInner>> getHybridConnectionSlotWithServiceResponseAsync(String resourceGroupName, String name, String namespaceName, String relayName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (namespaceName == null) {
            throw new IllegalArgumentException("Parameter namespaceName is required and cannot be null.");
        }
        if (relayName == null) {
            throw new IllegalArgumentException("Parameter relayName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HybridConnectionInner>>>() {
                @Override
                public Observable<ServiceResponse<HybridConnectionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HybridConnectionInner> clientResponse = getHybridConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HybridConnectionInner> getHybridConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<HybridConnectionInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<HybridConnectionInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new Hybrid Connection using a Service Bus relay.
     * Creates a new Hybrid Connection using a Service Bus relay.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param slot The name of the slot for the web app.
     * @param connectionEnvelope The details of the hybrid connection
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HybridConnectionInner object if successful.
     */
    public HybridConnectionInner createOrUpdateHybridConnectionSlot(String resourceGroupName, String name, String namespaceName, String relayName, String slot, HybridConnectionInner connectionEnvelope) {
        return createOrUpdateHybridConnectionSlotWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, slot, connectionEnvelope).toBlocking().single().body();
    }

    /**
     * Creates a new Hybrid Connection using a Service Bus relay.
     * Creates a new Hybrid Connection using a Service Bus relay.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param slot The name of the slot for the web app.
     * @param connectionEnvelope The details of the hybrid connection
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HybridConnectionInner> createOrUpdateHybridConnectionSlotAsync(String resourceGroupName, String name, String namespaceName, String relayName, String slot, HybridConnectionInner connectionEnvelope, final ServiceCallback<HybridConnectionInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateHybridConnectionSlotWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, slot, connectionEnvelope), serviceCallback);
    }

    /**
     * Creates a new Hybrid Connection using a Service Bus relay.
     * Creates a new Hybrid Connection using a Service Bus relay.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param slot The name of the slot for the web app.
     * @param connectionEnvelope The details of the hybrid connection
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<HybridConnectionInner> createOrUpdateHybridConnectionSlotAsync(String resourceGroupName, String name, String namespaceName, String relayName, String slot, HybridConnectionInner connectionEnvelope) {
        return createOrUpdateHybridConnectionSlotWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, slot, connectionEnvelope).map(new Func1<ServiceResponse<HybridConnectionInner>, HybridConnectionInner>() {
            @Override
            public HybridConnectionInner call(ServiceResponse<HybridConnectionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new Hybrid Connection using a Service Bus relay.
     * Creates a new Hybrid Connection using a Service Bus relay.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param slot The name of the slot for the web app.
     * @param connectionEnvelope The details of the hybrid connection
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<ServiceResponse<HybridConnectionInner>> createOrUpdateHybridConnectionSlotWithServiceResponseAsync(String resourceGroupName, String name, String namespaceName, String relayName, String slot, HybridConnectionInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (namespaceName == null) {
            throw new IllegalArgumentException("Parameter namespaceName is required and cannot be null.");
        }
        if (relayName == null) {
            throw new IllegalArgumentException("Parameter relayName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        final String apiVersion = "2016-08-01";
        return service.createOrUpdateHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, slot, this.client.subscriptionId(), connectionEnvelope, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HybridConnectionInner>>>() {
                @Override
                public Observable<ServiceResponse<HybridConnectionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HybridConnectionInner> clientResponse = createOrUpdateHybridConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HybridConnectionInner> createOrUpdateHybridConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<HybridConnectionInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<HybridConnectionInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Removes a Hybrid Connection from this site.
     * Removes a Hybrid Connection from this site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param slot The name of the slot for the web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteHybridConnectionSlot(String resourceGroupName, String name, String namespaceName, String relayName, String slot) {
        deleteHybridConnectionSlotWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, slot).toBlocking().single().body();
    }

    /**
     * Removes a Hybrid Connection from this site.
     * Removes a Hybrid Connection from this site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param slot The name of the slot for the web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteHybridConnectionSlotAsync(String resourceGroupName, String name, String namespaceName, String relayName, String slot, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteHybridConnectionSlotWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, slot), serviceCallback);
    }

    /**
     * Removes a Hybrid Connection from this site.
     * Removes a Hybrid Connection from this site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param slot The name of the slot for the web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteHybridConnectionSlotAsync(String resourceGroupName, String name, String namespaceName, String relayName, String slot) {
        return deleteHybridConnectionSlotWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, slot).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Removes a Hybrid Connection from this site.
     * Removes a Hybrid Connection from this site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param slot The name of the slot for the web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteHybridConnectionSlotWithServiceResponseAsync(String resourceGroupName, String name, String namespaceName, String relayName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (namespaceName == null) {
            throw new IllegalArgumentException("Parameter namespaceName is required and cannot be null.");
        }
        if (relayName == null) {
            throw new IllegalArgumentException("Parameter relayName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.deleteHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteHybridConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteHybridConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new Hybrid Connection using a Service Bus relay.
     * Creates a new Hybrid Connection using a Service Bus relay.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param slot The name of the slot for the web app.
     * @param connectionEnvelope The details of the hybrid connection
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HybridConnectionInner object if successful.
     */
    public HybridConnectionInner updateHybridConnectionSlot(String resourceGroupName, String name, String namespaceName, String relayName, String slot, HybridConnectionInner connectionEnvelope) {
        return updateHybridConnectionSlotWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, slot, connectionEnvelope).toBlocking().single().body();
    }

    /**
     * Creates a new Hybrid Connection using a Service Bus relay.
     * Creates a new Hybrid Connection using a Service Bus relay.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param slot The name of the slot for the web app.
     * @param connectionEnvelope The details of the hybrid connection
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HybridConnectionInner> updateHybridConnectionSlotAsync(String resourceGroupName, String name, String namespaceName, String relayName, String slot, HybridConnectionInner connectionEnvelope, final ServiceCallback<HybridConnectionInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateHybridConnectionSlotWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, slot, connectionEnvelope), serviceCallback);
    }

    /**
     * Creates a new Hybrid Connection using a Service Bus relay.
     * Creates a new Hybrid Connection using a Service Bus relay.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param slot The name of the slot for the web app.
     * @param connectionEnvelope The details of the hybrid connection
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<HybridConnectionInner> updateHybridConnectionSlotAsync(String resourceGroupName, String name, String namespaceName, String relayName, String slot, HybridConnectionInner connectionEnvelope) {
        return updateHybridConnectionSlotWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, slot, connectionEnvelope).map(new Func1<ServiceResponse<HybridConnectionInner>, HybridConnectionInner>() {
            @Override
            public HybridConnectionInner call(ServiceResponse<HybridConnectionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new Hybrid Connection using a Service Bus relay.
     * Creates a new Hybrid Connection using a Service Bus relay.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param slot The name of the slot for the web app.
     * @param connectionEnvelope The details of the hybrid connection
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<ServiceResponse<HybridConnectionInner>> updateHybridConnectionSlotWithServiceResponseAsync(String resourceGroupName, String name, String namespaceName, String relayName, String slot, HybridConnectionInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (namespaceName == null) {
            throw new IllegalArgumentException("Parameter namespaceName is required and cannot be null.");
        }
        if (relayName == null) {
            throw new IllegalArgumentException("Parameter relayName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        final String apiVersion = "2016-08-01";
        return service.updateHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, slot, this.client.subscriptionId(), connectionEnvelope, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HybridConnectionInner>>>() {
                @Override
                public Observable<ServiceResponse<HybridConnectionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HybridConnectionInner> clientResponse = updateHybridConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HybridConnectionInner> updateHybridConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<HybridConnectionInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<HybridConnectionInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the send key name and value for a Hybrid Connection.
     * Gets the send key name and value for a Hybrid Connection.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param slot The name of the slot for the web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HybridConnectionKeyInner object if successful.
     */
    public HybridConnectionKeyInner listHybridConnectionKeysSlot(String resourceGroupName, String name, String namespaceName, String relayName, String slot) {
        return listHybridConnectionKeysSlotWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, slot).toBlocking().single().body();
    }

    /**
     * Gets the send key name and value for a Hybrid Connection.
     * Gets the send key name and value for a Hybrid Connection.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param slot The name of the slot for the web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HybridConnectionKeyInner> listHybridConnectionKeysSlotAsync(String resourceGroupName, String name, String namespaceName, String relayName, String slot, final ServiceCallback<HybridConnectionKeyInner> serviceCallback) {
        return ServiceFuture.fromResponse(listHybridConnectionKeysSlotWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, slot), serviceCallback);
    }

    /**
     * Gets the send key name and value for a Hybrid Connection.
     * Gets the send key name and value for a Hybrid Connection.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param slot The name of the slot for the web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HybridConnectionKeyInner object
     */
    public Observable<HybridConnectionKeyInner> listHybridConnectionKeysSlotAsync(String resourceGroupName, String name, String namespaceName, String relayName, String slot) {
        return listHybridConnectionKeysSlotWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, slot).map(new Func1<ServiceResponse<HybridConnectionKeyInner>, HybridConnectionKeyInner>() {
            @Override
            public HybridConnectionKeyInner call(ServiceResponse<HybridConnectionKeyInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the send key name and value for a Hybrid Connection.
     * Gets the send key name and value for a Hybrid Connection.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param slot The name of the slot for the web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HybridConnectionKeyInner object
     */
    public Observable<ServiceResponse<HybridConnectionKeyInner>> listHybridConnectionKeysSlotWithServiceResponseAsync(String resourceGroupName, String name, String namespaceName, String relayName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (namespaceName == null) {
            throw new IllegalArgumentException("Parameter namespaceName is required and cannot be null.");
        }
        if (relayName == null) {
            throw new IllegalArgumentException("Parameter relayName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listHybridConnectionKeysSlot(resourceGroupName, name, namespaceName, relayName, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HybridConnectionKeyInner>>>() {
                @Override
                public Observable<ServiceResponse<HybridConnectionKeyInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HybridConnectionKeyInner> clientResponse = listHybridConnectionKeysSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HybridConnectionKeyInner> listHybridConnectionKeysSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<HybridConnectionKeyInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<HybridConnectionKeyInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves all Service Bus Hybrid Connections used by this Web App.
     * Retrieves all Service Bus Hybrid Connections used by this Web App.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app
     * @param slot The name of the slot for the web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the HybridConnectionInner object if successful.
     */
    public HybridConnectionInner listHybridConnectionsSlot(String resourceGroupName, String name, String slot) {
        return listHybridConnectionsSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Retrieves all Service Bus Hybrid Connections used by this Web App.
     * Retrieves all Service Bus Hybrid Connections used by this Web App.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app
     * @param slot The name of the slot for the web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<HybridConnectionInner> listHybridConnectionsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<HybridConnectionInner> serviceCallback) {
        return ServiceFuture.fromResponse(listHybridConnectionsSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Retrieves all Service Bus Hybrid Connections used by this Web App.
     * Retrieves all Service Bus Hybrid Connections used by this Web App.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app
     * @param slot The name of the slot for the web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<HybridConnectionInner> listHybridConnectionsSlotAsync(String resourceGroupName, String name, String slot) {
        return listHybridConnectionsSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<HybridConnectionInner>, HybridConnectionInner>() {
            @Override
            public HybridConnectionInner call(ServiceResponse<HybridConnectionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Retrieves all Service Bus Hybrid Connections used by this Web App.
     * Retrieves all Service Bus Hybrid Connections used by this Web App.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app
     * @param slot The name of the slot for the web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<ServiceResponse<HybridConnectionInner>> listHybridConnectionsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listHybridConnectionsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HybridConnectionInner>>>() {
                @Override
                public Observable<ServiceResponse<HybridConnectionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HybridConnectionInner> clientResponse = listHybridConnectionsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HybridConnectionInner> listHybridConnectionsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<HybridConnectionInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<HybridConnectionInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets hybrid connections configured for an app (or deployment slot, if specified).
     * Gets hybrid connections configured for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get hybrid connections for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RelayServiceConnectionEntityInner object if successful.
     */
    public RelayServiceConnectionEntityInner listRelayServiceConnectionsSlot(String resourceGroupName, String name, String slot) {
        return listRelayServiceConnectionsSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Gets hybrid connections configured for an app (or deployment slot, if specified).
     * Gets hybrid connections configured for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get hybrid connections for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RelayServiceConnectionEntityInner> listRelayServiceConnectionsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<RelayServiceConnectionEntityInner> serviceCallback) {
        return ServiceFuture.fromResponse(listRelayServiceConnectionsSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets hybrid connections configured for an app (or deployment slot, if specified).
     * Gets hybrid connections configured for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get hybrid connections for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<RelayServiceConnectionEntityInner> listRelayServiceConnectionsSlotAsync(String resourceGroupName, String name, String slot) {
        return listRelayServiceConnectionsSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<RelayServiceConnectionEntityInner>, RelayServiceConnectionEntityInner>() {
            @Override
            public RelayServiceConnectionEntityInner call(ServiceResponse<RelayServiceConnectionEntityInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets hybrid connections configured for an app (or deployment slot, if specified).
     * Gets hybrid connections configured for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get hybrid connections for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> listRelayServiceConnectionsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listRelayServiceConnectionsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RelayServiceConnectionEntityInner>>>() {
                @Override
                public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RelayServiceConnectionEntityInner> clientResponse = listRelayServiceConnectionsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RelayServiceConnectionEntityInner> listRelayServiceConnectionsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<RelayServiceConnectionEntityInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<RelayServiceConnectionEntityInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets a hybrid connection configuration by its name.
     * Gets a hybrid connection configuration by its name.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get a hybrid connection for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RelayServiceConnectionEntityInner object if successful.
     */
    public RelayServiceConnectionEntityInner getRelayServiceConnectionSlot(String resourceGroupName, String name, String entityName, String slot) {
        return getRelayServiceConnectionSlotWithServiceResponseAsync(resourceGroupName, name, entityName, slot).toBlocking().single().body();
    }

    /**
     * Gets a hybrid connection configuration by its name.
     * Gets a hybrid connection configuration by its name.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get a hybrid connection for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RelayServiceConnectionEntityInner> getRelayServiceConnectionSlotAsync(String resourceGroupName, String name, String entityName, String slot, final ServiceCallback<RelayServiceConnectionEntityInner> serviceCallback) {
        return ServiceFuture.fromResponse(getRelayServiceConnectionSlotWithServiceResponseAsync(resourceGroupName, name, entityName, slot), serviceCallback);
    }

    /**
     * Gets a hybrid connection configuration by its name.
     * Gets a hybrid connection configuration by its name.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get a hybrid connection for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<RelayServiceConnectionEntityInner> getRelayServiceConnectionSlotAsync(String resourceGroupName, String name, String entityName, String slot) {
        return getRelayServiceConnectionSlotWithServiceResponseAsync(resourceGroupName, name, entityName, slot).map(new Func1<ServiceResponse<RelayServiceConnectionEntityInner>, RelayServiceConnectionEntityInner>() {
            @Override
            public RelayServiceConnectionEntityInner call(ServiceResponse<RelayServiceConnectionEntityInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a hybrid connection configuration by its name.
     * Gets a hybrid connection configuration by its name.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get a hybrid connection for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> getRelayServiceConnectionSlotWithServiceResponseAsync(String resourceGroupName, String name, String entityName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getRelayServiceConnectionSlot(resourceGroupName, name, entityName, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RelayServiceConnectionEntityInner>>>() {
                @Override
                public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RelayServiceConnectionEntityInner> clientResponse = getRelayServiceConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RelayServiceConnectionEntityInner> getRelayServiceConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<RelayServiceConnectionEntityInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<RelayServiceConnectionEntityInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will create or update a hybrid connection for the production slot.
     * @param connectionEnvelope Details of the hybrid connection configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RelayServiceConnectionEntityInner object if successful.
     */
    public RelayServiceConnectionEntityInner createOrUpdateRelayServiceConnectionSlot(String resourceGroupName, String name, String entityName, String slot, RelayServiceConnectionEntityInner connectionEnvelope) {
        return createOrUpdateRelayServiceConnectionSlotWithServiceResponseAsync(resourceGroupName, name, entityName, slot, connectionEnvelope).toBlocking().single().body();
    }

    /**
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will create or update a hybrid connection for the production slot.
     * @param connectionEnvelope Details of the hybrid connection configuration.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RelayServiceConnectionEntityInner> createOrUpdateRelayServiceConnectionSlotAsync(String resourceGroupName, String name, String entityName, String slot, RelayServiceConnectionEntityInner connectionEnvelope, final ServiceCallback<RelayServiceConnectionEntityInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateRelayServiceConnectionSlotWithServiceResponseAsync(resourceGroupName, name, entityName, slot, connectionEnvelope), serviceCallback);
    }

    /**
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will create or update a hybrid connection for the production slot.
     * @param connectionEnvelope Details of the hybrid connection configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<RelayServiceConnectionEntityInner> createOrUpdateRelayServiceConnectionSlotAsync(String resourceGroupName, String name, String entityName, String slot, RelayServiceConnectionEntityInner connectionEnvelope) {
        return createOrUpdateRelayServiceConnectionSlotWithServiceResponseAsync(resourceGroupName, name, entityName, slot, connectionEnvelope).map(new Func1<ServiceResponse<RelayServiceConnectionEntityInner>, RelayServiceConnectionEntityInner>() {
            @Override
            public RelayServiceConnectionEntityInner call(ServiceResponse<RelayServiceConnectionEntityInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will create or update a hybrid connection for the production slot.
     * @param connectionEnvelope Details of the hybrid connection configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> createOrUpdateRelayServiceConnectionSlotWithServiceResponseAsync(String resourceGroupName, String name, String entityName, String slot, RelayServiceConnectionEntityInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        final String apiVersion = "2016-08-01";
        return service.createOrUpdateRelayServiceConnectionSlot(resourceGroupName, name, entityName, slot, this.client.subscriptionId(), connectionEnvelope, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RelayServiceConnectionEntityInner>>>() {
                @Override
                public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RelayServiceConnectionEntityInner> clientResponse = createOrUpdateRelayServiceConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RelayServiceConnectionEntityInner> createOrUpdateRelayServiceConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<RelayServiceConnectionEntityInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<RelayServiceConnectionEntityInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a relay service connection by its name.
     * Deletes a relay service connection by its name.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete a hybrid connection for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteRelayServiceConnectionSlot(String resourceGroupName, String name, String entityName, String slot) {
        deleteRelayServiceConnectionSlotWithServiceResponseAsync(resourceGroupName, name, entityName, slot).toBlocking().single().body();
    }

    /**
     * Deletes a relay service connection by its name.
     * Deletes a relay service connection by its name.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete a hybrid connection for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteRelayServiceConnectionSlotAsync(String resourceGroupName, String name, String entityName, String slot, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteRelayServiceConnectionSlotWithServiceResponseAsync(resourceGroupName, name, entityName, slot), serviceCallback);
    }

    /**
     * Deletes a relay service connection by its name.
     * Deletes a relay service connection by its name.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete a hybrid connection for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteRelayServiceConnectionSlotAsync(String resourceGroupName, String name, String entityName, String slot) {
        return deleteRelayServiceConnectionSlotWithServiceResponseAsync(resourceGroupName, name, entityName, slot).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a relay service connection by its name.
     * Deletes a relay service connection by its name.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete a hybrid connection for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteRelayServiceConnectionSlotWithServiceResponseAsync(String resourceGroupName, String name, String entityName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.deleteRelayServiceConnectionSlot(resourceGroupName, name, entityName, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteRelayServiceConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteRelayServiceConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will create or update a hybrid connection for the production slot.
     * @param connectionEnvelope Details of the hybrid connection configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RelayServiceConnectionEntityInner object if successful.
     */
    public RelayServiceConnectionEntityInner updateRelayServiceConnectionSlot(String resourceGroupName, String name, String entityName, String slot, RelayServiceConnectionEntityInner connectionEnvelope) {
        return updateRelayServiceConnectionSlotWithServiceResponseAsync(resourceGroupName, name, entityName, slot, connectionEnvelope).toBlocking().single().body();
    }

    /**
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will create or update a hybrid connection for the production slot.
     * @param connectionEnvelope Details of the hybrid connection configuration.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RelayServiceConnectionEntityInner> updateRelayServiceConnectionSlotAsync(String resourceGroupName, String name, String entityName, String slot, RelayServiceConnectionEntityInner connectionEnvelope, final ServiceCallback<RelayServiceConnectionEntityInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateRelayServiceConnectionSlotWithServiceResponseAsync(resourceGroupName, name, entityName, slot, connectionEnvelope), serviceCallback);
    }

    /**
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will create or update a hybrid connection for the production slot.
     * @param connectionEnvelope Details of the hybrid connection configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<RelayServiceConnectionEntityInner> updateRelayServiceConnectionSlotAsync(String resourceGroupName, String name, String entityName, String slot, RelayServiceConnectionEntityInner connectionEnvelope) {
        return updateRelayServiceConnectionSlotWithServiceResponseAsync(resourceGroupName, name, entityName, slot, connectionEnvelope).map(new Func1<ServiceResponse<RelayServiceConnectionEntityInner>, RelayServiceConnectionEntityInner>() {
            @Override
            public RelayServiceConnectionEntityInner call(ServiceResponse<RelayServiceConnectionEntityInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     * Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will create or update a hybrid connection for the production slot.
     * @param connectionEnvelope Details of the hybrid connection configuration.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> updateRelayServiceConnectionSlotWithServiceResponseAsync(String resourceGroupName, String name, String entityName, String slot, RelayServiceConnectionEntityInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        final String apiVersion = "2016-08-01";
        return service.updateRelayServiceConnectionSlot(resourceGroupName, name, entityName, slot, this.client.subscriptionId(), connectionEnvelope, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RelayServiceConnectionEntityInner>>>() {
                @Override
                public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RelayServiceConnectionEntityInner> clientResponse = updateRelayServiceConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RelayServiceConnectionEntityInner> updateRelayServiceConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<RelayServiceConnectionEntityInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<RelayServiceConnectionEntityInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets all scale-out instances of an app.
     * Gets all scale-out instances of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets the production slot instances.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SiteInstanceInner&gt; object if successful.
     */
    public PagedList<SiteInstanceInner> listInstanceIdentifiersSlot(final String resourceGroupName, final String name, final String slot) {
        ServiceResponse<Page<SiteInstanceInner>> response = listInstanceIdentifiersSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        return new PagedList<SiteInstanceInner>(response.body()) {
            @Override
            public Page<SiteInstanceInner> nextPage(String nextPageLink) {
                return listInstanceIdentifiersSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets all scale-out instances of an app.
     * Gets all scale-out instances of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets the production slot instances.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SiteInstanceInner>> listInstanceIdentifiersSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<SiteInstanceInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listInstanceIdentifiersSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(String nextPageLink) {
                    return listInstanceIdentifiersSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets all scale-out instances of an app.
     * Gets all scale-out instances of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets the production slot instances.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteInstanceInner&gt; object
     */
    public Observable<Page<SiteInstanceInner>> listInstanceIdentifiersSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return listInstanceIdentifiersSlotWithServiceResponseAsync(resourceGroupName, name, slot)
            .map(new Func1<ServiceResponse<Page<SiteInstanceInner>>, Page<SiteInstanceInner>>() {
                @Override
                public Page<SiteInstanceInner> call(ServiceResponse<Page<SiteInstanceInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets all scale-out instances of an app.
     * Gets all scale-out instances of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets the production slot instances.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteInstanceInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInstanceInner>>> listInstanceIdentifiersSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot) {
        return listInstanceIdentifiersSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<SiteInstanceInner>>, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(ServiceResponse<Page<SiteInstanceInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listInstanceIdentifiersSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets all scale-out instances of an app.
     * Gets all scale-out instances of an app.
     *
    ServiceResponse<PageImpl<SiteInstanceInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<SiteInstanceInner>> * @param name Name of the app.
    ServiceResponse<PageImpl<SiteInstanceInner>> * @param slot Name of the deployment slot. If a slot is not specified, the API gets the production slot instances.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SiteInstanceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInstanceInner>>> listInstanceIdentifiersSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listInstanceIdentifiersSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInstanceInner>> result = listInstanceIdentifiersSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInstanceInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteInstanceInner>> listInstanceIdentifiersSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<SiteInstanceInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SiteInstanceInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @param instanceId The ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances"
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;DeploymentInner&gt; object if successful.
     */
    public PagedList<DeploymentInner> listInstanceDeploymentsSlot(final String resourceGroupName, final String name, final String slot, final String instanceId) {
        ServiceResponse<Page<DeploymentInner>> response = listInstanceDeploymentsSlotSinglePageAsync(resourceGroupName, name, slot, instanceId).toBlocking().single();
        return new PagedList<DeploymentInner>(response.body()) {
            @Override
            public Page<DeploymentInner> nextPage(String nextPageLink) {
                return listInstanceDeploymentsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @param instanceId The ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances"
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<DeploymentInner>> listInstanceDeploymentsSlotAsync(final String resourceGroupName, final String name, final String slot, final String instanceId, final ListOperationCallback<DeploymentInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listInstanceDeploymentsSlotSinglePageAsync(resourceGroupName, name, slot, instanceId),
            new Func1<String, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(String nextPageLink) {
                    return listInstanceDeploymentsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @param instanceId The ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances"
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<Page<DeploymentInner>> listInstanceDeploymentsSlotAsync(final String resourceGroupName, final String name, final String slot, final String instanceId) {
        return listInstanceDeploymentsSlotWithServiceResponseAsync(resourceGroupName, name, slot, instanceId)
            .map(new Func1<ServiceResponse<Page<DeploymentInner>>, Page<DeploymentInner>>() {
                @Override
                public Page<DeploymentInner> call(ServiceResponse<Page<DeploymentInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
     * @param instanceId The ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances"
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> listInstanceDeploymentsSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot, final String instanceId) {
        return listInstanceDeploymentsSlotSinglePageAsync(resourceGroupName, name, slot, instanceId)
            .concatMap(new Func1<ServiceResponse<Page<DeploymentInner>>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(ServiceResponse<Page<DeploymentInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listInstanceDeploymentsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     *
    ServiceResponse<PageImpl<DeploymentInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<DeploymentInner>> * @param name Name of the app.
    ServiceResponse<PageImpl<DeploymentInner>> * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for the production slot.
    ServiceResponse<PageImpl<DeploymentInner>> * @param instanceId The ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances"
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;DeploymentInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> listInstanceDeploymentsSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot, final String instanceId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listInstanceDeploymentsSlot(resourceGroupName, name, slot, instanceId, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<DeploymentInner>> result = listInstanceDeploymentsSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<DeploymentInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<DeploymentInner>> listInstanceDeploymentsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<DeploymentInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<DeploymentInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     * Get a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets a deployment for the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances"
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the DeploymentInner object if successful.
     */
    public DeploymentInner getInstanceDeploymentSlot(String resourceGroupName, String name, String id, String slot, String instanceId) {
        return getInstanceDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot, instanceId).toBlocking().single().body();
    }

    /**
     * Get a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     * Get a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets a deployment for the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances"
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<DeploymentInner> getInstanceDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot, String instanceId, final ServiceCallback<DeploymentInner> serviceCallback) {
        return ServiceFuture.fromResponse(getInstanceDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot, instanceId), serviceCallback);
    }

    /**
     * Get a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     * Get a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets a deployment for the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances"
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeploymentInner object
     */
    public Observable<DeploymentInner> getInstanceDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot, String instanceId) {
        return getInstanceDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot, instanceId).map(new Func1<ServiceResponse<DeploymentInner>, DeploymentInner>() {
            @Override
            public DeploymentInner call(ServiceResponse<DeploymentInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     * Get a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets a deployment for the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances"
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeploymentInner object
     */
    public Observable<ServiceResponse<DeploymentInner>> getInstanceDeploymentSlotWithServiceResponseAsync(String resourceGroupName, String name, String id, String slot, String instanceId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getInstanceDeploymentSlot(resourceGroupName, name, id, slot, instanceId, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeploymentInner>>>() {
                @Override
                public Observable<ServiceResponse<DeploymentInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeploymentInner> clientResponse = getInstanceDeploymentSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DeploymentInner> getInstanceDeploymentSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<DeploymentInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<DeploymentInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Create a deployment for an app, a specific deployment slot, and/or a specific scaled-out instance.
     * Create a deployment for an app, a specific deployment slot, and/or a specific scaled-out instance.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id ID of an existing deployment.
     * @param slot Name of the deployment slot. If a slot is not specified, the API creates a deployment for the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances"
     * @param deployment Deployment details.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the DeploymentInner object if successful.
     */
    public DeploymentInner createInstanceDeploymentSlot(String resourceGroupName, String name, String id, String slot, String instanceId, DeploymentInner deployment) {
        return createInstanceDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot, instanceId, deployment).toBlocking().single().body();
    }

    /**
     * Create a deployment for an app, a specific deployment slot, and/or a specific scaled-out instance.
     * Create a deployment for an app, a specific deployment slot, and/or a specific scaled-out instance.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id ID of an existing deployment.
     * @param slot Name of the deployment slot. If a slot is not specified, the API creates a deployment for the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances"
     * @param deployment Deployment details.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<DeploymentInner> createInstanceDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot, String instanceId, DeploymentInner deployment, final ServiceCallback<DeploymentInner> serviceCallback) {
        return ServiceFuture.fromResponse(createInstanceDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot, instanceId, deployment), serviceCallback);
    }

    /**
     * Create a deployment for an app, a specific deployment slot, and/or a specific scaled-out instance.
     * Create a deployment for an app, a specific deployment slot, and/or a specific scaled-out instance.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id ID of an existing deployment.
     * @param slot Name of the deployment slot. If a slot is not specified, the API creates a deployment for the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances"
     * @param deployment Deployment details.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeploymentInner object
     */
    public Observable<DeploymentInner> createInstanceDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot, String instanceId, DeploymentInner deployment) {
        return createInstanceDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot, instanceId, deployment).map(new Func1<ServiceResponse<DeploymentInner>, DeploymentInner>() {
            @Override
            public DeploymentInner call(ServiceResponse<DeploymentInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Create a deployment for an app, a specific deployment slot, and/or a specific scaled-out instance.
     * Create a deployment for an app, a specific deployment slot, and/or a specific scaled-out instance.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id ID of an existing deployment.
     * @param slot Name of the deployment slot. If a slot is not specified, the API creates a deployment for the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances"
     * @param deployment Deployment details.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeploymentInner object
     */
    public Observable<ServiceResponse<DeploymentInner>> createInstanceDeploymentSlotWithServiceResponseAsync(String resourceGroupName, String name, String id, String slot, String instanceId, DeploymentInner deployment) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (deployment == null) {
            throw new IllegalArgumentException("Parameter deployment is required and cannot be null.");
        }
        Validator.validate(deployment);
        final String apiVersion = "2016-08-01";
        return service.createInstanceDeploymentSlot(resourceGroupName, name, id, slot, instanceId, this.client.subscriptionId(), deployment, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeploymentInner>>>() {
                @Override
                public Observable<ServiceResponse<DeploymentInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeploymentInner> clientResponse = createInstanceDeploymentSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DeploymentInner> createInstanceDeploymentSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<DeploymentInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<DeploymentInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Delete a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     * Delete a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances"
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteInstanceDeploymentSlot(String resourceGroupName, String name, String id, String slot, String instanceId) {
        deleteInstanceDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot, instanceId).toBlocking().single().body();
    }

    /**
     * Delete a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     * Delete a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances"
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteInstanceDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot, String instanceId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteInstanceDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot, instanceId), serviceCallback);
    }

    /**
     * Delete a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     * Delete a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances"
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteInstanceDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot, String instanceId) {
        return deleteInstanceDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot, instanceId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     * Delete a deployment by its ID for an app, a specific deployment slot, and/or a specific scaled-out instance.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment for the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in the JSON response from "GET api/sites/{siteName}/instances"
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteInstanceDeploymentSlotWithServiceResponseAsync(String resourceGroupName, String name, String id, String slot, String instanceId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.deleteInstanceDeploymentSlot(resourceGroupName, name, id, slot, instanceId, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteInstanceDeploymentSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteInstanceDeploymentSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Shows whether an app can be cloned to another resource group or subscription.
     * Shows whether an app can be cloned to another resource group or subscription.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. By default, this API returns information on the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteCloneabilityInner object if successful.
     */
    public SiteCloneabilityInner isCloneableSlot(String resourceGroupName, String name, String slot) {
        return isCloneableSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Shows whether an app can be cloned to another resource group or subscription.
     * Shows whether an app can be cloned to another resource group or subscription.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. By default, this API returns information on the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteCloneabilityInner> isCloneableSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<SiteCloneabilityInner> serviceCallback) {
        return ServiceFuture.fromResponse(isCloneableSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Shows whether an app can be cloned to another resource group or subscription.
     * Shows whether an app can be cloned to another resource group or subscription.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. By default, this API returns information on the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteCloneabilityInner object
     */
    public Observable<SiteCloneabilityInner> isCloneableSlotAsync(String resourceGroupName, String name, String slot) {
        return isCloneableSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<SiteCloneabilityInner>, SiteCloneabilityInner>() {
            @Override
            public SiteCloneabilityInner call(ServiceResponse<SiteCloneabilityInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Shows whether an app can be cloned to another resource group or subscription.
     * Shows whether an app can be cloned to another resource group or subscription.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. By default, this API returns information on the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteCloneabilityInner object
     */
    public Observable<ServiceResponse<SiteCloneabilityInner>> isCloneableSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.isCloneableSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteCloneabilityInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteCloneabilityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteCloneabilityInner> clientResponse = isCloneableSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteCloneabilityInner> isCloneableSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteCloneabilityInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteCloneabilityInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets all metric definitions of an app (or deployment slot, if specified).
     * Gets all metric definitions of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get metric definitions of the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ResourceMetricDefinitionInner&gt; object if successful.
     */
    public PagedList<ResourceMetricDefinitionInner> listMetricDefinitionsSlot(final String resourceGroupName, final String name, final String slot) {
        ServiceResponse<Page<ResourceMetricDefinitionInner>> response = listMetricDefinitionsSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        return new PagedList<ResourceMetricDefinitionInner>(response.body()) {
            @Override
            public Page<ResourceMetricDefinitionInner> nextPage(String nextPageLink) {
                return listMetricDefinitionsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets all metric definitions of an app (or deployment slot, if specified).
     * Gets all metric definitions of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get metric definitions of the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ResourceMetricDefinitionInner>> listMetricDefinitionsSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<ResourceMetricDefinitionInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listMetricDefinitionsSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>> call(String nextPageLink) {
                    return listMetricDefinitionsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets all metric definitions of an app (or deployment slot, if specified).
     * Gets all metric definitions of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get metric definitions of the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ResourceMetricDefinitionInner&gt; object
     */
    public Observable<Page<ResourceMetricDefinitionInner>> listMetricDefinitionsSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return listMetricDefinitionsSlotWithServiceResponseAsync(resourceGroupName, name, slot)
            .map(new Func1<ServiceResponse<Page<ResourceMetricDefinitionInner>>, Page<ResourceMetricDefinitionInner>>() {
                @Override
                public Page<ResourceMetricDefinitionInner> call(ServiceResponse<Page<ResourceMetricDefinitionInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets all metric definitions of an app (or deployment slot, if specified).
     * Gets all metric definitions of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get metric definitions of the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ResourceMetricDefinitionInner&gt; object
     */
    public Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>> listMetricDefinitionsSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot) {
        return listMetricDefinitionsSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<ResourceMetricDefinitionInner>>, Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>> call(ServiceResponse<Page<ResourceMetricDefinitionInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listMetricDefinitionsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets all metric definitions of an app (or deployment slot, if specified).
     * Gets all metric definitions of an app (or deployment slot, if specified).
     *
    ServiceResponse<PageImpl<ResourceMetricDefinitionInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<ResourceMetricDefinitionInner>> * @param name Name of the app.
    ServiceResponse<PageImpl<ResourceMetricDefinitionInner>> * @param slot Name of the deployment slot. If a slot is not specified, the API will get metric definitions of the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ResourceMetricDefinitionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>> listMetricDefinitionsSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listMetricDefinitionsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ResourceMetricDefinitionInner>> result = listMetricDefinitionsSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ResourceMetricDefinitionInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ResourceMetricDefinitionInner>> listMetricDefinitionsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ResourceMetricDefinitionInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ResourceMetricDefinitionInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get metrics of the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ResourceMetricInner&gt; object if successful.
     */
    public PagedList<ResourceMetricInner> listMetricsSlot(final String resourceGroupName, final String name, final String slot) {
        ServiceResponse<Page<ResourceMetricInner>> response = listMetricsSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        return new PagedList<ResourceMetricInner>(response.body()) {
            @Override
            public Page<ResourceMetricInner> nextPage(String nextPageLink) {
                return listMetricsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get metrics of the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ResourceMetricInner>> listMetricsSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<ResourceMetricInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listMetricsSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(String nextPageLink) {
                    return listMetricsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get metrics of the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<Page<ResourceMetricInner>> listMetricsSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return listMetricsSlotWithServiceResponseAsync(resourceGroupName, name, slot)
            .map(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Page<ResourceMetricInner>>() {
                @Override
                public Page<ResourceMetricInner> call(ServiceResponse<Page<ResourceMetricInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get metrics of the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> listMetricsSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot) {
        return listMetricsSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(ServiceResponse<Page<ResourceMetricInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listMetricsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get metrics of the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ResourceMetricInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> listMetricsSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        final Boolean details = null;
        final String filter = null;
        return service.listMetricsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), details, filter, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ResourceMetricInner>> result = listMetricsSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ResourceMetricInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get metrics of the production slot.
     * @param details Specify "true" to include metric details in the response. It is "false" by default.
     * @param filter Return only metrics specified in the filter (using OData syntax). For example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ResourceMetricInner&gt; object if successful.
     */
    public PagedList<ResourceMetricInner> listMetricsSlot(final String resourceGroupName, final String name, final String slot, final Boolean details, final String filter) {
        ServiceResponse<Page<ResourceMetricInner>> response = listMetricsSlotSinglePageAsync(resourceGroupName, name, slot, details, filter).toBlocking().single();
        return new PagedList<ResourceMetricInner>(response.body()) {
            @Override
            public Page<ResourceMetricInner> nextPage(String nextPageLink) {
                return listMetricsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get metrics of the production slot.
     * @param details Specify "true" to include metric details in the response. It is "false" by default.
     * @param filter Return only metrics specified in the filter (using OData syntax). For example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ResourceMetricInner>> listMetricsSlotAsync(final String resourceGroupName, final String name, final String slot, final Boolean details, final String filter, final ListOperationCallback<ResourceMetricInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listMetricsSlotSinglePageAsync(resourceGroupName, name, slot, details, filter),
            new Func1<String, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(String nextPageLink) {
                    return listMetricsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get metrics of the production slot.
     * @param details Specify "true" to include metric details in the response. It is "false" by default.
     * @param filter Return only metrics specified in the filter (using OData syntax). For example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<Page<ResourceMetricInner>> listMetricsSlotAsync(final String resourceGroupName, final String name, final String slot, final Boolean details, final String filter) {
        return listMetricsSlotWithServiceResponseAsync(resourceGroupName, name, slot, details, filter)
            .map(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Page<ResourceMetricInner>>() {
                @Override
                public Page<ResourceMetricInner> call(ServiceResponse<Page<ResourceMetricInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get metrics of the production slot.
     * @param details Specify "true" to include metric details in the response. It is "false" by default.
     * @param filter Return only metrics specified in the filter (using OData syntax). For example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> listMetricsSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot, final Boolean details, final String filter) {
        return listMetricsSlotSinglePageAsync(resourceGroupName, name, slot, details, filter)
            .concatMap(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(ServiceResponse<Page<ResourceMetricInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listMetricsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param name Name of the app.
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param slot Name of the deployment slot. If a slot is not specified, the API will get metrics of the production slot.
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param details Specify "true" to include metric details in the response. It is "false" by default.
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param filter Return only metrics specified in the filter (using OData syntax). For example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ResourceMetricInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> listMetricsSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot, final Boolean details, final String filter) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listMetricsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), details, filter, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ResourceMetricInner>> result = listMetricsSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ResourceMetricInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ResourceMetricInner>> listMetricsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ResourceMetricInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ResourceMetricInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Returns the status of MySql in app migration, if one is active, and whether or not MySql in app is enabled.
     * Returns the status of MySql in app migration, if one is active, and whether or not MySql in app is enabled.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param slot Name of the deployment slot
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MigrateMySqlStatusInner object if successful.
     */
    public MigrateMySqlStatusInner getMigrateMySqlStatusSlot(String resourceGroupName, String name, String slot) {
        return getMigrateMySqlStatusSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Returns the status of MySql in app migration, if one is active, and whether or not MySql in app is enabled.
     * Returns the status of MySql in app migration, if one is active, and whether or not MySql in app is enabled.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param slot Name of the deployment slot
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MigrateMySqlStatusInner> getMigrateMySqlStatusSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<MigrateMySqlStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(getMigrateMySqlStatusSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Returns the status of MySql in app migration, if one is active, and whether or not MySql in app is enabled.
     * Returns the status of MySql in app migration, if one is active, and whether or not MySql in app is enabled.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param slot Name of the deployment slot
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MigrateMySqlStatusInner object
     */
    public Observable<MigrateMySqlStatusInner> getMigrateMySqlStatusSlotAsync(String resourceGroupName, String name, String slot) {
        return getMigrateMySqlStatusSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<MigrateMySqlStatusInner>, MigrateMySqlStatusInner>() {
            @Override
            public MigrateMySqlStatusInner call(ServiceResponse<MigrateMySqlStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Returns the status of MySql in app migration, if one is active, and whether or not MySql in app is enabled.
     * Returns the status of MySql in app migration, if one is active, and whether or not MySql in app is enabled.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param slot Name of the deployment slot
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MigrateMySqlStatusInner object
     */
    public Observable<ServiceResponse<MigrateMySqlStatusInner>> getMigrateMySqlStatusSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getMigrateMySqlStatusSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<MigrateMySqlStatusInner>>>() {
                @Override
                public Observable<ServiceResponse<MigrateMySqlStatusInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<MigrateMySqlStatusInner> clientResponse = getMigrateMySqlStatusSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<MigrateMySqlStatusInner> getMigrateMySqlStatusSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<MigrateMySqlStatusInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<MigrateMySqlStatusInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets all network features used by the app (or deployment slot, if specified).
     * Gets all network features used by the app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param view The type of view. This can either be "summary" or "detailed".
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get network features for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the NetworkFeaturesInner object if successful.
     */
    public NetworkFeaturesInner listNetworkFeaturesSlot(String resourceGroupName, String name, String view, String slot) {
        return listNetworkFeaturesSlotWithServiceResponseAsync(resourceGroupName, name, view, slot).toBlocking().single().body();
    }

    /**
     * Gets all network features used by the app (or deployment slot, if specified).
     * Gets all network features used by the app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param view The type of view. This can either be "summary" or "detailed".
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get network features for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<NetworkFeaturesInner> listNetworkFeaturesSlotAsync(String resourceGroupName, String name, String view, String slot, final ServiceCallback<NetworkFeaturesInner> serviceCallback) {
        return ServiceFuture.fromResponse(listNetworkFeaturesSlotWithServiceResponseAsync(resourceGroupName, name, view, slot), serviceCallback);
    }

    /**
     * Gets all network features used by the app (or deployment slot, if specified).
     * Gets all network features used by the app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param view The type of view. This can either be "summary" or "detailed".
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get network features for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the NetworkFeaturesInner object
     */
    public Observable<NetworkFeaturesInner> listNetworkFeaturesSlotAsync(String resourceGroupName, String name, String view, String slot) {
        return listNetworkFeaturesSlotWithServiceResponseAsync(resourceGroupName, name, view, slot).map(new Func1<ServiceResponse<NetworkFeaturesInner>, NetworkFeaturesInner>() {
            @Override
            public NetworkFeaturesInner call(ServiceResponse<NetworkFeaturesInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets all network features used by the app (or deployment slot, if specified).
     * Gets all network features used by the app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param view The type of view. This can either be "summary" or "detailed".
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get network features for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the NetworkFeaturesInner object
     */
    public Observable<ServiceResponse<NetworkFeaturesInner>> listNetworkFeaturesSlotWithServiceResponseAsync(String resourceGroupName, String name, String view, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (view == null) {
            throw new IllegalArgumentException("Parameter view is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listNetworkFeaturesSlot(resourceGroupName, name, view, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<NetworkFeaturesInner>>>() {
                @Override
                public Observable<ServiceResponse<NetworkFeaturesInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<NetworkFeaturesInner> clientResponse = listNetworkFeaturesSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<NetworkFeaturesInner> listNetworkFeaturesSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<NetworkFeaturesInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<NetworkFeaturesInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Start capturing network packets for the site.
     * Start capturing network packets for the site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param slot The name of the slot for this web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the String object if successful.
     */
    public String startWebSiteNetworkTraceSlot(String resourceGroupName, String name, String slot) {
        return startWebSiteNetworkTraceSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Start capturing network packets for the site.
     * Start capturing network packets for the site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param slot The name of the slot for this web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<String> startWebSiteNetworkTraceSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<String> serviceCallback) {
        return ServiceFuture.fromResponse(startWebSiteNetworkTraceSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Start capturing network packets for the site.
     * Start capturing network packets for the site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param slot The name of the slot for this web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the String object
     */
    public Observable<String> startWebSiteNetworkTraceSlotAsync(String resourceGroupName, String name, String slot) {
        return startWebSiteNetworkTraceSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<String>, String>() {
            @Override
            public String call(ServiceResponse<String> response) {
                return response.body();
            }
        });
    }

    /**
     * Start capturing network packets for the site.
     * Start capturing network packets for the site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param slot The name of the slot for this web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the String object
     */
    public Observable<ServiceResponse<String>> startWebSiteNetworkTraceSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        final Integer durationInSeconds = null;
        final Integer maxFrameLength = null;
        final String sasUrl = null;
        return service.startWebSiteNetworkTraceSlot(resourceGroupName, name, slot, this.client.subscriptionId(), durationInSeconds, maxFrameLength, sasUrl, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<String>>>() {
                @Override
                public Observable<ServiceResponse<String>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<String> clientResponse = startWebSiteNetworkTraceSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Start capturing network packets for the site.
     * Start capturing network packets for the site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param slot The name of the slot for this web app.
     * @param durationInSeconds The duration to keep capturing in seconds.
     * @param maxFrameLength The maximum frame length in bytes (Optional).
     * @param sasUrl The Blob URL to store capture file.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the String object if successful.
     */
    public String startWebSiteNetworkTraceSlot(String resourceGroupName, String name, String slot, Integer durationInSeconds, Integer maxFrameLength, String sasUrl) {
        return startWebSiteNetworkTraceSlotWithServiceResponseAsync(resourceGroupName, name, slot, durationInSeconds, maxFrameLength, sasUrl).toBlocking().single().body();
    }

    /**
     * Start capturing network packets for the site.
     * Start capturing network packets for the site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param slot The name of the slot for this web app.
     * @param durationInSeconds The duration to keep capturing in seconds.
     * @param maxFrameLength The maximum frame length in bytes (Optional).
     * @param sasUrl The Blob URL to store capture file.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<String> startWebSiteNetworkTraceSlotAsync(String resourceGroupName, String name, String slot, Integer durationInSeconds, Integer maxFrameLength, String sasUrl, final ServiceCallback<String> serviceCallback) {
        return ServiceFuture.fromResponse(startWebSiteNetworkTraceSlotWithServiceResponseAsync(resourceGroupName, name, slot, durationInSeconds, maxFrameLength, sasUrl), serviceCallback);
    }

    /**
     * Start capturing network packets for the site.
     * Start capturing network packets for the site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param slot The name of the slot for this web app.
     * @param durationInSeconds The duration to keep capturing in seconds.
     * @param maxFrameLength The maximum frame length in bytes (Optional).
     * @param sasUrl The Blob URL to store capture file.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the String object
     */
    public Observable<String> startWebSiteNetworkTraceSlotAsync(String resourceGroupName, String name, String slot, Integer durationInSeconds, Integer maxFrameLength, String sasUrl) {
        return startWebSiteNetworkTraceSlotWithServiceResponseAsync(resourceGroupName, name, slot, durationInSeconds, maxFrameLength, sasUrl).map(new Func1<ServiceResponse<String>, String>() {
            @Override
            public String call(ServiceResponse<String> response) {
                return response.body();
            }
        });
    }

    /**
     * Start capturing network packets for the site.
     * Start capturing network packets for the site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param slot The name of the slot for this web app.
     * @param durationInSeconds The duration to keep capturing in seconds.
     * @param maxFrameLength The maximum frame length in bytes (Optional).
     * @param sasUrl The Blob URL to store capture file.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the String object
     */
    public Observable<ServiceResponse<String>> startWebSiteNetworkTraceSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, Integer durationInSeconds, Integer maxFrameLength, String sasUrl) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.startWebSiteNetworkTraceSlot(resourceGroupName, name, slot, this.client.subscriptionId(), durationInSeconds, maxFrameLength, sasUrl, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<String>>>() {
                @Override
                public Observable<ServiceResponse<String>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<String> clientResponse = startWebSiteNetworkTraceSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<String> startWebSiteNetworkTraceSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<String, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<String>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Stop ongoing capturing network packets for the site.
     * Stop ongoing capturing network packets for the site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param slot The name of the slot for this web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the String object if successful.
     */
    public String stopWebSiteNetworkTraceSlot(String resourceGroupName, String name, String slot) {
        return stopWebSiteNetworkTraceSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Stop ongoing capturing network packets for the site.
     * Stop ongoing capturing network packets for the site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param slot The name of the slot for this web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<String> stopWebSiteNetworkTraceSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<String> serviceCallback) {
        return ServiceFuture.fromResponse(stopWebSiteNetworkTraceSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Stop ongoing capturing network packets for the site.
     * Stop ongoing capturing network packets for the site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param slot The name of the slot for this web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the String object
     */
    public Observable<String> stopWebSiteNetworkTraceSlotAsync(String resourceGroupName, String name, String slot) {
        return stopWebSiteNetworkTraceSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<String>, String>() {
            @Override
            public String call(ServiceResponse<String> response) {
                return response.body();
            }
        });
    }

    /**
     * Stop ongoing capturing network packets for the site.
     * Stop ongoing capturing network packets for the site.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param slot The name of the slot for this web app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the String object
     */
    public Observable<ServiceResponse<String>> stopWebSiteNetworkTraceSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.stopWebSiteNetworkTraceSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<String>>>() {
                @Override
                public Observable<ServiceResponse<String>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<String> clientResponse = stopWebSiteNetworkTraceSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<String> stopWebSiteNetworkTraceSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<String, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<String>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Generates a new publishing password for an app (or deployment slot, if specified).
     * Generates a new publishing password for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API generate a new publishing password for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void generateNewSitePublishingPasswordSlot(String resourceGroupName, String name, String slot) {
        generateNewSitePublishingPasswordSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Generates a new publishing password for an app (or deployment slot, if specified).
     * Generates a new publishing password for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API generate a new publishing password for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> generateNewSitePublishingPasswordSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(generateNewSitePublishingPasswordSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Generates a new publishing password for an app (or deployment slot, if specified).
     * Generates a new publishing password for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API generate a new publishing password for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> generateNewSitePublishingPasswordSlotAsync(String resourceGroupName, String name, String slot) {
        return generateNewSitePublishingPasswordSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Generates a new publishing password for an app (or deployment slot, if specified).
     * Generates a new publishing password for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API generate a new publishing password for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> generateNewSitePublishingPasswordSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.generateNewSitePublishingPasswordSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = generateNewSitePublishingPasswordSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> generateNewSitePublishingPasswordSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot. **** CURRENTLY UNUSED *****
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;PerfMonResponseInner&gt; object if successful.
     */
    public PagedList<PerfMonResponseInner> listPerfMonCountersSlot(final String resourceGroupName, final String name, final String slot) {
        ServiceResponse<Page<PerfMonResponseInner>> response = listPerfMonCountersSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        return new PagedList<PerfMonResponseInner>(response.body()) {
            @Override
            public Page<PerfMonResponseInner> nextPage(String nextPageLink) {
                return listPerfMonCountersSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot. **** CURRENTLY UNUSED *****
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<PerfMonResponseInner>> listPerfMonCountersSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<PerfMonResponseInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listPerfMonCountersSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(String nextPageLink) {
                    return listPerfMonCountersSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot. **** CURRENTLY UNUSED *****
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;PerfMonResponseInner&gt; object
     */
    public Observable<Page<PerfMonResponseInner>> listPerfMonCountersSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return listPerfMonCountersSlotWithServiceResponseAsync(resourceGroupName, name, slot)
            .map(new Func1<ServiceResponse<Page<PerfMonResponseInner>>, Page<PerfMonResponseInner>>() {
                @Override
                public Page<PerfMonResponseInner> call(ServiceResponse<Page<PerfMonResponseInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot. **** CURRENTLY UNUSED *****
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;PerfMonResponseInner&gt; object
     */
    public Observable<ServiceResponse<Page<PerfMonResponseInner>>> listPerfMonCountersSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot) {
        return listPerfMonCountersSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<PerfMonResponseInner>>, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(ServiceResponse<Page<PerfMonResponseInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listPerfMonCountersSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot. **** CURRENTLY UNUSED *****
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;PerfMonResponseInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<PerfMonResponseInner>>> listPerfMonCountersSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        final String filter = null;
        return service.listPerfMonCountersSlot(resourceGroupName, name, slot, this.client.subscriptionId(), filter, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<PerfMonResponseInner>> result = listPerfMonCountersSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<PerfMonResponseInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot. **** CURRENTLY UNUSED *****
     * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;PerfMonResponseInner&gt; object if successful.
     */
    public PagedList<PerfMonResponseInner> listPerfMonCountersSlot(final String resourceGroupName, final String name, final String slot, final String filter) {
        ServiceResponse<Page<PerfMonResponseInner>> response = listPerfMonCountersSlotSinglePageAsync(resourceGroupName, name, slot, filter).toBlocking().single();
        return new PagedList<PerfMonResponseInner>(response.body()) {
            @Override
            public Page<PerfMonResponseInner> nextPage(String nextPageLink) {
                return listPerfMonCountersSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot. **** CURRENTLY UNUSED *****
     * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<PerfMonResponseInner>> listPerfMonCountersSlotAsync(final String resourceGroupName, final String name, final String slot, final String filter, final ListOperationCallback<PerfMonResponseInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listPerfMonCountersSlotSinglePageAsync(resourceGroupName, name, slot, filter),
            new Func1<String, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(String nextPageLink) {
                    return listPerfMonCountersSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot. **** CURRENTLY UNUSED *****
     * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;PerfMonResponseInner&gt; object
     */
    public Observable<Page<PerfMonResponseInner>> listPerfMonCountersSlotAsync(final String resourceGroupName, final String name, final String slot, final String filter) {
        return listPerfMonCountersSlotWithServiceResponseAsync(resourceGroupName, name, slot, filter)
            .map(new Func1<ServiceResponse<Page<PerfMonResponseInner>>, Page<PerfMonResponseInner>>() {
                @Override
                public Page<PerfMonResponseInner> call(ServiceResponse<Page<PerfMonResponseInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot. **** CURRENTLY UNUSED *****
     * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;PerfMonResponseInner&gt; object
     */
    public Observable<ServiceResponse<Page<PerfMonResponseInner>>> listPerfMonCountersSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot, final String filter) {
        return listPerfMonCountersSlotSinglePageAsync(resourceGroupName, name, slot, filter)
            .concatMap(new Func1<ServiceResponse<Page<PerfMonResponseInner>>, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(ServiceResponse<Page<PerfMonResponseInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listPerfMonCountersSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
    ServiceResponse<PageImpl<PerfMonResponseInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<PerfMonResponseInner>> * @param name Name of web app
    ServiceResponse<PageImpl<PerfMonResponseInner>> * @param slot Name of web app slot. If not specified then will default to production slot. **** CURRENTLY UNUSED *****
    ServiceResponse<PageImpl<PerfMonResponseInner>> * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;PerfMonResponseInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<PerfMonResponseInner>>> listPerfMonCountersSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot, final String filter) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listPerfMonCountersSlot(resourceGroupName, name, slot, this.client.subscriptionId(), filter, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<PerfMonResponseInner>> result = listPerfMonCountersSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<PerfMonResponseInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<PerfMonResponseInner>> listPerfMonCountersSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<PerfMonResponseInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<PerfMonResponseInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets web app's event logs.
     * Gets web app's event logs.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SitePhpErrorLogFlagInner object if successful.
     */
    public SitePhpErrorLogFlagInner getSitePhpErrorLogFlagSlot(String resourceGroupName, String name, String slot) {
        return getSitePhpErrorLogFlagSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Gets web app's event logs.
     * Gets web app's event logs.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SitePhpErrorLogFlagInner> getSitePhpErrorLogFlagSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<SitePhpErrorLogFlagInner> serviceCallback) {
        return ServiceFuture.fromResponse(getSitePhpErrorLogFlagSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets web app's event logs.
     * Gets web app's event logs.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SitePhpErrorLogFlagInner object
     */
    public Observable<SitePhpErrorLogFlagInner> getSitePhpErrorLogFlagSlotAsync(String resourceGroupName, String name, String slot) {
        return getSitePhpErrorLogFlagSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<SitePhpErrorLogFlagInner>, SitePhpErrorLogFlagInner>() {
            @Override
            public SitePhpErrorLogFlagInner call(ServiceResponse<SitePhpErrorLogFlagInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets web app's event logs.
     * Gets web app's event logs.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SitePhpErrorLogFlagInner object
     */
    public Observable<ServiceResponse<SitePhpErrorLogFlagInner>> getSitePhpErrorLogFlagSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getSitePhpErrorLogFlagSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SitePhpErrorLogFlagInner>>>() {
                @Override
                public Observable<ServiceResponse<SitePhpErrorLogFlagInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SitePhpErrorLogFlagInner> clientResponse = getSitePhpErrorLogFlagSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SitePhpErrorLogFlagInner> getSitePhpErrorLogFlagSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SitePhpErrorLogFlagInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SitePhpErrorLogFlagInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the premier add-ons of an app.
     * Gets the premier add-ons of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the premier add-ons for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PremierAddOnInner object if successful.
     */
    public PremierAddOnInner listPremierAddOnsSlot(String resourceGroupName, String name, String slot) {
        return listPremierAddOnsSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Gets the premier add-ons of an app.
     * Gets the premier add-ons of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the premier add-ons for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PremierAddOnInner> listPremierAddOnsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<PremierAddOnInner> serviceCallback) {
        return ServiceFuture.fromResponse(listPremierAddOnsSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the premier add-ons of an app.
     * Gets the premier add-ons of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the premier add-ons for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PremierAddOnInner object
     */
    public Observable<PremierAddOnInner> listPremierAddOnsSlotAsync(String resourceGroupName, String name, String slot) {
        return listPremierAddOnsSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<PremierAddOnInner>, PremierAddOnInner>() {
            @Override
            public PremierAddOnInner call(ServiceResponse<PremierAddOnInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the premier add-ons of an app.
     * Gets the premier add-ons of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the premier add-ons for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PremierAddOnInner object
     */
    public Observable<ServiceResponse<PremierAddOnInner>> listPremierAddOnsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listPremierAddOnsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PremierAddOnInner>>>() {
                @Override
                public Observable<ServiceResponse<PremierAddOnInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PremierAddOnInner> clientResponse = listPremierAddOnsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PremierAddOnInner> listPremierAddOnsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PremierAddOnInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PremierAddOnInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets a named add-on of an app.
     * Gets a named add-on of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the named add-on for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PremierAddOnInner object if successful.
     */
    public PremierAddOnInner getPremierAddOnSlot(String resourceGroupName, String name, String premierAddOnName, String slot) {
        return getPremierAddOnSlotWithServiceResponseAsync(resourceGroupName, name, premierAddOnName, slot).toBlocking().single().body();
    }

    /**
     * Gets a named add-on of an app.
     * Gets a named add-on of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the named add-on for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PremierAddOnInner> getPremierAddOnSlotAsync(String resourceGroupName, String name, String premierAddOnName, String slot, final ServiceCallback<PremierAddOnInner> serviceCallback) {
        return ServiceFuture.fromResponse(getPremierAddOnSlotWithServiceResponseAsync(resourceGroupName, name, premierAddOnName, slot), serviceCallback);
    }

    /**
     * Gets a named add-on of an app.
     * Gets a named add-on of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the named add-on for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PremierAddOnInner object
     */
    public Observable<PremierAddOnInner> getPremierAddOnSlotAsync(String resourceGroupName, String name, String premierAddOnName, String slot) {
        return getPremierAddOnSlotWithServiceResponseAsync(resourceGroupName, name, premierAddOnName, slot).map(new Func1<ServiceResponse<PremierAddOnInner>, PremierAddOnInner>() {
            @Override
            public PremierAddOnInner call(ServiceResponse<PremierAddOnInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a named add-on of an app.
     * Gets a named add-on of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the named add-on for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PremierAddOnInner object
     */
    public Observable<ServiceResponse<PremierAddOnInner>> getPremierAddOnSlotWithServiceResponseAsync(String resourceGroupName, String name, String premierAddOnName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (premierAddOnName == null) {
            throw new IllegalArgumentException("Parameter premierAddOnName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getPremierAddOnSlot(resourceGroupName, name, premierAddOnName, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PremierAddOnInner>>>() {
                @Override
                public Observable<ServiceResponse<PremierAddOnInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PremierAddOnInner> clientResponse = getPremierAddOnSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PremierAddOnInner> getPremierAddOnSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PremierAddOnInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PremierAddOnInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates a named add-on of an app.
     * Updates a named add-on of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the named add-on for the production slot.
     * @param premierAddOn A JSON representation of the edited premier add-on.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PremierAddOnInner object if successful.
     */
    public PremierAddOnInner addPremierAddOnSlot(String resourceGroupName, String name, String premierAddOnName, String slot, PremierAddOnInner premierAddOn) {
        return addPremierAddOnSlotWithServiceResponseAsync(resourceGroupName, name, premierAddOnName, slot, premierAddOn).toBlocking().single().body();
    }

    /**
     * Updates a named add-on of an app.
     * Updates a named add-on of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the named add-on for the production slot.
     * @param premierAddOn A JSON representation of the edited premier add-on.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PremierAddOnInner> addPremierAddOnSlotAsync(String resourceGroupName, String name, String premierAddOnName, String slot, PremierAddOnInner premierAddOn, final ServiceCallback<PremierAddOnInner> serviceCallback) {
        return ServiceFuture.fromResponse(addPremierAddOnSlotWithServiceResponseAsync(resourceGroupName, name, premierAddOnName, slot, premierAddOn), serviceCallback);
    }

    /**
     * Updates a named add-on of an app.
     * Updates a named add-on of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the named add-on for the production slot.
     * @param premierAddOn A JSON representation of the edited premier add-on.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PremierAddOnInner object
     */
    public Observable<PremierAddOnInner> addPremierAddOnSlotAsync(String resourceGroupName, String name, String premierAddOnName, String slot, PremierAddOnInner premierAddOn) {
        return addPremierAddOnSlotWithServiceResponseAsync(resourceGroupName, name, premierAddOnName, slot, premierAddOn).map(new Func1<ServiceResponse<PremierAddOnInner>, PremierAddOnInner>() {
            @Override
            public PremierAddOnInner call(ServiceResponse<PremierAddOnInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates a named add-on of an app.
     * Updates a named add-on of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the named add-on for the production slot.
     * @param premierAddOn A JSON representation of the edited premier add-on.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PremierAddOnInner object
     */
    public Observable<ServiceResponse<PremierAddOnInner>> addPremierAddOnSlotWithServiceResponseAsync(String resourceGroupName, String name, String premierAddOnName, String slot, PremierAddOnInner premierAddOn) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (premierAddOnName == null) {
            throw new IllegalArgumentException("Parameter premierAddOnName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (premierAddOn == null) {
            throw new IllegalArgumentException("Parameter premierAddOn is required and cannot be null.");
        }
        Validator.validate(premierAddOn);
        final String apiVersion = "2016-08-01";
        return service.addPremierAddOnSlot(resourceGroupName, name, premierAddOnName, slot, this.client.subscriptionId(), premierAddOn, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PremierAddOnInner>>>() {
                @Override
                public Observable<ServiceResponse<PremierAddOnInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PremierAddOnInner> clientResponse = addPremierAddOnSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PremierAddOnInner> addPremierAddOnSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PremierAddOnInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PremierAddOnInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Delete a premier add-on from an app.
     * Delete a premier add-on from an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the named add-on for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deletePremierAddOnSlot(String resourceGroupName, String name, String premierAddOnName, String slot) {
        deletePremierAddOnSlotWithServiceResponseAsync(resourceGroupName, name, premierAddOnName, slot).toBlocking().single().body();
    }

    /**
     * Delete a premier add-on from an app.
     * Delete a premier add-on from an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the named add-on for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deletePremierAddOnSlotAsync(String resourceGroupName, String name, String premierAddOnName, String slot, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deletePremierAddOnSlotWithServiceResponseAsync(resourceGroupName, name, premierAddOnName, slot), serviceCallback);
    }

    /**
     * Delete a premier add-on from an app.
     * Delete a premier add-on from an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the named add-on for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deletePremierAddOnSlotAsync(String resourceGroupName, String name, String premierAddOnName, String slot) {
        return deletePremierAddOnSlotWithServiceResponseAsync(resourceGroupName, name, premierAddOnName, slot).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete a premier add-on from an app.
     * Delete a premier add-on from an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the named add-on for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deletePremierAddOnSlotWithServiceResponseAsync(String resourceGroupName, String name, String premierAddOnName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (premierAddOnName == null) {
            throw new IllegalArgumentException("Parameter premierAddOnName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.deletePremierAddOnSlot(resourceGroupName, name, premierAddOnName, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deletePremierAddOnSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deletePremierAddOnSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the publishing profile for an app (or deployment slot, if specified).
     * Gets the publishing profile for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the publishing profile for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the InputStream object if successful.
     */
    public InputStream listPublishingProfileXmlWithSecretsSlot(String resourceGroupName, String name, String slot) {
        return listPublishingProfileXmlWithSecretsSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Gets the publishing profile for an app (or deployment slot, if specified).
     * Gets the publishing profile for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the publishing profile for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<InputStream> listPublishingProfileXmlWithSecretsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<InputStream> serviceCallback) {
        return ServiceFuture.fromResponse(listPublishingProfileXmlWithSecretsSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the publishing profile for an app (or deployment slot, if specified).
     * Gets the publishing profile for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the publishing profile for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the InputStream object
     */
    public Observable<InputStream> listPublishingProfileXmlWithSecretsSlotAsync(String resourceGroupName, String name, String slot) {
        return listPublishingProfileXmlWithSecretsSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<InputStream>, InputStream>() {
            @Override
            public InputStream call(ServiceResponse<InputStream> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the publishing profile for an app (or deployment slot, if specified).
     * Gets the publishing profile for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the publishing profile for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the InputStream object
     */
    public Observable<ServiceResponse<InputStream>> listPublishingProfileXmlWithSecretsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        final PublishingProfileFormat format = null;
        CsmPublishingProfileOptions publishingProfileOptions = new CsmPublishingProfileOptions();
        publishingProfileOptions.withFormat(null);
        return service.listPublishingProfileXmlWithSecretsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), publishingProfileOptions, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<InputStream>>>() {
                @Override
                public Observable<ServiceResponse<InputStream>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<InputStream> clientResponse = listPublishingProfileXmlWithSecretsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the publishing profile for an app (or deployment slot, if specified).
     * Gets the publishing profile for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the publishing profile for the production slot.
     * @param format Name of the format. Valid values are:
      FileZilla3
      WebDeploy -- default
      Ftp. Possible values include: 'FileZilla3', 'WebDeploy', 'Ftp'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the InputStream object if successful.
     */
    public InputStream listPublishingProfileXmlWithSecretsSlot(String resourceGroupName, String name, String slot, PublishingProfileFormat format) {
        return listPublishingProfileXmlWithSecretsSlotWithServiceResponseAsync(resourceGroupName, name, slot, format).toBlocking().single().body();
    }

    /**
     * Gets the publishing profile for an app (or deployment slot, if specified).
     * Gets the publishing profile for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the publishing profile for the production slot.
     * @param format Name of the format. Valid values are:
      FileZilla3
      WebDeploy -- default
      Ftp. Possible values include: 'FileZilla3', 'WebDeploy', 'Ftp'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<InputStream> listPublishingProfileXmlWithSecretsSlotAsync(String resourceGroupName, String name, String slot, PublishingProfileFormat format, final ServiceCallback<InputStream> serviceCallback) {
        return ServiceFuture.fromResponse(listPublishingProfileXmlWithSecretsSlotWithServiceResponseAsync(resourceGroupName, name, slot, format), serviceCallback);
    }

    /**
     * Gets the publishing profile for an app (or deployment slot, if specified).
     * Gets the publishing profile for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the publishing profile for the production slot.
     * @param format Name of the format. Valid values are:
      FileZilla3
      WebDeploy -- default
      Ftp. Possible values include: 'FileZilla3', 'WebDeploy', 'Ftp'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the InputStream object
     */
    public Observable<InputStream> listPublishingProfileXmlWithSecretsSlotAsync(String resourceGroupName, String name, String slot, PublishingProfileFormat format) {
        return listPublishingProfileXmlWithSecretsSlotWithServiceResponseAsync(resourceGroupName, name, slot, format).map(new Func1<ServiceResponse<InputStream>, InputStream>() {
            @Override
            public InputStream call(ServiceResponse<InputStream> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the publishing profile for an app (or deployment slot, if specified).
     * Gets the publishing profile for an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the publishing profile for the production slot.
     * @param format Name of the format. Valid values are:
      FileZilla3
      WebDeploy -- default
      Ftp. Possible values include: 'FileZilla3', 'WebDeploy', 'Ftp'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the InputStream object
     */
    public Observable<ServiceResponse<InputStream>> listPublishingProfileXmlWithSecretsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, PublishingProfileFormat format) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        CsmPublishingProfileOptions publishingProfileOptions = new CsmPublishingProfileOptions();
        publishingProfileOptions.withFormat(format);
        return service.listPublishingProfileXmlWithSecretsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), publishingProfileOptions, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<InputStream>>>() {
                @Override
                public Observable<ServiceResponse<InputStream>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<InputStream> clientResponse = listPublishingProfileXmlWithSecretsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<InputStream> listPublishingProfileXmlWithSecretsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<InputStream, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<InputStream>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Recovers a deleted web app.
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RecoverResponseInner object if successful.
     */
    public RecoverResponseInner recoverSlot(String resourceGroupName, String name, String slot, CsmSiteRecoveryEntityInner recoveryEntity) {
        return recoverSlotWithServiceResponseAsync(resourceGroupName, name, slot, recoveryEntity).toBlocking().last().body();
    }

    /**
     * Recovers a deleted web app.
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RecoverResponseInner> recoverSlotAsync(String resourceGroupName, String name, String slot, CsmSiteRecoveryEntityInner recoveryEntity, final ServiceCallback<RecoverResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(recoverSlotWithServiceResponseAsync(resourceGroupName, name, slot, recoveryEntity), serviceCallback);
    }

    /**
     * Recovers a deleted web app.
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<RecoverResponseInner> recoverSlotAsync(String resourceGroupName, String name, String slot, CsmSiteRecoveryEntityInner recoveryEntity) {
        return recoverSlotWithServiceResponseAsync(resourceGroupName, name, slot, recoveryEntity).map(new Func1<ServiceResponse<RecoverResponseInner>, RecoverResponseInner>() {
            @Override
            public RecoverResponseInner call(ServiceResponse<RecoverResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Recovers a deleted web app.
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<RecoverResponseInner>> recoverSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, CsmSiteRecoveryEntityInner recoveryEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (recoveryEntity == null) {
            throw new IllegalArgumentException("Parameter recoveryEntity is required and cannot be null.");
        }
        Validator.validate(recoveryEntity);
        final String apiVersion = "2016-08-01";
        Observable<Response<ResponseBody>> observable = service.recoverSlot(resourceGroupName, name, slot, this.client.subscriptionId(), recoveryEntity, apiVersion, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<RecoverResponseInner>() { }.getType());
    }

    /**
     * Recovers a deleted web app.
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RecoverResponseInner object if successful.
     */
    public RecoverResponseInner beginRecoverSlot(String resourceGroupName, String name, String slot, CsmSiteRecoveryEntityInner recoveryEntity) {
        return beginRecoverSlotWithServiceResponseAsync(resourceGroupName, name, slot, recoveryEntity).toBlocking().single().body();
    }

    /**
     * Recovers a deleted web app.
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RecoverResponseInner> beginRecoverSlotAsync(String resourceGroupName, String name, String slot, CsmSiteRecoveryEntityInner recoveryEntity, final ServiceCallback<RecoverResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginRecoverSlotWithServiceResponseAsync(resourceGroupName, name, slot, recoveryEntity), serviceCallback);
    }

    /**
     * Recovers a deleted web app.
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RecoverResponseInner object
     */
    public Observable<RecoverResponseInner> beginRecoverSlotAsync(String resourceGroupName, String name, String slot, CsmSiteRecoveryEntityInner recoveryEntity) {
        return beginRecoverSlotWithServiceResponseAsync(resourceGroupName, name, slot, recoveryEntity).map(new Func1<ServiceResponse<RecoverResponseInner>, RecoverResponseInner>() {
            @Override
            public RecoverResponseInner call(ServiceResponse<RecoverResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Recovers a deleted web app.
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RecoverResponseInner object
     */
    public Observable<ServiceResponse<RecoverResponseInner>> beginRecoverSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, CsmSiteRecoveryEntityInner recoveryEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (recoveryEntity == null) {
            throw new IllegalArgumentException("Parameter recoveryEntity is required and cannot be null.");
        }
        Validator.validate(recoveryEntity);
        final String apiVersion = "2016-08-01";
        return service.beginRecoverSlot(resourceGroupName, name, slot, this.client.subscriptionId(), recoveryEntity, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RecoverResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<RecoverResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RecoverResponseInner> clientResponse = beginRecoverSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RecoverResponseInner> beginRecoverSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<RecoverResponseInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<RecoverResponseInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Resets the configuration settings of the current slot if they were previously modified by calling the API with POST.
     * Resets the configuration settings of the current slot if they were previously modified by calling the API with POST.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API resets configuration settings for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void resetSlotConfigurationSlot(String resourceGroupName, String name, String slot) {
        resetSlotConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Resets the configuration settings of the current slot if they were previously modified by calling the API with POST.
     * Resets the configuration settings of the current slot if they were previously modified by calling the API with POST.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API resets configuration settings for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> resetSlotConfigurationSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(resetSlotConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Resets the configuration settings of the current slot if they were previously modified by calling the API with POST.
     * Resets the configuration settings of the current slot if they were previously modified by calling the API with POST.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API resets configuration settings for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> resetSlotConfigurationSlotAsync(String resourceGroupName, String name, String slot) {
        return resetSlotConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Resets the configuration settings of the current slot if they were previously modified by calling the API with POST.
     * Resets the configuration settings of the current slot if they were previously modified by calling the API with POST.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API resets configuration settings for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> resetSlotConfigurationSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.resetSlotConfigurationSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = resetSlotConfigurationSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> resetSlotConfigurationSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Restarts an app (or deployment slot, if specified).
     * Restarts an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will restart the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void restartSlot(String resourceGroupName, String name, String slot) {
        restartSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Restarts an app (or deployment slot, if specified).
     * Restarts an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will restart the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> restartSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(restartSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Restarts an app (or deployment slot, if specified).
     * Restarts an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will restart the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> restartSlotAsync(String resourceGroupName, String name, String slot) {
        return restartSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Restarts an app (or deployment slot, if specified).
     * Restarts an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will restart the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> restartSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        final Boolean softRestart = null;
        final Boolean synchronous = null;
        return service.restartSlot(resourceGroupName, name, slot, this.client.subscriptionId(), softRestart, synchronous, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = restartSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Restarts an app (or deployment slot, if specified).
     * Restarts an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will restart the production slot.
     * @param softRestart Specify true to apply the configuration settings and restarts the app only if necessary. By default, the API always restarts and reprovisions the app.
     * @param synchronous Specify true to block until the app is restarted. By default, it is set to false, and the API responds immediately (asynchronous).
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void restartSlot(String resourceGroupName, String name, String slot, Boolean softRestart, Boolean synchronous) {
        restartSlotWithServiceResponseAsync(resourceGroupName, name, slot, softRestart, synchronous).toBlocking().single().body();
    }

    /**
     * Restarts an app (or deployment slot, if specified).
     * Restarts an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will restart the production slot.
     * @param softRestart Specify true to apply the configuration settings and restarts the app only if necessary. By default, the API always restarts and reprovisions the app.
     * @param synchronous Specify true to block until the app is restarted. By default, it is set to false, and the API responds immediately (asynchronous).
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> restartSlotAsync(String resourceGroupName, String name, String slot, Boolean softRestart, Boolean synchronous, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(restartSlotWithServiceResponseAsync(resourceGroupName, name, slot, softRestart, synchronous), serviceCallback);
    }

    /**
     * Restarts an app (or deployment slot, if specified).
     * Restarts an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will restart the production slot.
     * @param softRestart Specify true to apply the configuration settings and restarts the app only if necessary. By default, the API always restarts and reprovisions the app.
     * @param synchronous Specify true to block until the app is restarted. By default, it is set to false, and the API responds immediately (asynchronous).
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> restartSlotAsync(String resourceGroupName, String name, String slot, Boolean softRestart, Boolean synchronous) {
        return restartSlotWithServiceResponseAsync(resourceGroupName, name, slot, softRestart, synchronous).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Restarts an app (or deployment slot, if specified).
     * Restarts an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will restart the production slot.
     * @param softRestart Specify true to apply the configuration settings and restarts the app only if necessary. By default, the API always restarts and reprovisions the app.
     * @param synchronous Specify true to block until the app is restarted. By default, it is set to false, and the API responds immediately (asynchronous).
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> restartSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, Boolean softRestart, Boolean synchronous) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.restartSlot(resourceGroupName, name, slot, this.client.subscriptionId(), softRestart, synchronous, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = restartSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> restartSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the source slot. If a slot is not specified, the production slot is used as the source slot.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SlotDifferenceInner&gt; object if successful.
     */
    public PagedList<SlotDifferenceInner> listSlotDifferencesSlot(final String resourceGroupName, final String name, final String slot, final CsmSlotEntityInner slotSwapEntity) {
        ServiceResponse<Page<SlotDifferenceInner>> response = listSlotDifferencesSlotSinglePageAsync(resourceGroupName, name, slot, slotSwapEntity).toBlocking().single();
        return new PagedList<SlotDifferenceInner>(response.body()) {
            @Override
            public Page<SlotDifferenceInner> nextPage(String nextPageLink) {
                return listSlotDifferencesSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the source slot. If a slot is not specified, the production slot is used as the source slot.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SlotDifferenceInner>> listSlotDifferencesSlotAsync(final String resourceGroupName, final String name, final String slot, final CsmSlotEntityInner slotSwapEntity, final ListOperationCallback<SlotDifferenceInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listSlotDifferencesSlotSinglePageAsync(resourceGroupName, name, slot, slotSwapEntity),
            new Func1<String, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(String nextPageLink) {
                    return listSlotDifferencesSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the source slot. If a slot is not specified, the production slot is used as the source slot.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SlotDifferenceInner&gt; object
     */
    public Observable<Page<SlotDifferenceInner>> listSlotDifferencesSlotAsync(final String resourceGroupName, final String name, final String slot, final CsmSlotEntityInner slotSwapEntity) {
        return listSlotDifferencesSlotWithServiceResponseAsync(resourceGroupName, name, slot, slotSwapEntity)
            .map(new Func1<ServiceResponse<Page<SlotDifferenceInner>>, Page<SlotDifferenceInner>>() {
                @Override
                public Page<SlotDifferenceInner> call(ServiceResponse<Page<SlotDifferenceInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the source slot. If a slot is not specified, the production slot is used as the source slot.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SlotDifferenceInner&gt; object
     */
    public Observable<ServiceResponse<Page<SlotDifferenceInner>>> listSlotDifferencesSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot, final CsmSlotEntityInner slotSwapEntity) {
        return listSlotDifferencesSlotSinglePageAsync(resourceGroupName, name, slot, slotSwapEntity)
            .concatMap(new Func1<ServiceResponse<Page<SlotDifferenceInner>>, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(ServiceResponse<Page<SlotDifferenceInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listSlotDifferencesSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
    ServiceResponse<PageImpl<SlotDifferenceInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<SlotDifferenceInner>> * @param name Name of the app.
    ServiceResponse<PageImpl<SlotDifferenceInner>> * @param slot Name of the source slot. If a slot is not specified, the production slot is used as the source slot.
    ServiceResponse<PageImpl<SlotDifferenceInner>> * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SlotDifferenceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SlotDifferenceInner>>> listSlotDifferencesSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot, final CsmSlotEntityInner slotSwapEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (slotSwapEntity == null) {
            throw new IllegalArgumentException("Parameter slotSwapEntity is required and cannot be null.");
        }
        Validator.validate(slotSwapEntity);
        final String apiVersion = "2016-08-01";
        return service.listSlotDifferencesSlot(resourceGroupName, name, slot, this.client.subscriptionId(), slotSwapEntity, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SlotDifferenceInner>> result = listSlotDifferencesSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SlotDifferenceInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SlotDifferenceInner>> listSlotDifferencesSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<SlotDifferenceInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SlotDifferenceInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Swaps two deployment slots of an app.
     * Swaps two deployment slots of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the source slot. If a slot is not specified, the production slot is used as the source slot.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void swapSlotSlot(String resourceGroupName, String name, String slot, CsmSlotEntityInner slotSwapEntity) {
        swapSlotSlotWithServiceResponseAsync(resourceGroupName, name, slot, slotSwapEntity).toBlocking().last().body();
    }

    /**
     * Swaps two deployment slots of an app.
     * Swaps two deployment slots of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the source slot. If a slot is not specified, the production slot is used as the source slot.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> swapSlotSlotAsync(String resourceGroupName, String name, String slot, CsmSlotEntityInner slotSwapEntity, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(swapSlotSlotWithServiceResponseAsync(resourceGroupName, name, slot, slotSwapEntity), serviceCallback);
    }

    /**
     * Swaps two deployment slots of an app.
     * Swaps two deployment slots of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the source slot. If a slot is not specified, the production slot is used as the source slot.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<Void> swapSlotSlotAsync(String resourceGroupName, String name, String slot, CsmSlotEntityInner slotSwapEntity) {
        return swapSlotSlotWithServiceResponseAsync(resourceGroupName, name, slot, slotSwapEntity).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Swaps two deployment slots of an app.
     * Swaps two deployment slots of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the source slot. If a slot is not specified, the production slot is used as the source slot.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<Void>> swapSlotSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, CsmSlotEntityInner slotSwapEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (slotSwapEntity == null) {
            throw new IllegalArgumentException("Parameter slotSwapEntity is required and cannot be null.");
        }
        Validator.validate(slotSwapEntity);
        final String apiVersion = "2016-08-01";
        Observable<Response<ResponseBody>> observable = service.swapSlotSlot(resourceGroupName, name, slot, this.client.subscriptionId(), slotSwapEntity, apiVersion, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<Void>() { }.getType());
    }

    /**
     * Swaps two deployment slots of an app.
     * Swaps two deployment slots of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the source slot. If a slot is not specified, the production slot is used as the source slot.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void beginSwapSlotSlot(String resourceGroupName, String name, String slot, CsmSlotEntityInner slotSwapEntity) {
        beginSwapSlotSlotWithServiceResponseAsync(resourceGroupName, name, slot, slotSwapEntity).toBlocking().single().body();
    }

    /**
     * Swaps two deployment slots of an app.
     * Swaps two deployment slots of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the source slot. If a slot is not specified, the production slot is used as the source slot.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> beginSwapSlotSlotAsync(String resourceGroupName, String name, String slot, CsmSlotEntityInner slotSwapEntity, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(beginSwapSlotSlotWithServiceResponseAsync(resourceGroupName, name, slot, slotSwapEntity), serviceCallback);
    }

    /**
     * Swaps two deployment slots of an app.
     * Swaps two deployment slots of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the source slot. If a slot is not specified, the production slot is used as the source slot.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> beginSwapSlotSlotAsync(String resourceGroupName, String name, String slot, CsmSlotEntityInner slotSwapEntity) {
        return beginSwapSlotSlotWithServiceResponseAsync(resourceGroupName, name, slot, slotSwapEntity).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Swaps two deployment slots of an app.
     * Swaps two deployment slots of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the source slot. If a slot is not specified, the production slot is used as the source slot.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> beginSwapSlotSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, CsmSlotEntityInner slotSwapEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (slotSwapEntity == null) {
            throw new IllegalArgumentException("Parameter slotSwapEntity is required and cannot be null.");
        }
        Validator.validate(slotSwapEntity);
        final String apiVersion = "2016-08-01";
        return service.beginSwapSlotSlot(resourceGroupName, name, slot, this.client.subscriptionId(), slotSwapEntity, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = beginSwapSlotSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> beginSwapSlotSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Website Name
     * @param slot Website Slot
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SnapshotInner&gt; object if successful.
     */
    public PagedList<SnapshotInner> listSnapshotsSlot(final String resourceGroupName, final String name, final String slot) {
        ServiceResponse<Page<SnapshotInner>> response = listSnapshotsSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        return new PagedList<SnapshotInner>(response.body()) {
            @Override
            public Page<SnapshotInner> nextPage(String nextPageLink) {
                return listSnapshotsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Website Name
     * @param slot Website Slot
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SnapshotInner>> listSnapshotsSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<SnapshotInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listSnapshotsSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<SnapshotInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SnapshotInner>>> call(String nextPageLink) {
                    return listSnapshotsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Website Name
     * @param slot Website Slot
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SnapshotInner&gt; object
     */
    public Observable<Page<SnapshotInner>> listSnapshotsSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return listSnapshotsSlotWithServiceResponseAsync(resourceGroupName, name, slot)
            .map(new Func1<ServiceResponse<Page<SnapshotInner>>, Page<SnapshotInner>>() {
                @Override
                public Page<SnapshotInner> call(ServiceResponse<Page<SnapshotInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Website Name
     * @param slot Website Slot
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SnapshotInner&gt; object
     */
    public Observable<ServiceResponse<Page<SnapshotInner>>> listSnapshotsSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot) {
        return listSnapshotsSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<SnapshotInner>>, Observable<ServiceResponse<Page<SnapshotInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SnapshotInner>>> call(ServiceResponse<Page<SnapshotInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listSnapshotsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
    ServiceResponse<PageImpl<SnapshotInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<SnapshotInner>> * @param name Website Name
    ServiceResponse<PageImpl<SnapshotInner>> * @param slot Website Slot
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SnapshotInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SnapshotInner>>> listSnapshotsSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listSnapshotsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SnapshotInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SnapshotInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SnapshotInner>> result = listSnapshotsSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SnapshotInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SnapshotInner>> listSnapshotsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<SnapshotInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SnapshotInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the source control configuration of an app.
     * Gets the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the source control configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteSourceControlInner object if successful.
     */
    public SiteSourceControlInner getSourceControlSlot(String resourceGroupName, String name, String slot) {
        return getSourceControlSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Gets the source control configuration of an app.
     * Gets the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the source control configuration for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteSourceControlInner> getSourceControlSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<SiteSourceControlInner> serviceCallback) {
        return ServiceFuture.fromResponse(getSourceControlSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the source control configuration of an app.
     * Gets the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the source control configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteSourceControlInner object
     */
    public Observable<SiteSourceControlInner> getSourceControlSlotAsync(String resourceGroupName, String name, String slot) {
        return getSourceControlSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<SiteSourceControlInner>, SiteSourceControlInner>() {
            @Override
            public SiteSourceControlInner call(ServiceResponse<SiteSourceControlInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the source control configuration of an app.
     * Gets the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the source control configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteSourceControlInner object
     */
    public Observable<ServiceResponse<SiteSourceControlInner>> getSourceControlSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getSourceControlSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteSourceControlInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteSourceControlInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteSourceControlInner> clientResponse = getSourceControlSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteSourceControlInner> getSourceControlSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteSourceControlInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteSourceControlInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the source control configuration of an app.
     * Updates the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the source control configuration for the production slot.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteSourceControlInner object if successful.
     */
    public SiteSourceControlInner createOrUpdateSourceControlSlot(String resourceGroupName, String name, String slot, SiteSourceControlInner siteSourceControl) {
        return createOrUpdateSourceControlSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteSourceControl).toBlocking().last().body();
    }

    /**
     * Updates the source control configuration of an app.
     * Updates the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the source control configuration for the production slot.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteSourceControlInner> createOrUpdateSourceControlSlotAsync(String resourceGroupName, String name, String slot, SiteSourceControlInner siteSourceControl, final ServiceCallback<SiteSourceControlInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateSourceControlSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteSourceControl), serviceCallback);
    }

    /**
     * Updates the source control configuration of an app.
     * Updates the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the source control configuration for the production slot.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<SiteSourceControlInner> createOrUpdateSourceControlSlotAsync(String resourceGroupName, String name, String slot, SiteSourceControlInner siteSourceControl) {
        return createOrUpdateSourceControlSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteSourceControl).map(new Func1<ServiceResponse<SiteSourceControlInner>, SiteSourceControlInner>() {
            @Override
            public SiteSourceControlInner call(ServiceResponse<SiteSourceControlInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the source control configuration of an app.
     * Updates the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the source control configuration for the production slot.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<SiteSourceControlInner>> createOrUpdateSourceControlSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, SiteSourceControlInner siteSourceControl) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteSourceControl == null) {
            throw new IllegalArgumentException("Parameter siteSourceControl is required and cannot be null.");
        }
        Validator.validate(siteSourceControl);
        final String apiVersion = "2016-08-01";
        Observable<Response<ResponseBody>> observable = service.createOrUpdateSourceControlSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteSourceControl, apiVersion, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultAsync(observable, new TypeToken<SiteSourceControlInner>() { }.getType());
    }

    /**
     * Updates the source control configuration of an app.
     * Updates the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the source control configuration for the production slot.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteSourceControlInner object if successful.
     */
    public SiteSourceControlInner beginCreateOrUpdateSourceControlSlot(String resourceGroupName, String name, String slot, SiteSourceControlInner siteSourceControl) {
        return beginCreateOrUpdateSourceControlSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteSourceControl).toBlocking().single().body();
    }

    /**
     * Updates the source control configuration of an app.
     * Updates the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the source control configuration for the production slot.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteSourceControlInner> beginCreateOrUpdateSourceControlSlotAsync(String resourceGroupName, String name, String slot, SiteSourceControlInner siteSourceControl, final ServiceCallback<SiteSourceControlInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginCreateOrUpdateSourceControlSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteSourceControl), serviceCallback);
    }

    /**
     * Updates the source control configuration of an app.
     * Updates the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the source control configuration for the production slot.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteSourceControlInner object
     */
    public Observable<SiteSourceControlInner> beginCreateOrUpdateSourceControlSlotAsync(String resourceGroupName, String name, String slot, SiteSourceControlInner siteSourceControl) {
        return beginCreateOrUpdateSourceControlSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteSourceControl).map(new Func1<ServiceResponse<SiteSourceControlInner>, SiteSourceControlInner>() {
            @Override
            public SiteSourceControlInner call(ServiceResponse<SiteSourceControlInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the source control configuration of an app.
     * Updates the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the source control configuration for the production slot.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteSourceControlInner object
     */
    public Observable<ServiceResponse<SiteSourceControlInner>> beginCreateOrUpdateSourceControlSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, SiteSourceControlInner siteSourceControl) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteSourceControl == null) {
            throw new IllegalArgumentException("Parameter siteSourceControl is required and cannot be null.");
        }
        Validator.validate(siteSourceControl);
        final String apiVersion = "2016-08-01";
        return service.beginCreateOrUpdateSourceControlSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteSourceControl, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteSourceControlInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteSourceControlInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteSourceControlInner> clientResponse = beginCreateOrUpdateSourceControlSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteSourceControlInner> beginCreateOrUpdateSourceControlSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteSourceControlInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteSourceControlInner>() { }.getType())
                .register(201, new TypeToken<SiteSourceControlInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes the source control configuration of an app.
     * Deletes the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the source control configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteSourceControlSlot(String resourceGroupName, String name, String slot) {
        deleteSourceControlSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Deletes the source control configuration of an app.
     * Deletes the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the source control configuration for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteSourceControlSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteSourceControlSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Deletes the source control configuration of an app.
     * Deletes the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the source control configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteSourceControlSlotAsync(String resourceGroupName, String name, String slot) {
        return deleteSourceControlSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes the source control configuration of an app.
     * Deletes the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the source control configuration for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteSourceControlSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.deleteSourceControlSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteSourceControlSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteSourceControlSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Starts an app (or deployment slot, if specified).
     * Starts an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will start the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void startSlot(String resourceGroupName, String name, String slot) {
        startSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Starts an app (or deployment slot, if specified).
     * Starts an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will start the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> startSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(startSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Starts an app (or deployment slot, if specified).
     * Starts an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will start the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> startSlotAsync(String resourceGroupName, String name, String slot) {
        return startSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Starts an app (or deployment slot, if specified).
     * Starts an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will start the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> startSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.startSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = startSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> startSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Stops an app (or deployment slot, if specified).
     * Stops an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will stop the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void stopSlot(String resourceGroupName, String name, String slot) {
        stopSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Stops an app (or deployment slot, if specified).
     * Stops an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will stop the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> stopSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(stopSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Stops an app (or deployment slot, if specified).
     * Stops an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will stop the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> stopSlotAsync(String resourceGroupName, String name, String slot) {
        return stopSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Stops an app (or deployment slot, if specified).
     * Stops an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will stop the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> stopSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.stopSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = stopSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> stopSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Sync web app repository.
     * Sync web app repository.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void syncRepositorySlot(String resourceGroupName, String name, String slot) {
        syncRepositorySlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Sync web app repository.
     * Sync web app repository.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> syncRepositorySlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(syncRepositorySlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Sync web app repository.
     * Sync web app repository.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> syncRepositorySlotAsync(String resourceGroupName, String name, String slot) {
        return syncRepositorySlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Sync web app repository.
     * Sync web app repository.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> syncRepositorySlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.syncRepositorySlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = syncRepositorySlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> syncRepositorySlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get quota information of the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;CsmUsageQuotaInner&gt; object if successful.
     */
    public PagedList<CsmUsageQuotaInner> listUsagesSlot(final String resourceGroupName, final String name, final String slot) {
        ServiceResponse<Page<CsmUsageQuotaInner>> response = listUsagesSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        return new PagedList<CsmUsageQuotaInner>(response.body()) {
            @Override
            public Page<CsmUsageQuotaInner> nextPage(String nextPageLink) {
                return listUsagesSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get quota information of the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<CsmUsageQuotaInner>> listUsagesSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<CsmUsageQuotaInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listUsagesSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(String nextPageLink) {
                    return listUsagesSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get quota information of the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<Page<CsmUsageQuotaInner>> listUsagesSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return listUsagesSlotWithServiceResponseAsync(resourceGroupName, name, slot)
            .map(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Page<CsmUsageQuotaInner>>() {
                @Override
                public Page<CsmUsageQuotaInner> call(ServiceResponse<Page<CsmUsageQuotaInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get quota information of the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> listUsagesSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot) {
        return listUsagesSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(ServiceResponse<Page<CsmUsageQuotaInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listUsagesSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get quota information of the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;CsmUsageQuotaInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> listUsagesSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        final String filter = null;
        return service.listUsagesSlot(resourceGroupName, name, slot, this.client.subscriptionId(), filter, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<CsmUsageQuotaInner>> result = listUsagesSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<CsmUsageQuotaInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get quota information of the production slot.
     * @param filter Return only information specified in the filter (using OData syntax). For example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;CsmUsageQuotaInner&gt; object if successful.
     */
    public PagedList<CsmUsageQuotaInner> listUsagesSlot(final String resourceGroupName, final String name, final String slot, final String filter) {
        ServiceResponse<Page<CsmUsageQuotaInner>> response = listUsagesSlotSinglePageAsync(resourceGroupName, name, slot, filter).toBlocking().single();
        return new PagedList<CsmUsageQuotaInner>(response.body()) {
            @Override
            public Page<CsmUsageQuotaInner> nextPage(String nextPageLink) {
                return listUsagesSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get quota information of the production slot.
     * @param filter Return only information specified in the filter (using OData syntax). For example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<CsmUsageQuotaInner>> listUsagesSlotAsync(final String resourceGroupName, final String name, final String slot, final String filter, final ListOperationCallback<CsmUsageQuotaInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listUsagesSlotSinglePageAsync(resourceGroupName, name, slot, filter),
            new Func1<String, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(String nextPageLink) {
                    return listUsagesSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get quota information of the production slot.
     * @param filter Return only information specified in the filter (using OData syntax). For example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<Page<CsmUsageQuotaInner>> listUsagesSlotAsync(final String resourceGroupName, final String name, final String slot, final String filter) {
        return listUsagesSlotWithServiceResponseAsync(resourceGroupName, name, slot, filter)
            .map(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Page<CsmUsageQuotaInner>>() {
                @Override
                public Page<CsmUsageQuotaInner> call(ServiceResponse<Page<CsmUsageQuotaInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get quota information of the production slot.
     * @param filter Return only information specified in the filter (using OData syntax). For example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> listUsagesSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot, final String filter) {
        return listUsagesSlotSinglePageAsync(resourceGroupName, name, slot, filter)
            .concatMap(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(ServiceResponse<Page<CsmUsageQuotaInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listUsagesSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
    ServiceResponse<PageImpl<CsmUsageQuotaInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<CsmUsageQuotaInner>> * @param name Name of the app.
    ServiceResponse<PageImpl<CsmUsageQuotaInner>> * @param slot Name of the deployment slot. If a slot is not specified, the API will get quota information of the production slot.
    ServiceResponse<PageImpl<CsmUsageQuotaInner>> * @param filter Return only information specified in the filter (using OData syntax). For example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;CsmUsageQuotaInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> listUsagesSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot, final String filter) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listUsagesSlot(resourceGroupName, name, slot, this.client.subscriptionId(), filter, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<CsmUsageQuotaInner>> result = listUsagesSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<CsmUsageQuotaInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<CsmUsageQuotaInner>> listUsagesSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<CsmUsageQuotaInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<CsmUsageQuotaInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the virtual networks the app (or deployment slot) is connected to.
     * Gets the virtual networks the app (or deployment slot) is connected to.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get virtual network connections for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;VnetInfoInner&gt; object if successful.
     */
    public List<VnetInfoInner> listVnetConnectionsSlot(String resourceGroupName, String name, String slot) {
        return listVnetConnectionsSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().body();
    }

    /**
     * Gets the virtual networks the app (or deployment slot) is connected to.
     * Gets the virtual networks the app (or deployment slot) is connected to.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get virtual network connections for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<VnetInfoInner>> listVnetConnectionsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<List<VnetInfoInner>> serviceCallback) {
        return ServiceFuture.fromResponse(listVnetConnectionsSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the virtual networks the app (or deployment slot) is connected to.
     * Gets the virtual networks the app (or deployment slot) is connected to.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get virtual network connections for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;VnetInfoInner&gt; object
     */
    public Observable<List<VnetInfoInner>> listVnetConnectionsSlotAsync(String resourceGroupName, String name, String slot) {
        return listVnetConnectionsSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<List<VnetInfoInner>>, List<VnetInfoInner>>() {
            @Override
            public List<VnetInfoInner> call(ServiceResponse<List<VnetInfoInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the virtual networks the app (or deployment slot) is connected to.
     * Gets the virtual networks the app (or deployment slot) is connected to.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get virtual network connections for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;VnetInfoInner&gt; object
     */
    public Observable<ServiceResponse<List<VnetInfoInner>>> listVnetConnectionsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listVnetConnectionsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<VnetInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<VnetInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<VnetInfoInner>> clientResponse = listVnetConnectionsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<VnetInfoInner>> listVnetConnectionsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<VnetInfoInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<VnetInfoInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets a virtual network the app (or deployment slot) is connected to by name.
     * Gets a virtual network the app (or deployment slot) is connected to by name.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the virtual network.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the named virtual network for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the VnetInfoInner object if successful.
     */
    public VnetInfoInner getVnetConnectionSlot(String resourceGroupName, String name, String vnetName, String slot) {
        return getVnetConnectionSlotWithServiceResponseAsync(resourceGroupName, name, vnetName, slot).toBlocking().single().body();
    }

    /**
     * Gets a virtual network the app (or deployment slot) is connected to by name.
     * Gets a virtual network the app (or deployment slot) is connected to by name.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the virtual network.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the named virtual network for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<VnetInfoInner> getVnetConnectionSlotAsync(String resourceGroupName, String name, String vnetName, String slot, final ServiceCallback<VnetInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getVnetConnectionSlotWithServiceResponseAsync(resourceGroupName, name, vnetName, slot), serviceCallback);
    }

    /**
     * Gets a virtual network the app (or deployment slot) is connected to by name.
     * Gets a virtual network the app (or deployment slot) is connected to by name.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the virtual network.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the named virtual network for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VnetInfoInner object
     */
    public Observable<VnetInfoInner> getVnetConnectionSlotAsync(String resourceGroupName, String name, String vnetName, String slot) {
        return getVnetConnectionSlotWithServiceResponseAsync(resourceGroupName, name, vnetName, slot).map(new Func1<ServiceResponse<VnetInfoInner>, VnetInfoInner>() {
            @Override
            public VnetInfoInner call(ServiceResponse<VnetInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a virtual network the app (or deployment slot) is connected to by name.
     * Gets a virtual network the app (or deployment slot) is connected to by name.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the virtual network.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the named virtual network for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VnetInfoInner object
     */
    public Observable<ServiceResponse<VnetInfoInner>> getVnetConnectionSlotWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getVnetConnectionSlot(resourceGroupName, name, vnetName, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetInfoInner> clientResponse = getVnetConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetInfoInner> getVnetConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<VnetInfoInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<VnetInfoInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of an existing Virtual Network.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will add or update connections for the production slot.
     * @param connectionEnvelope Properties of the Virtual Network connection. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the VnetInfoInner object if successful.
     */
    public VnetInfoInner createOrUpdateVnetConnectionSlot(String resourceGroupName, String name, String vnetName, String slot, VnetInfoInner connectionEnvelope) {
        return createOrUpdateVnetConnectionSlotWithServiceResponseAsync(resourceGroupName, name, vnetName, slot, connectionEnvelope).toBlocking().single().body();
    }

    /**
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of an existing Virtual Network.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will add or update connections for the production slot.
     * @param connectionEnvelope Properties of the Virtual Network connection. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<VnetInfoInner> createOrUpdateVnetConnectionSlotAsync(String resourceGroupName, String name, String vnetName, String slot, VnetInfoInner connectionEnvelope, final ServiceCallback<VnetInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateVnetConnectionSlotWithServiceResponseAsync(resourceGroupName, name, vnetName, slot, connectionEnvelope), serviceCallback);
    }

    /**
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of an existing Virtual Network.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will add or update connections for the production slot.
     * @param connectionEnvelope Properties of the Virtual Network connection. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VnetInfoInner object
     */
    public Observable<VnetInfoInner> createOrUpdateVnetConnectionSlotAsync(String resourceGroupName, String name, String vnetName, String slot, VnetInfoInner connectionEnvelope) {
        return createOrUpdateVnetConnectionSlotWithServiceResponseAsync(resourceGroupName, name, vnetName, slot, connectionEnvelope).map(new Func1<ServiceResponse<VnetInfoInner>, VnetInfoInner>() {
            @Override
            public VnetInfoInner call(ServiceResponse<VnetInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of an existing Virtual Network.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will add or update connections for the production slot.
     * @param connectionEnvelope Properties of the Virtual Network connection. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VnetInfoInner object
     */
    public Observable<ServiceResponse<VnetInfoInner>> createOrUpdateVnetConnectionSlotWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, String slot, VnetInfoInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        final String apiVersion = "2016-08-01";
        return service.createOrUpdateVnetConnectionSlot(resourceGroupName, name, vnetName, slot, this.client.subscriptionId(), connectionEnvelope, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetInfoInner> clientResponse = createOrUpdateVnetConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetInfoInner> createOrUpdateVnetConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<VnetInfoInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<VnetInfoInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a connection from an app (or deployment slot to a named virtual network.
     * Deletes a connection from an app (or deployment slot to a named virtual network.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the virtual network.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the connection for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteVnetConnectionSlot(String resourceGroupName, String name, String vnetName, String slot) {
        deleteVnetConnectionSlotWithServiceResponseAsync(resourceGroupName, name, vnetName, slot).toBlocking().single().body();
    }

    /**
     * Deletes a connection from an app (or deployment slot to a named virtual network.
     * Deletes a connection from an app (or deployment slot to a named virtual network.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the virtual network.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the connection for the production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteVnetConnectionSlotAsync(String resourceGroupName, String name, String vnetName, String slot, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteVnetConnectionSlotWithServiceResponseAsync(resourceGroupName, name, vnetName, slot), serviceCallback);
    }

    /**
     * Deletes a connection from an app (or deployment slot to a named virtual network.
     * Deletes a connection from an app (or deployment slot to a named virtual network.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the virtual network.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the connection for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteVnetConnectionSlotAsync(String resourceGroupName, String name, String vnetName, String slot) {
        return deleteVnetConnectionSlotWithServiceResponseAsync(resourceGroupName, name, vnetName, slot).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a connection from an app (or deployment slot to a named virtual network.
     * Deletes a connection from an app (or deployment slot to a named virtual network.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the virtual network.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the connection for the production slot.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteVnetConnectionSlotWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.deleteVnetConnectionSlot(resourceGroupName, name, vnetName, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteVnetConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteVnetConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of an existing Virtual Network.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will add or update connections for the production slot.
     * @param connectionEnvelope Properties of the Virtual Network connection. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the VnetInfoInner object if successful.
     */
    public VnetInfoInner updateVnetConnectionSlot(String resourceGroupName, String name, String vnetName, String slot, VnetInfoInner connectionEnvelope) {
        return updateVnetConnectionSlotWithServiceResponseAsync(resourceGroupName, name, vnetName, slot, connectionEnvelope).toBlocking().single().body();
    }

    /**
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of an existing Virtual Network.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will add or update connections for the production slot.
     * @param connectionEnvelope Properties of the Virtual Network connection. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<VnetInfoInner> updateVnetConnectionSlotAsync(String resourceGroupName, String name, String vnetName, String slot, VnetInfoInner connectionEnvelope, final ServiceCallback<VnetInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateVnetConnectionSlotWithServiceResponseAsync(resourceGroupName, name, vnetName, slot, connectionEnvelope), serviceCallback);
    }

    /**
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of an existing Virtual Network.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will add or update connections for the production slot.
     * @param connectionEnvelope Properties of the Virtual Network connection. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VnetInfoInner object
     */
    public Observable<VnetInfoInner> updateVnetConnectionSlotAsync(String resourceGroupName, String name, String vnetName, String slot, VnetInfoInner connectionEnvelope) {
        return updateVnetConnectionSlotWithServiceResponseAsync(resourceGroupName, name, vnetName, slot, connectionEnvelope).map(new Func1<ServiceResponse<VnetInfoInner>, VnetInfoInner>() {
            @Override
            public VnetInfoInner call(ServiceResponse<VnetInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of an existing Virtual Network.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will add or update connections for the production slot.
     * @param connectionEnvelope Properties of the Virtual Network connection. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VnetInfoInner object
     */
    public Observable<ServiceResponse<VnetInfoInner>> updateVnetConnectionSlotWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, String slot, VnetInfoInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        final String apiVersion = "2016-08-01";
        return service.updateVnetConnectionSlot(resourceGroupName, name, vnetName, slot, this.client.subscriptionId(), connectionEnvelope, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetInfoInner> clientResponse = updateVnetConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetInfoInner> updateVnetConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<VnetInfoInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<VnetInfoInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets an app's Virtual Network gateway.
     * Gets an app's Virtual Network gateway.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get a gateway for the production slot's Virtual Network.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the VnetGatewayInner object if successful.
     */
    public VnetGatewayInner getVnetConnectionGatewaySlot(String resourceGroupName, String name, String vnetName, String gatewayName, String slot) {
        return getVnetConnectionGatewaySlotWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, slot).toBlocking().single().body();
    }

    /**
     * Gets an app's Virtual Network gateway.
     * Gets an app's Virtual Network gateway.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get a gateway for the production slot's Virtual Network.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<VnetGatewayInner> getVnetConnectionGatewaySlotAsync(String resourceGroupName, String name, String vnetName, String gatewayName, String slot, final ServiceCallback<VnetGatewayInner> serviceCallback) {
        return ServiceFuture.fromResponse(getVnetConnectionGatewaySlotWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, slot), serviceCallback);
    }

    /**
     * Gets an app's Virtual Network gateway.
     * Gets an app's Virtual Network gateway.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get a gateway for the production slot's Virtual Network.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VnetGatewayInner object
     */
    public Observable<VnetGatewayInner> getVnetConnectionGatewaySlotAsync(String resourceGroupName, String name, String vnetName, String gatewayName, String slot) {
        return getVnetConnectionGatewaySlotWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, slot).map(new Func1<ServiceResponse<VnetGatewayInner>, VnetGatewayInner>() {
            @Override
            public VnetGatewayInner call(ServiceResponse<VnetGatewayInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets an app's Virtual Network gateway.
     * Gets an app's Virtual Network gateway.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get a gateway for the production slot's Virtual Network.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VnetGatewayInner object
     */
    public Observable<ServiceResponse<VnetGatewayInner>> getVnetConnectionGatewaySlotWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, String gatewayName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (gatewayName == null) {
            throw new IllegalArgumentException("Parameter gatewayName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getVnetConnectionGatewaySlot(resourceGroupName, name, vnetName, gatewayName, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetGatewayInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetGatewayInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetGatewayInner> clientResponse = getVnetConnectionGatewaySlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetGatewayInner> getVnetConnectionGatewaySlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<VnetGatewayInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<VnetGatewayInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param slot Name of the deployment slot. If a slot is not specified, the API will add or update a gateway for the production slot's Virtual Network.
     * @param connectionEnvelope The properties to update this gateway with.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the VnetGatewayInner object if successful.
     */
    public VnetGatewayInner createOrUpdateVnetConnectionGatewaySlot(String resourceGroupName, String name, String vnetName, String gatewayName, String slot, VnetGatewayInner connectionEnvelope) {
        return createOrUpdateVnetConnectionGatewaySlotWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, slot, connectionEnvelope).toBlocking().single().body();
    }

    /**
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param slot Name of the deployment slot. If a slot is not specified, the API will add or update a gateway for the production slot's Virtual Network.
     * @param connectionEnvelope The properties to update this gateway with.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<VnetGatewayInner> createOrUpdateVnetConnectionGatewaySlotAsync(String resourceGroupName, String name, String vnetName, String gatewayName, String slot, VnetGatewayInner connectionEnvelope, final ServiceCallback<VnetGatewayInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateVnetConnectionGatewaySlotWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, slot, connectionEnvelope), serviceCallback);
    }

    /**
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param slot Name of the deployment slot. If a slot is not specified, the API will add or update a gateway for the production slot's Virtual Network.
     * @param connectionEnvelope The properties to update this gateway with.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VnetGatewayInner object
     */
    public Observable<VnetGatewayInner> createOrUpdateVnetConnectionGatewaySlotAsync(String resourceGroupName, String name, String vnetName, String gatewayName, String slot, VnetGatewayInner connectionEnvelope) {
        return createOrUpdateVnetConnectionGatewaySlotWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, slot, connectionEnvelope).map(new Func1<ServiceResponse<VnetGatewayInner>, VnetGatewayInner>() {
            @Override
            public VnetGatewayInner call(ServiceResponse<VnetGatewayInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param slot Name of the deployment slot. If a slot is not specified, the API will add or update a gateway for the production slot's Virtual Network.
     * @param connectionEnvelope The properties to update this gateway with.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VnetGatewayInner object
     */
    public Observable<ServiceResponse<VnetGatewayInner>> createOrUpdateVnetConnectionGatewaySlotWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, String gatewayName, String slot, VnetGatewayInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (gatewayName == null) {
            throw new IllegalArgumentException("Parameter gatewayName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        final String apiVersion = "2016-08-01";
        return service.createOrUpdateVnetConnectionGatewaySlot(resourceGroupName, name, vnetName, gatewayName, slot, this.client.subscriptionId(), connectionEnvelope, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetGatewayInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetGatewayInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetGatewayInner> clientResponse = createOrUpdateVnetConnectionGatewaySlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetGatewayInner> createOrUpdateVnetConnectionGatewaySlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<VnetGatewayInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<VnetGatewayInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param slot Name of the deployment slot. If a slot is not specified, the API will add or update a gateway for the production slot's Virtual Network.
     * @param connectionEnvelope The properties to update this gateway with.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the VnetGatewayInner object if successful.
     */
    public VnetGatewayInner updateVnetConnectionGatewaySlot(String resourceGroupName, String name, String vnetName, String gatewayName, String slot, VnetGatewayInner connectionEnvelope) {
        return updateVnetConnectionGatewaySlotWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, slot, connectionEnvelope).toBlocking().single().body();
    }

    /**
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param slot Name of the deployment slot. If a slot is not specified, the API will add or update a gateway for the production slot's Virtual Network.
     * @param connectionEnvelope The properties to update this gateway with.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<VnetGatewayInner> updateVnetConnectionGatewaySlotAsync(String resourceGroupName, String name, String vnetName, String gatewayName, String slot, VnetGatewayInner connectionEnvelope, final ServiceCallback<VnetGatewayInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateVnetConnectionGatewaySlotWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, slot, connectionEnvelope), serviceCallback);
    }

    /**
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param slot Name of the deployment slot. If a slot is not specified, the API will add or update a gateway for the production slot's Virtual Network.
     * @param connectionEnvelope The properties to update this gateway with.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VnetGatewayInner object
     */
    public Observable<VnetGatewayInner> updateVnetConnectionGatewaySlotAsync(String resourceGroupName, String name, String vnetName, String gatewayName, String slot, VnetGatewayInner connectionEnvelope) {
        return updateVnetConnectionGatewaySlotWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, slot, connectionEnvelope).map(new Func1<ServiceResponse<VnetGatewayInner>, VnetGatewayInner>() {
            @Override
            public VnetGatewayInner call(ServiceResponse<VnetGatewayInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param slot Name of the deployment slot. If a slot is not specified, the API will add or update a gateway for the production slot's Virtual Network.
     * @param connectionEnvelope The properties to update this gateway with.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VnetGatewayInner object
     */
    public Observable<ServiceResponse<VnetGatewayInner>> updateVnetConnectionGatewaySlotWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, String gatewayName, String slot, VnetGatewayInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (gatewayName == null) {
            throw new IllegalArgumentException("Parameter gatewayName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        final String apiVersion = "2016-08-01";
        return service.updateVnetConnectionGatewaySlot(resourceGroupName, name, vnetName, gatewayName, slot, this.client.subscriptionId(), connectionEnvelope, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetGatewayInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetGatewayInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetGatewayInner> clientResponse = updateVnetConnectionGatewaySlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetGatewayInner> updateVnetConnectionGatewaySlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<VnetGatewayInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<VnetGatewayInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SlotDifferenceInner&gt; object if successful.
     */
    public PagedList<SlotDifferenceInner> listSlotDifferencesFromProduction(final String resourceGroupName, final String name, final CsmSlotEntityInner slotSwapEntity) {
        ServiceResponse<Page<SlotDifferenceInner>> response = listSlotDifferencesFromProductionSinglePageAsync(resourceGroupName, name, slotSwapEntity).toBlocking().single();
        return new PagedList<SlotDifferenceInner>(response.body()) {
            @Override
            public Page<SlotDifferenceInner> nextPage(String nextPageLink) {
                return listSlotDifferencesFromProductionNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SlotDifferenceInner>> listSlotDifferencesFromProductionAsync(final String resourceGroupName, final String name, final CsmSlotEntityInner slotSwapEntity, final ListOperationCallback<SlotDifferenceInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listSlotDifferencesFromProductionSinglePageAsync(resourceGroupName, name, slotSwapEntity),
            new Func1<String, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(String nextPageLink) {
                    return listSlotDifferencesFromProductionNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SlotDifferenceInner&gt; object
     */
    public Observable<Page<SlotDifferenceInner>> listSlotDifferencesFromProductionAsync(final String resourceGroupName, final String name, final CsmSlotEntityInner slotSwapEntity) {
        return listSlotDifferencesFromProductionWithServiceResponseAsync(resourceGroupName, name, slotSwapEntity)
            .map(new Func1<ServiceResponse<Page<SlotDifferenceInner>>, Page<SlotDifferenceInner>>() {
                @Override
                public Page<SlotDifferenceInner> call(ServiceResponse<Page<SlotDifferenceInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SlotDifferenceInner&gt; object
     */
    public Observable<ServiceResponse<Page<SlotDifferenceInner>>> listSlotDifferencesFromProductionWithServiceResponseAsync(final String resourceGroupName, final String name, final CsmSlotEntityInner slotSwapEntity) {
        return listSlotDifferencesFromProductionSinglePageAsync(resourceGroupName, name, slotSwapEntity)
            .concatMap(new Func1<ServiceResponse<Page<SlotDifferenceInner>>, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(ServiceResponse<Page<SlotDifferenceInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listSlotDifferencesFromProductionNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
    ServiceResponse<PageImpl<SlotDifferenceInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<SlotDifferenceInner>> * @param name Name of the app.
    ServiceResponse<PageImpl<SlotDifferenceInner>> * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SlotDifferenceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SlotDifferenceInner>>> listSlotDifferencesFromProductionSinglePageAsync(final String resourceGroupName, final String name, final CsmSlotEntityInner slotSwapEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (slotSwapEntity == null) {
            throw new IllegalArgumentException("Parameter slotSwapEntity is required and cannot be null.");
        }
        Validator.validate(slotSwapEntity);
        final String apiVersion = "2016-08-01";
        return service.listSlotDifferencesFromProduction(resourceGroupName, name, this.client.subscriptionId(), slotSwapEntity, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SlotDifferenceInner>> result = listSlotDifferencesFromProductionDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SlotDifferenceInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SlotDifferenceInner>> listSlotDifferencesFromProductionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<SlotDifferenceInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SlotDifferenceInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Swaps two deployment slots of an app.
     * Swaps two deployment slots of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void swapSlotWithProduction(String resourceGroupName, String name, CsmSlotEntityInner slotSwapEntity) {
        swapSlotWithProductionWithServiceResponseAsync(resourceGroupName, name, slotSwapEntity).toBlocking().last().body();
    }

    /**
     * Swaps two deployment slots of an app.
     * Swaps two deployment slots of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> swapSlotWithProductionAsync(String resourceGroupName, String name, CsmSlotEntityInner slotSwapEntity, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(swapSlotWithProductionWithServiceResponseAsync(resourceGroupName, name, slotSwapEntity), serviceCallback);
    }

    /**
     * Swaps two deployment slots of an app.
     * Swaps two deployment slots of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<Void> swapSlotWithProductionAsync(String resourceGroupName, String name, CsmSlotEntityInner slotSwapEntity) {
        return swapSlotWithProductionWithServiceResponseAsync(resourceGroupName, name, slotSwapEntity).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Swaps two deployment slots of an app.
     * Swaps two deployment slots of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<Void>> swapSlotWithProductionWithServiceResponseAsync(String resourceGroupName, String name, CsmSlotEntityInner slotSwapEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (slotSwapEntity == null) {
            throw new IllegalArgumentException("Parameter slotSwapEntity is required and cannot be null.");
        }
        Validator.validate(slotSwapEntity);
        final String apiVersion = "2016-08-01";
        Observable<Response<ResponseBody>> observable = service.swapSlotWithProduction(resourceGroupName, name, this.client.subscriptionId(), slotSwapEntity, apiVersion, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<Void>() { }.getType());
    }

    /**
     * Swaps two deployment slots of an app.
     * Swaps two deployment slots of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void beginSwapSlotWithProduction(String resourceGroupName, String name, CsmSlotEntityInner slotSwapEntity) {
        beginSwapSlotWithProductionWithServiceResponseAsync(resourceGroupName, name, slotSwapEntity).toBlocking().single().body();
    }

    /**
     * Swaps two deployment slots of an app.
     * Swaps two deployment slots of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> beginSwapSlotWithProductionAsync(String resourceGroupName, String name, CsmSlotEntityInner slotSwapEntity, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(beginSwapSlotWithProductionWithServiceResponseAsync(resourceGroupName, name, slotSwapEntity), serviceCallback);
    }

    /**
     * Swaps two deployment slots of an app.
     * Swaps two deployment slots of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> beginSwapSlotWithProductionAsync(String resourceGroupName, String name, CsmSlotEntityInner slotSwapEntity) {
        return beginSwapSlotWithProductionWithServiceResponseAsync(resourceGroupName, name, slotSwapEntity).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Swaps two deployment slots of an app.
     * Swaps two deployment slots of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> beginSwapSlotWithProductionWithServiceResponseAsync(String resourceGroupName, String name, CsmSlotEntityInner slotSwapEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (slotSwapEntity == null) {
            throw new IllegalArgumentException("Parameter slotSwapEntity is required and cannot be null.");
        }
        Validator.validate(slotSwapEntity);
        final String apiVersion = "2016-08-01";
        return service.beginSwapSlotWithProduction(resourceGroupName, name, this.client.subscriptionId(), slotSwapEntity, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = beginSwapSlotWithProductionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> beginSwapSlotWithProductionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Website Name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SnapshotInner&gt; object if successful.
     */
    public PagedList<SnapshotInner> listSnapshots(final String resourceGroupName, final String name) {
        ServiceResponse<Page<SnapshotInner>> response = listSnapshotsSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<SnapshotInner>(response.body()) {
            @Override
            public Page<SnapshotInner> nextPage(String nextPageLink) {
                return listSnapshotsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Website Name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SnapshotInner>> listSnapshotsAsync(final String resourceGroupName, final String name, final ListOperationCallback<SnapshotInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listSnapshotsSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<SnapshotInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SnapshotInner>>> call(String nextPageLink) {
                    return listSnapshotsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Website Name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SnapshotInner&gt; object
     */
    public Observable<Page<SnapshotInner>> listSnapshotsAsync(final String resourceGroupName, final String name) {
        return listSnapshotsWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<SnapshotInner>>, Page<SnapshotInner>>() {
                @Override
                public Page<SnapshotInner> call(ServiceResponse<Page<SnapshotInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Website Name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SnapshotInner&gt; object
     */
    public Observable<ServiceResponse<Page<SnapshotInner>>> listSnapshotsWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return listSnapshotsSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<SnapshotInner>>, Observable<ServiceResponse<Page<SnapshotInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SnapshotInner>>> call(ServiceResponse<Page<SnapshotInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listSnapshotsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
    ServiceResponse<PageImpl<SnapshotInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<SnapshotInner>> * @param name Website Name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SnapshotInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SnapshotInner>>> listSnapshotsSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listSnapshots(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SnapshotInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SnapshotInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SnapshotInner>> result = listSnapshotsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SnapshotInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SnapshotInner>> listSnapshotsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<SnapshotInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SnapshotInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the source control configuration of an app.
     * Gets the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteSourceControlInner object if successful.
     */
    public SiteSourceControlInner getSourceControl(String resourceGroupName, String name) {
        return getSourceControlWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Gets the source control configuration of an app.
     * Gets the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteSourceControlInner> getSourceControlAsync(String resourceGroupName, String name, final ServiceCallback<SiteSourceControlInner> serviceCallback) {
        return ServiceFuture.fromResponse(getSourceControlWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the source control configuration of an app.
     * Gets the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteSourceControlInner object
     */
    public Observable<SiteSourceControlInner> getSourceControlAsync(String resourceGroupName, String name) {
        return getSourceControlWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<SiteSourceControlInner>, SiteSourceControlInner>() {
            @Override
            public SiteSourceControlInner call(ServiceResponse<SiteSourceControlInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the source control configuration of an app.
     * Gets the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteSourceControlInner object
     */
    public Observable<ServiceResponse<SiteSourceControlInner>> getSourceControlWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getSourceControl(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteSourceControlInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteSourceControlInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteSourceControlInner> clientResponse = getSourceControlDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteSourceControlInner> getSourceControlDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteSourceControlInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteSourceControlInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the source control configuration of an app.
     * Updates the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteSourceControlInner object if successful.
     */
    public SiteSourceControlInner createOrUpdateSourceControl(String resourceGroupName, String name, SiteSourceControlInner siteSourceControl) {
        return createOrUpdateSourceControlWithServiceResponseAsync(resourceGroupName, name, siteSourceControl).toBlocking().last().body();
    }

    /**
     * Updates the source control configuration of an app.
     * Updates the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteSourceControlInner> createOrUpdateSourceControlAsync(String resourceGroupName, String name, SiteSourceControlInner siteSourceControl, final ServiceCallback<SiteSourceControlInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateSourceControlWithServiceResponseAsync(resourceGroupName, name, siteSourceControl), serviceCallback);
    }

    /**
     * Updates the source control configuration of an app.
     * Updates the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<SiteSourceControlInner> createOrUpdateSourceControlAsync(String resourceGroupName, String name, SiteSourceControlInner siteSourceControl) {
        return createOrUpdateSourceControlWithServiceResponseAsync(resourceGroupName, name, siteSourceControl).map(new Func1<ServiceResponse<SiteSourceControlInner>, SiteSourceControlInner>() {
            @Override
            public SiteSourceControlInner call(ServiceResponse<SiteSourceControlInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the source control configuration of an app.
     * Updates the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<SiteSourceControlInner>> createOrUpdateSourceControlWithServiceResponseAsync(String resourceGroupName, String name, SiteSourceControlInner siteSourceControl) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteSourceControl == null) {
            throw new IllegalArgumentException("Parameter siteSourceControl is required and cannot be null.");
        }
        Validator.validate(siteSourceControl);
        final String apiVersion = "2016-08-01";
        Observable<Response<ResponseBody>> observable = service.createOrUpdateSourceControl(resourceGroupName, name, this.client.subscriptionId(), siteSourceControl, apiVersion, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultAsync(observable, new TypeToken<SiteSourceControlInner>() { }.getType());
    }

    /**
     * Updates the source control configuration of an app.
     * Updates the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SiteSourceControlInner object if successful.
     */
    public SiteSourceControlInner beginCreateOrUpdateSourceControl(String resourceGroupName, String name, SiteSourceControlInner siteSourceControl) {
        return beginCreateOrUpdateSourceControlWithServiceResponseAsync(resourceGroupName, name, siteSourceControl).toBlocking().single().body();
    }

    /**
     * Updates the source control configuration of an app.
     * Updates the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SiteSourceControlInner> beginCreateOrUpdateSourceControlAsync(String resourceGroupName, String name, SiteSourceControlInner siteSourceControl, final ServiceCallback<SiteSourceControlInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginCreateOrUpdateSourceControlWithServiceResponseAsync(resourceGroupName, name, siteSourceControl), serviceCallback);
    }

    /**
     * Updates the source control configuration of an app.
     * Updates the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteSourceControlInner object
     */
    public Observable<SiteSourceControlInner> beginCreateOrUpdateSourceControlAsync(String resourceGroupName, String name, SiteSourceControlInner siteSourceControl) {
        return beginCreateOrUpdateSourceControlWithServiceResponseAsync(resourceGroupName, name, siteSourceControl).map(new Func1<ServiceResponse<SiteSourceControlInner>, SiteSourceControlInner>() {
            @Override
            public SiteSourceControlInner call(ServiceResponse<SiteSourceControlInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the source control configuration of an app.
     * Updates the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SiteSourceControlInner object
     */
    public Observable<ServiceResponse<SiteSourceControlInner>> beginCreateOrUpdateSourceControlWithServiceResponseAsync(String resourceGroupName, String name, SiteSourceControlInner siteSourceControl) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteSourceControl == null) {
            throw new IllegalArgumentException("Parameter siteSourceControl is required and cannot be null.");
        }
        Validator.validate(siteSourceControl);
        final String apiVersion = "2016-08-01";
        return service.beginCreateOrUpdateSourceControl(resourceGroupName, name, this.client.subscriptionId(), siteSourceControl, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteSourceControlInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteSourceControlInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteSourceControlInner> clientResponse = beginCreateOrUpdateSourceControlDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteSourceControlInner> beginCreateOrUpdateSourceControlDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SiteSourceControlInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SiteSourceControlInner>() { }.getType())
                .register(201, new TypeToken<SiteSourceControlInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes the source control configuration of an app.
     * Deletes the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteSourceControl(String resourceGroupName, String name) {
        deleteSourceControlWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Deletes the source control configuration of an app.
     * Deletes the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteSourceControlAsync(String resourceGroupName, String name, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteSourceControlWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Deletes the source control configuration of an app.
     * Deletes the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteSourceControlAsync(String resourceGroupName, String name) {
        return deleteSourceControlWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes the source control configuration of an app.
     * Deletes the source control configuration of an app.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteSourceControlWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.deleteSourceControl(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteSourceControlDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteSourceControlDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Starts an app (or deployment slot, if specified).
     * Starts an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void start(String resourceGroupName, String name) {
        startWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Starts an app (or deployment slot, if specified).
     * Starts an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> startAsync(String resourceGroupName, String name, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(startWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Starts an app (or deployment slot, if specified).
     * Starts an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> startAsync(String resourceGroupName, String name) {
        return startWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Starts an app (or deployment slot, if specified).
     * Starts an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> startWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.start(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = startDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> startDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Stops an app (or deployment slot, if specified).
     * Stops an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void stop(String resourceGroupName, String name) {
        stopWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Stops an app (or deployment slot, if specified).
     * Stops an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> stopAsync(String resourceGroupName, String name, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(stopWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Stops an app (or deployment slot, if specified).
     * Stops an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> stopAsync(String resourceGroupName, String name) {
        return stopWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Stops an app (or deployment slot, if specified).
     * Stops an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> stopWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.stop(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = stopDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> stopDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Sync web app repository.
     * Sync web app repository.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void syncRepository(String resourceGroupName, String name) {
        syncRepositoryWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Sync web app repository.
     * Sync web app repository.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> syncRepositoryAsync(String resourceGroupName, String name, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(syncRepositoryWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Sync web app repository.
     * Sync web app repository.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> syncRepositoryAsync(String resourceGroupName, String name) {
        return syncRepositoryWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Sync web app repository.
     * Sync web app repository.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> syncRepositoryWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.syncRepository(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = syncRepositoryDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> syncRepositoryDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;CsmUsageQuotaInner&gt; object if successful.
     */
    public PagedList<CsmUsageQuotaInner> listUsages(final String resourceGroupName, final String name) {
        ServiceResponse<Page<CsmUsageQuotaInner>> response = listUsagesSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<CsmUsageQuotaInner>(response.body()) {
            @Override
            public Page<CsmUsageQuotaInner> nextPage(String nextPageLink) {
                return listUsagesNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<CsmUsageQuotaInner>> listUsagesAsync(final String resourceGroupName, final String name, final ListOperationCallback<CsmUsageQuotaInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listUsagesSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(String nextPageLink) {
                    return listUsagesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<Page<CsmUsageQuotaInner>> listUsagesAsync(final String resourceGroupName, final String name) {
        return listUsagesWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Page<CsmUsageQuotaInner>>() {
                @Override
                public Page<CsmUsageQuotaInner> call(ServiceResponse<Page<CsmUsageQuotaInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> listUsagesWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return listUsagesSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(ServiceResponse<Page<CsmUsageQuotaInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listUsagesNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;CsmUsageQuotaInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> listUsagesSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        final String filter = null;
        return service.listUsages(resourceGroupName, name, this.client.subscriptionId(), filter, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<CsmUsageQuotaInner>> result = listUsagesDelegate(response);
                        return Observable.just(new ServiceResponse<Page<CsmUsageQuotaInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param filter Return only information specified in the filter (using OData syntax). For example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;CsmUsageQuotaInner&gt; object if successful.
     */
    public PagedList<CsmUsageQuotaInner> listUsages(final String resourceGroupName, final String name, final String filter) {
        ServiceResponse<Page<CsmUsageQuotaInner>> response = listUsagesSinglePageAsync(resourceGroupName, name, filter).toBlocking().single();
        return new PagedList<CsmUsageQuotaInner>(response.body()) {
            @Override
            public Page<CsmUsageQuotaInner> nextPage(String nextPageLink) {
                return listUsagesNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param filter Return only information specified in the filter (using OData syntax). For example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<CsmUsageQuotaInner>> listUsagesAsync(final String resourceGroupName, final String name, final String filter, final ListOperationCallback<CsmUsageQuotaInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listUsagesSinglePageAsync(resourceGroupName, name, filter),
            new Func1<String, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(String nextPageLink) {
                    return listUsagesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param filter Return only information specified in the filter (using OData syntax). For example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<Page<CsmUsageQuotaInner>> listUsagesAsync(final String resourceGroupName, final String name, final String filter) {
        return listUsagesWithServiceResponseAsync(resourceGroupName, name, filter)
            .map(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Page<CsmUsageQuotaInner>>() {
                @Override
                public Page<CsmUsageQuotaInner> call(ServiceResponse<Page<CsmUsageQuotaInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param filter Return only information specified in the filter (using OData syntax). For example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> listUsagesWithServiceResponseAsync(final String resourceGroupName, final String name, final String filter) {
        return listUsagesSinglePageAsync(resourceGroupName, name, filter)
            .concatMap(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(ServiceResponse<Page<CsmUsageQuotaInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listUsagesNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
    ServiceResponse<PageImpl<CsmUsageQuotaInner>> * @param resourceGroupName Name of the resource group to which the resource belongs.
    ServiceResponse<PageImpl<CsmUsageQuotaInner>> * @param name Name of the app.
    ServiceResponse<PageImpl<CsmUsageQuotaInner>> * @param filter Return only information specified in the filter (using OData syntax). For example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;CsmUsageQuotaInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> listUsagesSinglePageAsync(final String resourceGroupName, final String name, final String filter) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listUsages(resourceGroupName, name, this.client.subscriptionId(), filter, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<CsmUsageQuotaInner>> result = listUsagesDelegate(response);
                        return Observable.just(new ServiceResponse<Page<CsmUsageQuotaInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<CsmUsageQuotaInner>> listUsagesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<CsmUsageQuotaInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<CsmUsageQuotaInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the virtual networks the app (or deployment slot) is connected to.
     * Gets the virtual networks the app (or deployment slot) is connected to.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;VnetInfoInner&gt; object if successful.
     */
    public List<VnetInfoInner> listVnetConnections(String resourceGroupName, String name) {
        return listVnetConnectionsWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().body();
    }

    /**
     * Gets the virtual networks the app (or deployment slot) is connected to.
     * Gets the virtual networks the app (or deployment slot) is connected to.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<VnetInfoInner>> listVnetConnectionsAsync(String resourceGroupName, String name, final ServiceCallback<List<VnetInfoInner>> serviceCallback) {
        return ServiceFuture.fromResponse(listVnetConnectionsWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the virtual networks the app (or deployment slot) is connected to.
     * Gets the virtual networks the app (or deployment slot) is connected to.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;VnetInfoInner&gt; object
     */
    public Observable<List<VnetInfoInner>> listVnetConnectionsAsync(String resourceGroupName, String name) {
        return listVnetConnectionsWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<List<VnetInfoInner>>, List<VnetInfoInner>>() {
            @Override
            public List<VnetInfoInner> call(ServiceResponse<List<VnetInfoInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the virtual networks the app (or deployment slot) is connected to.
     * Gets the virtual networks the app (or deployment slot) is connected to.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;VnetInfoInner&gt; object
     */
    public Observable<ServiceResponse<List<VnetInfoInner>>> listVnetConnectionsWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listVnetConnections(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<VnetInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<VnetInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<VnetInfoInner>> clientResponse = listVnetConnectionsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<VnetInfoInner>> listVnetConnectionsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<VnetInfoInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<VnetInfoInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets a virtual network the app (or deployment slot) is connected to by name.
     * Gets a virtual network the app (or deployment slot) is connected to by name.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the virtual network.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the VnetInfoInner object if successful.
     */
    public VnetInfoInner getVnetConnection(String resourceGroupName, String name, String vnetName) {
        return getVnetConnectionWithServiceResponseAsync(resourceGroupName, name, vnetName).toBlocking().single().body();
    }

    /**
     * Gets a virtual network the app (or deployment slot) is connected to by name.
     * Gets a virtual network the app (or deployment slot) is connected to by name.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the virtual network.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<VnetInfoInner> getVnetConnectionAsync(String resourceGroupName, String name, String vnetName, final ServiceCallback<VnetInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(getVnetConnectionWithServiceResponseAsync(resourceGroupName, name, vnetName), serviceCallback);
    }

    /**
     * Gets a virtual network the app (or deployment slot) is connected to by name.
     * Gets a virtual network the app (or deployment slot) is connected to by name.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the virtual network.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VnetInfoInner object
     */
    public Observable<VnetInfoInner> getVnetConnectionAsync(String resourceGroupName, String name, String vnetName) {
        return getVnetConnectionWithServiceResponseAsync(resourceGroupName, name, vnetName).map(new Func1<ServiceResponse<VnetInfoInner>, VnetInfoInner>() {
            @Override
            public VnetInfoInner call(ServiceResponse<VnetInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a virtual network the app (or deployment slot) is connected to by name.
     * Gets a virtual network the app (or deployment slot) is connected to by name.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the virtual network.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VnetInfoInner object
     */
    public Observable<ServiceResponse<VnetInfoInner>> getVnetConnectionWithServiceResponseAsync(String resourceGroupName, String name, String vnetName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getVnetConnection(resourceGroupName, name, vnetName, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetInfoInner> clientResponse = getVnetConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetInfoInner> getVnetConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<VnetInfoInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<VnetInfoInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of an existing Virtual Network.
     * @param connectionEnvelope Properties of the Virtual Network connection. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the VnetInfoInner object if successful.
     */
    public VnetInfoInner createOrUpdateVnetConnection(String resourceGroupName, String name, String vnetName, VnetInfoInner connectionEnvelope) {
        return createOrUpdateVnetConnectionWithServiceResponseAsync(resourceGroupName, name, vnetName, connectionEnvelope).toBlocking().single().body();
    }

    /**
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of an existing Virtual Network.
     * @param connectionEnvelope Properties of the Virtual Network connection. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<VnetInfoInner> createOrUpdateVnetConnectionAsync(String resourceGroupName, String name, String vnetName, VnetInfoInner connectionEnvelope, final ServiceCallback<VnetInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateVnetConnectionWithServiceResponseAsync(resourceGroupName, name, vnetName, connectionEnvelope), serviceCallback);
    }

    /**
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of an existing Virtual Network.
     * @param connectionEnvelope Properties of the Virtual Network connection. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VnetInfoInner object
     */
    public Observable<VnetInfoInner> createOrUpdateVnetConnectionAsync(String resourceGroupName, String name, String vnetName, VnetInfoInner connectionEnvelope) {
        return createOrUpdateVnetConnectionWithServiceResponseAsync(resourceGroupName, name, vnetName, connectionEnvelope).map(new Func1<ServiceResponse<VnetInfoInner>, VnetInfoInner>() {
            @Override
            public VnetInfoInner call(ServiceResponse<VnetInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of an existing Virtual Network.
     * @param connectionEnvelope Properties of the Virtual Network connection. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VnetInfoInner object
     */
    public Observable<ServiceResponse<VnetInfoInner>> createOrUpdateVnetConnectionWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, VnetInfoInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        final String apiVersion = "2016-08-01";
        return service.createOrUpdateVnetConnection(resourceGroupName, name, vnetName, this.client.subscriptionId(), connectionEnvelope, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetInfoInner> clientResponse = createOrUpdateVnetConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetInfoInner> createOrUpdateVnetConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<VnetInfoInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<VnetInfoInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a connection from an app (or deployment slot to a named virtual network.
     * Deletes a connection from an app (or deployment slot to a named virtual network.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the virtual network.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteVnetConnection(String resourceGroupName, String name, String vnetName) {
        deleteVnetConnectionWithServiceResponseAsync(resourceGroupName, name, vnetName).toBlocking().single().body();
    }

    /**
     * Deletes a connection from an app (or deployment slot to a named virtual network.
     * Deletes a connection from an app (or deployment slot to a named virtual network.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the virtual network.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteVnetConnectionAsync(String resourceGroupName, String name, String vnetName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteVnetConnectionWithServiceResponseAsync(resourceGroupName, name, vnetName), serviceCallback);
    }

    /**
     * Deletes a connection from an app (or deployment slot to a named virtual network.
     * Deletes a connection from an app (or deployment slot to a named virtual network.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the virtual network.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteVnetConnectionAsync(String resourceGroupName, String name, String vnetName) {
        return deleteVnetConnectionWithServiceResponseAsync(resourceGroupName, name, vnetName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a connection from an app (or deployment slot to a named virtual network.
     * Deletes a connection from an app (or deployment slot to a named virtual network.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the virtual network.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteVnetConnectionWithServiceResponseAsync(String resourceGroupName, String name, String vnetName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.deleteVnetConnection(resourceGroupName, name, vnetName, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteVnetConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteVnetConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of an existing Virtual Network.
     * @param connectionEnvelope Properties of the Virtual Network connection. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the VnetInfoInner object if successful.
     */
    public VnetInfoInner updateVnetConnection(String resourceGroupName, String name, String vnetName, VnetInfoInner connectionEnvelope) {
        return updateVnetConnectionWithServiceResponseAsync(resourceGroupName, name, vnetName, connectionEnvelope).toBlocking().single().body();
    }

    /**
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of an existing Virtual Network.
     * @param connectionEnvelope Properties of the Virtual Network connection. See example.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<VnetInfoInner> updateVnetConnectionAsync(String resourceGroupName, String name, String vnetName, VnetInfoInner connectionEnvelope, final ServiceCallback<VnetInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateVnetConnectionWithServiceResponseAsync(resourceGroupName, name, vnetName, connectionEnvelope), serviceCallback);
    }

    /**
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of an existing Virtual Network.
     * @param connectionEnvelope Properties of the Virtual Network connection. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VnetInfoInner object
     */
    public Observable<VnetInfoInner> updateVnetConnectionAsync(String resourceGroupName, String name, String vnetName, VnetInfoInner connectionEnvelope) {
        return updateVnetConnectionWithServiceResponseAsync(resourceGroupName, name, vnetName, connectionEnvelope).map(new Func1<ServiceResponse<VnetInfoInner>, VnetInfoInner>() {
            @Override
            public VnetInfoInner call(ServiceResponse<VnetInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     * Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of an existing Virtual Network.
     * @param connectionEnvelope Properties of the Virtual Network connection. See example.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VnetInfoInner object
     */
    public Observable<ServiceResponse<VnetInfoInner>> updateVnetConnectionWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, VnetInfoInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        final String apiVersion = "2016-08-01";
        return service.updateVnetConnection(resourceGroupName, name, vnetName, this.client.subscriptionId(), connectionEnvelope, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetInfoInner> clientResponse = updateVnetConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetInfoInner> updateVnetConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<VnetInfoInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<VnetInfoInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets an app's Virtual Network gateway.
     * Gets an app's Virtual Network gateway.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the VnetGatewayInner object if successful.
     */
    public VnetGatewayInner getVnetConnectionGateway(String resourceGroupName, String name, String vnetName, String gatewayName) {
        return getVnetConnectionGatewayWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName).toBlocking().single().body();
    }

    /**
     * Gets an app's Virtual Network gateway.
     * Gets an app's Virtual Network gateway.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<VnetGatewayInner> getVnetConnectionGatewayAsync(String resourceGroupName, String name, String vnetName, String gatewayName, final ServiceCallback<VnetGatewayInner> serviceCallback) {
        return ServiceFuture.fromResponse(getVnetConnectionGatewayWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName), serviceCallback);
    }

    /**
     * Gets an app's Virtual Network gateway.
     * Gets an app's Virtual Network gateway.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VnetGatewayInner object
     */
    public Observable<VnetGatewayInner> getVnetConnectionGatewayAsync(String resourceGroupName, String name, String vnetName, String gatewayName) {
        return getVnetConnectionGatewayWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName).map(new Func1<ServiceResponse<VnetGatewayInner>, VnetGatewayInner>() {
            @Override
            public VnetGatewayInner call(ServiceResponse<VnetGatewayInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets an app's Virtual Network gateway.
     * Gets an app's Virtual Network gateway.
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VnetGatewayInner object
     */
    public Observable<ServiceResponse<VnetGatewayInner>> getVnetConnectionGatewayWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, String gatewayName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (gatewayName == null) {
            throw new IllegalArgumentException("Parameter gatewayName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getVnetConnectionGateway(resourceGroupName, name, vnetName, gatewayName, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetGatewayInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetGatewayInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetGatewayInner> clientResponse = getVnetConnectionGatewayDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetGatewayInner> getVnetConnectionGatewayDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<VnetGatewayInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<VnetGatewayInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param connectionEnvelope The properties to update this gateway with.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the VnetGatewayInner object if successful.
     */
    public VnetGatewayInner createOrUpdateVnetConnectionGateway(String resourceGroupName, String name, String vnetName, String gatewayName, VnetGatewayInner connectionEnvelope) {
        return createOrUpdateVnetConnectionGatewayWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope).toBlocking().single().body();
    }

    /**
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param connectionEnvelope The properties to update this gateway with.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<VnetGatewayInner> createOrUpdateVnetConnectionGatewayAsync(String resourceGroupName, String name, String vnetName, String gatewayName, VnetGatewayInner connectionEnvelope, final ServiceCallback<VnetGatewayInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateVnetConnectionGatewayWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope), serviceCallback);
    }

    /**
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param connectionEnvelope The properties to update this gateway with.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VnetGatewayInner object
     */
    public Observable<VnetGatewayInner> createOrUpdateVnetConnectionGatewayAsync(String resourceGroupName, String name, String vnetName, String gatewayName, VnetGatewayInner connectionEnvelope) {
        return createOrUpdateVnetConnectionGatewayWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope).map(new Func1<ServiceResponse<VnetGatewayInner>, VnetGatewayInner>() {
            @Override
            public VnetGatewayInner call(ServiceResponse<VnetGatewayInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param connectionEnvelope The properties to update this gateway with.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VnetGatewayInner object
     */
    public Observable<ServiceResponse<VnetGatewayInner>> createOrUpdateVnetConnectionGatewayWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, String gatewayName, VnetGatewayInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (gatewayName == null) {
            throw new IllegalArgumentException("Parameter gatewayName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        final String apiVersion = "2016-08-01";
        return service.createOrUpdateVnetConnectionGateway(resourceGroupName, name, vnetName, gatewayName, this.client.subscriptionId(), connectionEnvelope, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetGatewayInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetGatewayInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetGatewayInner> clientResponse = createOrUpdateVnetConnectionGatewayDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetGatewayInner> createOrUpdateVnetConnectionGatewayDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<VnetGatewayInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<VnetGatewayInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param connectionEnvelope The properties to update this gateway with.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the VnetGatewayInner object if successful.
     */
    public VnetGatewayInner updateVnetConnectionGateway(String resourceGroupName, String name, String vnetName, String gatewayName, VnetGatewayInner connectionEnvelope) {
        return updateVnetConnectionGatewayWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope).toBlocking().single().body();
    }

    /**
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param connectionEnvelope The properties to update this gateway with.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<VnetGatewayInner> updateVnetConnectionGatewayAsync(String resourceGroupName, String name, String vnetName, String gatewayName, VnetGatewayInner connectionEnvelope, final ServiceCallback<VnetGatewayInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateVnetConnectionGatewayWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope), serviceCallback);
    }

    /**
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param connectionEnvelope The properties to update this gateway with.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VnetGatewayInner object
     */
    public Observable<VnetGatewayInner> updateVnetConnectionGatewayAsync(String resourceGroupName, String name, String vnetName, String gatewayName, VnetGatewayInner connectionEnvelope) {
        return updateVnetConnectionGatewayWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope).map(new Func1<ServiceResponse<VnetGatewayInner>, VnetGatewayInner>() {
            @Override
            public VnetGatewayInner call(ServiceResponse<VnetGatewayInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     *
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param connectionEnvelope The properties to update this gateway with.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VnetGatewayInner object
     */
    public Observable<ServiceResponse<VnetGatewayInner>> updateVnetConnectionGatewayWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, String gatewayName, VnetGatewayInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (gatewayName == null) {
            throw new IllegalArgumentException("Parameter gatewayName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        final String apiVersion = "2016-08-01";
        return service.updateVnetConnectionGateway(resourceGroupName, name, vnetName, gatewayName, this.client.subscriptionId(), connectionEnvelope, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetGatewayInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetGatewayInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetGatewayInner> clientResponse = updateVnetConnectionGatewayDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetGatewayInner> updateVnetConnectionGatewayDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<VnetGatewayInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<VnetGatewayInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get all apps for a subscription.
     * Get all apps for a subscription.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SiteInner&gt; object if successful.
     */
    public PagedList<SiteInner> listNext(final String nextPageLink) {
        ServiceResponse<Page<SiteInner>> response = listNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<SiteInner>(response.body()) {
            @Override
            public Page<SiteInner> nextPage(String nextPageLink) {
                return listNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get all apps for a subscription.
     * Get all apps for a subscription.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SiteInner>> listNextAsync(final String nextPageLink, final ServiceFuture<List<SiteInner>> serviceFuture, final ListOperationCallback<SiteInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(String nextPageLink) {
                    return listNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get all apps for a subscription.
     * Get all apps for a subscription.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<Page<SiteInner>> listNextAsync(final String nextPageLink) {
        return listNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<SiteInner>>, Page<SiteInner>>() {
                @Override
                public Page<SiteInner> call(ServiceResponse<Page<SiteInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get all apps for a subscription.
     * Get all apps for a subscription.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInner>>> listNextWithServiceResponseAsync(final String nextPageLink) {
        return listNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<SiteInner>>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(ServiceResponse<Page<SiteInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get all apps for a subscription.
     * Get all apps for a subscription.
     *
    ServiceResponse<PageImpl<SiteInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInner>>> listNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInner>> result = listNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteInner>> listNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<SiteInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SiteInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets all web, mobile, and API apps in the specified resource group.
     * Gets all web, mobile, and API apps in the specified resource group.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SiteInner&gt; object if successful.
     */
    public PagedList<SiteInner> listByResourceGroupNext(final String nextPageLink) {
        ServiceResponse<Page<SiteInner>> response = listByResourceGroupNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<SiteInner>(response.body()) {
            @Override
            public Page<SiteInner> nextPage(String nextPageLink) {
                return listByResourceGroupNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets all web, mobile, and API apps in the specified resource group.
     * Gets all web, mobile, and API apps in the specified resource group.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SiteInner>> listByResourceGroupNextAsync(final String nextPageLink, final ServiceFuture<List<SiteInner>> serviceFuture, final ListOperationCallback<SiteInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByResourceGroupNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(String nextPageLink) {
                    return listByResourceGroupNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets all web, mobile, and API apps in the specified resource group.
     * Gets all web, mobile, and API apps in the specified resource group.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<Page<SiteInner>> listByResourceGroupNextAsync(final String nextPageLink) {
        return listByResourceGroupNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<SiteInner>>, Page<SiteInner>>() {
                @Override
                public Page<SiteInner> call(ServiceResponse<Page<SiteInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets all web, mobile, and API apps in the specified resource group.
     * Gets all web, mobile, and API apps in the specified resource group.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInner>>> listByResourceGroupNextWithServiceResponseAsync(final String nextPageLink) {
        return listByResourceGroupNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<SiteInner>>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(ServiceResponse<Page<SiteInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByResourceGroupNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets all web, mobile, and API apps in the specified resource group.
     * Gets all web, mobile, and API apps in the specified resource group.
     *
    ServiceResponse<PageImpl<SiteInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInner>>> listByResourceGroupNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listByResourceGroupNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInner>> result = listByResourceGroupNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteInner>> listByResourceGroupNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<SiteInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SiteInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets existing backups of an app.
     * Gets existing backups of an app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;BackupItemInner&gt; object if successful.
     */
    public PagedList<BackupItemInner> listBackupsNext(final String nextPageLink) {
        ServiceResponse<Page<BackupItemInner>> response = listBackupsNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<BackupItemInner>(response.body()) {
            @Override
            public Page<BackupItemInner> nextPage(String nextPageLink) {
                return listBackupsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets existing backups of an app.
     * Gets existing backups of an app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<BackupItemInner>> listBackupsNextAsync(final String nextPageLink, final ServiceFuture<List<BackupItemInner>> serviceFuture, final ListOperationCallback<BackupItemInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listBackupsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(String nextPageLink) {
                    return listBackupsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets existing backups of an app.
     * Gets existing backups of an app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;BackupItemInner&gt; object
     */
    public Observable<Page<BackupItemInner>> listBackupsNextAsync(final String nextPageLink) {
        return listBackupsNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<BackupItemInner>>, Page<BackupItemInner>>() {
                @Override
                public Page<BackupItemInner> call(ServiceResponse<Page<BackupItemInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets existing backups of an app.
     * Gets existing backups of an app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;BackupItemInner&gt; object
     */
    public Observable<ServiceResponse<Page<BackupItemInner>>> listBackupsNextWithServiceResponseAsync(final String nextPageLink) {
        return listBackupsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<BackupItemInner>>, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(ServiceResponse<Page<BackupItemInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listBackupsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets existing backups of an app.
     * Gets existing backups of an app.
     *
    ServiceResponse<PageImpl<BackupItemInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;BackupItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<BackupItemInner>>> listBackupsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listBackupsNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<BackupItemInner>> result = listBackupsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<BackupItemInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<BackupItemInner>> listBackupsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<BackupItemInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<BackupItemInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;DeploymentInner&gt; object if successful.
     */
    public PagedList<DeploymentInner> listDeploymentsNext(final String nextPageLink) {
        ServiceResponse<Page<DeploymentInner>> response = listDeploymentsNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<DeploymentInner>(response.body()) {
            @Override
            public Page<DeploymentInner> nextPage(String nextPageLink) {
                return listDeploymentsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<DeploymentInner>> listDeploymentsNextAsync(final String nextPageLink, final ServiceFuture<List<DeploymentInner>> serviceFuture, final ListOperationCallback<DeploymentInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listDeploymentsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(String nextPageLink) {
                    return listDeploymentsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<Page<DeploymentInner>> listDeploymentsNextAsync(final String nextPageLink) {
        return listDeploymentsNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<DeploymentInner>>, Page<DeploymentInner>>() {
                @Override
                public Page<DeploymentInner> call(ServiceResponse<Page<DeploymentInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> listDeploymentsNextWithServiceResponseAsync(final String nextPageLink) {
        return listDeploymentsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<DeploymentInner>>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(ServiceResponse<Page<DeploymentInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listDeploymentsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     *
    ServiceResponse<PageImpl<DeploymentInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;DeploymentInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> listDeploymentsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listDeploymentsNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<DeploymentInner>> result = listDeploymentsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<DeploymentInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<DeploymentInner>> listDeploymentsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<DeploymentInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<DeploymentInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Lists ownership identifiers for domain associated with web app.
     * Lists ownership identifiers for domain associated with web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;IdentifierInner&gt; object if successful.
     */
    public PagedList<IdentifierInner> listDomainOwnershipIdentifiersNext(final String nextPageLink) {
        ServiceResponse<Page<IdentifierInner>> response = listDomainOwnershipIdentifiersNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<IdentifierInner>(response.body()) {
            @Override
            public Page<IdentifierInner> nextPage(String nextPageLink) {
                return listDomainOwnershipIdentifiersNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists ownership identifiers for domain associated with web app.
     * Lists ownership identifiers for domain associated with web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<IdentifierInner>> listDomainOwnershipIdentifiersNextAsync(final String nextPageLink, final ServiceFuture<List<IdentifierInner>> serviceFuture, final ListOperationCallback<IdentifierInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listDomainOwnershipIdentifiersNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<IdentifierInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<IdentifierInner>>> call(String nextPageLink) {
                    return listDomainOwnershipIdentifiersNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists ownership identifiers for domain associated with web app.
     * Lists ownership identifiers for domain associated with web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;IdentifierInner&gt; object
     */
    public Observable<Page<IdentifierInner>> listDomainOwnershipIdentifiersNextAsync(final String nextPageLink) {
        return listDomainOwnershipIdentifiersNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<IdentifierInner>>, Page<IdentifierInner>>() {
                @Override
                public Page<IdentifierInner> call(ServiceResponse<Page<IdentifierInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists ownership identifiers for domain associated with web app.
     * Lists ownership identifiers for domain associated with web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;IdentifierInner&gt; object
     */
    public Observable<ServiceResponse<Page<IdentifierInner>>> listDomainOwnershipIdentifiersNextWithServiceResponseAsync(final String nextPageLink) {
        return listDomainOwnershipIdentifiersNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<IdentifierInner>>, Observable<ServiceResponse<Page<IdentifierInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<IdentifierInner>>> call(ServiceResponse<Page<IdentifierInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listDomainOwnershipIdentifiersNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists ownership identifiers for domain associated with web app.
     * Lists ownership identifiers for domain associated with web app.
     *
    ServiceResponse<PageImpl<IdentifierInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;IdentifierInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<IdentifierInner>>> listDomainOwnershipIdentifiersNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listDomainOwnershipIdentifiersNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<IdentifierInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<IdentifierInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<IdentifierInner>> result = listDomainOwnershipIdentifiersNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<IdentifierInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<IdentifierInner>> listDomainOwnershipIdentifiersNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<IdentifierInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<IdentifierInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get hostname bindings for an app or a deployment slot.
     * Get hostname bindings for an app or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;HostNameBindingInner&gt; object if successful.
     */
    public PagedList<HostNameBindingInner> listHostNameBindingsNext(final String nextPageLink) {
        ServiceResponse<Page<HostNameBindingInner>> response = listHostNameBindingsNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<HostNameBindingInner>(response.body()) {
            @Override
            public Page<HostNameBindingInner> nextPage(String nextPageLink) {
                return listHostNameBindingsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get hostname bindings for an app or a deployment slot.
     * Get hostname bindings for an app or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<HostNameBindingInner>> listHostNameBindingsNextAsync(final String nextPageLink, final ServiceFuture<List<HostNameBindingInner>> serviceFuture, final ListOperationCallback<HostNameBindingInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listHostNameBindingsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(String nextPageLink) {
                    return listHostNameBindingsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get hostname bindings for an app or a deployment slot.
     * Get hostname bindings for an app or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;HostNameBindingInner&gt; object
     */
    public Observable<Page<HostNameBindingInner>> listHostNameBindingsNextAsync(final String nextPageLink) {
        return listHostNameBindingsNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<HostNameBindingInner>>, Page<HostNameBindingInner>>() {
                @Override
                public Page<HostNameBindingInner> call(ServiceResponse<Page<HostNameBindingInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get hostname bindings for an app or a deployment slot.
     * Get hostname bindings for an app or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;HostNameBindingInner&gt; object
     */
    public Observable<ServiceResponse<Page<HostNameBindingInner>>> listHostNameBindingsNextWithServiceResponseAsync(final String nextPageLink) {
        return listHostNameBindingsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<HostNameBindingInner>>, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(ServiceResponse<Page<HostNameBindingInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listHostNameBindingsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get hostname bindings for an app or a deployment slot.
     * Get hostname bindings for an app or a deployment slot.
     *
    ServiceResponse<PageImpl<HostNameBindingInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;HostNameBindingInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<HostNameBindingInner>>> listHostNameBindingsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listHostNameBindingsNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<HostNameBindingInner>> result = listHostNameBindingsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<HostNameBindingInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<HostNameBindingInner>> listHostNameBindingsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<HostNameBindingInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<HostNameBindingInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets all scale-out instances of an app.
     * Gets all scale-out instances of an app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SiteInstanceInner&gt; object if successful.
     */
    public PagedList<SiteInstanceInner> listInstanceIdentifiersNext(final String nextPageLink) {
        ServiceResponse<Page<SiteInstanceInner>> response = listInstanceIdentifiersNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<SiteInstanceInner>(response.body()) {
            @Override
            public Page<SiteInstanceInner> nextPage(String nextPageLink) {
                return listInstanceIdentifiersNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets all scale-out instances of an app.
     * Gets all scale-out instances of an app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SiteInstanceInner>> listInstanceIdentifiersNextAsync(final String nextPageLink, final ServiceFuture<List<SiteInstanceInner>> serviceFuture, final ListOperationCallback<SiteInstanceInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listInstanceIdentifiersNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(String nextPageLink) {
                    return listInstanceIdentifiersNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets all scale-out instances of an app.
     * Gets all scale-out instances of an app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteInstanceInner&gt; object
     */
    public Observable<Page<SiteInstanceInner>> listInstanceIdentifiersNextAsync(final String nextPageLink) {
        return listInstanceIdentifiersNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<SiteInstanceInner>>, Page<SiteInstanceInner>>() {
                @Override
                public Page<SiteInstanceInner> call(ServiceResponse<Page<SiteInstanceInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets all scale-out instances of an app.
     * Gets all scale-out instances of an app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteInstanceInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInstanceInner>>> listInstanceIdentifiersNextWithServiceResponseAsync(final String nextPageLink) {
        return listInstanceIdentifiersNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<SiteInstanceInner>>, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(ServiceResponse<Page<SiteInstanceInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listInstanceIdentifiersNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets all scale-out instances of an app.
     * Gets all scale-out instances of an app.
     *
    ServiceResponse<PageImpl<SiteInstanceInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SiteInstanceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInstanceInner>>> listInstanceIdentifiersNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listInstanceIdentifiersNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInstanceInner>> result = listInstanceIdentifiersNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInstanceInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteInstanceInner>> listInstanceIdentifiersNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<SiteInstanceInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SiteInstanceInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;DeploymentInner&gt; object if successful.
     */
    public PagedList<DeploymentInner> listInstanceDeploymentsNext(final String nextPageLink) {
        ServiceResponse<Page<DeploymentInner>> response = listInstanceDeploymentsNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<DeploymentInner>(response.body()) {
            @Override
            public Page<DeploymentInner> nextPage(String nextPageLink) {
                return listInstanceDeploymentsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<DeploymentInner>> listInstanceDeploymentsNextAsync(final String nextPageLink, final ServiceFuture<List<DeploymentInner>> serviceFuture, final ListOperationCallback<DeploymentInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listInstanceDeploymentsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(String nextPageLink) {
                    return listInstanceDeploymentsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<Page<DeploymentInner>> listInstanceDeploymentsNextAsync(final String nextPageLink) {
        return listInstanceDeploymentsNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<DeploymentInner>>, Page<DeploymentInner>>() {
                @Override
                public Page<DeploymentInner> call(ServiceResponse<Page<DeploymentInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> listInstanceDeploymentsNextWithServiceResponseAsync(final String nextPageLink) {
        return listInstanceDeploymentsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<DeploymentInner>>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(ServiceResponse<Page<DeploymentInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listInstanceDeploymentsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     *
    ServiceResponse<PageImpl<DeploymentInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;DeploymentInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> listInstanceDeploymentsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listInstanceDeploymentsNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<DeploymentInner>> result = listInstanceDeploymentsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<DeploymentInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<DeploymentInner>> listInstanceDeploymentsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<DeploymentInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<DeploymentInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets all metric definitions of an app (or deployment slot, if specified).
     * Gets all metric definitions of an app (or deployment slot, if specified).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ResourceMetricDefinitionInner&gt; object if successful.
     */
    public PagedList<ResourceMetricDefinitionInner> listMetricDefinitionsNext(final String nextPageLink) {
        ServiceResponse<Page<ResourceMetricDefinitionInner>> response = listMetricDefinitionsNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<ResourceMetricDefinitionInner>(response.body()) {
            @Override
            public Page<ResourceMetricDefinitionInner> nextPage(String nextPageLink) {
                return listMetricDefinitionsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets all metric definitions of an app (or deployment slot, if specified).
     * Gets all metric definitions of an app (or deployment slot, if specified).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ResourceMetricDefinitionInner>> listMetricDefinitionsNextAsync(final String nextPageLink, final ServiceFuture<List<ResourceMetricDefinitionInner>> serviceFuture, final ListOperationCallback<ResourceMetricDefinitionInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listMetricDefinitionsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>> call(String nextPageLink) {
                    return listMetricDefinitionsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets all metric definitions of an app (or deployment slot, if specified).
     * Gets all metric definitions of an app (or deployment slot, if specified).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ResourceMetricDefinitionInner&gt; object
     */
    public Observable<Page<ResourceMetricDefinitionInner>> listMetricDefinitionsNextAsync(final String nextPageLink) {
        return listMetricDefinitionsNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<ResourceMetricDefinitionInner>>, Page<ResourceMetricDefinitionInner>>() {
                @Override
                public Page<ResourceMetricDefinitionInner> call(ServiceResponse<Page<ResourceMetricDefinitionInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets all metric definitions of an app (or deployment slot, if specified).
     * Gets all metric definitions of an app (or deployment slot, if specified).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ResourceMetricDefinitionInner&gt; object
     */
    public Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>> listMetricDefinitionsNextWithServiceResponseAsync(final String nextPageLink) {
        return listMetricDefinitionsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<ResourceMetricDefinitionInner>>, Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>> call(ServiceResponse<Page<ResourceMetricDefinitionInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listMetricDefinitionsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets all metric definitions of an app (or deployment slot, if specified).
     * Gets all metric definitions of an app (or deployment slot, if specified).
     *
    ServiceResponse<PageImpl<ResourceMetricDefinitionInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ResourceMetricDefinitionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>> listMetricDefinitionsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listMetricDefinitionsNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ResourceMetricDefinitionInner>> result = listMetricDefinitionsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ResourceMetricDefinitionInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ResourceMetricDefinitionInner>> listMetricDefinitionsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ResourceMetricDefinitionInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ResourceMetricDefinitionInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ResourceMetricInner&gt; object if successful.
     */
    public PagedList<ResourceMetricInner> listMetricsNext(final String nextPageLink) {
        ServiceResponse<Page<ResourceMetricInner>> response = listMetricsNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<ResourceMetricInner>(response.body()) {
            @Override
            public Page<ResourceMetricInner> nextPage(String nextPageLink) {
                return listMetricsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ResourceMetricInner>> listMetricsNextAsync(final String nextPageLink, final ServiceFuture<List<ResourceMetricInner>> serviceFuture, final ListOperationCallback<ResourceMetricInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listMetricsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(String nextPageLink) {
                    return listMetricsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<Page<ResourceMetricInner>> listMetricsNextAsync(final String nextPageLink) {
        return listMetricsNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Page<ResourceMetricInner>>() {
                @Override
                public Page<ResourceMetricInner> call(ServiceResponse<Page<ResourceMetricInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> listMetricsNextWithServiceResponseAsync(final String nextPageLink) {
        return listMetricsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(ServiceResponse<Page<ResourceMetricInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listMetricsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ResourceMetricInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> listMetricsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listMetricsNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ResourceMetricInner>> result = listMetricsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ResourceMetricInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ResourceMetricInner>> listMetricsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ResourceMetricInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ResourceMetricInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;PerfMonResponseInner&gt; object if successful.
     */
    public PagedList<PerfMonResponseInner> listPerfMonCountersNext(final String nextPageLink) {
        ServiceResponse<Page<PerfMonResponseInner>> response = listPerfMonCountersNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<PerfMonResponseInner>(response.body()) {
            @Override
            public Page<PerfMonResponseInner> nextPage(String nextPageLink) {
                return listPerfMonCountersNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<PerfMonResponseInner>> listPerfMonCountersNextAsync(final String nextPageLink, final ServiceFuture<List<PerfMonResponseInner>> serviceFuture, final ListOperationCallback<PerfMonResponseInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listPerfMonCountersNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(String nextPageLink) {
                    return listPerfMonCountersNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;PerfMonResponseInner&gt; object
     */
    public Observable<Page<PerfMonResponseInner>> listPerfMonCountersNextAsync(final String nextPageLink) {
        return listPerfMonCountersNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<PerfMonResponseInner>>, Page<PerfMonResponseInner>>() {
                @Override
                public Page<PerfMonResponseInner> call(ServiceResponse<Page<PerfMonResponseInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;PerfMonResponseInner&gt; object
     */
    public Observable<ServiceResponse<Page<PerfMonResponseInner>>> listPerfMonCountersNextWithServiceResponseAsync(final String nextPageLink) {
        return listPerfMonCountersNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<PerfMonResponseInner>>, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(ServiceResponse<Page<PerfMonResponseInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listPerfMonCountersNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
    ServiceResponse<PageImpl<PerfMonResponseInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;PerfMonResponseInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<PerfMonResponseInner>>> listPerfMonCountersNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listPerfMonCountersNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<PerfMonResponseInner>> result = listPerfMonCountersNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<PerfMonResponseInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<PerfMonResponseInner>> listPerfMonCountersNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<PerfMonResponseInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<PerfMonResponseInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets an app's deployment slots.
     * Gets an app's deployment slots.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SiteInner&gt; object if successful.
     */
    public PagedList<SiteInner> listSlotsNext(final String nextPageLink) {
        ServiceResponse<Page<SiteInner>> response = listSlotsNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<SiteInner>(response.body()) {
            @Override
            public Page<SiteInner> nextPage(String nextPageLink) {
                return listSlotsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets an app's deployment slots.
     * Gets an app's deployment slots.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SiteInner>> listSlotsNextAsync(final String nextPageLink, final ServiceFuture<List<SiteInner>> serviceFuture, final ListOperationCallback<SiteInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listSlotsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(String nextPageLink) {
                    return listSlotsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets an app's deployment slots.
     * Gets an app's deployment slots.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<Page<SiteInner>> listSlotsNextAsync(final String nextPageLink) {
        return listSlotsNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<SiteInner>>, Page<SiteInner>>() {
                @Override
                public Page<SiteInner> call(ServiceResponse<Page<SiteInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets an app's deployment slots.
     * Gets an app's deployment slots.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInner>>> listSlotsNextWithServiceResponseAsync(final String nextPageLink) {
        return listSlotsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<SiteInner>>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(ServiceResponse<Page<SiteInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listSlotsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets an app's deployment slots.
     * Gets an app's deployment slots.
     *
    ServiceResponse<PageImpl<SiteInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInner>>> listSlotsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listSlotsNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInner>> result = listSlotsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteInner>> listSlotsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<SiteInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SiteInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets existing backups of an app.
     * Gets existing backups of an app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;BackupItemInner&gt; object if successful.
     */
    public PagedList<BackupItemInner> listBackupsSlotNext(final String nextPageLink) {
        ServiceResponse<Page<BackupItemInner>> response = listBackupsSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<BackupItemInner>(response.body()) {
            @Override
            public Page<BackupItemInner> nextPage(String nextPageLink) {
                return listBackupsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets existing backups of an app.
     * Gets existing backups of an app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<BackupItemInner>> listBackupsSlotNextAsync(final String nextPageLink, final ServiceFuture<List<BackupItemInner>> serviceFuture, final ListOperationCallback<BackupItemInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listBackupsSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(String nextPageLink) {
                    return listBackupsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets existing backups of an app.
     * Gets existing backups of an app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;BackupItemInner&gt; object
     */
    public Observable<Page<BackupItemInner>> listBackupsSlotNextAsync(final String nextPageLink) {
        return listBackupsSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<BackupItemInner>>, Page<BackupItemInner>>() {
                @Override
                public Page<BackupItemInner> call(ServiceResponse<Page<BackupItemInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets existing backups of an app.
     * Gets existing backups of an app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;BackupItemInner&gt; object
     */
    public Observable<ServiceResponse<Page<BackupItemInner>>> listBackupsSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return listBackupsSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<BackupItemInner>>, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(ServiceResponse<Page<BackupItemInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listBackupsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets existing backups of an app.
     * Gets existing backups of an app.
     *
    ServiceResponse<PageImpl<BackupItemInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;BackupItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<BackupItemInner>>> listBackupsSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listBackupsSlotNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<BackupItemInner>> result = listBackupsSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<BackupItemInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<BackupItemInner>> listBackupsSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<BackupItemInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<BackupItemInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;DeploymentInner&gt; object if successful.
     */
    public PagedList<DeploymentInner> listDeploymentsSlotNext(final String nextPageLink) {
        ServiceResponse<Page<DeploymentInner>> response = listDeploymentsSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<DeploymentInner>(response.body()) {
            @Override
            public Page<DeploymentInner> nextPage(String nextPageLink) {
                return listDeploymentsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<DeploymentInner>> listDeploymentsSlotNextAsync(final String nextPageLink, final ServiceFuture<List<DeploymentInner>> serviceFuture, final ListOperationCallback<DeploymentInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listDeploymentsSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(String nextPageLink) {
                    return listDeploymentsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<Page<DeploymentInner>> listDeploymentsSlotNextAsync(final String nextPageLink) {
        return listDeploymentsSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<DeploymentInner>>, Page<DeploymentInner>>() {
                @Override
                public Page<DeploymentInner> call(ServiceResponse<Page<DeploymentInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> listDeploymentsSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return listDeploymentsSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<DeploymentInner>>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(ServiceResponse<Page<DeploymentInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listDeploymentsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     *
    ServiceResponse<PageImpl<DeploymentInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;DeploymentInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> listDeploymentsSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listDeploymentsSlotNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<DeploymentInner>> result = listDeploymentsSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<DeploymentInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<DeploymentInner>> listDeploymentsSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<DeploymentInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<DeploymentInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Lists ownership identifiers for domain associated with web app.
     * Lists ownership identifiers for domain associated with web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;IdentifierInner&gt; object if successful.
     */
    public PagedList<IdentifierInner> listDomainOwnershipIdentifiersSlotNext(final String nextPageLink) {
        ServiceResponse<Page<IdentifierInner>> response = listDomainOwnershipIdentifiersSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<IdentifierInner>(response.body()) {
            @Override
            public Page<IdentifierInner> nextPage(String nextPageLink) {
                return listDomainOwnershipIdentifiersSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists ownership identifiers for domain associated with web app.
     * Lists ownership identifiers for domain associated with web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<IdentifierInner>> listDomainOwnershipIdentifiersSlotNextAsync(final String nextPageLink, final ServiceFuture<List<IdentifierInner>> serviceFuture, final ListOperationCallback<IdentifierInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listDomainOwnershipIdentifiersSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<IdentifierInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<IdentifierInner>>> call(String nextPageLink) {
                    return listDomainOwnershipIdentifiersSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists ownership identifiers for domain associated with web app.
     * Lists ownership identifiers for domain associated with web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;IdentifierInner&gt; object
     */
    public Observable<Page<IdentifierInner>> listDomainOwnershipIdentifiersSlotNextAsync(final String nextPageLink) {
        return listDomainOwnershipIdentifiersSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<IdentifierInner>>, Page<IdentifierInner>>() {
                @Override
                public Page<IdentifierInner> call(ServiceResponse<Page<IdentifierInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists ownership identifiers for domain associated with web app.
     * Lists ownership identifiers for domain associated with web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;IdentifierInner&gt; object
     */
    public Observable<ServiceResponse<Page<IdentifierInner>>> listDomainOwnershipIdentifiersSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return listDomainOwnershipIdentifiersSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<IdentifierInner>>, Observable<ServiceResponse<Page<IdentifierInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<IdentifierInner>>> call(ServiceResponse<Page<IdentifierInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listDomainOwnershipIdentifiersSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists ownership identifiers for domain associated with web app.
     * Lists ownership identifiers for domain associated with web app.
     *
    ServiceResponse<PageImpl<IdentifierInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;IdentifierInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<IdentifierInner>>> listDomainOwnershipIdentifiersSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listDomainOwnershipIdentifiersSlotNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<IdentifierInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<IdentifierInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<IdentifierInner>> result = listDomainOwnershipIdentifiersSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<IdentifierInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<IdentifierInner>> listDomainOwnershipIdentifiersSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<IdentifierInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<IdentifierInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get hostname bindings for an app or a deployment slot.
     * Get hostname bindings for an app or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;HostNameBindingInner&gt; object if successful.
     */
    public PagedList<HostNameBindingInner> listHostNameBindingsSlotNext(final String nextPageLink) {
        ServiceResponse<Page<HostNameBindingInner>> response = listHostNameBindingsSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<HostNameBindingInner>(response.body()) {
            @Override
            public Page<HostNameBindingInner> nextPage(String nextPageLink) {
                return listHostNameBindingsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get hostname bindings for an app or a deployment slot.
     * Get hostname bindings for an app or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<HostNameBindingInner>> listHostNameBindingsSlotNextAsync(final String nextPageLink, final ServiceFuture<List<HostNameBindingInner>> serviceFuture, final ListOperationCallback<HostNameBindingInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listHostNameBindingsSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(String nextPageLink) {
                    return listHostNameBindingsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get hostname bindings for an app or a deployment slot.
     * Get hostname bindings for an app or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;HostNameBindingInner&gt; object
     */
    public Observable<Page<HostNameBindingInner>> listHostNameBindingsSlotNextAsync(final String nextPageLink) {
        return listHostNameBindingsSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<HostNameBindingInner>>, Page<HostNameBindingInner>>() {
                @Override
                public Page<HostNameBindingInner> call(ServiceResponse<Page<HostNameBindingInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get hostname bindings for an app or a deployment slot.
     * Get hostname bindings for an app or a deployment slot.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;HostNameBindingInner&gt; object
     */
    public Observable<ServiceResponse<Page<HostNameBindingInner>>> listHostNameBindingsSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return listHostNameBindingsSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<HostNameBindingInner>>, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(ServiceResponse<Page<HostNameBindingInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listHostNameBindingsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get hostname bindings for an app or a deployment slot.
     * Get hostname bindings for an app or a deployment slot.
     *
    ServiceResponse<PageImpl<HostNameBindingInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;HostNameBindingInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<HostNameBindingInner>>> listHostNameBindingsSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listHostNameBindingsSlotNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<HostNameBindingInner>> result = listHostNameBindingsSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<HostNameBindingInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<HostNameBindingInner>> listHostNameBindingsSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<HostNameBindingInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<HostNameBindingInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets all scale-out instances of an app.
     * Gets all scale-out instances of an app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SiteInstanceInner&gt; object if successful.
     */
    public PagedList<SiteInstanceInner> listInstanceIdentifiersSlotNext(final String nextPageLink) {
        ServiceResponse<Page<SiteInstanceInner>> response = listInstanceIdentifiersSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<SiteInstanceInner>(response.body()) {
            @Override
            public Page<SiteInstanceInner> nextPage(String nextPageLink) {
                return listInstanceIdentifiersSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets all scale-out instances of an app.
     * Gets all scale-out instances of an app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SiteInstanceInner>> listInstanceIdentifiersSlotNextAsync(final String nextPageLink, final ServiceFuture<List<SiteInstanceInner>> serviceFuture, final ListOperationCallback<SiteInstanceInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listInstanceIdentifiersSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(String nextPageLink) {
                    return listInstanceIdentifiersSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets all scale-out instances of an app.
     * Gets all scale-out instances of an app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteInstanceInner&gt; object
     */
    public Observable<Page<SiteInstanceInner>> listInstanceIdentifiersSlotNextAsync(final String nextPageLink) {
        return listInstanceIdentifiersSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<SiteInstanceInner>>, Page<SiteInstanceInner>>() {
                @Override
                public Page<SiteInstanceInner> call(ServiceResponse<Page<SiteInstanceInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets all scale-out instances of an app.
     * Gets all scale-out instances of an app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SiteInstanceInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInstanceInner>>> listInstanceIdentifiersSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return listInstanceIdentifiersSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<SiteInstanceInner>>, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(ServiceResponse<Page<SiteInstanceInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listInstanceIdentifiersSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets all scale-out instances of an app.
     * Gets all scale-out instances of an app.
     *
    ServiceResponse<PageImpl<SiteInstanceInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SiteInstanceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInstanceInner>>> listInstanceIdentifiersSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listInstanceIdentifiersSlotNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInstanceInner>> result = listInstanceIdentifiersSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInstanceInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteInstanceInner>> listInstanceIdentifiersSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<SiteInstanceInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SiteInstanceInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;DeploymentInner&gt; object if successful.
     */
    public PagedList<DeploymentInner> listInstanceDeploymentsSlotNext(final String nextPageLink) {
        ServiceResponse<Page<DeploymentInner>> response = listInstanceDeploymentsSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<DeploymentInner>(response.body()) {
            @Override
            public Page<DeploymentInner> nextPage(String nextPageLink) {
                return listInstanceDeploymentsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<DeploymentInner>> listInstanceDeploymentsSlotNextAsync(final String nextPageLink, final ServiceFuture<List<DeploymentInner>> serviceFuture, final ListOperationCallback<DeploymentInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listInstanceDeploymentsSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(String nextPageLink) {
                    return listInstanceDeploymentsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<Page<DeploymentInner>> listInstanceDeploymentsSlotNextAsync(final String nextPageLink) {
        return listInstanceDeploymentsSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<DeploymentInner>>, Page<DeploymentInner>>() {
                @Override
                public Page<DeploymentInner> call(ServiceResponse<Page<DeploymentInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> listInstanceDeploymentsSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return listInstanceDeploymentsSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<DeploymentInner>>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(ServiceResponse<Page<DeploymentInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listInstanceDeploymentsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     * List deployments for an app, or a deployment slot, or for an instance of a scaled-out app.
     *
    ServiceResponse<PageImpl<DeploymentInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;DeploymentInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> listInstanceDeploymentsSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listInstanceDeploymentsSlotNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<DeploymentInner>> result = listInstanceDeploymentsSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<DeploymentInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<DeploymentInner>> listInstanceDeploymentsSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<DeploymentInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<DeploymentInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets all metric definitions of an app (or deployment slot, if specified).
     * Gets all metric definitions of an app (or deployment slot, if specified).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ResourceMetricDefinitionInner&gt; object if successful.
     */
    public PagedList<ResourceMetricDefinitionInner> listMetricDefinitionsSlotNext(final String nextPageLink) {
        ServiceResponse<Page<ResourceMetricDefinitionInner>> response = listMetricDefinitionsSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<ResourceMetricDefinitionInner>(response.body()) {
            @Override
            public Page<ResourceMetricDefinitionInner> nextPage(String nextPageLink) {
                return listMetricDefinitionsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets all metric definitions of an app (or deployment slot, if specified).
     * Gets all metric definitions of an app (or deployment slot, if specified).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ResourceMetricDefinitionInner>> listMetricDefinitionsSlotNextAsync(final String nextPageLink, final ServiceFuture<List<ResourceMetricDefinitionInner>> serviceFuture, final ListOperationCallback<ResourceMetricDefinitionInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listMetricDefinitionsSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>> call(String nextPageLink) {
                    return listMetricDefinitionsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets all metric definitions of an app (or deployment slot, if specified).
     * Gets all metric definitions of an app (or deployment slot, if specified).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ResourceMetricDefinitionInner&gt; object
     */
    public Observable<Page<ResourceMetricDefinitionInner>> listMetricDefinitionsSlotNextAsync(final String nextPageLink) {
        return listMetricDefinitionsSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<ResourceMetricDefinitionInner>>, Page<ResourceMetricDefinitionInner>>() {
                @Override
                public Page<ResourceMetricDefinitionInner> call(ServiceResponse<Page<ResourceMetricDefinitionInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets all metric definitions of an app (or deployment slot, if specified).
     * Gets all metric definitions of an app (or deployment slot, if specified).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ResourceMetricDefinitionInner&gt; object
     */
    public Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>> listMetricDefinitionsSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return listMetricDefinitionsSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<ResourceMetricDefinitionInner>>, Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>> call(ServiceResponse<Page<ResourceMetricDefinitionInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listMetricDefinitionsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets all metric definitions of an app (or deployment slot, if specified).
     * Gets all metric definitions of an app (or deployment slot, if specified).
     *
    ServiceResponse<PageImpl<ResourceMetricDefinitionInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ResourceMetricDefinitionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>> listMetricDefinitionsSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listMetricDefinitionsSlotNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricDefinitionInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ResourceMetricDefinitionInner>> result = listMetricDefinitionsSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ResourceMetricDefinitionInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ResourceMetricDefinitionInner>> listMetricDefinitionsSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ResourceMetricDefinitionInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ResourceMetricDefinitionInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ResourceMetricInner&gt; object if successful.
     */
    public PagedList<ResourceMetricInner> listMetricsSlotNext(final String nextPageLink) {
        ServiceResponse<Page<ResourceMetricInner>> response = listMetricsSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<ResourceMetricInner>(response.body()) {
            @Override
            public Page<ResourceMetricInner> nextPage(String nextPageLink) {
                return listMetricsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ResourceMetricInner>> listMetricsSlotNextAsync(final String nextPageLink, final ServiceFuture<List<ResourceMetricInner>> serviceFuture, final ListOperationCallback<ResourceMetricInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listMetricsSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(String nextPageLink) {
                    return listMetricsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<Page<ResourceMetricInner>> listMetricsSlotNextAsync(final String nextPageLink) {
        return listMetricsSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Page<ResourceMetricInner>>() {
                @Override
                public Page<ResourceMetricInner> call(ServiceResponse<Page<ResourceMetricInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> listMetricsSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return listMetricsSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(ServiceResponse<Page<ResourceMetricInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listMetricsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets performance metrics of an app (or deployment slot, if specified).
     * Gets performance metrics of an app (or deployment slot, if specified).
     *
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ResourceMetricInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> listMetricsSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listMetricsSlotNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ResourceMetricInner>> result = listMetricsSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ResourceMetricInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ResourceMetricInner>> listMetricsSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ResourceMetricInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ResourceMetricInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;PerfMonResponseInner&gt; object if successful.
     */
    public PagedList<PerfMonResponseInner> listPerfMonCountersSlotNext(final String nextPageLink) {
        ServiceResponse<Page<PerfMonResponseInner>> response = listPerfMonCountersSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<PerfMonResponseInner>(response.body()) {
            @Override
            public Page<PerfMonResponseInner> nextPage(String nextPageLink) {
                return listPerfMonCountersSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<PerfMonResponseInner>> listPerfMonCountersSlotNextAsync(final String nextPageLink, final ServiceFuture<List<PerfMonResponseInner>> serviceFuture, final ListOperationCallback<PerfMonResponseInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listPerfMonCountersSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(String nextPageLink) {
                    return listPerfMonCountersSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;PerfMonResponseInner&gt; object
     */
    public Observable<Page<PerfMonResponseInner>> listPerfMonCountersSlotNextAsync(final String nextPageLink) {
        return listPerfMonCountersSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<PerfMonResponseInner>>, Page<PerfMonResponseInner>>() {
                @Override
                public Page<PerfMonResponseInner> call(ServiceResponse<Page<PerfMonResponseInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;PerfMonResponseInner&gt; object
     */
    public Observable<ServiceResponse<Page<PerfMonResponseInner>>> listPerfMonCountersSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return listPerfMonCountersSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<PerfMonResponseInner>>, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(ServiceResponse<Page<PerfMonResponseInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listPerfMonCountersSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
    ServiceResponse<PageImpl<PerfMonResponseInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;PerfMonResponseInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<PerfMonResponseInner>>> listPerfMonCountersSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listPerfMonCountersSlotNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<PerfMonResponseInner>> result = listPerfMonCountersSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<PerfMonResponseInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<PerfMonResponseInner>> listPerfMonCountersSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<PerfMonResponseInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<PerfMonResponseInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SlotDifferenceInner&gt; object if successful.
     */
    public PagedList<SlotDifferenceInner> listSlotDifferencesSlotNext(final String nextPageLink) {
        ServiceResponse<Page<SlotDifferenceInner>> response = listSlotDifferencesSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<SlotDifferenceInner>(response.body()) {
            @Override
            public Page<SlotDifferenceInner> nextPage(String nextPageLink) {
                return listSlotDifferencesSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SlotDifferenceInner>> listSlotDifferencesSlotNextAsync(final String nextPageLink, final ServiceFuture<List<SlotDifferenceInner>> serviceFuture, final ListOperationCallback<SlotDifferenceInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listSlotDifferencesSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(String nextPageLink) {
                    return listSlotDifferencesSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SlotDifferenceInner&gt; object
     */
    public Observable<Page<SlotDifferenceInner>> listSlotDifferencesSlotNextAsync(final String nextPageLink) {
        return listSlotDifferencesSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<SlotDifferenceInner>>, Page<SlotDifferenceInner>>() {
                @Override
                public Page<SlotDifferenceInner> call(ServiceResponse<Page<SlotDifferenceInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SlotDifferenceInner&gt; object
     */
    public Observable<ServiceResponse<Page<SlotDifferenceInner>>> listSlotDifferencesSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return listSlotDifferencesSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<SlotDifferenceInner>>, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(ServiceResponse<Page<SlotDifferenceInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listSlotDifferencesSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
    ServiceResponse<PageImpl<SlotDifferenceInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SlotDifferenceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SlotDifferenceInner>>> listSlotDifferencesSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listSlotDifferencesSlotNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SlotDifferenceInner>> result = listSlotDifferencesSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SlotDifferenceInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SlotDifferenceInner>> listSlotDifferencesSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<SlotDifferenceInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SlotDifferenceInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SnapshotInner&gt; object if successful.
     */
    public PagedList<SnapshotInner> listSnapshotsSlotNext(final String nextPageLink) {
        ServiceResponse<Page<SnapshotInner>> response = listSnapshotsSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<SnapshotInner>(response.body()) {
            @Override
            public Page<SnapshotInner> nextPage(String nextPageLink) {
                return listSnapshotsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SnapshotInner>> listSnapshotsSlotNextAsync(final String nextPageLink, final ServiceFuture<List<SnapshotInner>> serviceFuture, final ListOperationCallback<SnapshotInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listSnapshotsSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<SnapshotInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SnapshotInner>>> call(String nextPageLink) {
                    return listSnapshotsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SnapshotInner&gt; object
     */
    public Observable<Page<SnapshotInner>> listSnapshotsSlotNextAsync(final String nextPageLink) {
        return listSnapshotsSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<SnapshotInner>>, Page<SnapshotInner>>() {
                @Override
                public Page<SnapshotInner> call(ServiceResponse<Page<SnapshotInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SnapshotInner&gt; object
     */
    public Observable<ServiceResponse<Page<SnapshotInner>>> listSnapshotsSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return listSnapshotsSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<SnapshotInner>>, Observable<ServiceResponse<Page<SnapshotInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SnapshotInner>>> call(ServiceResponse<Page<SnapshotInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listSnapshotsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
    ServiceResponse<PageImpl<SnapshotInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SnapshotInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SnapshotInner>>> listSnapshotsSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listSnapshotsSlotNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SnapshotInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SnapshotInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SnapshotInner>> result = listSnapshotsSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SnapshotInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SnapshotInner>> listSnapshotsSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<SnapshotInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SnapshotInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;CsmUsageQuotaInner&gt; object if successful.
     */
    public PagedList<CsmUsageQuotaInner> listUsagesSlotNext(final String nextPageLink) {
        ServiceResponse<Page<CsmUsageQuotaInner>> response = listUsagesSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<CsmUsageQuotaInner>(response.body()) {
            @Override
            public Page<CsmUsageQuotaInner> nextPage(String nextPageLink) {
                return listUsagesSlotNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<CsmUsageQuotaInner>> listUsagesSlotNextAsync(final String nextPageLink, final ServiceFuture<List<CsmUsageQuotaInner>> serviceFuture, final ListOperationCallback<CsmUsageQuotaInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listUsagesSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(String nextPageLink) {
                    return listUsagesSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<Page<CsmUsageQuotaInner>> listUsagesSlotNextAsync(final String nextPageLink) {
        return listUsagesSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Page<CsmUsageQuotaInner>>() {
                @Override
                public Page<CsmUsageQuotaInner> call(ServiceResponse<Page<CsmUsageQuotaInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> listUsagesSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return listUsagesSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(ServiceResponse<Page<CsmUsageQuotaInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listUsagesSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
    ServiceResponse<PageImpl<CsmUsageQuotaInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;CsmUsageQuotaInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> listUsagesSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listUsagesSlotNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<CsmUsageQuotaInner>> result = listUsagesSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<CsmUsageQuotaInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<CsmUsageQuotaInner>> listUsagesSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<CsmUsageQuotaInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<CsmUsageQuotaInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SlotDifferenceInner&gt; object if successful.
     */
    public PagedList<SlotDifferenceInner> listSlotDifferencesFromProductionNext(final String nextPageLink) {
        ServiceResponse<Page<SlotDifferenceInner>> response = listSlotDifferencesFromProductionNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<SlotDifferenceInner>(response.body()) {
            @Override
            public Page<SlotDifferenceInner> nextPage(String nextPageLink) {
                return listSlotDifferencesFromProductionNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SlotDifferenceInner>> listSlotDifferencesFromProductionNextAsync(final String nextPageLink, final ServiceFuture<List<SlotDifferenceInner>> serviceFuture, final ListOperationCallback<SlotDifferenceInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listSlotDifferencesFromProductionNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(String nextPageLink) {
                    return listSlotDifferencesFromProductionNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SlotDifferenceInner&gt; object
     */
    public Observable<Page<SlotDifferenceInner>> listSlotDifferencesFromProductionNextAsync(final String nextPageLink) {
        return listSlotDifferencesFromProductionNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<SlotDifferenceInner>>, Page<SlotDifferenceInner>>() {
                @Override
                public Page<SlotDifferenceInner> call(ServiceResponse<Page<SlotDifferenceInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SlotDifferenceInner&gt; object
     */
    public Observable<ServiceResponse<Page<SlotDifferenceInner>>> listSlotDifferencesFromProductionNextWithServiceResponseAsync(final String nextPageLink) {
        return listSlotDifferencesFromProductionNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<SlotDifferenceInner>>, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(ServiceResponse<Page<SlotDifferenceInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listSlotDifferencesFromProductionNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
    ServiceResponse<PageImpl<SlotDifferenceInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SlotDifferenceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SlotDifferenceInner>>> listSlotDifferencesFromProductionNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listSlotDifferencesFromProductionNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SlotDifferenceInner>> result = listSlotDifferencesFromProductionNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SlotDifferenceInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SlotDifferenceInner>> listSlotDifferencesFromProductionNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<SlotDifferenceInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SlotDifferenceInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SnapshotInner&gt; object if successful.
     */
    public PagedList<SnapshotInner> listSnapshotsNext(final String nextPageLink) {
        ServiceResponse<Page<SnapshotInner>> response = listSnapshotsNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<SnapshotInner>(response.body()) {
            @Override
            public Page<SnapshotInner> nextPage(String nextPageLink) {
                return listSnapshotsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SnapshotInner>> listSnapshotsNextAsync(final String nextPageLink, final ServiceFuture<List<SnapshotInner>> serviceFuture, final ListOperationCallback<SnapshotInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listSnapshotsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<SnapshotInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SnapshotInner>>> call(String nextPageLink) {
                    return listSnapshotsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SnapshotInner&gt; object
     */
    public Observable<Page<SnapshotInner>> listSnapshotsNextAsync(final String nextPageLink) {
        return listSnapshotsNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<SnapshotInner>>, Page<SnapshotInner>>() {
                @Override
                public Page<SnapshotInner> call(ServiceResponse<Page<SnapshotInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SnapshotInner&gt; object
     */
    public Observable<ServiceResponse<Page<SnapshotInner>>> listSnapshotsNextWithServiceResponseAsync(final String nextPageLink) {
        return listSnapshotsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<SnapshotInner>>, Observable<ServiceResponse<Page<SnapshotInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SnapshotInner>>> call(ServiceResponse<Page<SnapshotInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listSnapshotsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
    ServiceResponse<PageImpl<SnapshotInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SnapshotInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SnapshotInner>>> listSnapshotsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listSnapshotsNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SnapshotInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SnapshotInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SnapshotInner>> result = listSnapshotsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SnapshotInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SnapshotInner>> listSnapshotsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<SnapshotInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SnapshotInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;CsmUsageQuotaInner&gt; object if successful.
     */
    public PagedList<CsmUsageQuotaInner> listUsagesNext(final String nextPageLink) {
        ServiceResponse<Page<CsmUsageQuotaInner>> response = listUsagesNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<CsmUsageQuotaInner>(response.body()) {
            @Override
            public Page<CsmUsageQuotaInner> nextPage(String nextPageLink) {
                return listUsagesNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<CsmUsageQuotaInner>> listUsagesNextAsync(final String nextPageLink, final ServiceFuture<List<CsmUsageQuotaInner>> serviceFuture, final ListOperationCallback<CsmUsageQuotaInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listUsagesNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(String nextPageLink) {
                    return listUsagesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<Page<CsmUsageQuotaInner>> listUsagesNextAsync(final String nextPageLink) {
        return listUsagesNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Page<CsmUsageQuotaInner>>() {
                @Override
                public Page<CsmUsageQuotaInner> call(ServiceResponse<Page<CsmUsageQuotaInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> listUsagesNextWithServiceResponseAsync(final String nextPageLink) {
        return listUsagesNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(ServiceResponse<Page<CsmUsageQuotaInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listUsagesNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the quota usage information of an app (or deployment slot, if specified).
     * Gets the quota usage information of an app (or deployment slot, if specified).
     *
    ServiceResponse<PageImpl<CsmUsageQuotaInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;CsmUsageQuotaInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> listUsagesNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listUsagesNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<CsmUsageQuotaInner>> result = listUsagesNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<CsmUsageQuotaInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<CsmUsageQuotaInner>> listUsagesNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<CsmUsageQuotaInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<CsmUsageQuotaInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

}
