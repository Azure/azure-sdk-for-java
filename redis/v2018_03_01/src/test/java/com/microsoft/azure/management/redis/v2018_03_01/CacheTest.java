/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.management.redis.v2018_03_01;
import com.microsoft.azure.arm.core.TestBase;
import com.microsoft.azure.credentials.ApplicationTokenCredentials;
import com.microsoft.azure.management.redis.v2018_03_01.implementation. CacheManager;
import com.microsoft.azure.management.resources.implementation.ResourceManager;
import com.microsoft.rest.RestClient;
import com.microsoft.azure.arm.utils.SdkContext;
import org.junit.Ignore;
import org.junit.Test;
import org.junit.Assert;
import com.microsoft.azure.arm.resources.Region;
import com.microsoft.azure.management.resources.ResourceGroup;
import rx.functions.Func1;

import java.io.File;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.Proxy;
import java.util.ArrayList;
import java.util.List;

public class  CacheTest extends TestBase {
    protected static ResourceManager resourceManager;
    protected static CacheManager manager;
    private static String rgName;
    protected static String RG_NAME = "";
    protected static String RC_NAME = "";
    protected static String RC_PATCH_NAME = "";

    @Override
    protected void initializeClients(RestClient restClient, String defaultSubscription, String domain) {
        final File credFile = new File(System.getenv("AZURE_AUTH_LOCATION"));
        try {
            ApplicationTokenCredentials credentials = ApplicationTokenCredentials.fromFile(credFile);

            resourceManager = ResourceManager
                    .authenticate(restClient)
                    .withSubscription(defaultSubscription);

            manager = CacheManager
                    .authenticate(restClient, defaultSubscription);

            RG_NAME = generateRandomResourceName("fl-redis-rg", 20);
            RC_NAME = generateRandomResourceName("fl-redis", 15);
            RC_PATCH_NAME = generateRandomResourceName("fl-rp", 15);
        } catch(IOException ex) {
        }
    }
    @Override
    protected void cleanUpResources() {
        resourceManager.resourceGroups().beginDeleteByName(rgName);
    }

    @Override
    protected Proxy proxy() {
        return new Proxy(Proxy.Type.HTTP, new InetSocketAddress("localhost", 8888));
    }

    @Test
    @Ignore("Test fails in the middle due to withTag issue in update stage. https://github.com/Azure/autorest.java/issues/207 ")
    public void canCRUDRedis() throws Exception {
        resourceManager.resourceGroups()
                .define(RG_NAME)
                .withRegion(com.microsoft.azure.management.resources.fluentcore.arm.Region.US_CENTRAL)
                .create();

        List<String> zones = new ArrayList<>();
        zones.add(com.microsoft.azure.arm.resources.Region.US_CENTRAL.toString());

        // redis
        RedisResource rc = manager.redis()
                .define(RC_NAME)
                .withRegion(com.microsoft.azure.arm.resources.Region.US_CENTRAL)
                .withExistingResourceGroup(RG_NAME)
                .withSku(new Sku()
                        .withName(SkuName.PREMIUM)
                        .withFamily(SkuFamily.P)
                        .withCapacity(1))
                .withShardCount(10)
                // Throws exception that zones for this API version are not supported
                //.withZones(zones)
                .create();

        Assert.assertNotNull(rc);
        Assert.assertTrue(rc.name().equalsIgnoreCase(RC_NAME));
        Assert.assertTrue(rc.resourceGroupName().equalsIgnoreCase(RG_NAME));
        Assert.assertEquals(SkuFamily.P, rc.sku().family());
        Assert.assertEquals(SkuName.PREMIUM, rc.sku().name());
        Assert.assertEquals(1, rc.sku().capacity());
        Assert.assertEquals(false, rc.enableNonSslPort());
        /*Assert.assertNotNull(rc.zones());
        Assert.assertEquals(com.microsoft.azure.arm.resources.Region.US_CENTRAL.toString(), rc.zones().get(0));*/

        RedisResource rcUpdated = rc.update()
                .withTag("tag1", "value2")
                .withEnableNonSslPort(true)
                .apply();

        Assert.assertEquals(rc, rcUpdated);
        Assert.assertNotNull(rcUpdated);
        Assert.assertTrue(rcUpdated.name().equalsIgnoreCase(RC_NAME));
        Assert.assertTrue(rcUpdated.resourceGroupName().equalsIgnoreCase(RG_NAME));
        Assert.assertEquals(SkuName.PREMIUM, rcUpdated.sku().name());
        Assert.assertEquals(true, rcUpdated.enableNonSslPort());
        Assert.assertNotNull(rcUpdated.tags());
        Assert.assertEquals(1, rcUpdated.tags().size());
        Assert.assertEquals("value2", rcUpdated.tags().get("tag1"));

        RedisAccessKeys rak = manager.redis().listKeysAsync(RC_NAME, RC_NAME)
                .toBlocking()
                .last();
        Assert.assertNotNull(rak);

        Assert.assertEquals(rc.accessKeys().primaryKey(), rak.primaryKey());
        Assert.assertEquals(rc.accessKeys().secondaryKey(), rak.secondaryKey());

        Assert.assertNotNull(rc.accessKeys().primaryKey());
        Assert.assertNotNull(rc.accessKeys().secondaryKey());

        manager.redis().checkNameAvailabilityAsync( new CheckNameAvailabilityParameters()
                .withName("dummyName")
                .withType(rcUpdated.type()))
                .wait();

        RedisForceRebootResponse rfResp = manager.redis().forceRebootAsync(RC_NAME, RC_NAME, new RedisRebootParameters()
                .withRebootType(RebootType.ALL_NODES))
                .toBlocking()
                .last();
        Assert.assertNotNull(rfResp);

        RedisFirewallRule fRule = manager.redis().firewallRules().listByRedisAsync(RC_NAME, RC_NAME)
                .toBlocking()
                .last();
        Assert.assertNotNull(fRule);

        RedisLinkedServerWithProperties fServers = manager.redis().linkedServers().listByRedisAsync(RC_NAME, RC_NAME)
                .toBlocking()
                .last();
        Assert.assertNotNull(fServers);

        NotificationListResponse nlr = manager.redis().listUpgradeNotifications().listUpgradeNotificationsAsync(RC_NAME, RC_NAME, 2000)
                .toBlocking()
                .last();
        Assert.assertNotNull(nlr);

        // operations
        final List<Operation> operations = new ArrayList<>();
        manager.operations().listAsync().map(new Func1<Operation, Operation>() {
            @Override
            public Operation call(Operation operation) {
                operations.add(operation);
                return operation;
            }
        }).toBlocking().subscribe();

        Assert.assertNotNull(operations);
        Assert.assertTrue(operations.size() > 0);

        List<ScheduleEntry> scheduleEntries = new ArrayList<>();
        scheduleEntries.add(new ScheduleEntry()
                .withDayOfWeek(DayOfWeek.SATURDAY)
                .withStartHourUtc(4));

        RedisPatchSchedule patchSchedules = manager.patchSchedules()
                .define(RC_PATCH_NAME)
                .withExistingRedis(RG_NAME, RC_NAME)
                .withScheduleEntries(scheduleEntries)
                .create();

        Assert.assertNotNull(patchSchedules);

        manager.redis().deleteByResourceGroup(RG_NAME, RC_NAME);
    }
}
