resources:
  repositories:
    - repository: azure-sdk-build-tools
      type: git
      name: internal/azure-sdk-build-tools
      ref: refs/tags/azure-sdk-build-tools_20220329.1

parameters:
- name: Artifacts
  type: object
  default: []
- name: TestPipeline
  type: boolean
  default: false
- name: AdditionalModules
  type: object
  default: []
- name: SDKType
  type: string
  default: client
- name: ServiceDirectory
  type: string
  default: not-specified
- name: TargetDocRepoName
  type: string
  default: azure-docs-sdk-java
- name: SkipAggregateReports
  type: boolean
  default: false
# Unsure if this is necessary. Only keyvault uses them
- name: AdditionalLintingOptions
  type: string
  default: ''
- name: BuildParallelization
  type: string
  default: '2C'
- name: AdditionalBuildOptions
  type: string
  default: $(AdditionalBuildOptions)
- name: UseEsrpRelease
  type: boolean
  default: true
- name: JavaBuildVersion
  type: string
  default: $(JavaBuildVersion)

stages:
  - stage: Build
    jobs:
    - job: 'Build Client Libraries'

      variables:
        - template: /eng/pipelines/templates/variables/globals.yml
        - name: ArtifactName
          value: 'packages'

      pool:
        name: azsdk-pool-mms-ubuntu-2004-general

      steps:
        # Skip sparse checkout for the `azure-sdk-for-<lang>-pr` private mirrored repositories
        # as we require the github service connection to be loaded.
        - ${{ if not(contains(variables['Build.DefinitionName'], 'java-pr')) }}:
          - template: /eng/common/pipelines/templates/steps/sparse-checkout.yml
            parameters:
              Paths:
                - '**/*.xml'
                - '**/*.md'
                - '!sdk/**/test-recordings'
                - '!sdk/**/session-records'

        - template: /eng/pipelines/templates/steps/generate-project-list-and-cache-maven-repository.yml
          parameters:
            Artifacts: ${{parameters.Artifacts}}
            AdditionalModules: ${{parameters.AdditionalModules}}
            JobType: 'Build'

        - task: UsePythonVersion@0
          displayName: 'Use Python 3.6'
          inputs:
            versionSpec: '3.6'

        - task: PythonScript@0
          displayName: 'Set versions for source build'
          inputs:
            scriptPath: 'eng/versioning/set_versions.py'
            arguments: '--build-type client --pst'
          condition: and(succeeded())

        - task: PythonScript@0
          displayName: 'Update versions for source build'
          inputs:
            scriptPath: 'eng/versioning/update_versions.py'
            arguments: '--update-type library --build-type client --sr'
          condition: and(succeeded())

        - task: PythonScript@0
          displayName: 'Generate FromSource POM and directories for sparse checkout'
          inputs:
            scriptPath: 'eng/scripts/generate_from_source_pom.py'
            arguments: '--project-list $(ProjectList)'
            workingDirectory: '$(System.DefaultWorkingDirectory)'

        - template: /eng/common/pipelines/templates/steps/sparse-checkout.yml
          parameters:
            Paths: $(SparseCheckoutDirectories)
            SkipDefaultCheckout: true

        # Just in case template is part of the release set
        - template: /eng/common/pipelines/templates/steps/set-test-pipeline-version.yml
          parameters:
            PackageName: "azure-sdk-template"
            ServiceDirectory: "template"
            TestPipeline: true

        - template: /eng/common/pipelines/templates/steps/set-test-pipeline-version.yml
          parameters:
            PackageName: "azure-sdk-template-two"
            ServiceDirectory: "template"
            TestPipeline: true

        - template: /eng/common/pipelines/templates/steps/set-test-pipeline-version.yml
          parameters:
            PackageName: "azure-sdk-template-three"
            ServiceDirectory: "template"
            TestPipeline: true

        - script: |
            pip install markdown2 BeautifulSoup4
          displayName: 'pip install markdown2 and BeautifulSoup4'

        - task: Maven@3
          displayName: 'Build From Source and Package, JDK Version: ${{ parameters.JavaBuildVersion }}'
          inputs:
            mavenPomFile: ClientFromSourcePom.xml
            goals: 'deploy'
            options: '$(DefaultOptions) -T ${{parameters.BuildParallelization}} ${{parameters.AdditionalBuildOptions}} -DskipTests -Dgenerate-overview -Dspotbugs.skip=true -Dcheckstyle.skip=true -Drevapi.skip=true -pl $(ProjectList) -am -DaltDeploymentRepository=id::default::file://$(System.DefaultWorkingDirectory)/build' # We include template-module so we ensure it always builds in CI
            mavenOptions: '$(MemoryOptions) $(LoggingOptions)'
            javaHomeOption: 'JDKVersion'
            jdkVersionOption: ${{ parameters.JavaBuildVersion }}
            jdkArchitectureOption: 'x64'
            publishJUnitResults: false

        - task: PowerShell@2
          displayName: 'Verify Required Maven Artifacts'
          inputs:
            pwsh: true
            workingDirectory: $(Agent.BuildDirectory)
            filePath: eng/scripts/Verify-Required-Maven-Artifacts.ps1
            arguments: >
              -BuildOutputDirectory $(System.DefaultWorkingDirectory)/build
              -ArtifactsList ('${{ convertToJson(parameters.Artifacts) }}' | ConvertFrom-Json | Select-Object name, groupId)
              -InformationAction Continue

        - task: PowerShell@2
          displayName: 'Copy artifacts to staging'
          inputs:
            pwsh: true
            workingDirectory: $(Agent.BuildDirectory)
            filePath: eng/scripts/Stage-MavenPackageArtifacts.ps1
            arguments: >
              -SourceDirectory $(System.DefaultWorkingDirectory)/build
              -TargetDirectory $(Build.ArtifactStagingDirectory)
              -InformationAction Continue

        - template: /eng/common/pipelines/templates/steps/publish-artifact.yml
          parameters:
            ArtifactPath: $(Build.ArtifactStagingDirectory)
            ArtifactName: '$(ArtifactName)'

        - task: AzureArtifacts.manifest-generator-task.manifest-generator-task.ManifestGeneratorTask@0
          displayName: 'Generate SBOM'
          condition: succeededOrFailed()
          inputs:
            BuildDropPath: $(Build.ArtifactStagingDirectory)

        - template: /eng/common/pipelines/templates/steps/publish-artifact.yml
          parameters:
            ArtifactPath: '$(Build.ArtifactStagingDirectory)/_manifest'
            ArtifactName: 'manifest'

        - template: ../steps/upload-repository-on-failure.yml

# JRS - At this point do we need to build/install in order to run SpotBugs, Checkstyle, RevApi, and Javadoc?
# There's going to be a problem running that due to AdditionalLintingOptions that only exists for keyvault
    - job: 'Analyze/Verify'
      condition: and(succeeded(), ne(variables['Skip.Analyze'], 'true'))

      variables:
        - template: /eng/pipelines/templates/variables/globals.yml

      pool:
        name: azsdk-pool-mms-ubuntu-2004-general
        vmImage: MMSUbuntu20.04

      steps:
        - task: UsePythonVersion@0
          displayName: 'Use Python 3.6'
          inputs:
            versionSpec: '3.6'

        - template: /eng/common/pipelines/templates/steps/sparse-checkout.yml
          parameters:
            Paths:
              - '**/*.xml'
              - '**/*.md'
              - '.vscode/cspell.json'
              - '!sdk/**/test-recordings'
              - '!sdk/**/session-records'

        - template: /eng/pipelines/templates/steps/generate-project-list-and-cache-maven-repository.yml
          parameters:
            Artifacts: ${{ parameters.Artifacts }}
            AdditionalModules: ${{ parameters.AdditionalModules }}
            JobType: 'Analyze/Verify'

        - task: PythonScript@0
          displayName: 'Set versions for source build'
          inputs:
            scriptPath: 'eng/versioning/set_versions.py'
            arguments: '--build-type client --pst'
          condition: and(succeeded())

        - task: PythonScript@0
          displayName: 'Update versions for source build'
          inputs:
            scriptPath: 'eng/versioning/update_versions.py'
            arguments: '--update-type library --build-type client --sr'
          condition: and(succeeded())

        - task: PythonScript@0
          displayName: 'Generate FromSource POM and directories for sparse checkout'
          inputs:
            scriptPath: 'eng/scripts/generate_from_source_pom.py'
            arguments: '--project-list $(ProjectList)'
            workingDirectory: '$(System.DefaultWorkingDirectory)'

        - template: /eng/common/pipelines/templates/steps/sparse-checkout.yml
          parameters:
            Paths: $(SparseCheckoutDirectories)
            SkipDefaultCheckout: true

        - template: /eng/common/pipelines/templates/steps/set-test-pipeline-version.yml
          parameters:
            PackageName: "azure-sdk-template"
            ServiceDirectory: "template"
            TestPipeline: true

        - template: /eng/common/pipelines/templates/steps/set-test-pipeline-version.yml
          parameters:
            PackageName: "azure-sdk-template-two"
            ServiceDirectory: "template"
            TestPipeline: true

        - template: /eng/common/pipelines/templates/steps/set-test-pipeline-version.yml
          parameters:
            PackageName: "azure-sdk-template-three"
            ServiceDirectory: "template"
            TestPipeline: true

        - template: /eng/common/pipelines/templates/steps/check-spelling.yml
          parameters:
            CspellConfigPath: .vscode/cspell.json

        - task: PowerShell@2
          displayName: 'Verify versions in POM files'
          inputs:
            pwsh: true
            workingDirectory: $(Agent.BuildDirectory)
            filePath: eng/versioning/pom_file_version_scanner.ps1
            arguments: -Debug:$$(IsDebug)

        # Do all the verifications for all the artifacts after the sparse-checkout
        - pwsh: |
            $ArtifactsList = $('${{ convertToJson(parameters.Artifacts) }}' | ConvertFrom-Json | Select-Object name, groupId)
            $ArtifactsList | Format-Table -Property GroupId, Name | Out-String | Write-Host
            python --version
            foreach($artifact in $ArtifactsList) {
              python eng/versioning/set_versions.py --build-type ${{parameters.SDKType}} --vv --ai $($artifact.name) --gi $($artifact.groupId)
            }
          displayName: 'Verify artifact versions for release'

        # Uber JARs release a flattened POM, as dependencies are incorporated into the JAR circumnavigating the
        # need to list dependencies in the POM. The flattened POM is generated and won't comply with our versioning
        # validation, so omit uberJars from the artifacts list to verify.
        - pwsh: |
            $ArtifactsList = $('${{ convertToJson(parameters.Artifacts) }}' | ConvertFrom-Json | Select-Object name, groupId, uberJar | Where-Object -Not "uberJar")
            $ArtifactsList | Format-Table -Property GroupId, Name | Out-String | Write-Host
            python --version
            foreach($artifact in $ArtifactsList) {
              $(Build.SourcesDirectory)/eng/versioning/scan_for_unreleased_dependencies.ps1 $($artifact.groupId) $($artifact.name) $(Build.SourcesDirectory)/sdk/${{parameters.ServiceDirectory}}
            }
          displayName: "Verify no unreleased dependencies or beta dependencies for GA libraries"

          # JRS - Do I need to actually rewrite this. The scripts being run that'll generate the artifacts
          # list are figuring out everything that needs to be built and released. This step should be
          # unncessary
          # Given a list of libraries to release, verify that the list of libraries has full transitive closure.
          # This prevents us from releasing a library whose dependency is not being released. UberJar needs to be
          # be passed in, we skip check on UberJars but we still do need to fail correctly if the user didn't
          # select any artifacts to be released.
          #- task: PowerShell@2
          #  displayName: Verify Release Set
          #  inputs:
          #    pwsh: true
          #    filePath: $(Build.SourcesDirectory)/eng/versioning/verify_release_set.ps1
          #    arguments: >
          #      -ServiceDirectory $(Build.SourcesDirectory)/sdk/${{parameters.ServiceDirectory}}
          #      -ArtifactsList ('${{ convertToJson(parameters.Artifacts) }}' | ConvertFrom-Json | Select-Object name, groupId, uberJar)

        - template: /eng/common/pipelines/templates/steps/verify-readme.yml
          parameters:
            # For the moment, ServiceDirectories is JSON which may change to a comma delimited list instead of
            # what's going on below
            ScanPaths: (($(ServiceDirectories) | ConvertFrom-Json | ForEach-Object { "$(Build.SourcesDirectory)/sdk/$_".Replace('\\', '/') }) -join ',')

        # JRS - verify-links right now isn't something that's can take multiple service directories
        # without a major rewrite as it sets the working directory to the service directory on top
        # of everything else
        # Question: Do we actually need the verify-links here?
        #- template: /eng/common/pipelines/templates/steps/verify-links.yml
        #  parameters:
        #    ${{ if eq(variables['Build.Reason'], 'PullRequest') }}:
        #      Directory: ''
        #      Urls: (eng/common/scripts/get-markdown-files-from-changed-files.ps1)
        #    ${{ if ne(variables['Build.Reason'], 'PullRequest') }}:
        #      Directory: sdk/${{ parameters.ServiceDirectory }}
        #    CheckLinkGuidance: $true

        - template: /eng/common/pipelines/templates/steps/verify-samples.yml
          parameters:
            ServiceDirectories: (($(ServiceDirectories) | ConvertFrom-Json) -join ',')

        # Use BasePathLength of 38 instead of the default 49 as some released files fail when the number is higher.
        - template: /eng/common/pipelines/templates/steps/verify-path-length.yml
          parameters:
            SourceDirectory: $(Build.SourcesDirectory)
            BasePathLength: 38

        # JRS - I hate this, I hate this a lot. Verify changelog, the way it currently works would
        # require a complete overhaul in order to be able to deal with multiple artifacts and
        # multiple service directories. Even ignoring this, there's still the fact that each artifact's
        # metadata can cause this step to be skipped so we still need to loop over this.
        - ${{if ne(parameters.SDKType, 'data')}}:
          - ${{ each artifact in parameters.Artifacts }}:
            - ${{if ne(artifact.skipVerifyChangelog, 'true')}}:
              - template: /eng/common/pipelines/templates/steps/verify-changelog.yml
                parameters:
                  PackageName: ${{artifact.name}}
                  ServiceName: ${{artifact.ServiceDirectory}}
                  # Note, for the patch release pipeline there's no point in verifying the non-release
                  # changelog since the only time this pipeline should run is for a patch release.
                  ForRelease: true

        # We `install` the code quality reports tooling into our local m2 cache separately from building the Maven project
        # reports. This means it is available as part of that, but also so that this is not documented in the project report.
        - template: ../steps/install-reporting-tools.yml
          parameters:
            JdkVersion: ${{ parameters.JavaBuildVersion }}

        - template: /eng/common/pipelines/templates/steps/eng-common-workflow-enforcer.yml

  # This pipeline should never get kicked off outside of an internal, manual run. Put the checks here
  # so the pipeline never gets to the signing/release portions unless this is the case.
  - ${{if and(in(variables['Build.Reason'], 'Manual', ''), eq(variables['System.TeamProject'], 'internal'))}}:
    - template: archetype-java-release-batch.yml
      parameters:
        DependsOn:
          - Build
        SDKType: ${{ parameters.SDKType }}
        Artifacts: ${{ parameters.Artifacts }}
        TestPipeline: ${{ parameters.TestPipeline }}
        ArtifactName: packages
        TargetDocRepoName: ${{ parameters.TargetDocRepoName }}
        UseEsrpRelease: ${{ parameters.UseEsrpRelease }}