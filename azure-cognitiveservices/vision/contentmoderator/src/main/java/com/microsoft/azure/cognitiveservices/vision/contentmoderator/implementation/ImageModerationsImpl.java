/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.cognitiveservices.vision.contentmoderator.implementation;

import com.microsoft.azure.cognitiveservices.vision.contentmoderator.models.FindFacesOptionalParameter;
import com.microsoft.azure.cognitiveservices.vision.contentmoderator.models.OCRMethodOptionalParameter;
import com.microsoft.azure.cognitiveservices.vision.contentmoderator.models.EvaluateMethodOptionalParameter;
import com.microsoft.azure.cognitiveservices.vision.contentmoderator.models.MatchMethodOptionalParameter;
import com.microsoft.azure.cognitiveservices.vision.contentmoderator.models.FindFacesFileInputOptionalParameter;
import com.microsoft.azure.cognitiveservices.vision.contentmoderator.models.FindFacesUrlInputOptionalParameter;
import com.microsoft.azure.cognitiveservices.vision.contentmoderator.models.OCRUrlInputOptionalParameter;
import com.microsoft.azure.cognitiveservices.vision.contentmoderator.models.OCRFileInputOptionalParameter;
import com.microsoft.azure.cognitiveservices.vision.contentmoderator.models.EvaluateFileInputOptionalParameter;
import com.microsoft.azure.cognitiveservices.vision.contentmoderator.models.EvaluateUrlInputOptionalParameter;
import com.microsoft.azure.cognitiveservices.vision.contentmoderator.models.MatchUrlInputOptionalParameter;
import com.microsoft.azure.cognitiveservices.vision.contentmoderator.models.MatchFileInputOptionalParameter;
import retrofit2.Retrofit;
import com.microsoft.azure.cognitiveservices.vision.contentmoderator.ImageModerations;
import com.google.common.base.Joiner;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.cognitiveservices.vision.contentmoderator.models.APIErrorException;
import com.microsoft.azure.cognitiveservices.vision.contentmoderator.models.BodyModel;
import com.microsoft.azure.cognitiveservices.vision.contentmoderator.models.Evaluate;
import com.microsoft.azure.cognitiveservices.vision.contentmoderator.models.FoundFaces;
import com.microsoft.azure.cognitiveservices.vision.contentmoderator.models.MatchResponse;
import com.microsoft.azure.cognitiveservices.vision.contentmoderator.models.OCR;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.IOException;
import okhttp3.MediaType;
import okhttp3.RequestBody;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.POST;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in ImageModerations.
 */
public class ImageModerationsImpl implements ImageModerations {
    /** The Retrofit service to perform REST calls. */
    private ImageModerationsService service;
    /** The service client containing this operation class. */
    private ContentModeratorClientImpl client;

    /**
     * Initializes an instance of ImageModerationsImpl.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public ImageModerationsImpl(Retrofit retrofit, ContentModeratorClientImpl client) {
        this.service = retrofit.create(ImageModerationsService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for ImageModerations to be
     * used by Retrofit to perform actually REST calls.
     */
    interface ImageModerationsService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.contentmoderator.ImageModerations findFaces" })
        @POST("contentmoderator/moderate/v1.0/ProcessImage/FindFaces")
        Observable<Response<ResponseBody>> findFaces(@Query("CacheImage") Boolean cacheImage, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.contentmoderator.ImageModerations oCRMethod" })
        @POST("contentmoderator/moderate/v1.0/ProcessImage/OCR")
        Observable<Response<ResponseBody>> oCRMethod(@Query("language") String language, @Query("CacheImage") Boolean cacheImage, @Query("enhanced") Boolean enhanced, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.contentmoderator.ImageModerations evaluateMethod" })
        @POST("contentmoderator/moderate/v1.0/ProcessImage/Evaluate")
        Observable<Response<ResponseBody>> evaluateMethod(@Query("CacheImage") Boolean cacheImage, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.contentmoderator.ImageModerations matchMethod" })
        @POST("contentmoderator/moderate/v1.0/ProcessImage/Match")
        Observable<Response<ResponseBody>> matchMethod(@Query("listId") String listId, @Query("CacheImage") Boolean cacheImage, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: image/gif", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.contentmoderator.ImageModerations findFacesFileInput" })
        @POST("contentmoderator/moderate/v1.0/ProcessImage/FindFaces")
        Observable<Response<ResponseBody>> findFacesFileInput(@Query("CacheImage") Boolean cacheImage, @Body RequestBody imageStream, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.contentmoderator.ImageModerations findFacesUrlInput" })
        @POST("contentmoderator/moderate/v1.0/ProcessImage/FindFaces")
        Observable<Response<ResponseBody>> findFacesUrlInput(@Query("CacheImage") Boolean cacheImage, @Header("Content-Type") String contentType, @Body BodyModel imageUrl, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.contentmoderator.ImageModerations oCRUrlInput" })
        @POST("contentmoderator/moderate/v1.0/ProcessImage/OCR")
        Observable<Response<ResponseBody>> oCRUrlInput(@Query("language") String language, @Query("CacheImage") Boolean cacheImage, @Query("enhanced") Boolean enhanced, @Header("Content-Type") String contentType, @Body BodyModel imageUrl, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: image/gif", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.contentmoderator.ImageModerations oCRFileInput" })
        @POST("contentmoderator/moderate/v1.0/ProcessImage/OCR")
        Observable<Response<ResponseBody>> oCRFileInput(@Query("language") String language, @Query("CacheImage") Boolean cacheImage, @Query("enhanced") Boolean enhanced, @Body RequestBody imageStream, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: image/gif", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.contentmoderator.ImageModerations evaluateFileInput" })
        @POST("contentmoderator/moderate/v1.0/ProcessImage/Evaluate")
        Observable<Response<ResponseBody>> evaluateFileInput(@Query("CacheImage") Boolean cacheImage, @Body RequestBody imageStream, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.contentmoderator.ImageModerations evaluateUrlInput" })
        @POST("contentmoderator/moderate/v1.0/ProcessImage/Evaluate")
        Observable<Response<ResponseBody>> evaluateUrlInput(@Query("CacheImage") Boolean cacheImage, @Header("Content-Type") String contentType, @Body BodyModel imageUrl, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.contentmoderator.ImageModerations matchUrlInput" })
        @POST("contentmoderator/moderate/v1.0/ProcessImage/Match")
        Observable<Response<ResponseBody>> matchUrlInput(@Query("listId") String listId, @Query("CacheImage") Boolean cacheImage, @Header("Content-Type") String contentType, @Body BodyModel imageUrl, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: image/gif", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.contentmoderator.ImageModerations matchFileInput" })
        @POST("contentmoderator/moderate/v1.0/ProcessImage/Match")
        Observable<Response<ResponseBody>> matchFileInput(@Query("listId") String listId, @Query("CacheImage") Boolean cacheImage, @Body RequestBody imageStream, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

    }


    /**
     * Returns the list of faces found.
     *
     * @param findFacesOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the FoundFaces object if successful.
     */
    public FoundFaces findFaces(FindFacesOptionalParameter findFacesOptionalParameter) {
        return findFacesWithServiceResponseAsync(findFacesOptionalParameter).toBlocking().single().body();
    }

    /**
     * Returns the list of faces found.
     *
     * @param findFacesOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<FoundFaces> findFacesAsync(FindFacesOptionalParameter findFacesOptionalParameter, final ServiceCallback<FoundFaces> serviceCallback) {
        return ServiceFuture.fromResponse(findFacesWithServiceResponseAsync(findFacesOptionalParameter), serviceCallback);
    }

    /**
     * Returns the list of faces found.
     *
     * @param findFacesOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FoundFaces object
     */
    public Observable<FoundFaces> findFacesAsync(FindFacesOptionalParameter findFacesOptionalParameter) {
        return findFacesWithServiceResponseAsync(findFacesOptionalParameter).map(new Func1<ServiceResponse<FoundFaces>, FoundFaces>() {
            @Override
            public FoundFaces call(ServiceResponse<FoundFaces> response) {
                return response.body();
            }
        });
    }

    /**
     * Returns the list of faces found.
     *
     * @param findFacesOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FoundFaces object
     */
    public Observable<ServiceResponse<FoundFaces>> findFacesWithServiceResponseAsync(FindFacesOptionalParameter findFacesOptionalParameter) {
        if (this.client.baseUrl() == null) {
            throw new IllegalArgumentException("Parameter this.client.baseUrl() is required and cannot be null.");
        }
        final Boolean cacheImage = findFacesOptionalParameter != null ? findFacesOptionalParameter.cacheImage() : null;
        String parameterizedHost = Joiner.on(", ").join("{baseUrl}", this.client.baseUrl());

        return findFacesWithServiceResponseAsync(cacheImage);
    }

    /**
     * Returns the list of faces found.
     *
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FoundFaces object
     */
    public Observable<ServiceResponse<FoundFaces>> findFacesWithServiceResponseAsync(Boolean cacheImage) {
        if (this.client.baseUrl() == null) {
            throw new IllegalArgumentException("Parameter this.client.baseUrl() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{baseUrl}", this.client.baseUrl());
        return service.findFaces(cacheImage, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<FoundFaces>>>() {
                @Override
                public Observable<ServiceResponse<FoundFaces>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<FoundFaces> clientResponse = findFacesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<FoundFaces> findFacesDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<FoundFaces, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<FoundFaces>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }


    /**
     * Returns any text found in the image for the language specified. If no language is specified in input then the detection defaults to English.
     *
     * @param language Language of the terms.
     * @param oCRMethodOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OCR object if successful.
     */
    public OCR oCRMethod(String language, OCRMethodOptionalParameter oCRMethodOptionalParameter) {
        return oCRMethodWithServiceResponseAsync(language, oCRMethodOptionalParameter).toBlocking().single().body();
    }

    /**
     * Returns any text found in the image for the language specified. If no language is specified in input then the detection defaults to English.
     *
     * @param language Language of the terms.
     * @param oCRMethodOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OCR> oCRMethodAsync(String language, OCRMethodOptionalParameter oCRMethodOptionalParameter, final ServiceCallback<OCR> serviceCallback) {
        return ServiceFuture.fromResponse(oCRMethodWithServiceResponseAsync(language, oCRMethodOptionalParameter), serviceCallback);
    }

    /**
     * Returns any text found in the image for the language specified. If no language is specified in input then the detection defaults to English.
     *
     * @param language Language of the terms.
     * @param oCRMethodOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OCR object
     */
    public Observable<OCR> oCRMethodAsync(String language, OCRMethodOptionalParameter oCRMethodOptionalParameter) {
        return oCRMethodWithServiceResponseAsync(language, oCRMethodOptionalParameter).map(new Func1<ServiceResponse<OCR>, OCR>() {
            @Override
            public OCR call(ServiceResponse<OCR> response) {
                return response.body();
            }
        });
    }

    /**
     * Returns any text found in the image for the language specified. If no language is specified in input then the detection defaults to English.
     *
     * @param language Language of the terms.
     * @param oCRMethodOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OCR object
     */
    public Observable<ServiceResponse<OCR>> oCRMethodWithServiceResponseAsync(String language, OCRMethodOptionalParameter oCRMethodOptionalParameter) {
        if (this.client.baseUrl() == null) {
            throw new IllegalArgumentException("Parameter this.client.baseUrl() is required and cannot be null.");
        }
        if (language == null) {
            throw new IllegalArgumentException("Parameter language is required and cannot be null.");
        }
        final Boolean cacheImage = oCRMethodOptionalParameter != null ? oCRMethodOptionalParameter.cacheImage() : null;
        final Boolean enhanced = oCRMethodOptionalParameter != null ? oCRMethodOptionalParameter.enhanced() : null;
        String parameterizedHost = Joiner.on(", ").join("{baseUrl}", this.client.baseUrl());

        return oCRMethodWithServiceResponseAsync(language, cacheImage, enhanced);
    }

    /**
     * Returns any text found in the image for the language specified. If no language is specified in input then the detection defaults to English.
     *
     * @param language Language of the terms.
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @param enhanced When set to True, the image goes through additional processing to come with additional candidates.
     image/tiff is not supported when enhanced is set to true
     Note: This impacts the response time.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OCR object
     */
    public Observable<ServiceResponse<OCR>> oCRMethodWithServiceResponseAsync(String language, Boolean cacheImage, Boolean enhanced) {
        if (this.client.baseUrl() == null) {
            throw new IllegalArgumentException("Parameter this.client.baseUrl() is required and cannot be null.");
        }
        if (language == null) {
            throw new IllegalArgumentException("Parameter language is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{baseUrl}", this.client.baseUrl());
        return service.oCRMethod(language, cacheImage, enhanced, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OCR>>>() {
                @Override
                public Observable<ServiceResponse<OCR>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OCR> clientResponse = oCRMethodDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OCR> oCRMethodDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OCR, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OCR>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }


    /**
     * Returns probabilities of the image containing racy or adult content.
     *
     * @param evaluateMethodOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Evaluate object if successful.
     */
    public Evaluate evaluateMethod(EvaluateMethodOptionalParameter evaluateMethodOptionalParameter) {
        return evaluateMethodWithServiceResponseAsync(evaluateMethodOptionalParameter).toBlocking().single().body();
    }

    /**
     * Returns probabilities of the image containing racy or adult content.
     *
     * @param evaluateMethodOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Evaluate> evaluateMethodAsync(EvaluateMethodOptionalParameter evaluateMethodOptionalParameter, final ServiceCallback<Evaluate> serviceCallback) {
        return ServiceFuture.fromResponse(evaluateMethodWithServiceResponseAsync(evaluateMethodOptionalParameter), serviceCallback);
    }

    /**
     * Returns probabilities of the image containing racy or adult content.
     *
     * @param evaluateMethodOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Evaluate object
     */
    public Observable<Evaluate> evaluateMethodAsync(EvaluateMethodOptionalParameter evaluateMethodOptionalParameter) {
        return evaluateMethodWithServiceResponseAsync(evaluateMethodOptionalParameter).map(new Func1<ServiceResponse<Evaluate>, Evaluate>() {
            @Override
            public Evaluate call(ServiceResponse<Evaluate> response) {
                return response.body();
            }
        });
    }

    /**
     * Returns probabilities of the image containing racy or adult content.
     *
     * @param evaluateMethodOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Evaluate object
     */
    public Observable<ServiceResponse<Evaluate>> evaluateMethodWithServiceResponseAsync(EvaluateMethodOptionalParameter evaluateMethodOptionalParameter) {
        if (this.client.baseUrl() == null) {
            throw new IllegalArgumentException("Parameter this.client.baseUrl() is required and cannot be null.");
        }
        final Boolean cacheImage = evaluateMethodOptionalParameter != null ? evaluateMethodOptionalParameter.cacheImage() : null;
        String parameterizedHost = Joiner.on(", ").join("{baseUrl}", this.client.baseUrl());

        return evaluateMethodWithServiceResponseAsync(cacheImage);
    }

    /**
     * Returns probabilities of the image containing racy or adult content.
     *
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Evaluate object
     */
    public Observable<ServiceResponse<Evaluate>> evaluateMethodWithServiceResponseAsync(Boolean cacheImage) {
        if (this.client.baseUrl() == null) {
            throw new IllegalArgumentException("Parameter this.client.baseUrl() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{baseUrl}", this.client.baseUrl());
        return service.evaluateMethod(cacheImage, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Evaluate>>>() {
                @Override
                public Observable<ServiceResponse<Evaluate>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Evaluate> clientResponse = evaluateMethodDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Evaluate> evaluateMethodDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Evaluate, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Evaluate>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }


    /**
     * Fuzzily match an image against one of your custom Image Lists. You can create and manage your custom image lists using &lt;a href="/docs/services/578ff44d2703741568569ab9/operations/578ff7b12703741568569abe"&gt;this&lt;/a&gt; API.
     Returns ID and tags of matching image.&lt;br/&gt;
     &lt;br/&gt;
     Note: Refresh Index must be run on the corresponding Image List before additions and removals are reflected in the response.
     *
     * @param matchMethodOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MatchResponse object if successful.
     */
    public MatchResponse matchMethod(MatchMethodOptionalParameter matchMethodOptionalParameter) {
        return matchMethodWithServiceResponseAsync(matchMethodOptionalParameter).toBlocking().single().body();
    }

    /**
     * Fuzzily match an image against one of your custom Image Lists. You can create and manage your custom image lists using &lt;a href="/docs/services/578ff44d2703741568569ab9/operations/578ff7b12703741568569abe"&gt;this&lt;/a&gt; API.
     Returns ID and tags of matching image.&lt;br/&gt;
     &lt;br/&gt;
     Note: Refresh Index must be run on the corresponding Image List before additions and removals are reflected in the response.
     *
     * @param matchMethodOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MatchResponse> matchMethodAsync(MatchMethodOptionalParameter matchMethodOptionalParameter, final ServiceCallback<MatchResponse> serviceCallback) {
        return ServiceFuture.fromResponse(matchMethodWithServiceResponseAsync(matchMethodOptionalParameter), serviceCallback);
    }

    /**
     * Fuzzily match an image against one of your custom Image Lists. You can create and manage your custom image lists using &lt;a href="/docs/services/578ff44d2703741568569ab9/operations/578ff7b12703741568569abe"&gt;this&lt;/a&gt; API.
     Returns ID and tags of matching image.&lt;br/&gt;
     &lt;br/&gt;
     Note: Refresh Index must be run on the corresponding Image List before additions and removals are reflected in the response.
     *
     * @param matchMethodOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MatchResponse object
     */
    public Observable<MatchResponse> matchMethodAsync(MatchMethodOptionalParameter matchMethodOptionalParameter) {
        return matchMethodWithServiceResponseAsync(matchMethodOptionalParameter).map(new Func1<ServiceResponse<MatchResponse>, MatchResponse>() {
            @Override
            public MatchResponse call(ServiceResponse<MatchResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * Fuzzily match an image against one of your custom Image Lists. You can create and manage your custom image lists using &lt;a href="/docs/services/578ff44d2703741568569ab9/operations/578ff7b12703741568569abe"&gt;this&lt;/a&gt; API.
     Returns ID and tags of matching image.&lt;br/&gt;
     &lt;br/&gt;
     Note: Refresh Index must be run on the corresponding Image List before additions and removals are reflected in the response.
     *
     * @param matchMethodOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MatchResponse object
     */
    public Observable<ServiceResponse<MatchResponse>> matchMethodWithServiceResponseAsync(MatchMethodOptionalParameter matchMethodOptionalParameter) {
        if (this.client.baseUrl() == null) {
            throw new IllegalArgumentException("Parameter this.client.baseUrl() is required and cannot be null.");
        }
        final String listId = matchMethodOptionalParameter != null ? matchMethodOptionalParameter.listId() : null;
        final Boolean cacheImage = matchMethodOptionalParameter != null ? matchMethodOptionalParameter.cacheImage() : null;
        String parameterizedHost = Joiner.on(", ").join("{baseUrl}", this.client.baseUrl());

        return matchMethodWithServiceResponseAsync(listId, cacheImage);
    }

    /**
     * Fuzzily match an image against one of your custom Image Lists. You can create and manage your custom image lists using &lt;a href="/docs/services/578ff44d2703741568569ab9/operations/578ff7b12703741568569abe"&gt;this&lt;/a&gt; API.
     Returns ID and tags of matching image.&lt;br/&gt;
     &lt;br/&gt;
     Note: Refresh Index must be run on the corresponding Image List before additions and removals are reflected in the response.
     *
     * @param listId The list Id.
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MatchResponse object
     */
    public Observable<ServiceResponse<MatchResponse>> matchMethodWithServiceResponseAsync(String listId, Boolean cacheImage) {
        if (this.client.baseUrl() == null) {
            throw new IllegalArgumentException("Parameter this.client.baseUrl() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{baseUrl}", this.client.baseUrl());
        return service.matchMethod(listId, cacheImage, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<MatchResponse>>>() {
                @Override
                public Observable<ServiceResponse<MatchResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<MatchResponse> clientResponse = matchMethodDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<MatchResponse> matchMethodDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<MatchResponse, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<MatchResponse>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }


    /**
     * Returns the list of faces found.
     *
     * @param imageStream The image file.
     * @param findFacesFileInputOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the FoundFaces object if successful.
     */
    public FoundFaces findFacesFileInput(byte[] imageStream, FindFacesFileInputOptionalParameter findFacesFileInputOptionalParameter) {
        return findFacesFileInputWithServiceResponseAsync(imageStream, findFacesFileInputOptionalParameter).toBlocking().single().body();
    }

    /**
     * Returns the list of faces found.
     *
     * @param imageStream The image file.
     * @param findFacesFileInputOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<FoundFaces> findFacesFileInputAsync(byte[] imageStream, FindFacesFileInputOptionalParameter findFacesFileInputOptionalParameter, final ServiceCallback<FoundFaces> serviceCallback) {
        return ServiceFuture.fromResponse(findFacesFileInputWithServiceResponseAsync(imageStream, findFacesFileInputOptionalParameter), serviceCallback);
    }

    /**
     * Returns the list of faces found.
     *
     * @param imageStream The image file.
     * @param findFacesFileInputOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FoundFaces object
     */
    public Observable<FoundFaces> findFacesFileInputAsync(byte[] imageStream, FindFacesFileInputOptionalParameter findFacesFileInputOptionalParameter) {
        return findFacesFileInputWithServiceResponseAsync(imageStream, findFacesFileInputOptionalParameter).map(new Func1<ServiceResponse<FoundFaces>, FoundFaces>() {
            @Override
            public FoundFaces call(ServiceResponse<FoundFaces> response) {
                return response.body();
            }
        });
    }

    /**
     * Returns the list of faces found.
     *
     * @param imageStream The image file.
     * @param findFacesFileInputOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FoundFaces object
     */
    public Observable<ServiceResponse<FoundFaces>> findFacesFileInputWithServiceResponseAsync(byte[] imageStream, FindFacesFileInputOptionalParameter findFacesFileInputOptionalParameter) {
        if (this.client.baseUrl() == null) {
            throw new IllegalArgumentException("Parameter this.client.baseUrl() is required and cannot be null.");
        }
        if (imageStream == null) {
            throw new IllegalArgumentException("Parameter imageStream is required and cannot be null.");
        }
        final Boolean cacheImage = findFacesFileInputOptionalParameter != null ? findFacesFileInputOptionalParameter.cacheImage() : null;
        String parameterizedHost = Joiner.on(", ").join("{baseUrl}", this.client.baseUrl());
        RequestBody imageStreamConverted = RequestBody.create(MediaType.parse("image/gif"), imageStream);

        return findFacesFileInputWithServiceResponseAsync(imageStream, cacheImage);
    }

    /**
     * Returns the list of faces found.
     *
     * @param imageStream The image file.
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FoundFaces object
     */
    public Observable<ServiceResponse<FoundFaces>> findFacesFileInputWithServiceResponseAsync(byte[] imageStream, Boolean cacheImage) {
        if (this.client.baseUrl() == null) {
            throw new IllegalArgumentException("Parameter this.client.baseUrl() is required and cannot be null.");
        }
        if (imageStream == null) {
            throw new IllegalArgumentException("Parameter imageStream is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{baseUrl}", this.client.baseUrl());
        RequestBody imageStreamConverted = RequestBody.create(MediaType.parse("image/gif"), imageStream);
        return service.findFacesFileInput(cacheImage, imageStreamConverted, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<FoundFaces>>>() {
                @Override
                public Observable<ServiceResponse<FoundFaces>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<FoundFaces> clientResponse = findFacesFileInputDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<FoundFaces> findFacesFileInputDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<FoundFaces, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<FoundFaces>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }


    /**
     * Returns the list of faces found.
     *
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @param findFacesUrlInputOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the FoundFaces object if successful.
     */
    public FoundFaces findFacesUrlInput(String contentType, BodyModel imageUrl, FindFacesUrlInputOptionalParameter findFacesUrlInputOptionalParameter) {
        return findFacesUrlInputWithServiceResponseAsync(contentType, imageUrl, findFacesUrlInputOptionalParameter).toBlocking().single().body();
    }

    /**
     * Returns the list of faces found.
     *
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @param findFacesUrlInputOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<FoundFaces> findFacesUrlInputAsync(String contentType, BodyModel imageUrl, FindFacesUrlInputOptionalParameter findFacesUrlInputOptionalParameter, final ServiceCallback<FoundFaces> serviceCallback) {
        return ServiceFuture.fromResponse(findFacesUrlInputWithServiceResponseAsync(contentType, imageUrl, findFacesUrlInputOptionalParameter), serviceCallback);
    }

    /**
     * Returns the list of faces found.
     *
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @param findFacesUrlInputOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FoundFaces object
     */
    public Observable<FoundFaces> findFacesUrlInputAsync(String contentType, BodyModel imageUrl, FindFacesUrlInputOptionalParameter findFacesUrlInputOptionalParameter) {
        return findFacesUrlInputWithServiceResponseAsync(contentType, imageUrl, findFacesUrlInputOptionalParameter).map(new Func1<ServiceResponse<FoundFaces>, FoundFaces>() {
            @Override
            public FoundFaces call(ServiceResponse<FoundFaces> response) {
                return response.body();
            }
        });
    }

    /**
     * Returns the list of faces found.
     *
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @param findFacesUrlInputOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FoundFaces object
     */
    public Observable<ServiceResponse<FoundFaces>> findFacesUrlInputWithServiceResponseAsync(String contentType, BodyModel imageUrl, FindFacesUrlInputOptionalParameter findFacesUrlInputOptionalParameter) {
        if (this.client.baseUrl() == null) {
            throw new IllegalArgumentException("Parameter this.client.baseUrl() is required and cannot be null.");
        }
        if (contentType == null) {
            throw new IllegalArgumentException("Parameter contentType is required and cannot be null.");
        }
        if (imageUrl == null) {
            throw new IllegalArgumentException("Parameter imageUrl is required and cannot be null.");
        }
        Validator.validate(imageUrl);
        final Boolean cacheImage = findFacesUrlInputOptionalParameter != null ? findFacesUrlInputOptionalParameter.cacheImage() : null;
        String parameterizedHost = Joiner.on(", ").join("{baseUrl}", this.client.baseUrl());

        return findFacesUrlInputWithServiceResponseAsync(contentType, imageUrl, cacheImage);
    }

    /**
     * Returns the list of faces found.
     *
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FoundFaces object
     */
    public Observable<ServiceResponse<FoundFaces>> findFacesUrlInputWithServiceResponseAsync(String contentType, BodyModel imageUrl, Boolean cacheImage) {
        if (this.client.baseUrl() == null) {
            throw new IllegalArgumentException("Parameter this.client.baseUrl() is required and cannot be null.");
        }
        if (contentType == null) {
            throw new IllegalArgumentException("Parameter contentType is required and cannot be null.");
        }
        if (imageUrl == null) {
            throw new IllegalArgumentException("Parameter imageUrl is required and cannot be null.");
        }
        Validator.validate(imageUrl);
        String parameterizedHost = Joiner.on(", ").join("{baseUrl}", this.client.baseUrl());
        return service.findFacesUrlInput(cacheImage, contentType, imageUrl, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<FoundFaces>>>() {
                @Override
                public Observable<ServiceResponse<FoundFaces>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<FoundFaces> clientResponse = findFacesUrlInputDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<FoundFaces> findFacesUrlInputDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<FoundFaces, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<FoundFaces>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }


    /**
     * Returns any text found in the image for the language specified. If no language is specified in input then the detection defaults to English.
     *
     * @param language Language of the terms.
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @param oCRUrlInputOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OCR object if successful.
     */
    public OCR oCRUrlInput(String language, String contentType, BodyModel imageUrl, OCRUrlInputOptionalParameter oCRUrlInputOptionalParameter) {
        return oCRUrlInputWithServiceResponseAsync(language, contentType, imageUrl, oCRUrlInputOptionalParameter).toBlocking().single().body();
    }

    /**
     * Returns any text found in the image for the language specified. If no language is specified in input then the detection defaults to English.
     *
     * @param language Language of the terms.
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @param oCRUrlInputOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OCR> oCRUrlInputAsync(String language, String contentType, BodyModel imageUrl, OCRUrlInputOptionalParameter oCRUrlInputOptionalParameter, final ServiceCallback<OCR> serviceCallback) {
        return ServiceFuture.fromResponse(oCRUrlInputWithServiceResponseAsync(language, contentType, imageUrl, oCRUrlInputOptionalParameter), serviceCallback);
    }

    /**
     * Returns any text found in the image for the language specified. If no language is specified in input then the detection defaults to English.
     *
     * @param language Language of the terms.
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @param oCRUrlInputOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OCR object
     */
    public Observable<OCR> oCRUrlInputAsync(String language, String contentType, BodyModel imageUrl, OCRUrlInputOptionalParameter oCRUrlInputOptionalParameter) {
        return oCRUrlInputWithServiceResponseAsync(language, contentType, imageUrl, oCRUrlInputOptionalParameter).map(new Func1<ServiceResponse<OCR>, OCR>() {
            @Override
            public OCR call(ServiceResponse<OCR> response) {
                return response.body();
            }
        });
    }

    /**
     * Returns any text found in the image for the language specified. If no language is specified in input then the detection defaults to English.
     *
     * @param language Language of the terms.
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @param oCRUrlInputOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OCR object
     */
    public Observable<ServiceResponse<OCR>> oCRUrlInputWithServiceResponseAsync(String language, String contentType, BodyModel imageUrl, OCRUrlInputOptionalParameter oCRUrlInputOptionalParameter) {
        if (this.client.baseUrl() == null) {
            throw new IllegalArgumentException("Parameter this.client.baseUrl() is required and cannot be null.");
        }
        if (language == null) {
            throw new IllegalArgumentException("Parameter language is required and cannot be null.");
        }
        if (contentType == null) {
            throw new IllegalArgumentException("Parameter contentType is required and cannot be null.");
        }
        if (imageUrl == null) {
            throw new IllegalArgumentException("Parameter imageUrl is required and cannot be null.");
        }
        Validator.validate(imageUrl);
        final Boolean cacheImage = oCRUrlInputOptionalParameter != null ? oCRUrlInputOptionalParameter.cacheImage() : null;
        final Boolean enhanced = oCRUrlInputOptionalParameter != null ? oCRUrlInputOptionalParameter.enhanced() : null;
        String parameterizedHost = Joiner.on(", ").join("{baseUrl}", this.client.baseUrl());

        return oCRUrlInputWithServiceResponseAsync(language, contentType, imageUrl, cacheImage, enhanced);
    }

    /**
     * Returns any text found in the image for the language specified. If no language is specified in input then the detection defaults to English.
     *
     * @param language Language of the terms.
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @param enhanced When set to True, the image goes through additional processing to come with additional candidates.
     image/tiff is not supported when enhanced is set to true
     Note: This impacts the response time.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OCR object
     */
    public Observable<ServiceResponse<OCR>> oCRUrlInputWithServiceResponseAsync(String language, String contentType, BodyModel imageUrl, Boolean cacheImage, Boolean enhanced) {
        if (this.client.baseUrl() == null) {
            throw new IllegalArgumentException("Parameter this.client.baseUrl() is required and cannot be null.");
        }
        if (language == null) {
            throw new IllegalArgumentException("Parameter language is required and cannot be null.");
        }
        if (contentType == null) {
            throw new IllegalArgumentException("Parameter contentType is required and cannot be null.");
        }
        if (imageUrl == null) {
            throw new IllegalArgumentException("Parameter imageUrl is required and cannot be null.");
        }
        Validator.validate(imageUrl);
        String parameterizedHost = Joiner.on(", ").join("{baseUrl}", this.client.baseUrl());
        return service.oCRUrlInput(language, cacheImage, enhanced, contentType, imageUrl, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OCR>>>() {
                @Override
                public Observable<ServiceResponse<OCR>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OCR> clientResponse = oCRUrlInputDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OCR> oCRUrlInputDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OCR, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OCR>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }


    /**
     * Returns any text found in the image for the language specified. If no language is specified in input then the detection defaults to English.
     *
     * @param language Language of the terms.
     * @param imageStream The image file.
     * @param oCRFileInputOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OCR object if successful.
     */
    public OCR oCRFileInput(String language, byte[] imageStream, OCRFileInputOptionalParameter oCRFileInputOptionalParameter) {
        return oCRFileInputWithServiceResponseAsync(language, imageStream, oCRFileInputOptionalParameter).toBlocking().single().body();
    }

    /**
     * Returns any text found in the image for the language specified. If no language is specified in input then the detection defaults to English.
     *
     * @param language Language of the terms.
     * @param imageStream The image file.
     * @param oCRFileInputOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OCR> oCRFileInputAsync(String language, byte[] imageStream, OCRFileInputOptionalParameter oCRFileInputOptionalParameter, final ServiceCallback<OCR> serviceCallback) {
        return ServiceFuture.fromResponse(oCRFileInputWithServiceResponseAsync(language, imageStream, oCRFileInputOptionalParameter), serviceCallback);
    }

    /**
     * Returns any text found in the image for the language specified. If no language is specified in input then the detection defaults to English.
     *
     * @param language Language of the terms.
     * @param imageStream The image file.
     * @param oCRFileInputOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OCR object
     */
    public Observable<OCR> oCRFileInputAsync(String language, byte[] imageStream, OCRFileInputOptionalParameter oCRFileInputOptionalParameter) {
        return oCRFileInputWithServiceResponseAsync(language, imageStream, oCRFileInputOptionalParameter).map(new Func1<ServiceResponse<OCR>, OCR>() {
            @Override
            public OCR call(ServiceResponse<OCR> response) {
                return response.body();
            }
        });
    }

    /**
     * Returns any text found in the image for the language specified. If no language is specified in input then the detection defaults to English.
     *
     * @param language Language of the terms.
     * @param imageStream The image file.
     * @param oCRFileInputOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OCR object
     */
    public Observable<ServiceResponse<OCR>> oCRFileInputWithServiceResponseAsync(String language, byte[] imageStream, OCRFileInputOptionalParameter oCRFileInputOptionalParameter) {
        if (this.client.baseUrl() == null) {
            throw new IllegalArgumentException("Parameter this.client.baseUrl() is required and cannot be null.");
        }
        if (language == null) {
            throw new IllegalArgumentException("Parameter language is required and cannot be null.");
        }
        if (imageStream == null) {
            throw new IllegalArgumentException("Parameter imageStream is required and cannot be null.");
        }
        final Boolean cacheImage = oCRFileInputOptionalParameter != null ? oCRFileInputOptionalParameter.cacheImage() : null;
        final Boolean enhanced = oCRFileInputOptionalParameter != null ? oCRFileInputOptionalParameter.enhanced() : null;
        String parameterizedHost = Joiner.on(", ").join("{baseUrl}", this.client.baseUrl());
        RequestBody imageStreamConverted = RequestBody.create(MediaType.parse("image/gif"), imageStream);

        return oCRFileInputWithServiceResponseAsync(language, imageStream, cacheImage, enhanced);
    }

    /**
     * Returns any text found in the image for the language specified. If no language is specified in input then the detection defaults to English.
     *
     * @param language Language of the terms.
     * @param imageStream The image file.
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @param enhanced When set to True, the image goes through additional processing to come with additional candidates.
     image/tiff is not supported when enhanced is set to true
     Note: This impacts the response time.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OCR object
     */
    public Observable<ServiceResponse<OCR>> oCRFileInputWithServiceResponseAsync(String language, byte[] imageStream, Boolean cacheImage, Boolean enhanced) {
        if (this.client.baseUrl() == null) {
            throw new IllegalArgumentException("Parameter this.client.baseUrl() is required and cannot be null.");
        }
        if (language == null) {
            throw new IllegalArgumentException("Parameter language is required and cannot be null.");
        }
        if (imageStream == null) {
            throw new IllegalArgumentException("Parameter imageStream is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{baseUrl}", this.client.baseUrl());
        RequestBody imageStreamConverted = RequestBody.create(MediaType.parse("image/gif"), imageStream);
        return service.oCRFileInput(language, cacheImage, enhanced, imageStreamConverted, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OCR>>>() {
                @Override
                public Observable<ServiceResponse<OCR>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OCR> clientResponse = oCRFileInputDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OCR> oCRFileInputDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OCR, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OCR>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }


    /**
     * Returns probabilities of the image containing racy or adult content.
     *
     * @param imageStream The image file.
     * @param evaluateFileInputOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Evaluate object if successful.
     */
    public Evaluate evaluateFileInput(byte[] imageStream, EvaluateFileInputOptionalParameter evaluateFileInputOptionalParameter) {
        return evaluateFileInputWithServiceResponseAsync(imageStream, evaluateFileInputOptionalParameter).toBlocking().single().body();
    }

    /**
     * Returns probabilities of the image containing racy or adult content.
     *
     * @param imageStream The image file.
     * @param evaluateFileInputOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Evaluate> evaluateFileInputAsync(byte[] imageStream, EvaluateFileInputOptionalParameter evaluateFileInputOptionalParameter, final ServiceCallback<Evaluate> serviceCallback) {
        return ServiceFuture.fromResponse(evaluateFileInputWithServiceResponseAsync(imageStream, evaluateFileInputOptionalParameter), serviceCallback);
    }

    /**
     * Returns probabilities of the image containing racy or adult content.
     *
     * @param imageStream The image file.
     * @param evaluateFileInputOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Evaluate object
     */
    public Observable<Evaluate> evaluateFileInputAsync(byte[] imageStream, EvaluateFileInputOptionalParameter evaluateFileInputOptionalParameter) {
        return evaluateFileInputWithServiceResponseAsync(imageStream, evaluateFileInputOptionalParameter).map(new Func1<ServiceResponse<Evaluate>, Evaluate>() {
            @Override
            public Evaluate call(ServiceResponse<Evaluate> response) {
                return response.body();
            }
        });
    }

    /**
     * Returns probabilities of the image containing racy or adult content.
     *
     * @param imageStream The image file.
     * @param evaluateFileInputOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Evaluate object
     */
    public Observable<ServiceResponse<Evaluate>> evaluateFileInputWithServiceResponseAsync(byte[] imageStream, EvaluateFileInputOptionalParameter evaluateFileInputOptionalParameter) {
        if (this.client.baseUrl() == null) {
            throw new IllegalArgumentException("Parameter this.client.baseUrl() is required and cannot be null.");
        }
        if (imageStream == null) {
            throw new IllegalArgumentException("Parameter imageStream is required and cannot be null.");
        }
        final Boolean cacheImage = evaluateFileInputOptionalParameter != null ? evaluateFileInputOptionalParameter.cacheImage() : null;
        String parameterizedHost = Joiner.on(", ").join("{baseUrl}", this.client.baseUrl());
        RequestBody imageStreamConverted = RequestBody.create(MediaType.parse("image/gif"), imageStream);

        return evaluateFileInputWithServiceResponseAsync(imageStream, cacheImage);
    }

    /**
     * Returns probabilities of the image containing racy or adult content.
     *
     * @param imageStream The image file.
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Evaluate object
     */
    public Observable<ServiceResponse<Evaluate>> evaluateFileInputWithServiceResponseAsync(byte[] imageStream, Boolean cacheImage) {
        if (this.client.baseUrl() == null) {
            throw new IllegalArgumentException("Parameter this.client.baseUrl() is required and cannot be null.");
        }
        if (imageStream == null) {
            throw new IllegalArgumentException("Parameter imageStream is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{baseUrl}", this.client.baseUrl());
        RequestBody imageStreamConverted = RequestBody.create(MediaType.parse("image/gif"), imageStream);
        return service.evaluateFileInput(cacheImage, imageStreamConverted, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Evaluate>>>() {
                @Override
                public Observable<ServiceResponse<Evaluate>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Evaluate> clientResponse = evaluateFileInputDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Evaluate> evaluateFileInputDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Evaluate, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Evaluate>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }


    /**
     * Returns probabilities of the image containing racy or adult content.
     *
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @param evaluateUrlInputOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Evaluate object if successful.
     */
    public Evaluate evaluateUrlInput(String contentType, BodyModel imageUrl, EvaluateUrlInputOptionalParameter evaluateUrlInputOptionalParameter) {
        return evaluateUrlInputWithServiceResponseAsync(contentType, imageUrl, evaluateUrlInputOptionalParameter).toBlocking().single().body();
    }

    /**
     * Returns probabilities of the image containing racy or adult content.
     *
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @param evaluateUrlInputOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Evaluate> evaluateUrlInputAsync(String contentType, BodyModel imageUrl, EvaluateUrlInputOptionalParameter evaluateUrlInputOptionalParameter, final ServiceCallback<Evaluate> serviceCallback) {
        return ServiceFuture.fromResponse(evaluateUrlInputWithServiceResponseAsync(contentType, imageUrl, evaluateUrlInputOptionalParameter), serviceCallback);
    }

    /**
     * Returns probabilities of the image containing racy or adult content.
     *
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @param evaluateUrlInputOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Evaluate object
     */
    public Observable<Evaluate> evaluateUrlInputAsync(String contentType, BodyModel imageUrl, EvaluateUrlInputOptionalParameter evaluateUrlInputOptionalParameter) {
        return evaluateUrlInputWithServiceResponseAsync(contentType, imageUrl, evaluateUrlInputOptionalParameter).map(new Func1<ServiceResponse<Evaluate>, Evaluate>() {
            @Override
            public Evaluate call(ServiceResponse<Evaluate> response) {
                return response.body();
            }
        });
    }

    /**
     * Returns probabilities of the image containing racy or adult content.
     *
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @param evaluateUrlInputOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Evaluate object
     */
    public Observable<ServiceResponse<Evaluate>> evaluateUrlInputWithServiceResponseAsync(String contentType, BodyModel imageUrl, EvaluateUrlInputOptionalParameter evaluateUrlInputOptionalParameter) {
        if (this.client.baseUrl() == null) {
            throw new IllegalArgumentException("Parameter this.client.baseUrl() is required and cannot be null.");
        }
        if (contentType == null) {
            throw new IllegalArgumentException("Parameter contentType is required and cannot be null.");
        }
        if (imageUrl == null) {
            throw new IllegalArgumentException("Parameter imageUrl is required and cannot be null.");
        }
        Validator.validate(imageUrl);
        final Boolean cacheImage = evaluateUrlInputOptionalParameter != null ? evaluateUrlInputOptionalParameter.cacheImage() : null;
        String parameterizedHost = Joiner.on(", ").join("{baseUrl}", this.client.baseUrl());

        return evaluateUrlInputWithServiceResponseAsync(contentType, imageUrl, cacheImage);
    }

    /**
     * Returns probabilities of the image containing racy or adult content.
     *
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Evaluate object
     */
    public Observable<ServiceResponse<Evaluate>> evaluateUrlInputWithServiceResponseAsync(String contentType, BodyModel imageUrl, Boolean cacheImage) {
        if (this.client.baseUrl() == null) {
            throw new IllegalArgumentException("Parameter this.client.baseUrl() is required and cannot be null.");
        }
        if (contentType == null) {
            throw new IllegalArgumentException("Parameter contentType is required and cannot be null.");
        }
        if (imageUrl == null) {
            throw new IllegalArgumentException("Parameter imageUrl is required and cannot be null.");
        }
        Validator.validate(imageUrl);
        String parameterizedHost = Joiner.on(", ").join("{baseUrl}", this.client.baseUrl());
        return service.evaluateUrlInput(cacheImage, contentType, imageUrl, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Evaluate>>>() {
                @Override
                public Observable<ServiceResponse<Evaluate>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Evaluate> clientResponse = evaluateUrlInputDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Evaluate> evaluateUrlInputDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Evaluate, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Evaluate>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }


    /**
     * Fuzzily match an image against one of your custom Image Lists. You can create and manage your custom image lists using &lt;a href="/docs/services/578ff44d2703741568569ab9/operations/578ff7b12703741568569abe"&gt;this&lt;/a&gt; API.
     Returns ID and tags of matching image.&lt;br/&gt;
     &lt;br/&gt;
     Note: Refresh Index must be run on the corresponding Image List before additions and removals are reflected in the response.
     *
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @param matchUrlInputOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MatchResponse object if successful.
     */
    public MatchResponse matchUrlInput(String contentType, BodyModel imageUrl, MatchUrlInputOptionalParameter matchUrlInputOptionalParameter) {
        return matchUrlInputWithServiceResponseAsync(contentType, imageUrl, matchUrlInputOptionalParameter).toBlocking().single().body();
    }

    /**
     * Fuzzily match an image against one of your custom Image Lists. You can create and manage your custom image lists using &lt;a href="/docs/services/578ff44d2703741568569ab9/operations/578ff7b12703741568569abe"&gt;this&lt;/a&gt; API.
     Returns ID and tags of matching image.&lt;br/&gt;
     &lt;br/&gt;
     Note: Refresh Index must be run on the corresponding Image List before additions and removals are reflected in the response.
     *
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @param matchUrlInputOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MatchResponse> matchUrlInputAsync(String contentType, BodyModel imageUrl, MatchUrlInputOptionalParameter matchUrlInputOptionalParameter, final ServiceCallback<MatchResponse> serviceCallback) {
        return ServiceFuture.fromResponse(matchUrlInputWithServiceResponseAsync(contentType, imageUrl, matchUrlInputOptionalParameter), serviceCallback);
    }

    /**
     * Fuzzily match an image against one of your custom Image Lists. You can create and manage your custom image lists using &lt;a href="/docs/services/578ff44d2703741568569ab9/operations/578ff7b12703741568569abe"&gt;this&lt;/a&gt; API.
     Returns ID and tags of matching image.&lt;br/&gt;
     &lt;br/&gt;
     Note: Refresh Index must be run on the corresponding Image List before additions and removals are reflected in the response.
     *
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @param matchUrlInputOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MatchResponse object
     */
    public Observable<MatchResponse> matchUrlInputAsync(String contentType, BodyModel imageUrl, MatchUrlInputOptionalParameter matchUrlInputOptionalParameter) {
        return matchUrlInputWithServiceResponseAsync(contentType, imageUrl, matchUrlInputOptionalParameter).map(new Func1<ServiceResponse<MatchResponse>, MatchResponse>() {
            @Override
            public MatchResponse call(ServiceResponse<MatchResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * Fuzzily match an image against one of your custom Image Lists. You can create and manage your custom image lists using &lt;a href="/docs/services/578ff44d2703741568569ab9/operations/578ff7b12703741568569abe"&gt;this&lt;/a&gt; API.
     Returns ID and tags of matching image.&lt;br/&gt;
     &lt;br/&gt;
     Note: Refresh Index must be run on the corresponding Image List before additions and removals are reflected in the response.
     *
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @param matchUrlInputOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MatchResponse object
     */
    public Observable<ServiceResponse<MatchResponse>> matchUrlInputWithServiceResponseAsync(String contentType, BodyModel imageUrl, MatchUrlInputOptionalParameter matchUrlInputOptionalParameter) {
        if (this.client.baseUrl() == null) {
            throw new IllegalArgumentException("Parameter this.client.baseUrl() is required and cannot be null.");
        }
        if (contentType == null) {
            throw new IllegalArgumentException("Parameter contentType is required and cannot be null.");
        }
        if (imageUrl == null) {
            throw new IllegalArgumentException("Parameter imageUrl is required and cannot be null.");
        }
        Validator.validate(imageUrl);
        final String listId = matchUrlInputOptionalParameter != null ? matchUrlInputOptionalParameter.listId() : null;
        final Boolean cacheImage = matchUrlInputOptionalParameter != null ? matchUrlInputOptionalParameter.cacheImage() : null;
        String parameterizedHost = Joiner.on(", ").join("{baseUrl}", this.client.baseUrl());

        return matchUrlInputWithServiceResponseAsync(contentType, imageUrl, listId, cacheImage);
    }

    /**
     * Fuzzily match an image against one of your custom Image Lists. You can create and manage your custom image lists using &lt;a href="/docs/services/578ff44d2703741568569ab9/operations/578ff7b12703741568569abe"&gt;this&lt;/a&gt; API.
     Returns ID and tags of matching image.&lt;br/&gt;
     &lt;br/&gt;
     Note: Refresh Index must be run on the corresponding Image List before additions and removals are reflected in the response.
     *
     * @param contentType The content type.
     * @param imageUrl The image url.
     * @param listId The list Id.
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MatchResponse object
     */
    public Observable<ServiceResponse<MatchResponse>> matchUrlInputWithServiceResponseAsync(String contentType, BodyModel imageUrl, String listId, Boolean cacheImage) {
        if (this.client.baseUrl() == null) {
            throw new IllegalArgumentException("Parameter this.client.baseUrl() is required and cannot be null.");
        }
        if (contentType == null) {
            throw new IllegalArgumentException("Parameter contentType is required and cannot be null.");
        }
        if (imageUrl == null) {
            throw new IllegalArgumentException("Parameter imageUrl is required and cannot be null.");
        }
        Validator.validate(imageUrl);
        String parameterizedHost = Joiner.on(", ").join("{baseUrl}", this.client.baseUrl());
        return service.matchUrlInput(listId, cacheImage, contentType, imageUrl, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<MatchResponse>>>() {
                @Override
                public Observable<ServiceResponse<MatchResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<MatchResponse> clientResponse = matchUrlInputDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<MatchResponse> matchUrlInputDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<MatchResponse, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<MatchResponse>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }


    /**
     * Fuzzily match an image against one of your custom Image Lists. You can create and manage your custom image lists using &lt;a href="/docs/services/578ff44d2703741568569ab9/operations/578ff7b12703741568569abe"&gt;this&lt;/a&gt; API.
     Returns ID and tags of matching image.&lt;br/&gt;
     &lt;br/&gt;
     Note: Refresh Index must be run on the corresponding Image List before additions and removals are reflected in the response.
     *
     * @param imageStream The image file.
     * @param matchFileInputOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws APIErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MatchResponse object if successful.
     */
    public MatchResponse matchFileInput(byte[] imageStream, MatchFileInputOptionalParameter matchFileInputOptionalParameter) {
        return matchFileInputWithServiceResponseAsync(imageStream, matchFileInputOptionalParameter).toBlocking().single().body();
    }

    /**
     * Fuzzily match an image against one of your custom Image Lists. You can create and manage your custom image lists using &lt;a href="/docs/services/578ff44d2703741568569ab9/operations/578ff7b12703741568569abe"&gt;this&lt;/a&gt; API.
     Returns ID and tags of matching image.&lt;br/&gt;
     &lt;br/&gt;
     Note: Refresh Index must be run on the corresponding Image List before additions and removals are reflected in the response.
     *
     * @param imageStream The image file.
     * @param matchFileInputOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MatchResponse> matchFileInputAsync(byte[] imageStream, MatchFileInputOptionalParameter matchFileInputOptionalParameter, final ServiceCallback<MatchResponse> serviceCallback) {
        return ServiceFuture.fromResponse(matchFileInputWithServiceResponseAsync(imageStream, matchFileInputOptionalParameter), serviceCallback);
    }

    /**
     * Fuzzily match an image against one of your custom Image Lists. You can create and manage your custom image lists using &lt;a href="/docs/services/578ff44d2703741568569ab9/operations/578ff7b12703741568569abe"&gt;this&lt;/a&gt; API.
     Returns ID and tags of matching image.&lt;br/&gt;
     &lt;br/&gt;
     Note: Refresh Index must be run on the corresponding Image List before additions and removals are reflected in the response.
     *
     * @param imageStream The image file.
     * @param matchFileInputOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MatchResponse object
     */
    public Observable<MatchResponse> matchFileInputAsync(byte[] imageStream, MatchFileInputOptionalParameter matchFileInputOptionalParameter) {
        return matchFileInputWithServiceResponseAsync(imageStream, matchFileInputOptionalParameter).map(new Func1<ServiceResponse<MatchResponse>, MatchResponse>() {
            @Override
            public MatchResponse call(ServiceResponse<MatchResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * Fuzzily match an image against one of your custom Image Lists. You can create and manage your custom image lists using &lt;a href="/docs/services/578ff44d2703741568569ab9/operations/578ff7b12703741568569abe"&gt;this&lt;/a&gt; API.
     Returns ID and tags of matching image.&lt;br/&gt;
     &lt;br/&gt;
     Note: Refresh Index must be run on the corresponding Image List before additions and removals are reflected in the response.
     *
     * @param imageStream The image file.
     * @param matchFileInputOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MatchResponse object
     */
    public Observable<ServiceResponse<MatchResponse>> matchFileInputWithServiceResponseAsync(byte[] imageStream, MatchFileInputOptionalParameter matchFileInputOptionalParameter) {
        if (this.client.baseUrl() == null) {
            throw new IllegalArgumentException("Parameter this.client.baseUrl() is required and cannot be null.");
        }
        if (imageStream == null) {
            throw new IllegalArgumentException("Parameter imageStream is required and cannot be null.");
        }
        final String listId = matchFileInputOptionalParameter != null ? matchFileInputOptionalParameter.listId() : null;
        final Boolean cacheImage = matchFileInputOptionalParameter != null ? matchFileInputOptionalParameter.cacheImage() : null;
        String parameterizedHost = Joiner.on(", ").join("{baseUrl}", this.client.baseUrl());
        RequestBody imageStreamConverted = RequestBody.create(MediaType.parse("image/gif"), imageStream);

        return matchFileInputWithServiceResponseAsync(imageStream, listId, cacheImage);
    }

    /**
     * Fuzzily match an image against one of your custom Image Lists. You can create and manage your custom image lists using &lt;a href="/docs/services/578ff44d2703741568569ab9/operations/578ff7b12703741568569abe"&gt;this&lt;/a&gt; API.
     Returns ID and tags of matching image.&lt;br/&gt;
     &lt;br/&gt;
     Note: Refresh Index must be run on the corresponding Image List before additions and removals are reflected in the response.
     *
     * @param imageStream The image file.
     * @param listId The list Id.
     * @param cacheImage Whether to retain the submitted image for future use; defaults to false if omitted.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MatchResponse object
     */
    public Observable<ServiceResponse<MatchResponse>> matchFileInputWithServiceResponseAsync(byte[] imageStream, String listId, Boolean cacheImage) {
        if (this.client.baseUrl() == null) {
            throw new IllegalArgumentException("Parameter this.client.baseUrl() is required and cannot be null.");
        }
        if (imageStream == null) {
            throw new IllegalArgumentException("Parameter imageStream is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{baseUrl}", this.client.baseUrl());
        RequestBody imageStreamConverted = RequestBody.create(MediaType.parse("image/gif"), imageStream);
        return service.matchFileInput(listId, cacheImage, imageStreamConverted, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<MatchResponse>>>() {
                @Override
                public Observable<ServiceResponse<MatchResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<MatchResponse> clientResponse = matchFileInputDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<MatchResponse> matchFileInputDelegate(Response<ResponseBody> response) throws APIErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<MatchResponse, APIErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<MatchResponse>() { }.getType())
                .registerError(APIErrorException.class)
                .build(response);
    }

}
