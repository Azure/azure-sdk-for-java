/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.cognitiveservices.language.luis.programmatic.implementation;

import com.microsoft.azure.cognitiveservices.language.luis.programmatic.models.ListAppsOptionalParameter;
import com.microsoft.azure.cognitiveservices.language.luis.programmatic.models.ImportAppsOptionalParameter;
import com.microsoft.azure.cognitiveservices.language.luis.programmatic.models.UpdateSettingsOptionalParameter;
import retrofit2.Retrofit;
import com.microsoft.azure.cognitiveservices.language.luis.programmatic.Apps;
import com.google.common.base.Joiner;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.CloudException;
import com.microsoft.azure.cognitiveservices.language.luis.programmatic.models.ApplicationCreateObject;
import com.microsoft.azure.cognitiveservices.language.luis.programmatic.models.ApplicationInfoResponse;
import com.microsoft.azure.cognitiveservices.language.luis.programmatic.models.ApplicationPublishObject;
import com.microsoft.azure.cognitiveservices.language.luis.programmatic.models.ApplicationSettings;
import com.microsoft.azure.cognitiveservices.language.luis.programmatic.models.ApplicationSettingUpdateObject;
import com.microsoft.azure.cognitiveservices.language.luis.programmatic.models.ApplicationUpdateObject;
import com.microsoft.azure.cognitiveservices.language.luis.programmatic.models.AvailableCulture;
import com.microsoft.azure.cognitiveservices.language.luis.programmatic.models.AzureRegions;
import com.microsoft.azure.cognitiveservices.language.luis.programmatic.models.ErrorResponseException;
import com.microsoft.azure.cognitiveservices.language.luis.programmatic.models.LuisApp;
import com.microsoft.azure.cognitiveservices.language.luis.programmatic.models.OperationStatus;
import com.microsoft.azure.cognitiveservices.language.luis.programmatic.models.PersonalAssistantsResponse;
import com.microsoft.azure.cognitiveservices.language.luis.programmatic.models.PrebuiltDomain;
import com.microsoft.azure.cognitiveservices.language.luis.programmatic.models.PrebuiltDomainCreateObject;
import com.microsoft.azure.cognitiveservices.language.luis.programmatic.models.ProductionOrStagingEndpointInfo;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.InputStream;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.http.Streaming;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in Apps.
 */
public class AppsImpl implements Apps {
    /** The Retrofit service to perform REST calls. */
    private AppsService service;
    /** The service client containing this operation class. */
    private LUISProgrammaticAPIImpl client;

    /**
     * Initializes an instance of AppsImpl.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public AppsImpl(Retrofit retrofit, LUISProgrammaticAPIImpl client) {
        this.service = retrofit.create(AppsService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for Apps to be
     * used by Retrofit to perform actually REST calls.
     */
    interface AppsService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.programmatic.Apps add" })
        @POST("apps/")
        Observable<Response<ResponseBody>> add(@Body ApplicationCreateObject applicationCreateObject, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.programmatic.Apps listApps" })
        @GET("apps/")
        Observable<Response<ResponseBody>> listApps(@Query("skip") Integer skip, @Query("take") Integer take, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.programmatic.Apps importApps" })
        @POST("apps/import")
        Observable<Response<ResponseBody>> importApps(@Query("appName") String appName, @Body LuisApp luisApp, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.programmatic.Apps listCortanaEndpoints" })
        @GET("apps/assistants")
        Observable<Response<ResponseBody>> listCortanaEndpoints(@Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.programmatic.Apps listDomains" })
        @GET("apps/domains")
        Observable<Response<ResponseBody>> listDomains(@Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.programmatic.Apps listUsageScenarios" })
        @GET("apps/usagescenarios")
        Observable<Response<ResponseBody>> listUsageScenarios(@Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.programmatic.Apps listSupportedCultures" })
        @GET("apps/cultures")
        Observable<Response<ResponseBody>> listSupportedCultures(@Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.programmatic.Apps downloadQueryLogs" })
        @GET("apps/{appId}/querylogs")
        @Streaming
        Observable<Response<ResponseBody>> downloadQueryLogs(@Path("appId") UUID appId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.programmatic.Apps get" })
        @GET("apps/{appId}")
        Observable<Response<ResponseBody>> get(@Path("appId") UUID appId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.programmatic.Apps updateApps" })
        @PUT("apps/{appId}")
        Observable<Response<ResponseBody>> updateApps(@Path("appId") UUID appId, @Body ApplicationUpdateObject applicationUpdateObject, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.programmatic.Apps delete" })
        @HTTP(path = "apps/{appId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> delete(@Path("appId") UUID appId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.programmatic.Apps publish" })
        @POST("apps/{appId}/publish")
        Observable<Response<ResponseBody>> publish(@Path("appId") UUID appId, @Body ApplicationPublishObject applicationPublishObject, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.programmatic.Apps getSettings" })
        @GET("apps/{appId}/settings")
        Observable<Response<ResponseBody>> getSettings(@Path("appId") UUID appId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.programmatic.Apps updateSettings" })
        @PUT("apps/{appId}/settings")
        Observable<Response<ResponseBody>> updateSettings(@Path("appId") UUID appId, @Header("accept-language") String acceptLanguage, @Body ApplicationSettingUpdateObject applicationSettingUpdateObject, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.programmatic.Apps listEndpoints" })
        @GET("apps/{appId}/endpoints")
        Observable<Response<ResponseBody>> listEndpoints(@Path("appId") UUID appId, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.programmatic.Apps listAvailableCustomPrebuiltDomains" })
        @GET("apps/customprebuiltdomains")
        Observable<Response<ResponseBody>> listAvailableCustomPrebuiltDomains(@Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.programmatic.Apps addCustomPrebuiltDomain" })
        @POST("apps/customprebuiltdomains")
        Observable<Response<ResponseBody>> addCustomPrebuiltDomain(@Body PrebuiltDomainCreateObject prebuiltDomainCreateObject, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.language.luis.programmatic.Apps listAvailableCustomPrebuiltDomainsForCulture" })
        @GET("apps/customprebuiltdomains/{culture}")
        Observable<Response<ResponseBody>> listAvailableCustomPrebuiltDomainsForCulture(@Path("culture") String culture, @Header("accept-language") String acceptLanguage, @Header("x-ms-parameterized-host") String parameterizedHost, @Header("User-Agent") String userAgent);

    }

    /**
     * Creates a new LUIS app.
     *
     * @param applicationCreateObject A model containing Name, Description (optional), Culture, Usage Scenario (optional), Domain (optional) and initial version ID (optional) of the application. Default value for the version ID is 0.1. Note: the culture cannot be changed after the app is created.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UUID object if successful.
     */
    public UUID add(ApplicationCreateObject applicationCreateObject) {
        return addWithServiceResponseAsync(applicationCreateObject).toBlocking().single().body();
    }

    /**
     * Creates a new LUIS app.
     *
     * @param applicationCreateObject A model containing Name, Description (optional), Culture, Usage Scenario (optional), Domain (optional) and initial version ID (optional) of the application. Default value for the version ID is 0.1. Note: the culture cannot be changed after the app is created.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UUID> addAsync(ApplicationCreateObject applicationCreateObject, final ServiceCallback<UUID> serviceCallback) {
        return ServiceFuture.fromResponse(addWithServiceResponseAsync(applicationCreateObject), serviceCallback);
    }

    /**
     * Creates a new LUIS app.
     *
     * @param applicationCreateObject A model containing Name, Description (optional), Culture, Usage Scenario (optional), Domain (optional) and initial version ID (optional) of the application. Default value for the version ID is 0.1. Note: the culture cannot be changed after the app is created.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UUID object
     */
    public Observable<UUID> addAsync(ApplicationCreateObject applicationCreateObject) {
        return addWithServiceResponseAsync(applicationCreateObject).map(new Func1<ServiceResponse<UUID>, UUID>() {
            @Override
            public UUID call(ServiceResponse<UUID> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new LUIS app.
     *
     * @param applicationCreateObject A model containing Name, Description (optional), Culture, Usage Scenario (optional), Domain (optional) and initial version ID (optional) of the application. Default value for the version ID is 0.1. Note: the culture cannot be changed after the app is created.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UUID object
     */
    public Observable<ServiceResponse<UUID>> addWithServiceResponseAsync(ApplicationCreateObject applicationCreateObject) {
        if (this.client.azureRegion() == null) {
            throw new IllegalArgumentException("Parameter this.client.azureRegion() is required and cannot be null.");
        }
        if (applicationCreateObject == null) {
            throw new IllegalArgumentException("Parameter applicationCreateObject is required and cannot be null.");
        }
        Validator.validate(applicationCreateObject);
        String parameterizedHost = Joiner.on(", ").join("{AzureRegion}", this.client.azureRegion());
        return service.add(applicationCreateObject, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UUID>>>() {
                @Override
                public Observable<ServiceResponse<UUID>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UUID> clientResponse = addDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<UUID> addDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<UUID, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(201, new TypeToken<UUID>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }


    /**
     * Lists all of the user applications.
     *
     * @param listAppsOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ApplicationInfoResponse&gt; object if successful.
     */
    public List<ApplicationInfoResponse> listApps(ListAppsOptionalParameter listAppsOptionalParameter) {
        return listAppsWithServiceResponseAsync(listAppsOptionalParameter).toBlocking().single().body();
    }

    /**
     * Lists all of the user applications.
     *
     * @param listAppsOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ApplicationInfoResponse>> listAppsAsync(ListAppsOptionalParameter listAppsOptionalParameter, final ServiceCallback<List<ApplicationInfoResponse>> serviceCallback) {
        return ServiceFuture.fromResponse(listAppsWithServiceResponseAsync(listAppsOptionalParameter), serviceCallback);
    }

    /**
     * Lists all of the user applications.
     *
     * @param listAppsOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ApplicationInfoResponse&gt; object
     */
    public Observable<List<ApplicationInfoResponse>> listAppsAsync(ListAppsOptionalParameter listAppsOptionalParameter) {
        return listAppsWithServiceResponseAsync(listAppsOptionalParameter).map(new Func1<ServiceResponse<List<ApplicationInfoResponse>>, List<ApplicationInfoResponse>>() {
            @Override
            public List<ApplicationInfoResponse> call(ServiceResponse<List<ApplicationInfoResponse>> response) {
                return response.body();
            }
        });
    }

    /**
     * Lists all of the user applications.
     *
     * @param listAppsOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ApplicationInfoResponse&gt; object
     */
    public Observable<ServiceResponse<List<ApplicationInfoResponse>>> listAppsWithServiceResponseAsync(ListAppsOptionalParameter listAppsOptionalParameter) {
        if (this.client.azureRegion() == null) {
            throw new IllegalArgumentException("Parameter this.client.azureRegion() is required and cannot be null.");
        }
        final Integer skip = listAppsOptionalParameter != null ? listAppsOptionalParameter.skip() : null;
        final Integer take = listAppsOptionalParameter != null ? listAppsOptionalParameter.take() : null;
        String parameterizedHost = Joiner.on(", ").join("{AzureRegion}", this.client.azureRegion());

        return listAppsWithServiceResponseAsync(skip, take);
    }

    /**
     * Lists all of the user applications.
     *
     * @param skip The number of entries to skip. Default value is 0.
     * @param take The number of entries to return. Maximum page size is 500. Default is 100.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ApplicationInfoResponse&gt; object
     */
    public Observable<ServiceResponse<List<ApplicationInfoResponse>>> listAppsWithServiceResponseAsync(Integer skip, Integer take) {
        if (this.client.azureRegion() == null) {
            throw new IllegalArgumentException("Parameter this.client.azureRegion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{AzureRegion}", this.client.azureRegion());
        return service.listApps(skip, take, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ApplicationInfoResponse>>>>() {
                @Override
                public Observable<ServiceResponse<List<ApplicationInfoResponse>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<ApplicationInfoResponse>> clientResponse = listAppsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<ApplicationInfoResponse>> listAppsDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<ApplicationInfoResponse>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<ApplicationInfoResponse>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }


    /**
     * Imports an application to LUIS, the application's structure should be included in in the request body.
     *
     * @param luisApp A LUIS application structure.
     * @param importAppsOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UUID object if successful.
     */
    public UUID importApps(LuisApp luisApp, ImportAppsOptionalParameter importAppsOptionalParameter) {
        return importAppsWithServiceResponseAsync(luisApp, importAppsOptionalParameter).toBlocking().single().body();
    }

    /**
     * Imports an application to LUIS, the application's structure should be included in in the request body.
     *
     * @param luisApp A LUIS application structure.
     * @param importAppsOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UUID> importAppsAsync(LuisApp luisApp, ImportAppsOptionalParameter importAppsOptionalParameter, final ServiceCallback<UUID> serviceCallback) {
        return ServiceFuture.fromResponse(importAppsWithServiceResponseAsync(luisApp, importAppsOptionalParameter), serviceCallback);
    }

    /**
     * Imports an application to LUIS, the application's structure should be included in in the request body.
     *
     * @param luisApp A LUIS application structure.
     * @param importAppsOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UUID object
     */
    public Observable<UUID> importAppsAsync(LuisApp luisApp, ImportAppsOptionalParameter importAppsOptionalParameter) {
        return importAppsWithServiceResponseAsync(luisApp, importAppsOptionalParameter).map(new Func1<ServiceResponse<UUID>, UUID>() {
            @Override
            public UUID call(ServiceResponse<UUID> response) {
                return response.body();
            }
        });
    }

    /**
     * Imports an application to LUIS, the application's structure should be included in in the request body.
     *
     * @param luisApp A LUIS application structure.
     * @param importAppsOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UUID object
     */
    public Observable<ServiceResponse<UUID>> importAppsWithServiceResponseAsync(LuisApp luisApp, ImportAppsOptionalParameter importAppsOptionalParameter) {
        if (this.client.azureRegion() == null) {
            throw new IllegalArgumentException("Parameter this.client.azureRegion() is required and cannot be null.");
        }
        if (luisApp == null) {
            throw new IllegalArgumentException("Parameter luisApp is required and cannot be null.");
        }
        Validator.validate(luisApp);
        final String appName = importAppsOptionalParameter != null ? importAppsOptionalParameter.appName() : null;
        String parameterizedHost = Joiner.on(", ").join("{AzureRegion}", this.client.azureRegion());

        return importAppsWithServiceResponseAsync(luisApp, appName);
    }

    /**
     * Imports an application to LUIS, the application's structure should be included in in the request body.
     *
     * @param luisApp A LUIS application structure.
     * @param appName The application name to create. If not specified, the application name will be read from the imported object.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UUID object
     */
    public Observable<ServiceResponse<UUID>> importAppsWithServiceResponseAsync(LuisApp luisApp, String appName) {
        if (this.client.azureRegion() == null) {
            throw new IllegalArgumentException("Parameter this.client.azureRegion() is required and cannot be null.");
        }
        if (luisApp == null) {
            throw new IllegalArgumentException("Parameter luisApp is required and cannot be null.");
        }
        Validator.validate(luisApp);
        String parameterizedHost = Joiner.on(", ").join("{AzureRegion}", this.client.azureRegion());
        return service.importApps(appName, luisApp, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UUID>>>() {
                @Override
                public Observable<ServiceResponse<UUID>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UUID> clientResponse = importAppsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<UUID> importAppsDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<UUID, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(201, new TypeToken<UUID>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Gets the endpoint URLs for the prebuilt Cortana applications.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PersonalAssistantsResponse object if successful.
     */
    public PersonalAssistantsResponse listCortanaEndpoints() {
        return listCortanaEndpointsWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets the endpoint URLs for the prebuilt Cortana applications.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PersonalAssistantsResponse> listCortanaEndpointsAsync(final ServiceCallback<PersonalAssistantsResponse> serviceCallback) {
        return ServiceFuture.fromResponse(listCortanaEndpointsWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets the endpoint URLs for the prebuilt Cortana applications.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PersonalAssistantsResponse object
     */
    public Observable<PersonalAssistantsResponse> listCortanaEndpointsAsync() {
        return listCortanaEndpointsWithServiceResponseAsync().map(new Func1<ServiceResponse<PersonalAssistantsResponse>, PersonalAssistantsResponse>() {
            @Override
            public PersonalAssistantsResponse call(ServiceResponse<PersonalAssistantsResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the endpoint URLs for the prebuilt Cortana applications.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PersonalAssistantsResponse object
     */
    public Observable<ServiceResponse<PersonalAssistantsResponse>> listCortanaEndpointsWithServiceResponseAsync() {
        if (this.client.azureRegion() == null) {
            throw new IllegalArgumentException("Parameter this.client.azureRegion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{AzureRegion}", this.client.azureRegion());
        return service.listCortanaEndpoints(this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PersonalAssistantsResponse>>>() {
                @Override
                public Observable<ServiceResponse<PersonalAssistantsResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PersonalAssistantsResponse> clientResponse = listCortanaEndpointsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PersonalAssistantsResponse> listCortanaEndpointsDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PersonalAssistantsResponse, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PersonalAssistantsResponse>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Gets the available application domains.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;String&gt; object if successful.
     */
    public List<String> listDomains() {
        return listDomainsWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets the available application domains.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<String>> listDomainsAsync(final ServiceCallback<List<String>> serviceCallback) {
        return ServiceFuture.fromResponse(listDomainsWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets the available application domains.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;String&gt; object
     */
    public Observable<List<String>> listDomainsAsync() {
        return listDomainsWithServiceResponseAsync().map(new Func1<ServiceResponse<List<String>>, List<String>>() {
            @Override
            public List<String> call(ServiceResponse<List<String>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the available application domains.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;String&gt; object
     */
    public Observable<ServiceResponse<List<String>>> listDomainsWithServiceResponseAsync() {
        if (this.client.azureRegion() == null) {
            throw new IllegalArgumentException("Parameter this.client.azureRegion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{AzureRegion}", this.client.azureRegion());
        return service.listDomains(this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<String>>>>() {
                @Override
                public Observable<ServiceResponse<List<String>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<String>> clientResponse = listDomainsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<String>> listDomainsDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<String>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<String>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Gets the application available usage scenarios.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;String&gt; object if successful.
     */
    public List<String> listUsageScenarios() {
        return listUsageScenariosWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets the application available usage scenarios.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<String>> listUsageScenariosAsync(final ServiceCallback<List<String>> serviceCallback) {
        return ServiceFuture.fromResponse(listUsageScenariosWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets the application available usage scenarios.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;String&gt; object
     */
    public Observable<List<String>> listUsageScenariosAsync() {
        return listUsageScenariosWithServiceResponseAsync().map(new Func1<ServiceResponse<List<String>>, List<String>>() {
            @Override
            public List<String> call(ServiceResponse<List<String>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the application available usage scenarios.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;String&gt; object
     */
    public Observable<ServiceResponse<List<String>>> listUsageScenariosWithServiceResponseAsync() {
        if (this.client.azureRegion() == null) {
            throw new IllegalArgumentException("Parameter this.client.azureRegion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{AzureRegion}", this.client.azureRegion());
        return service.listUsageScenarios(this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<String>>>>() {
                @Override
                public Observable<ServiceResponse<List<String>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<String>> clientResponse = listUsageScenariosDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<String>> listUsageScenariosDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<String>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<String>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Gets the supported application cultures.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;AvailableCulture&gt; object if successful.
     */
    public List<AvailableCulture> listSupportedCultures() {
        return listSupportedCulturesWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets the supported application cultures.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<AvailableCulture>> listSupportedCulturesAsync(final ServiceCallback<List<AvailableCulture>> serviceCallback) {
        return ServiceFuture.fromResponse(listSupportedCulturesWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets the supported application cultures.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;AvailableCulture&gt; object
     */
    public Observable<List<AvailableCulture>> listSupportedCulturesAsync() {
        return listSupportedCulturesWithServiceResponseAsync().map(new Func1<ServiceResponse<List<AvailableCulture>>, List<AvailableCulture>>() {
            @Override
            public List<AvailableCulture> call(ServiceResponse<List<AvailableCulture>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the supported application cultures.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;AvailableCulture&gt; object
     */
    public Observable<ServiceResponse<List<AvailableCulture>>> listSupportedCulturesWithServiceResponseAsync() {
        if (this.client.azureRegion() == null) {
            throw new IllegalArgumentException("Parameter this.client.azureRegion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{AzureRegion}", this.client.azureRegion());
        return service.listSupportedCultures(this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<AvailableCulture>>>>() {
                @Override
                public Observable<ServiceResponse<List<AvailableCulture>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<AvailableCulture>> clientResponse = listSupportedCulturesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<AvailableCulture>> listSupportedCulturesDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<AvailableCulture>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<AvailableCulture>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Gets the query logs of the past month for the application.
     *
     * @param appId The application ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the InputStream object if successful.
     */
    public InputStream downloadQueryLogs(UUID appId) {
        return downloadQueryLogsWithServiceResponseAsync(appId).toBlocking().single().body();
    }

    /**
     * Gets the query logs of the past month for the application.
     *
     * @param appId The application ID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<InputStream> downloadQueryLogsAsync(UUID appId, final ServiceCallback<InputStream> serviceCallback) {
        return ServiceFuture.fromResponse(downloadQueryLogsWithServiceResponseAsync(appId), serviceCallback);
    }

    /**
     * Gets the query logs of the past month for the application.
     *
     * @param appId The application ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the InputStream object
     */
    public Observable<InputStream> downloadQueryLogsAsync(UUID appId) {
        return downloadQueryLogsWithServiceResponseAsync(appId).map(new Func1<ServiceResponse<InputStream>, InputStream>() {
            @Override
            public InputStream call(ServiceResponse<InputStream> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the query logs of the past month for the application.
     *
     * @param appId The application ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the InputStream object
     */
    public Observable<ServiceResponse<InputStream>> downloadQueryLogsWithServiceResponseAsync(UUID appId) {
        if (this.client.azureRegion() == null) {
            throw new IllegalArgumentException("Parameter this.client.azureRegion() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{AzureRegion}", this.client.azureRegion());
        return service.downloadQueryLogs(appId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<InputStream>>>() {
                @Override
                public Observable<ServiceResponse<InputStream>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<InputStream> clientResponse = downloadQueryLogsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<InputStream> downloadQueryLogsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<InputStream, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<InputStream>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the application info.
     *
     * @param appId The application ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ApplicationInfoResponse object if successful.
     */
    public ApplicationInfoResponse get(UUID appId) {
        return getWithServiceResponseAsync(appId).toBlocking().single().body();
    }

    /**
     * Gets the application info.
     *
     * @param appId The application ID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ApplicationInfoResponse> getAsync(UUID appId, final ServiceCallback<ApplicationInfoResponse> serviceCallback) {
        return ServiceFuture.fromResponse(getWithServiceResponseAsync(appId), serviceCallback);
    }

    /**
     * Gets the application info.
     *
     * @param appId The application ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationInfoResponse object
     */
    public Observable<ApplicationInfoResponse> getAsync(UUID appId) {
        return getWithServiceResponseAsync(appId).map(new Func1<ServiceResponse<ApplicationInfoResponse>, ApplicationInfoResponse>() {
            @Override
            public ApplicationInfoResponse call(ServiceResponse<ApplicationInfoResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the application info.
     *
     * @param appId The application ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationInfoResponse object
     */
    public Observable<ServiceResponse<ApplicationInfoResponse>> getWithServiceResponseAsync(UUID appId) {
        if (this.client.azureRegion() == null) {
            throw new IllegalArgumentException("Parameter this.client.azureRegion() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{AzureRegion}", this.client.azureRegion());
        return service.get(appId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ApplicationInfoResponse>>>() {
                @Override
                public Observable<ServiceResponse<ApplicationInfoResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ApplicationInfoResponse> clientResponse = getDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ApplicationInfoResponse> getDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ApplicationInfoResponse, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ApplicationInfoResponse>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Updates the name or description of the application.
     *
     * @param appId The application ID.
     * @param applicationUpdateObject A model containing Name and Description of the application.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatus object if successful.
     */
    public OperationStatus updateApps(UUID appId, ApplicationUpdateObject applicationUpdateObject) {
        return updateAppsWithServiceResponseAsync(appId, applicationUpdateObject).toBlocking().single().body();
    }

    /**
     * Updates the name or description of the application.
     *
     * @param appId The application ID.
     * @param applicationUpdateObject A model containing Name and Description of the application.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatus> updateAppsAsync(UUID appId, ApplicationUpdateObject applicationUpdateObject, final ServiceCallback<OperationStatus> serviceCallback) {
        return ServiceFuture.fromResponse(updateAppsWithServiceResponseAsync(appId, applicationUpdateObject), serviceCallback);
    }

    /**
     * Updates the name or description of the application.
     *
     * @param appId The application ID.
     * @param applicationUpdateObject A model containing Name and Description of the application.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<OperationStatus> updateAppsAsync(UUID appId, ApplicationUpdateObject applicationUpdateObject) {
        return updateAppsWithServiceResponseAsync(appId, applicationUpdateObject).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
            @Override
            public OperationStatus call(ServiceResponse<OperationStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the name or description of the application.
     *
     * @param appId The application ID.
     * @param applicationUpdateObject A model containing Name and Description of the application.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> updateAppsWithServiceResponseAsync(UUID appId, ApplicationUpdateObject applicationUpdateObject) {
        if (this.client.azureRegion() == null) {
            throw new IllegalArgumentException("Parameter this.client.azureRegion() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (applicationUpdateObject == null) {
            throw new IllegalArgumentException("Parameter applicationUpdateObject is required and cannot be null.");
        }
        Validator.validate(applicationUpdateObject);
        String parameterizedHost = Joiner.on(", ").join("{AzureRegion}", this.client.azureRegion());
        return service.updateApps(appId, applicationUpdateObject, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatus>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatus> clientResponse = updateAppsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatus> updateAppsDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatus, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatus>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Deletes an application.
     *
     * @param appId The application ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatus object if successful.
     */
    public OperationStatus delete(UUID appId) {
        return deleteWithServiceResponseAsync(appId).toBlocking().single().body();
    }

    /**
     * Deletes an application.
     *
     * @param appId The application ID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatus> deleteAsync(UUID appId, final ServiceCallback<OperationStatus> serviceCallback) {
        return ServiceFuture.fromResponse(deleteWithServiceResponseAsync(appId), serviceCallback);
    }

    /**
     * Deletes an application.
     *
     * @param appId The application ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<OperationStatus> deleteAsync(UUID appId) {
        return deleteWithServiceResponseAsync(appId).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
            @Override
            public OperationStatus call(ServiceResponse<OperationStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes an application.
     *
     * @param appId The application ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> deleteWithServiceResponseAsync(UUID appId) {
        if (this.client.azureRegion() == null) {
            throw new IllegalArgumentException("Parameter this.client.azureRegion() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{AzureRegion}", this.client.azureRegion());
        return service.delete(appId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatus>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatus> clientResponse = deleteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatus> deleteDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatus, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatus>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Publishes a specific version of the application.
     *
     * @param appId The application ID.
     * @param applicationPublishObject The application publish object. The region is the target region that the application is published to.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductionOrStagingEndpointInfo object if successful.
     */
    public ProductionOrStagingEndpointInfo publish(UUID appId, ApplicationPublishObject applicationPublishObject) {
        return publishWithServiceResponseAsync(appId, applicationPublishObject).toBlocking().single().body();
    }

    /**
     * Publishes a specific version of the application.
     *
     * @param appId The application ID.
     * @param applicationPublishObject The application publish object. The region is the target region that the application is published to.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductionOrStagingEndpointInfo> publishAsync(UUID appId, ApplicationPublishObject applicationPublishObject, final ServiceCallback<ProductionOrStagingEndpointInfo> serviceCallback) {
        return ServiceFuture.fromResponse(publishWithServiceResponseAsync(appId, applicationPublishObject), serviceCallback);
    }

    /**
     * Publishes a specific version of the application.
     *
     * @param appId The application ID.
     * @param applicationPublishObject The application publish object. The region is the target region that the application is published to.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProductionOrStagingEndpointInfo object
     */
    public Observable<ProductionOrStagingEndpointInfo> publishAsync(UUID appId, ApplicationPublishObject applicationPublishObject) {
        return publishWithServiceResponseAsync(appId, applicationPublishObject).map(new Func1<ServiceResponse<ProductionOrStagingEndpointInfo>, ProductionOrStagingEndpointInfo>() {
            @Override
            public ProductionOrStagingEndpointInfo call(ServiceResponse<ProductionOrStagingEndpointInfo> response) {
                return response.body();
            }
        });
    }

    /**
     * Publishes a specific version of the application.
     *
     * @param appId The application ID.
     * @param applicationPublishObject The application publish object. The region is the target region that the application is published to.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProductionOrStagingEndpointInfo object
     */
    public Observable<ServiceResponse<ProductionOrStagingEndpointInfo>> publishWithServiceResponseAsync(UUID appId, ApplicationPublishObject applicationPublishObject) {
        if (this.client.azureRegion() == null) {
            throw new IllegalArgumentException("Parameter this.client.azureRegion() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        if (applicationPublishObject == null) {
            throw new IllegalArgumentException("Parameter applicationPublishObject is required and cannot be null.");
        }
        Validator.validate(applicationPublishObject);
        String parameterizedHost = Joiner.on(", ").join("{AzureRegion}", this.client.azureRegion());
        return service.publish(appId, applicationPublishObject, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ProductionOrStagingEndpointInfo>>>() {
                @Override
                public Observable<ServiceResponse<ProductionOrStagingEndpointInfo>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ProductionOrStagingEndpointInfo> clientResponse = publishDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ProductionOrStagingEndpointInfo> publishDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ProductionOrStagingEndpointInfo, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(201, new TypeToken<ProductionOrStagingEndpointInfo>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Get the application settings.
     *
     * @param appId The application ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ApplicationSettings object if successful.
     */
    public ApplicationSettings getSettings(UUID appId) {
        return getSettingsWithServiceResponseAsync(appId).toBlocking().single().body();
    }

    /**
     * Get the application settings.
     *
     * @param appId The application ID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ApplicationSettings> getSettingsAsync(UUID appId, final ServiceCallback<ApplicationSettings> serviceCallback) {
        return ServiceFuture.fromResponse(getSettingsWithServiceResponseAsync(appId), serviceCallback);
    }

    /**
     * Get the application settings.
     *
     * @param appId The application ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationSettings object
     */
    public Observable<ApplicationSettings> getSettingsAsync(UUID appId) {
        return getSettingsWithServiceResponseAsync(appId).map(new Func1<ServiceResponse<ApplicationSettings>, ApplicationSettings>() {
            @Override
            public ApplicationSettings call(ServiceResponse<ApplicationSettings> response) {
                return response.body();
            }
        });
    }

    /**
     * Get the application settings.
     *
     * @param appId The application ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ApplicationSettings object
     */
    public Observable<ServiceResponse<ApplicationSettings>> getSettingsWithServiceResponseAsync(UUID appId) {
        if (this.client.azureRegion() == null) {
            throw new IllegalArgumentException("Parameter this.client.azureRegion() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{AzureRegion}", this.client.azureRegion());
        return service.getSettings(appId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ApplicationSettings>>>() {
                @Override
                public Observable<ServiceResponse<ApplicationSettings>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ApplicationSettings> clientResponse = getSettingsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ApplicationSettings> getSettingsDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ApplicationSettings, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ApplicationSettings>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }


    /**
     * Updates the application settings.
     *
     * @param appId The application ID.
     * @param updateSettingsOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationStatus object if successful.
     */
    public OperationStatus updateSettings(UUID appId, UpdateSettingsOptionalParameter updateSettingsOptionalParameter) {
        return updateSettingsWithServiceResponseAsync(appId, updateSettingsOptionalParameter).toBlocking().single().body();
    }

    /**
     * Updates the application settings.
     *
     * @param appId The application ID.
     * @param updateSettingsOptionalParameter the object representing the optional parameters to be set before calling this API
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationStatus> updateSettingsAsync(UUID appId, UpdateSettingsOptionalParameter updateSettingsOptionalParameter, final ServiceCallback<OperationStatus> serviceCallback) {
        return ServiceFuture.fromResponse(updateSettingsWithServiceResponseAsync(appId, updateSettingsOptionalParameter), serviceCallback);
    }

    /**
     * Updates the application settings.
     *
     * @param appId The application ID.
     * @param updateSettingsOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<OperationStatus> updateSettingsAsync(UUID appId, UpdateSettingsOptionalParameter updateSettingsOptionalParameter) {
        return updateSettingsWithServiceResponseAsync(appId, updateSettingsOptionalParameter).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
            @Override
            public OperationStatus call(ServiceResponse<OperationStatus> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates the application settings.
     *
     * @param appId The application ID.
     * @param updateSettingsOptionalParameter the object representing the optional parameters to be set before calling this API
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> updateSettingsWithServiceResponseAsync(UUID appId, UpdateSettingsOptionalParameter updateSettingsOptionalParameter) {
        if (this.client.azureRegion() == null) {
            throw new IllegalArgumentException("Parameter this.client.azureRegion() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        final Boolean publicParameter = updateSettingsOptionalParameter != null ? updateSettingsOptionalParameter.publicParameter() : null;
        ApplicationSettingUpdateObject applicationSettingUpdateObject = new ApplicationSettingUpdateObject();
        applicationSettingUpdateObject.withPublicProperty(null);
        String parameterizedHost = Joiner.on(", ").join("{AzureRegion}", this.client.azureRegion());

        return updateSettingsWithServiceResponseAsync(appId, publicParameter);
    }

    /**
     * Updates the application settings.
     *
     * @param appId The application ID.
     * @param publicParameter Setting your application as public allows other people to use your application's endpoint using their own keys.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationStatus object
     */
    public Observable<ServiceResponse<OperationStatus>> updateSettingsWithServiceResponseAsync(UUID appId, Boolean publicParameter) {
        if (this.client.azureRegion() == null) {
            throw new IllegalArgumentException("Parameter this.client.azureRegion() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        ApplicationSettingUpdateObject applicationSettingUpdateObject = new ApplicationSettingUpdateObject();
        applicationSettingUpdateObject.withPublicProperty(publicParameter);
        String parameterizedHost = Joiner.on(", ").join("{AzureRegion}", this.client.azureRegion());
        return service.updateSettings(appId, this.client.acceptLanguage(), applicationSettingUpdateObject, parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationStatus>>>() {
                @Override
                public Observable<ServiceResponse<OperationStatus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationStatus> clientResponse = updateSettingsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationStatus> updateSettingsDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationStatus, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationStatus>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Returns the available endpoint deployment regions and URLs.
     *
     * @param appId The application ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, String&gt; object if successful.
     */
    public Map<String, String> listEndpoints(UUID appId) {
        return listEndpointsWithServiceResponseAsync(appId).toBlocking().single().body();
    }

    /**
     * Returns the available endpoint deployment regions and URLs.
     *
     * @param appId The application ID.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, String>> listEndpointsAsync(UUID appId, final ServiceCallback<Map<String, String>> serviceCallback) {
        return ServiceFuture.fromResponse(listEndpointsWithServiceResponseAsync(appId), serviceCallback);
    }

    /**
     * Returns the available endpoint deployment regions and URLs.
     *
     * @param appId The application ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Map&lt;String, String&gt; object
     */
    public Observable<Map<String, String>> listEndpointsAsync(UUID appId) {
        return listEndpointsWithServiceResponseAsync(appId).map(new Func1<ServiceResponse<Map<String, String>>, Map<String, String>>() {
            @Override
            public Map<String, String> call(ServiceResponse<Map<String, String>> response) {
                return response.body();
            }
        });
    }

    /**
     * Returns the available endpoint deployment regions and URLs.
     *
     * @param appId The application ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Map&lt;String, String&gt; object
     */
    public Observable<ServiceResponse<Map<String, String>>> listEndpointsWithServiceResponseAsync(UUID appId) {
        if (this.client.azureRegion() == null) {
            throw new IllegalArgumentException("Parameter this.client.azureRegion() is required and cannot be null.");
        }
        if (appId == null) {
            throw new IllegalArgumentException("Parameter appId is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{AzureRegion}", this.client.azureRegion());
        return service.listEndpoints(appId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, String>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, String>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, String>> clientResponse = listEndpointsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, String>> listEndpointsDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Map<String, String>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Map<String, String>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Gets all the available custom prebuilt domains for all cultures.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;PrebuiltDomain&gt; object if successful.
     */
    public List<PrebuiltDomain> listAvailableCustomPrebuiltDomains() {
        return listAvailableCustomPrebuiltDomainsWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets all the available custom prebuilt domains for all cultures.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<PrebuiltDomain>> listAvailableCustomPrebuiltDomainsAsync(final ServiceCallback<List<PrebuiltDomain>> serviceCallback) {
        return ServiceFuture.fromResponse(listAvailableCustomPrebuiltDomainsWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets all the available custom prebuilt domains for all cultures.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PrebuiltDomain&gt; object
     */
    public Observable<List<PrebuiltDomain>> listAvailableCustomPrebuiltDomainsAsync() {
        return listAvailableCustomPrebuiltDomainsWithServiceResponseAsync().map(new Func1<ServiceResponse<List<PrebuiltDomain>>, List<PrebuiltDomain>>() {
            @Override
            public List<PrebuiltDomain> call(ServiceResponse<List<PrebuiltDomain>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets all the available custom prebuilt domains for all cultures.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PrebuiltDomain&gt; object
     */
    public Observable<ServiceResponse<List<PrebuiltDomain>>> listAvailableCustomPrebuiltDomainsWithServiceResponseAsync() {
        if (this.client.azureRegion() == null) {
            throw new IllegalArgumentException("Parameter this.client.azureRegion() is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{AzureRegion}", this.client.azureRegion());
        return service.listAvailableCustomPrebuiltDomains(this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<PrebuiltDomain>>>>() {
                @Override
                public Observable<ServiceResponse<List<PrebuiltDomain>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<PrebuiltDomain>> clientResponse = listAvailableCustomPrebuiltDomainsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<PrebuiltDomain>> listAvailableCustomPrebuiltDomainsDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<PrebuiltDomain>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<PrebuiltDomain>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Adds a prebuilt domain along with its models as a new application.
     *
     * @param prebuiltDomainCreateObject A prebuilt domain create object containing the name and culture of the domain.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UUID object if successful.
     */
    public UUID addCustomPrebuiltDomain(PrebuiltDomainCreateObject prebuiltDomainCreateObject) {
        return addCustomPrebuiltDomainWithServiceResponseAsync(prebuiltDomainCreateObject).toBlocking().single().body();
    }

    /**
     * Adds a prebuilt domain along with its models as a new application.
     *
     * @param prebuiltDomainCreateObject A prebuilt domain create object containing the name and culture of the domain.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UUID> addCustomPrebuiltDomainAsync(PrebuiltDomainCreateObject prebuiltDomainCreateObject, final ServiceCallback<UUID> serviceCallback) {
        return ServiceFuture.fromResponse(addCustomPrebuiltDomainWithServiceResponseAsync(prebuiltDomainCreateObject), serviceCallback);
    }

    /**
     * Adds a prebuilt domain along with its models as a new application.
     *
     * @param prebuiltDomainCreateObject A prebuilt domain create object containing the name and culture of the domain.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UUID object
     */
    public Observable<UUID> addCustomPrebuiltDomainAsync(PrebuiltDomainCreateObject prebuiltDomainCreateObject) {
        return addCustomPrebuiltDomainWithServiceResponseAsync(prebuiltDomainCreateObject).map(new Func1<ServiceResponse<UUID>, UUID>() {
            @Override
            public UUID call(ServiceResponse<UUID> response) {
                return response.body();
            }
        });
    }

    /**
     * Adds a prebuilt domain along with its models as a new application.
     *
     * @param prebuiltDomainCreateObject A prebuilt domain create object containing the name and culture of the domain.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UUID object
     */
    public Observable<ServiceResponse<UUID>> addCustomPrebuiltDomainWithServiceResponseAsync(PrebuiltDomainCreateObject prebuiltDomainCreateObject) {
        if (this.client.azureRegion() == null) {
            throw new IllegalArgumentException("Parameter this.client.azureRegion() is required and cannot be null.");
        }
        if (prebuiltDomainCreateObject == null) {
            throw new IllegalArgumentException("Parameter prebuiltDomainCreateObject is required and cannot be null.");
        }
        Validator.validate(prebuiltDomainCreateObject);
        String parameterizedHost = Joiner.on(", ").join("{AzureRegion}", this.client.azureRegion());
        return service.addCustomPrebuiltDomain(prebuiltDomainCreateObject, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UUID>>>() {
                @Override
                public Observable<ServiceResponse<UUID>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UUID> clientResponse = addCustomPrebuiltDomainDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<UUID> addCustomPrebuiltDomainDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<UUID, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(201, new TypeToken<UUID>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Gets all the available custom prebuilt domains for a specific culture.
     *
     * @param culture Culture.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;PrebuiltDomain&gt; object if successful.
     */
    public List<PrebuiltDomain> listAvailableCustomPrebuiltDomainsForCulture(String culture) {
        return listAvailableCustomPrebuiltDomainsForCultureWithServiceResponseAsync(culture).toBlocking().single().body();
    }

    /**
     * Gets all the available custom prebuilt domains for a specific culture.
     *
     * @param culture Culture.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<PrebuiltDomain>> listAvailableCustomPrebuiltDomainsForCultureAsync(String culture, final ServiceCallback<List<PrebuiltDomain>> serviceCallback) {
        return ServiceFuture.fromResponse(listAvailableCustomPrebuiltDomainsForCultureWithServiceResponseAsync(culture), serviceCallback);
    }

    /**
     * Gets all the available custom prebuilt domains for a specific culture.
     *
     * @param culture Culture.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PrebuiltDomain&gt; object
     */
    public Observable<List<PrebuiltDomain>> listAvailableCustomPrebuiltDomainsForCultureAsync(String culture) {
        return listAvailableCustomPrebuiltDomainsForCultureWithServiceResponseAsync(culture).map(new Func1<ServiceResponse<List<PrebuiltDomain>>, List<PrebuiltDomain>>() {
            @Override
            public List<PrebuiltDomain> call(ServiceResponse<List<PrebuiltDomain>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets all the available custom prebuilt domains for a specific culture.
     *
     * @param culture Culture.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PrebuiltDomain&gt; object
     */
    public Observable<ServiceResponse<List<PrebuiltDomain>>> listAvailableCustomPrebuiltDomainsForCultureWithServiceResponseAsync(String culture) {
        if (this.client.azureRegion() == null) {
            throw new IllegalArgumentException("Parameter this.client.azureRegion() is required and cannot be null.");
        }
        if (culture == null) {
            throw new IllegalArgumentException("Parameter culture is required and cannot be null.");
        }
        String parameterizedHost = Joiner.on(", ").join("{AzureRegion}", this.client.azureRegion());
        return service.listAvailableCustomPrebuiltDomainsForCulture(culture, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<PrebuiltDomain>>>>() {
                @Override
                public Observable<ServiceResponse<List<PrebuiltDomain>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<PrebuiltDomain>> clientResponse = listAvailableCustomPrebuiltDomainsForCultureDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<PrebuiltDomain>> listAvailableCustomPrebuiltDomainsForCultureDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<PrebuiltDomain>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<PrebuiltDomain>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

}
