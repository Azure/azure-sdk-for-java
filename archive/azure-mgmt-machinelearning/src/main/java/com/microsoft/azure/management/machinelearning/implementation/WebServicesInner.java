/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.management.machinelearning.implementation;

import com.microsoft.azure.management.resources.fluentcore.collection.InnerSupportsGet;
import com.microsoft.azure.management.resources.fluentcore.collection.InnerSupportsDelete;
import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.AzureServiceFuture;
import com.microsoft.azure.CloudException;
import com.microsoft.azure.ListOperationCallback;
import com.microsoft.azure.Page;
import com.microsoft.azure.PagedList;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.List;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.PATCH;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.http.Url;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in WebServices.
 */
public class WebServicesInner implements InnerSupportsGet<WebServiceInner>, InnerSupportsDelete<Void> {
    /** The Retrofit service to perform REST calls. */
    private WebServicesService service;
    /** The service client containing this operation class. */
    private AzureMLWebServicesManagementClientImpl client;

    /**
     * Initializes an instance of WebServicesInner.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public WebServicesInner(Retrofit retrofit, AzureMLWebServicesManagementClientImpl client) {
        this.service = retrofit.create(WebServicesService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for WebServices to be
     * used by Retrofit to perform actually REST calls.
     */
    interface WebServicesService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.machinelearning.WebServices createOrUpdate" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearning/webServices/{webServiceName}")
        Observable<Response<ResponseBody>> createOrUpdate(@Path("resourceGroupName") String resourceGroupName, @Path("webServiceName") String webServiceName, @Path("subscriptionId") String subscriptionId, @Body WebServiceInner createOrUpdatePayload, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.machinelearning.WebServices beginCreateOrUpdate" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearning/webServices/{webServiceName}")
        Observable<Response<ResponseBody>> beginCreateOrUpdate(@Path("resourceGroupName") String resourceGroupName, @Path("webServiceName") String webServiceName, @Path("subscriptionId") String subscriptionId, @Body WebServiceInner createOrUpdatePayload, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.machinelearning.WebServices getByResourceGroup" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearning/webServices/{webServiceName}")
        Observable<Response<ResponseBody>> getByResourceGroup(@Path("resourceGroupName") String resourceGroupName, @Path("webServiceName") String webServiceName, @Path("subscriptionId") String subscriptionId, @Query("region") String region, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.machinelearning.WebServices patch" })
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearning/webServices/{webServiceName}")
        Observable<Response<ResponseBody>> patch(@Path("resourceGroupName") String resourceGroupName, @Path("webServiceName") String webServiceName, @Path("subscriptionId") String subscriptionId, @Body WebServiceInner patchPayload, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.machinelearning.WebServices beginPatch" })
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearning/webServices/{webServiceName}")
        Observable<Response<ResponseBody>> beginPatch(@Path("resourceGroupName") String resourceGroupName, @Path("webServiceName") String webServiceName, @Path("subscriptionId") String subscriptionId, @Body WebServiceInner patchPayload, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.machinelearning.WebServices delete" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearning/webServices/{webServiceName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> delete(@Path("resourceGroupName") String resourceGroupName, @Path("webServiceName") String webServiceName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.machinelearning.WebServices beginDelete" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearning/webServices/{webServiceName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> beginDelete(@Path("resourceGroupName") String resourceGroupName, @Path("webServiceName") String webServiceName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.machinelearning.WebServices createRegionalProperties" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearning/webServices/{webServiceName}/CreateRegionalBlob")
        Observable<Response<ResponseBody>> createRegionalProperties(@Path("resourceGroupName") String resourceGroupName, @Path("webServiceName") String webServiceName, @Path("subscriptionId") String subscriptionId, @Query("region") String region, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.machinelearning.WebServices beginCreateRegionalProperties" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearning/webServices/{webServiceName}/CreateRegionalBlob")
        Observable<Response<ResponseBody>> beginCreateRegionalProperties(@Path("resourceGroupName") String resourceGroupName, @Path("webServiceName") String webServiceName, @Path("subscriptionId") String subscriptionId, @Query("region") String region, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.machinelearning.WebServices listKeys" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearning/webServices/{webServiceName}/listKeys")
        Observable<Response<ResponseBody>> listKeys(@Path("resourceGroupName") String resourceGroupName, @Path("webServiceName") String webServiceName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.machinelearning.WebServices listByResourceGroup" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearning/webServices")
        Observable<Response<ResponseBody>> listByResourceGroup(@Path("resourceGroupName") String resourceGroupName, @Path("subscriptionId") String subscriptionId, @Query("$skiptoken") String skiptoken, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.machinelearning.WebServices listBySubscriptionId" })
        @GET("subscriptions/{subscriptionId}/providers/Microsoft.MachineLearning/webServices")
        Observable<Response<ResponseBody>> listBySubscriptionId(@Path("subscriptionId") String subscriptionId, @Query("$skiptoken") String skiptoken, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.machinelearning.WebServices listByResourceGroupNext" })
        @GET
        Observable<Response<ResponseBody>> listByResourceGroupNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.machinelearning.WebServices listBySubscriptionIdNext" })
        @GET
        Observable<Response<ResponseBody>> listBySubscriptionIdNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

    }

    /**
     * Create or update a web service. This call will overwrite an existing web service. Note that there is no warning or confirmation. This is a nonrecoverable operation. If your intent is to create a new web service, call the Get operation first to verify that it does not exist.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @param webServiceName The name of the web service.
     * @param createOrUpdatePayload The payload that is used to create or update the web service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the WebServiceInner object if successful.
     */
    public WebServiceInner createOrUpdate(String resourceGroupName, String webServiceName, WebServiceInner createOrUpdatePayload) {
        return createOrUpdateWithServiceResponseAsync(resourceGroupName, webServiceName, createOrUpdatePayload).toBlocking().last().body();
    }

    /**
     * Create or update a web service. This call will overwrite an existing web service. Note that there is no warning or confirmation. This is a nonrecoverable operation. If your intent is to create a new web service, call the Get operation first to verify that it does not exist.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @param webServiceName The name of the web service.
     * @param createOrUpdatePayload The payload that is used to create or update the web service.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<WebServiceInner> createOrUpdateAsync(String resourceGroupName, String webServiceName, WebServiceInner createOrUpdatePayload, final ServiceCallback<WebServiceInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateWithServiceResponseAsync(resourceGroupName, webServiceName, createOrUpdatePayload), serviceCallback);
    }

    /**
     * Create or update a web service. This call will overwrite an existing web service. Note that there is no warning or confirmation. This is a nonrecoverable operation. If your intent is to create a new web service, call the Get operation first to verify that it does not exist.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @param webServiceName The name of the web service.
     * @param createOrUpdatePayload The payload that is used to create or update the web service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<WebServiceInner> createOrUpdateAsync(String resourceGroupName, String webServiceName, WebServiceInner createOrUpdatePayload) {
        return createOrUpdateWithServiceResponseAsync(resourceGroupName, webServiceName, createOrUpdatePayload).map(new Func1<ServiceResponse<WebServiceInner>, WebServiceInner>() {
            @Override
            public WebServiceInner call(ServiceResponse<WebServiceInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Create or update a web service. This call will overwrite an existing web service. Note that there is no warning or confirmation. This is a nonrecoverable operation. If your intent is to create a new web service, call the Get operation first to verify that it does not exist.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @param webServiceName The name of the web service.
     * @param createOrUpdatePayload The payload that is used to create or update the web service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<WebServiceInner>> createOrUpdateWithServiceResponseAsync(String resourceGroupName, String webServiceName, WebServiceInner createOrUpdatePayload) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (webServiceName == null) {
            throw new IllegalArgumentException("Parameter webServiceName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (createOrUpdatePayload == null) {
            throw new IllegalArgumentException("Parameter createOrUpdatePayload is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(createOrUpdatePayload);
        Observable<Response<ResponseBody>> observable = service.createOrUpdate(resourceGroupName, webServiceName, this.client.subscriptionId(), createOrUpdatePayload, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultAsync(observable, new TypeToken<WebServiceInner>() { }.getType());
    }

    /**
     * Create or update a web service. This call will overwrite an existing web service. Note that there is no warning or confirmation. This is a nonrecoverable operation. If your intent is to create a new web service, call the Get operation first to verify that it does not exist.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @param webServiceName The name of the web service.
     * @param createOrUpdatePayload The payload that is used to create or update the web service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the WebServiceInner object if successful.
     */
    public WebServiceInner beginCreateOrUpdate(String resourceGroupName, String webServiceName, WebServiceInner createOrUpdatePayload) {
        return beginCreateOrUpdateWithServiceResponseAsync(resourceGroupName, webServiceName, createOrUpdatePayload).toBlocking().single().body();
    }

    /**
     * Create or update a web service. This call will overwrite an existing web service. Note that there is no warning or confirmation. This is a nonrecoverable operation. If your intent is to create a new web service, call the Get operation first to verify that it does not exist.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @param webServiceName The name of the web service.
     * @param createOrUpdatePayload The payload that is used to create or update the web service.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<WebServiceInner> beginCreateOrUpdateAsync(String resourceGroupName, String webServiceName, WebServiceInner createOrUpdatePayload, final ServiceCallback<WebServiceInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginCreateOrUpdateWithServiceResponseAsync(resourceGroupName, webServiceName, createOrUpdatePayload), serviceCallback);
    }

    /**
     * Create or update a web service. This call will overwrite an existing web service. Note that there is no warning or confirmation. This is a nonrecoverable operation. If your intent is to create a new web service, call the Get operation first to verify that it does not exist.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @param webServiceName The name of the web service.
     * @param createOrUpdatePayload The payload that is used to create or update the web service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the WebServiceInner object
     */
    public Observable<WebServiceInner> beginCreateOrUpdateAsync(String resourceGroupName, String webServiceName, WebServiceInner createOrUpdatePayload) {
        return beginCreateOrUpdateWithServiceResponseAsync(resourceGroupName, webServiceName, createOrUpdatePayload).map(new Func1<ServiceResponse<WebServiceInner>, WebServiceInner>() {
            @Override
            public WebServiceInner call(ServiceResponse<WebServiceInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Create or update a web service. This call will overwrite an existing web service. Note that there is no warning or confirmation. This is a nonrecoverable operation. If your intent is to create a new web service, call the Get operation first to verify that it does not exist.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @param webServiceName The name of the web service.
     * @param createOrUpdatePayload The payload that is used to create or update the web service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the WebServiceInner object
     */
    public Observable<ServiceResponse<WebServiceInner>> beginCreateOrUpdateWithServiceResponseAsync(String resourceGroupName, String webServiceName, WebServiceInner createOrUpdatePayload) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (webServiceName == null) {
            throw new IllegalArgumentException("Parameter webServiceName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (createOrUpdatePayload == null) {
            throw new IllegalArgumentException("Parameter createOrUpdatePayload is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(createOrUpdatePayload);
        return service.beginCreateOrUpdate(resourceGroupName, webServiceName, this.client.subscriptionId(), createOrUpdatePayload, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<WebServiceInner>>>() {
                @Override
                public Observable<ServiceResponse<WebServiceInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<WebServiceInner> clientResponse = beginCreateOrUpdateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<WebServiceInner> beginCreateOrUpdateDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<WebServiceInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<WebServiceInner>() { }.getType())
                .register(201, new TypeToken<WebServiceInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the Web Service Definition as specified by a subscription, resource group, and name. Note that the storage credentials and web service keys are not returned by this call. To get the web service access keys, call List Keys.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @param webServiceName The name of the web service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the WebServiceInner object if successful.
     */
    public WebServiceInner getByResourceGroup(String resourceGroupName, String webServiceName) {
        return getByResourceGroupWithServiceResponseAsync(resourceGroupName, webServiceName).toBlocking().single().body();
    }

    /**
     * Gets the Web Service Definition as specified by a subscription, resource group, and name. Note that the storage credentials and web service keys are not returned by this call. To get the web service access keys, call List Keys.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @param webServiceName The name of the web service.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<WebServiceInner> getByResourceGroupAsync(String resourceGroupName, String webServiceName, final ServiceCallback<WebServiceInner> serviceCallback) {
        return ServiceFuture.fromResponse(getByResourceGroupWithServiceResponseAsync(resourceGroupName, webServiceName), serviceCallback);
    }

    /**
     * Gets the Web Service Definition as specified by a subscription, resource group, and name. Note that the storage credentials and web service keys are not returned by this call. To get the web service access keys, call List Keys.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @param webServiceName The name of the web service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the WebServiceInner object
     */
    public Observable<WebServiceInner> getByResourceGroupAsync(String resourceGroupName, String webServiceName) {
        return getByResourceGroupWithServiceResponseAsync(resourceGroupName, webServiceName).map(new Func1<ServiceResponse<WebServiceInner>, WebServiceInner>() {
            @Override
            public WebServiceInner call(ServiceResponse<WebServiceInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the Web Service Definition as specified by a subscription, resource group, and name. Note that the storage credentials and web service keys are not returned by this call. To get the web service access keys, call List Keys.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @param webServiceName The name of the web service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the WebServiceInner object
     */
    public Observable<ServiceResponse<WebServiceInner>> getByResourceGroupWithServiceResponseAsync(String resourceGroupName, String webServiceName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (webServiceName == null) {
            throw new IllegalArgumentException("Parameter webServiceName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String region = null;
        return service.getByResourceGroup(resourceGroupName, webServiceName, this.client.subscriptionId(), region, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<WebServiceInner>>>() {
                @Override
                public Observable<ServiceResponse<WebServiceInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<WebServiceInner> clientResponse = getByResourceGroupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the Web Service Definition as specified by a subscription, resource group, and name. Note that the storage credentials and web service keys are not returned by this call. To get the web service access keys, call List Keys.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @param webServiceName The name of the web service.
     * @param region The region for which encrypted credential parameters are valid.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the WebServiceInner object if successful.
     */
    public WebServiceInner getByResourceGroup(String resourceGroupName, String webServiceName, String region) {
        return getByResourceGroupWithServiceResponseAsync(resourceGroupName, webServiceName, region).toBlocking().single().body();
    }

    /**
     * Gets the Web Service Definition as specified by a subscription, resource group, and name. Note that the storage credentials and web service keys are not returned by this call. To get the web service access keys, call List Keys.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @param webServiceName The name of the web service.
     * @param region The region for which encrypted credential parameters are valid.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<WebServiceInner> getByResourceGroupAsync(String resourceGroupName, String webServiceName, String region, final ServiceCallback<WebServiceInner> serviceCallback) {
        return ServiceFuture.fromResponse(getByResourceGroupWithServiceResponseAsync(resourceGroupName, webServiceName, region), serviceCallback);
    }

    /**
     * Gets the Web Service Definition as specified by a subscription, resource group, and name. Note that the storage credentials and web service keys are not returned by this call. To get the web service access keys, call List Keys.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @param webServiceName The name of the web service.
     * @param region The region for which encrypted credential parameters are valid.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the WebServiceInner object
     */
    public Observable<WebServiceInner> getByResourceGroupAsync(String resourceGroupName, String webServiceName, String region) {
        return getByResourceGroupWithServiceResponseAsync(resourceGroupName, webServiceName, region).map(new Func1<ServiceResponse<WebServiceInner>, WebServiceInner>() {
            @Override
            public WebServiceInner call(ServiceResponse<WebServiceInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the Web Service Definition as specified by a subscription, resource group, and name. Note that the storage credentials and web service keys are not returned by this call. To get the web service access keys, call List Keys.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @param webServiceName The name of the web service.
     * @param region The region for which encrypted credential parameters are valid.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the WebServiceInner object
     */
    public Observable<ServiceResponse<WebServiceInner>> getByResourceGroupWithServiceResponseAsync(String resourceGroupName, String webServiceName, String region) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (webServiceName == null) {
            throw new IllegalArgumentException("Parameter webServiceName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getByResourceGroup(resourceGroupName, webServiceName, this.client.subscriptionId(), region, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<WebServiceInner>>>() {
                @Override
                public Observable<ServiceResponse<WebServiceInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<WebServiceInner> clientResponse = getByResourceGroupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<WebServiceInner> getByResourceGroupDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<WebServiceInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<WebServiceInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Modifies an existing web service resource. The PATCH API call is an asynchronous operation. To determine whether it has completed successfully, you must perform a Get operation.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @param webServiceName The name of the web service.
     * @param patchPayload The payload to use to patch the web service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the WebServiceInner object if successful.
     */
    public WebServiceInner patch(String resourceGroupName, String webServiceName, WebServiceInner patchPayload) {
        return patchWithServiceResponseAsync(resourceGroupName, webServiceName, patchPayload).toBlocking().last().body();
    }

    /**
     * Modifies an existing web service resource. The PATCH API call is an asynchronous operation. To determine whether it has completed successfully, you must perform a Get operation.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @param webServiceName The name of the web service.
     * @param patchPayload The payload to use to patch the web service.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<WebServiceInner> patchAsync(String resourceGroupName, String webServiceName, WebServiceInner patchPayload, final ServiceCallback<WebServiceInner> serviceCallback) {
        return ServiceFuture.fromResponse(patchWithServiceResponseAsync(resourceGroupName, webServiceName, patchPayload), serviceCallback);
    }

    /**
     * Modifies an existing web service resource. The PATCH API call is an asynchronous operation. To determine whether it has completed successfully, you must perform a Get operation.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @param webServiceName The name of the web service.
     * @param patchPayload The payload to use to patch the web service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<WebServiceInner> patchAsync(String resourceGroupName, String webServiceName, WebServiceInner patchPayload) {
        return patchWithServiceResponseAsync(resourceGroupName, webServiceName, patchPayload).map(new Func1<ServiceResponse<WebServiceInner>, WebServiceInner>() {
            @Override
            public WebServiceInner call(ServiceResponse<WebServiceInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Modifies an existing web service resource. The PATCH API call is an asynchronous operation. To determine whether it has completed successfully, you must perform a Get operation.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @param webServiceName The name of the web service.
     * @param patchPayload The payload to use to patch the web service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<WebServiceInner>> patchWithServiceResponseAsync(String resourceGroupName, String webServiceName, WebServiceInner patchPayload) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (webServiceName == null) {
            throw new IllegalArgumentException("Parameter webServiceName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (patchPayload == null) {
            throw new IllegalArgumentException("Parameter patchPayload is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(patchPayload);
        Observable<Response<ResponseBody>> observable = service.patch(resourceGroupName, webServiceName, this.client.subscriptionId(), patchPayload, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultAsync(observable, new TypeToken<WebServiceInner>() { }.getType());
    }

    /**
     * Modifies an existing web service resource. The PATCH API call is an asynchronous operation. To determine whether it has completed successfully, you must perform a Get operation.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @param webServiceName The name of the web service.
     * @param patchPayload The payload to use to patch the web service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the WebServiceInner object if successful.
     */
    public WebServiceInner beginPatch(String resourceGroupName, String webServiceName, WebServiceInner patchPayload) {
        return beginPatchWithServiceResponseAsync(resourceGroupName, webServiceName, patchPayload).toBlocking().single().body();
    }

    /**
     * Modifies an existing web service resource. The PATCH API call is an asynchronous operation. To determine whether it has completed successfully, you must perform a Get operation.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @param webServiceName The name of the web service.
     * @param patchPayload The payload to use to patch the web service.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<WebServiceInner> beginPatchAsync(String resourceGroupName, String webServiceName, WebServiceInner patchPayload, final ServiceCallback<WebServiceInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginPatchWithServiceResponseAsync(resourceGroupName, webServiceName, patchPayload), serviceCallback);
    }

    /**
     * Modifies an existing web service resource. The PATCH API call is an asynchronous operation. To determine whether it has completed successfully, you must perform a Get operation.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @param webServiceName The name of the web service.
     * @param patchPayload The payload to use to patch the web service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the WebServiceInner object
     */
    public Observable<WebServiceInner> beginPatchAsync(String resourceGroupName, String webServiceName, WebServiceInner patchPayload) {
        return beginPatchWithServiceResponseAsync(resourceGroupName, webServiceName, patchPayload).map(new Func1<ServiceResponse<WebServiceInner>, WebServiceInner>() {
            @Override
            public WebServiceInner call(ServiceResponse<WebServiceInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Modifies an existing web service resource. The PATCH API call is an asynchronous operation. To determine whether it has completed successfully, you must perform a Get operation.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @param webServiceName The name of the web service.
     * @param patchPayload The payload to use to patch the web service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the WebServiceInner object
     */
    public Observable<ServiceResponse<WebServiceInner>> beginPatchWithServiceResponseAsync(String resourceGroupName, String webServiceName, WebServiceInner patchPayload) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (webServiceName == null) {
            throw new IllegalArgumentException("Parameter webServiceName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (patchPayload == null) {
            throw new IllegalArgumentException("Parameter patchPayload is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(patchPayload);
        return service.beginPatch(resourceGroupName, webServiceName, this.client.subscriptionId(), patchPayload, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<WebServiceInner>>>() {
                @Override
                public Observable<ServiceResponse<WebServiceInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<WebServiceInner> clientResponse = beginPatchDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<WebServiceInner> beginPatchDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<WebServiceInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<WebServiceInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes the specified web service.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @param webServiceName The name of the web service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void delete(String resourceGroupName, String webServiceName) {
        deleteWithServiceResponseAsync(resourceGroupName, webServiceName).toBlocking().last().body();
    }

    /**
     * Deletes the specified web service.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @param webServiceName The name of the web service.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteAsync(String resourceGroupName, String webServiceName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteWithServiceResponseAsync(resourceGroupName, webServiceName), serviceCallback);
    }

    /**
     * Deletes the specified web service.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @param webServiceName The name of the web service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<Void> deleteAsync(String resourceGroupName, String webServiceName) {
        return deleteWithServiceResponseAsync(resourceGroupName, webServiceName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes the specified web service.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @param webServiceName The name of the web service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<Void>> deleteWithServiceResponseAsync(String resourceGroupName, String webServiceName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (webServiceName == null) {
            throw new IllegalArgumentException("Parameter webServiceName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Observable<Response<ResponseBody>> observable = service.delete(resourceGroupName, webServiceName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<Void>() { }.getType());
    }

    /**
     * Deletes the specified web service.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @param webServiceName The name of the web service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void beginDelete(String resourceGroupName, String webServiceName) {
        beginDeleteWithServiceResponseAsync(resourceGroupName, webServiceName).toBlocking().single().body();
    }

    /**
     * Deletes the specified web service.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @param webServiceName The name of the web service.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> beginDeleteAsync(String resourceGroupName, String webServiceName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(beginDeleteWithServiceResponseAsync(resourceGroupName, webServiceName), serviceCallback);
    }

    /**
     * Deletes the specified web service.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @param webServiceName The name of the web service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> beginDeleteAsync(String resourceGroupName, String webServiceName) {
        return beginDeleteWithServiceResponseAsync(resourceGroupName, webServiceName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes the specified web service.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @param webServiceName The name of the web service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> beginDeleteWithServiceResponseAsync(String resourceGroupName, String webServiceName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (webServiceName == null) {
            throw new IllegalArgumentException("Parameter webServiceName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.beginDelete(resourceGroupName, webServiceName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = beginDeleteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> beginDeleteDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates an encrypted credentials parameter blob for the specified region. To get the web service from a region other than the region in which it has been created, you must first call Create Regional Web Services Properties to create a copy of the encrypted credential parameter blob in that region. You only need to do this before the first time that you get the web service in the new region.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @param webServiceName The name of the web service.
     * @param region The region for which encrypted credential parameters are created.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the AsyncOperationStatusInner object if successful.
     */
    public AsyncOperationStatusInner createRegionalProperties(String resourceGroupName, String webServiceName, String region) {
        return createRegionalPropertiesWithServiceResponseAsync(resourceGroupName, webServiceName, region).toBlocking().last().body();
    }

    /**
     * Creates an encrypted credentials parameter blob for the specified region. To get the web service from a region other than the region in which it has been created, you must first call Create Regional Web Services Properties to create a copy of the encrypted credential parameter blob in that region. You only need to do this before the first time that you get the web service in the new region.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @param webServiceName The name of the web service.
     * @param region The region for which encrypted credential parameters are created.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<AsyncOperationStatusInner> createRegionalPropertiesAsync(String resourceGroupName, String webServiceName, String region, final ServiceCallback<AsyncOperationStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(createRegionalPropertiesWithServiceResponseAsync(resourceGroupName, webServiceName, region), serviceCallback);
    }

    /**
     * Creates an encrypted credentials parameter blob for the specified region. To get the web service from a region other than the region in which it has been created, you must first call Create Regional Web Services Properties to create a copy of the encrypted credential parameter blob in that region. You only need to do this before the first time that you get the web service in the new region.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @param webServiceName The name of the web service.
     * @param region The region for which encrypted credential parameters are created.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<AsyncOperationStatusInner> createRegionalPropertiesAsync(String resourceGroupName, String webServiceName, String region) {
        return createRegionalPropertiesWithServiceResponseAsync(resourceGroupName, webServiceName, region).map(new Func1<ServiceResponse<AsyncOperationStatusInner>, AsyncOperationStatusInner>() {
            @Override
            public AsyncOperationStatusInner call(ServiceResponse<AsyncOperationStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates an encrypted credentials parameter blob for the specified region. To get the web service from a region other than the region in which it has been created, you must first call Create Regional Web Services Properties to create a copy of the encrypted credential parameter blob in that region. You only need to do this before the first time that you get the web service in the new region.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @param webServiceName The name of the web service.
     * @param region The region for which encrypted credential parameters are created.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<AsyncOperationStatusInner>> createRegionalPropertiesWithServiceResponseAsync(String resourceGroupName, String webServiceName, String region) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (webServiceName == null) {
            throw new IllegalArgumentException("Parameter webServiceName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (region == null) {
            throw new IllegalArgumentException("Parameter region is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Observable<Response<ResponseBody>> observable = service.createRegionalProperties(resourceGroupName, webServiceName, this.client.subscriptionId(), region, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<AsyncOperationStatusInner>() { }.getType());
    }

    /**
     * Creates an encrypted credentials parameter blob for the specified region. To get the web service from a region other than the region in which it has been created, you must first call Create Regional Web Services Properties to create a copy of the encrypted credential parameter blob in that region. You only need to do this before the first time that you get the web service in the new region.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @param webServiceName The name of the web service.
     * @param region The region for which encrypted credential parameters are created.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the AsyncOperationStatusInner object if successful.
     */
    public AsyncOperationStatusInner beginCreateRegionalProperties(String resourceGroupName, String webServiceName, String region) {
        return beginCreateRegionalPropertiesWithServiceResponseAsync(resourceGroupName, webServiceName, region).toBlocking().single().body();
    }

    /**
     * Creates an encrypted credentials parameter blob for the specified region. To get the web service from a region other than the region in which it has been created, you must first call Create Regional Web Services Properties to create a copy of the encrypted credential parameter blob in that region. You only need to do this before the first time that you get the web service in the new region.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @param webServiceName The name of the web service.
     * @param region The region for which encrypted credential parameters are created.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<AsyncOperationStatusInner> beginCreateRegionalPropertiesAsync(String resourceGroupName, String webServiceName, String region, final ServiceCallback<AsyncOperationStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginCreateRegionalPropertiesWithServiceResponseAsync(resourceGroupName, webServiceName, region), serviceCallback);
    }

    /**
     * Creates an encrypted credentials parameter blob for the specified region. To get the web service from a region other than the region in which it has been created, you must first call Create Regional Web Services Properties to create a copy of the encrypted credential parameter blob in that region. You only need to do this before the first time that you get the web service in the new region.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @param webServiceName The name of the web service.
     * @param region The region for which encrypted credential parameters are created.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the AsyncOperationStatusInner object
     */
    public Observable<AsyncOperationStatusInner> beginCreateRegionalPropertiesAsync(String resourceGroupName, String webServiceName, String region) {
        return beginCreateRegionalPropertiesWithServiceResponseAsync(resourceGroupName, webServiceName, region).map(new Func1<ServiceResponse<AsyncOperationStatusInner>, AsyncOperationStatusInner>() {
            @Override
            public AsyncOperationStatusInner call(ServiceResponse<AsyncOperationStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates an encrypted credentials parameter blob for the specified region. To get the web service from a region other than the region in which it has been created, you must first call Create Regional Web Services Properties to create a copy of the encrypted credential parameter blob in that region. You only need to do this before the first time that you get the web service in the new region.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @param webServiceName The name of the web service.
     * @param region The region for which encrypted credential parameters are created.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the AsyncOperationStatusInner object
     */
    public Observable<ServiceResponse<AsyncOperationStatusInner>> beginCreateRegionalPropertiesWithServiceResponseAsync(String resourceGroupName, String webServiceName, String region) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (webServiceName == null) {
            throw new IllegalArgumentException("Parameter webServiceName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (region == null) {
            throw new IllegalArgumentException("Parameter region is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.beginCreateRegionalProperties(resourceGroupName, webServiceName, this.client.subscriptionId(), region, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<AsyncOperationStatusInner>>>() {
                @Override
                public Observable<ServiceResponse<AsyncOperationStatusInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<AsyncOperationStatusInner> clientResponse = beginCreateRegionalPropertiesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<AsyncOperationStatusInner> beginCreateRegionalPropertiesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<AsyncOperationStatusInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .register(200, new TypeToken<AsyncOperationStatusInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the access keys for the specified web service.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @param webServiceName The name of the web service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the WebServiceKeysInner object if successful.
     */
    public WebServiceKeysInner listKeys(String resourceGroupName, String webServiceName) {
        return listKeysWithServiceResponseAsync(resourceGroupName, webServiceName).toBlocking().single().body();
    }

    /**
     * Gets the access keys for the specified web service.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @param webServiceName The name of the web service.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<WebServiceKeysInner> listKeysAsync(String resourceGroupName, String webServiceName, final ServiceCallback<WebServiceKeysInner> serviceCallback) {
        return ServiceFuture.fromResponse(listKeysWithServiceResponseAsync(resourceGroupName, webServiceName), serviceCallback);
    }

    /**
     * Gets the access keys for the specified web service.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @param webServiceName The name of the web service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the WebServiceKeysInner object
     */
    public Observable<WebServiceKeysInner> listKeysAsync(String resourceGroupName, String webServiceName) {
        return listKeysWithServiceResponseAsync(resourceGroupName, webServiceName).map(new Func1<ServiceResponse<WebServiceKeysInner>, WebServiceKeysInner>() {
            @Override
            public WebServiceKeysInner call(ServiceResponse<WebServiceKeysInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the access keys for the specified web service.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @param webServiceName The name of the web service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the WebServiceKeysInner object
     */
    public Observable<ServiceResponse<WebServiceKeysInner>> listKeysWithServiceResponseAsync(String resourceGroupName, String webServiceName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (webServiceName == null) {
            throw new IllegalArgumentException("Parameter webServiceName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listKeys(resourceGroupName, webServiceName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<WebServiceKeysInner>>>() {
                @Override
                public Observable<ServiceResponse<WebServiceKeysInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<WebServiceKeysInner> clientResponse = listKeysDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<WebServiceKeysInner> listKeysDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<WebServiceKeysInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<WebServiceKeysInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the web services in the specified resource group.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;WebServiceInner&gt; object if successful.
     */
    public PagedList<WebServiceInner> listByResourceGroup(final String resourceGroupName) {
        ServiceResponse<Page<WebServiceInner>> response = listByResourceGroupSinglePageAsync(resourceGroupName).toBlocking().single();
        return new PagedList<WebServiceInner>(response.body()) {
            @Override
            public Page<WebServiceInner> nextPage(String nextPageLink) {
                return listByResourceGroupNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the web services in the specified resource group.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<WebServiceInner>> listByResourceGroupAsync(final String resourceGroupName, final ListOperationCallback<WebServiceInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByResourceGroupSinglePageAsync(resourceGroupName),
            new Func1<String, Observable<ServiceResponse<Page<WebServiceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<WebServiceInner>>> call(String nextPageLink) {
                    return listByResourceGroupNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the web services in the specified resource group.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;WebServiceInner&gt; object
     */
    public Observable<Page<WebServiceInner>> listByResourceGroupAsync(final String resourceGroupName) {
        return listByResourceGroupWithServiceResponseAsync(resourceGroupName)
            .map(new Func1<ServiceResponse<Page<WebServiceInner>>, Page<WebServiceInner>>() {
                @Override
                public Page<WebServiceInner> call(ServiceResponse<Page<WebServiceInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the web services in the specified resource group.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;WebServiceInner&gt; object
     */
    public Observable<ServiceResponse<Page<WebServiceInner>>> listByResourceGroupWithServiceResponseAsync(final String resourceGroupName) {
        return listByResourceGroupSinglePageAsync(resourceGroupName)
            .concatMap(new Func1<ServiceResponse<Page<WebServiceInner>>, Observable<ServiceResponse<Page<WebServiceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<WebServiceInner>>> call(ServiceResponse<Page<WebServiceInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByResourceGroupNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the web services in the specified resource group.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;WebServiceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<WebServiceInner>>> listByResourceGroupSinglePageAsync(final String resourceGroupName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String skiptoken = null;
        return service.listByResourceGroup(resourceGroupName, this.client.subscriptionId(), skiptoken, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<WebServiceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<WebServiceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<WebServiceInner>> result = listByResourceGroupDelegate(response);
                        return Observable.just(new ServiceResponse<Page<WebServiceInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the web services in the specified resource group.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @param skiptoken Continuation token for pagination.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;WebServiceInner&gt; object if successful.
     */
    public PagedList<WebServiceInner> listByResourceGroup(final String resourceGroupName, final String skiptoken) {
        ServiceResponse<Page<WebServiceInner>> response = listByResourceGroupSinglePageAsync(resourceGroupName, skiptoken).toBlocking().single();
        return new PagedList<WebServiceInner>(response.body()) {
            @Override
            public Page<WebServiceInner> nextPage(String nextPageLink) {
                return listByResourceGroupNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the web services in the specified resource group.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @param skiptoken Continuation token for pagination.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<WebServiceInner>> listByResourceGroupAsync(final String resourceGroupName, final String skiptoken, final ListOperationCallback<WebServiceInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByResourceGroupSinglePageAsync(resourceGroupName, skiptoken),
            new Func1<String, Observable<ServiceResponse<Page<WebServiceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<WebServiceInner>>> call(String nextPageLink) {
                    return listByResourceGroupNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the web services in the specified resource group.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @param skiptoken Continuation token for pagination.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;WebServiceInner&gt; object
     */
    public Observable<Page<WebServiceInner>> listByResourceGroupAsync(final String resourceGroupName, final String skiptoken) {
        return listByResourceGroupWithServiceResponseAsync(resourceGroupName, skiptoken)
            .map(new Func1<ServiceResponse<Page<WebServiceInner>>, Page<WebServiceInner>>() {
                @Override
                public Page<WebServiceInner> call(ServiceResponse<Page<WebServiceInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the web services in the specified resource group.
     *
     * @param resourceGroupName Name of the resource group in which the web service is located.
     * @param skiptoken Continuation token for pagination.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;WebServiceInner&gt; object
     */
    public Observable<ServiceResponse<Page<WebServiceInner>>> listByResourceGroupWithServiceResponseAsync(final String resourceGroupName, final String skiptoken) {
        return listByResourceGroupSinglePageAsync(resourceGroupName, skiptoken)
            .concatMap(new Func1<ServiceResponse<Page<WebServiceInner>>, Observable<ServiceResponse<Page<WebServiceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<WebServiceInner>>> call(ServiceResponse<Page<WebServiceInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByResourceGroupNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the web services in the specified resource group.
     *
    ServiceResponse<PageImpl<WebServiceInner>> * @param resourceGroupName Name of the resource group in which the web service is located.
    ServiceResponse<PageImpl<WebServiceInner>> * @param skiptoken Continuation token for pagination.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;WebServiceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<WebServiceInner>>> listByResourceGroupSinglePageAsync(final String resourceGroupName, final String skiptoken) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listByResourceGroup(resourceGroupName, this.client.subscriptionId(), skiptoken, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<WebServiceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<WebServiceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<WebServiceInner>> result = listByResourceGroupDelegate(response);
                        return Observable.just(new ServiceResponse<Page<WebServiceInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<WebServiceInner>> listByResourceGroupDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<WebServiceInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<WebServiceInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the web services in the specified subscription.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;WebServiceInner&gt; object if successful.
     */
    public PagedList<WebServiceInner> listBySubscriptionId() {
        ServiceResponse<Page<WebServiceInner>> response = listBySubscriptionIdSinglePageAsync().toBlocking().single();
        return new PagedList<WebServiceInner>(response.body()) {
            @Override
            public Page<WebServiceInner> nextPage(String nextPageLink) {
                return listBySubscriptionIdNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the web services in the specified subscription.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<WebServiceInner>> listBySubscriptionIdAsync(final ListOperationCallback<WebServiceInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listBySubscriptionIdSinglePageAsync(),
            new Func1<String, Observable<ServiceResponse<Page<WebServiceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<WebServiceInner>>> call(String nextPageLink) {
                    return listBySubscriptionIdNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the web services in the specified subscription.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;WebServiceInner&gt; object
     */
    public Observable<Page<WebServiceInner>> listBySubscriptionIdAsync() {
        return listBySubscriptionIdWithServiceResponseAsync()
            .map(new Func1<ServiceResponse<Page<WebServiceInner>>, Page<WebServiceInner>>() {
                @Override
                public Page<WebServiceInner> call(ServiceResponse<Page<WebServiceInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the web services in the specified subscription.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;WebServiceInner&gt; object
     */
    public Observable<ServiceResponse<Page<WebServiceInner>>> listBySubscriptionIdWithServiceResponseAsync() {
        return listBySubscriptionIdSinglePageAsync()
            .concatMap(new Func1<ServiceResponse<Page<WebServiceInner>>, Observable<ServiceResponse<Page<WebServiceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<WebServiceInner>>> call(ServiceResponse<Page<WebServiceInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listBySubscriptionIdNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the web services in the specified subscription.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;WebServiceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<WebServiceInner>>> listBySubscriptionIdSinglePageAsync() {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String skiptoken = null;
        return service.listBySubscriptionId(this.client.subscriptionId(), skiptoken, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<WebServiceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<WebServiceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<WebServiceInner>> result = listBySubscriptionIdDelegate(response);
                        return Observable.just(new ServiceResponse<Page<WebServiceInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the web services in the specified subscription.
     *
     * @param skiptoken Continuation token for pagination.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;WebServiceInner&gt; object if successful.
     */
    public PagedList<WebServiceInner> listBySubscriptionId(final String skiptoken) {
        ServiceResponse<Page<WebServiceInner>> response = listBySubscriptionIdSinglePageAsync(skiptoken).toBlocking().single();
        return new PagedList<WebServiceInner>(response.body()) {
            @Override
            public Page<WebServiceInner> nextPage(String nextPageLink) {
                return listBySubscriptionIdNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the web services in the specified subscription.
     *
     * @param skiptoken Continuation token for pagination.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<WebServiceInner>> listBySubscriptionIdAsync(final String skiptoken, final ListOperationCallback<WebServiceInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listBySubscriptionIdSinglePageAsync(skiptoken),
            new Func1<String, Observable<ServiceResponse<Page<WebServiceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<WebServiceInner>>> call(String nextPageLink) {
                    return listBySubscriptionIdNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the web services in the specified subscription.
     *
     * @param skiptoken Continuation token for pagination.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;WebServiceInner&gt; object
     */
    public Observable<Page<WebServiceInner>> listBySubscriptionIdAsync(final String skiptoken) {
        return listBySubscriptionIdWithServiceResponseAsync(skiptoken)
            .map(new Func1<ServiceResponse<Page<WebServiceInner>>, Page<WebServiceInner>>() {
                @Override
                public Page<WebServiceInner> call(ServiceResponse<Page<WebServiceInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the web services in the specified subscription.
     *
     * @param skiptoken Continuation token for pagination.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;WebServiceInner&gt; object
     */
    public Observable<ServiceResponse<Page<WebServiceInner>>> listBySubscriptionIdWithServiceResponseAsync(final String skiptoken) {
        return listBySubscriptionIdSinglePageAsync(skiptoken)
            .concatMap(new Func1<ServiceResponse<Page<WebServiceInner>>, Observable<ServiceResponse<Page<WebServiceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<WebServiceInner>>> call(ServiceResponse<Page<WebServiceInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listBySubscriptionIdNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the web services in the specified subscription.
     *
    ServiceResponse<PageImpl<WebServiceInner>> * @param skiptoken Continuation token for pagination.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;WebServiceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<WebServiceInner>>> listBySubscriptionIdSinglePageAsync(final String skiptoken) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listBySubscriptionId(this.client.subscriptionId(), skiptoken, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<WebServiceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<WebServiceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<WebServiceInner>> result = listBySubscriptionIdDelegate(response);
                        return Observable.just(new ServiceResponse<Page<WebServiceInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<WebServiceInner>> listBySubscriptionIdDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<WebServiceInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<WebServiceInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the web services in the specified resource group.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;WebServiceInner&gt; object if successful.
     */
    public PagedList<WebServiceInner> listByResourceGroupNext(final String nextPageLink) {
        ServiceResponse<Page<WebServiceInner>> response = listByResourceGroupNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<WebServiceInner>(response.body()) {
            @Override
            public Page<WebServiceInner> nextPage(String nextPageLink) {
                return listByResourceGroupNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the web services in the specified resource group.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<WebServiceInner>> listByResourceGroupNextAsync(final String nextPageLink, final ServiceFuture<List<WebServiceInner>> serviceFuture, final ListOperationCallback<WebServiceInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByResourceGroupNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<WebServiceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<WebServiceInner>>> call(String nextPageLink) {
                    return listByResourceGroupNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the web services in the specified resource group.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;WebServiceInner&gt; object
     */
    public Observable<Page<WebServiceInner>> listByResourceGroupNextAsync(final String nextPageLink) {
        return listByResourceGroupNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<WebServiceInner>>, Page<WebServiceInner>>() {
                @Override
                public Page<WebServiceInner> call(ServiceResponse<Page<WebServiceInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the web services in the specified resource group.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;WebServiceInner&gt; object
     */
    public Observable<ServiceResponse<Page<WebServiceInner>>> listByResourceGroupNextWithServiceResponseAsync(final String nextPageLink) {
        return listByResourceGroupNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<WebServiceInner>>, Observable<ServiceResponse<Page<WebServiceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<WebServiceInner>>> call(ServiceResponse<Page<WebServiceInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByResourceGroupNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the web services in the specified resource group.
     *
    ServiceResponse<PageImpl<WebServiceInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;WebServiceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<WebServiceInner>>> listByResourceGroupNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listByResourceGroupNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<WebServiceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<WebServiceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<WebServiceInner>> result = listByResourceGroupNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<WebServiceInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<WebServiceInner>> listByResourceGroupNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<WebServiceInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<WebServiceInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the web services in the specified subscription.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;WebServiceInner&gt; object if successful.
     */
    public PagedList<WebServiceInner> listBySubscriptionIdNext(final String nextPageLink) {
        ServiceResponse<Page<WebServiceInner>> response = listBySubscriptionIdNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<WebServiceInner>(response.body()) {
            @Override
            public Page<WebServiceInner> nextPage(String nextPageLink) {
                return listBySubscriptionIdNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Gets the web services in the specified subscription.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<WebServiceInner>> listBySubscriptionIdNextAsync(final String nextPageLink, final ServiceFuture<List<WebServiceInner>> serviceFuture, final ListOperationCallback<WebServiceInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listBySubscriptionIdNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<WebServiceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<WebServiceInner>>> call(String nextPageLink) {
                    return listBySubscriptionIdNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the web services in the specified subscription.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;WebServiceInner&gt; object
     */
    public Observable<Page<WebServiceInner>> listBySubscriptionIdNextAsync(final String nextPageLink) {
        return listBySubscriptionIdNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<WebServiceInner>>, Page<WebServiceInner>>() {
                @Override
                public Page<WebServiceInner> call(ServiceResponse<Page<WebServiceInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Gets the web services in the specified subscription.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;WebServiceInner&gt; object
     */
    public Observable<ServiceResponse<Page<WebServiceInner>>> listBySubscriptionIdNextWithServiceResponseAsync(final String nextPageLink) {
        return listBySubscriptionIdNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<WebServiceInner>>, Observable<ServiceResponse<Page<WebServiceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<WebServiceInner>>> call(ServiceResponse<Page<WebServiceInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listBySubscriptionIdNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the web services in the specified subscription.
     *
    ServiceResponse<PageImpl<WebServiceInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;WebServiceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<WebServiceInner>>> listBySubscriptionIdNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listBySubscriptionIdNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<WebServiceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<WebServiceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<WebServiceInner>> result = listBySubscriptionIdNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<WebServiceInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<WebServiceInner>> listBySubscriptionIdNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<WebServiceInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<WebServiceInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

}
