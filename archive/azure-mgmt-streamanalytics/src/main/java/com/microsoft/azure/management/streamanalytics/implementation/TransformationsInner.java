/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.management.streamanalytics.implementation;

import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.CloudException;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponseWithHeaders;
import com.microsoft.rest.Validator;
import java.io.IOException;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.PATCH;
import retrofit2.http.Path;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in Transformations.
 */
public class TransformationsInner {
    /** The Retrofit service to perform REST calls. */
    private TransformationsService service;
    /** The service client containing this operation class. */
    private StreamAnalyticsManagementClientImpl client;

    /**
     * Initializes an instance of TransformationsInner.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public TransformationsInner(Retrofit retrofit, StreamAnalyticsManagementClientImpl client) {
        this.service = retrofit.create(TransformationsService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for Transformations to be
     * used by Retrofit to perform actually REST calls.
     */
    interface TransformationsService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.streamanalytics.Transformations createOrReplace" })
        @PUT("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/transformations/{transformationName}")
        Observable<Response<ResponseBody>> createOrReplace(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("jobName") String jobName, @Path("transformationName") String transformationName, @Body TransformationInner transformation, @Header("If-Match") String ifMatch, @Header("If-None-Match") String ifNoneMatch, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.streamanalytics.Transformations update" })
        @PATCH("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/transformations/{transformationName}")
        Observable<Response<ResponseBody>> update(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("jobName") String jobName, @Path("transformationName") String transformationName, @Body TransformationInner transformation, @Header("If-Match") String ifMatch, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.streamanalytics.Transformations get" })
        @GET("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/transformations/{transformationName}")
        Observable<Response<ResponseBody>> get(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("jobName") String jobName, @Path("transformationName") String transformationName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

    }

    /**
     * Creates a transformation or replaces an already existing transformation under an existing streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param transformationName The name of the transformation.
     * @param transformation The definition of the transformation that will be used to create a new transformation or replace the existing one under the streaming job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TransformationInner object if successful.
     */
    public TransformationInner createOrReplace(String resourceGroupName, String jobName, String transformationName, TransformationInner transformation) {
        return createOrReplaceWithServiceResponseAsync(resourceGroupName, jobName, transformationName, transformation).toBlocking().single().body();
    }

    /**
     * Creates a transformation or replaces an already existing transformation under an existing streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param transformationName The name of the transformation.
     * @param transformation The definition of the transformation that will be used to create a new transformation or replace the existing one under the streaming job.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TransformationInner> createOrReplaceAsync(String resourceGroupName, String jobName, String transformationName, TransformationInner transformation, final ServiceCallback<TransformationInner> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createOrReplaceWithServiceResponseAsync(resourceGroupName, jobName, transformationName, transformation), serviceCallback);
    }

    /**
     * Creates a transformation or replaces an already existing transformation under an existing streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param transformationName The name of the transformation.
     * @param transformation The definition of the transformation that will be used to create a new transformation or replace the existing one under the streaming job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformationInner object
     */
    public Observable<TransformationInner> createOrReplaceAsync(String resourceGroupName, String jobName, String transformationName, TransformationInner transformation) {
        return createOrReplaceWithServiceResponseAsync(resourceGroupName, jobName, transformationName, transformation).map(new Func1<ServiceResponseWithHeaders<TransformationInner, TransformationsCreateOrReplaceHeadersInner>, TransformationInner>() {
            @Override
            public TransformationInner call(ServiceResponseWithHeaders<TransformationInner, TransformationsCreateOrReplaceHeadersInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a transformation or replaces an already existing transformation under an existing streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param transformationName The name of the transformation.
     * @param transformation The definition of the transformation that will be used to create a new transformation or replace the existing one under the streaming job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformationInner object
     */
    public Observable<ServiceResponseWithHeaders<TransformationInner, TransformationsCreateOrReplaceHeadersInner>> createOrReplaceWithServiceResponseAsync(String resourceGroupName, String jobName, String transformationName, TransformationInner transformation) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        if (transformationName == null) {
            throw new IllegalArgumentException("Parameter transformationName is required and cannot be null.");
        }
        if (transformation == null) {
            throw new IllegalArgumentException("Parameter transformation is required and cannot be null.");
        }
        Validator.validate(transformation);
        final String apiVersion = "2016-03-01";
        final String ifMatch = null;
        final String ifNoneMatch = null;
        return service.createOrReplace(this.client.subscriptionId(), resourceGroupName, jobName, transformationName, transformation, ifMatch, ifNoneMatch, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<TransformationInner, TransformationsCreateOrReplaceHeadersInner>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<TransformationInner, TransformationsCreateOrReplaceHeadersInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<TransformationInner, TransformationsCreateOrReplaceHeadersInner> clientResponse = createOrReplaceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Creates a transformation or replaces an already existing transformation under an existing streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param transformationName The name of the transformation.
     * @param transformation The definition of the transformation that will be used to create a new transformation or replace the existing one under the streaming job.
     * @param ifMatch The ETag of the transformation. Omit this value to always overwrite the current transformation. Specify the last-seen ETag value to prevent accidentally overwritting concurrent changes.
     * @param ifNoneMatch Set to '*' to allow a new transformation to be created, but to prevent updating an existing transformation. Other values will result in a 412 Pre-condition Failed response.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TransformationInner object if successful.
     */
    public TransformationInner createOrReplace(String resourceGroupName, String jobName, String transformationName, TransformationInner transformation, String ifMatch, String ifNoneMatch) {
        return createOrReplaceWithServiceResponseAsync(resourceGroupName, jobName, transformationName, transformation, ifMatch, ifNoneMatch).toBlocking().single().body();
    }

    /**
     * Creates a transformation or replaces an already existing transformation under an existing streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param transformationName The name of the transformation.
     * @param transformation The definition of the transformation that will be used to create a new transformation or replace the existing one under the streaming job.
     * @param ifMatch The ETag of the transformation. Omit this value to always overwrite the current transformation. Specify the last-seen ETag value to prevent accidentally overwritting concurrent changes.
     * @param ifNoneMatch Set to '*' to allow a new transformation to be created, but to prevent updating an existing transformation. Other values will result in a 412 Pre-condition Failed response.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TransformationInner> createOrReplaceAsync(String resourceGroupName, String jobName, String transformationName, TransformationInner transformation, String ifMatch, String ifNoneMatch, final ServiceCallback<TransformationInner> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createOrReplaceWithServiceResponseAsync(resourceGroupName, jobName, transformationName, transformation, ifMatch, ifNoneMatch), serviceCallback);
    }

    /**
     * Creates a transformation or replaces an already existing transformation under an existing streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param transformationName The name of the transformation.
     * @param transformation The definition of the transformation that will be used to create a new transformation or replace the existing one under the streaming job.
     * @param ifMatch The ETag of the transformation. Omit this value to always overwrite the current transformation. Specify the last-seen ETag value to prevent accidentally overwritting concurrent changes.
     * @param ifNoneMatch Set to '*' to allow a new transformation to be created, but to prevent updating an existing transformation. Other values will result in a 412 Pre-condition Failed response.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformationInner object
     */
    public Observable<TransformationInner> createOrReplaceAsync(String resourceGroupName, String jobName, String transformationName, TransformationInner transformation, String ifMatch, String ifNoneMatch) {
        return createOrReplaceWithServiceResponseAsync(resourceGroupName, jobName, transformationName, transformation, ifMatch, ifNoneMatch).map(new Func1<ServiceResponseWithHeaders<TransformationInner, TransformationsCreateOrReplaceHeadersInner>, TransformationInner>() {
            @Override
            public TransformationInner call(ServiceResponseWithHeaders<TransformationInner, TransformationsCreateOrReplaceHeadersInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a transformation or replaces an already existing transformation under an existing streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param transformationName The name of the transformation.
     * @param transformation The definition of the transformation that will be used to create a new transformation or replace the existing one under the streaming job.
     * @param ifMatch The ETag of the transformation. Omit this value to always overwrite the current transformation. Specify the last-seen ETag value to prevent accidentally overwritting concurrent changes.
     * @param ifNoneMatch Set to '*' to allow a new transformation to be created, but to prevent updating an existing transformation. Other values will result in a 412 Pre-condition Failed response.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformationInner object
     */
    public Observable<ServiceResponseWithHeaders<TransformationInner, TransformationsCreateOrReplaceHeadersInner>> createOrReplaceWithServiceResponseAsync(String resourceGroupName, String jobName, String transformationName, TransformationInner transformation, String ifMatch, String ifNoneMatch) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        if (transformationName == null) {
            throw new IllegalArgumentException("Parameter transformationName is required and cannot be null.");
        }
        if (transformation == null) {
            throw new IllegalArgumentException("Parameter transformation is required and cannot be null.");
        }
        Validator.validate(transformation);
        final String apiVersion = "2016-03-01";
        return service.createOrReplace(this.client.subscriptionId(), resourceGroupName, jobName, transformationName, transformation, ifMatch, ifNoneMatch, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<TransformationInner, TransformationsCreateOrReplaceHeadersInner>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<TransformationInner, TransformationsCreateOrReplaceHeadersInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<TransformationInner, TransformationsCreateOrReplaceHeadersInner> clientResponse = createOrReplaceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<TransformationInner, TransformationsCreateOrReplaceHeadersInner> createOrReplaceDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<TransformationInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<TransformationInner>() { }.getType())
                .register(201, new TypeToken<TransformationInner>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, TransformationsCreateOrReplaceHeadersInner.class);
    }

    /**
     * Updates an existing transformation under an existing streaming job. This can be used to partially update (ie. update one or two properties) a transformation without affecting the rest the job or transformation definition.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param transformationName The name of the transformation.
     * @param transformation A Transformation object. The properties specified here will overwrite the corresponding properties in the existing transformation (ie. Those properties will be updated). Any properties that are set to null here will mean that the corresponding property in the existing transformation will remain the same and not change as a result of this PATCH operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TransformationInner object if successful.
     */
    public TransformationInner update(String resourceGroupName, String jobName, String transformationName, TransformationInner transformation) {
        return updateWithServiceResponseAsync(resourceGroupName, jobName, transformationName, transformation).toBlocking().single().body();
    }

    /**
     * Updates an existing transformation under an existing streaming job. This can be used to partially update (ie. update one or two properties) a transformation without affecting the rest the job or transformation definition.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param transformationName The name of the transformation.
     * @param transformation A Transformation object. The properties specified here will overwrite the corresponding properties in the existing transformation (ie. Those properties will be updated). Any properties that are set to null here will mean that the corresponding property in the existing transformation will remain the same and not change as a result of this PATCH operation.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TransformationInner> updateAsync(String resourceGroupName, String jobName, String transformationName, TransformationInner transformation, final ServiceCallback<TransformationInner> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateWithServiceResponseAsync(resourceGroupName, jobName, transformationName, transformation), serviceCallback);
    }

    /**
     * Updates an existing transformation under an existing streaming job. This can be used to partially update (ie. update one or two properties) a transformation without affecting the rest the job or transformation definition.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param transformationName The name of the transformation.
     * @param transformation A Transformation object. The properties specified here will overwrite the corresponding properties in the existing transformation (ie. Those properties will be updated). Any properties that are set to null here will mean that the corresponding property in the existing transformation will remain the same and not change as a result of this PATCH operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformationInner object
     */
    public Observable<TransformationInner> updateAsync(String resourceGroupName, String jobName, String transformationName, TransformationInner transformation) {
        return updateWithServiceResponseAsync(resourceGroupName, jobName, transformationName, transformation).map(new Func1<ServiceResponseWithHeaders<TransformationInner, TransformationsUpdateHeadersInner>, TransformationInner>() {
            @Override
            public TransformationInner call(ServiceResponseWithHeaders<TransformationInner, TransformationsUpdateHeadersInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates an existing transformation under an existing streaming job. This can be used to partially update (ie. update one or two properties) a transformation without affecting the rest the job or transformation definition.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param transformationName The name of the transformation.
     * @param transformation A Transformation object. The properties specified here will overwrite the corresponding properties in the existing transformation (ie. Those properties will be updated). Any properties that are set to null here will mean that the corresponding property in the existing transformation will remain the same and not change as a result of this PATCH operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformationInner object
     */
    public Observable<ServiceResponseWithHeaders<TransformationInner, TransformationsUpdateHeadersInner>> updateWithServiceResponseAsync(String resourceGroupName, String jobName, String transformationName, TransformationInner transformation) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        if (transformationName == null) {
            throw new IllegalArgumentException("Parameter transformationName is required and cannot be null.");
        }
        if (transformation == null) {
            throw new IllegalArgumentException("Parameter transformation is required and cannot be null.");
        }
        Validator.validate(transformation);
        final String apiVersion = "2016-03-01";
        final String ifMatch = null;
        return service.update(this.client.subscriptionId(), resourceGroupName, jobName, transformationName, transformation, ifMatch, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<TransformationInner, TransformationsUpdateHeadersInner>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<TransformationInner, TransformationsUpdateHeadersInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<TransformationInner, TransformationsUpdateHeadersInner> clientResponse = updateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Updates an existing transformation under an existing streaming job. This can be used to partially update (ie. update one or two properties) a transformation without affecting the rest the job or transformation definition.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param transformationName The name of the transformation.
     * @param transformation A Transformation object. The properties specified here will overwrite the corresponding properties in the existing transformation (ie. Those properties will be updated). Any properties that are set to null here will mean that the corresponding property in the existing transformation will remain the same and not change as a result of this PATCH operation.
     * @param ifMatch The ETag of the transformation. Omit this value to always overwrite the current transformation. Specify the last-seen ETag value to prevent accidentally overwritting concurrent changes.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TransformationInner object if successful.
     */
    public TransformationInner update(String resourceGroupName, String jobName, String transformationName, TransformationInner transformation, String ifMatch) {
        return updateWithServiceResponseAsync(resourceGroupName, jobName, transformationName, transformation, ifMatch).toBlocking().single().body();
    }

    /**
     * Updates an existing transformation under an existing streaming job. This can be used to partially update (ie. update one or two properties) a transformation without affecting the rest the job or transformation definition.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param transformationName The name of the transformation.
     * @param transformation A Transformation object. The properties specified here will overwrite the corresponding properties in the existing transformation (ie. Those properties will be updated). Any properties that are set to null here will mean that the corresponding property in the existing transformation will remain the same and not change as a result of this PATCH operation.
     * @param ifMatch The ETag of the transformation. Omit this value to always overwrite the current transformation. Specify the last-seen ETag value to prevent accidentally overwritting concurrent changes.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TransformationInner> updateAsync(String resourceGroupName, String jobName, String transformationName, TransformationInner transformation, String ifMatch, final ServiceCallback<TransformationInner> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateWithServiceResponseAsync(resourceGroupName, jobName, transformationName, transformation, ifMatch), serviceCallback);
    }

    /**
     * Updates an existing transformation under an existing streaming job. This can be used to partially update (ie. update one or two properties) a transformation without affecting the rest the job or transformation definition.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param transformationName The name of the transformation.
     * @param transformation A Transformation object. The properties specified here will overwrite the corresponding properties in the existing transformation (ie. Those properties will be updated). Any properties that are set to null here will mean that the corresponding property in the existing transformation will remain the same and not change as a result of this PATCH operation.
     * @param ifMatch The ETag of the transformation. Omit this value to always overwrite the current transformation. Specify the last-seen ETag value to prevent accidentally overwritting concurrent changes.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformationInner object
     */
    public Observable<TransformationInner> updateAsync(String resourceGroupName, String jobName, String transformationName, TransformationInner transformation, String ifMatch) {
        return updateWithServiceResponseAsync(resourceGroupName, jobName, transformationName, transformation, ifMatch).map(new Func1<ServiceResponseWithHeaders<TransformationInner, TransformationsUpdateHeadersInner>, TransformationInner>() {
            @Override
            public TransformationInner call(ServiceResponseWithHeaders<TransformationInner, TransformationsUpdateHeadersInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates an existing transformation under an existing streaming job. This can be used to partially update (ie. update one or two properties) a transformation without affecting the rest the job or transformation definition.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param transformationName The name of the transformation.
     * @param transformation A Transformation object. The properties specified here will overwrite the corresponding properties in the existing transformation (ie. Those properties will be updated). Any properties that are set to null here will mean that the corresponding property in the existing transformation will remain the same and not change as a result of this PATCH operation.
     * @param ifMatch The ETag of the transformation. Omit this value to always overwrite the current transformation. Specify the last-seen ETag value to prevent accidentally overwritting concurrent changes.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformationInner object
     */
    public Observable<ServiceResponseWithHeaders<TransformationInner, TransformationsUpdateHeadersInner>> updateWithServiceResponseAsync(String resourceGroupName, String jobName, String transformationName, TransformationInner transformation, String ifMatch) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        if (transformationName == null) {
            throw new IllegalArgumentException("Parameter transformationName is required and cannot be null.");
        }
        if (transformation == null) {
            throw new IllegalArgumentException("Parameter transformation is required and cannot be null.");
        }
        Validator.validate(transformation);
        final String apiVersion = "2016-03-01";
        return service.update(this.client.subscriptionId(), resourceGroupName, jobName, transformationName, transformation, ifMatch, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<TransformationInner, TransformationsUpdateHeadersInner>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<TransformationInner, TransformationsUpdateHeadersInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<TransformationInner, TransformationsUpdateHeadersInner> clientResponse = updateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<TransformationInner, TransformationsUpdateHeadersInner> updateDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<TransformationInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<TransformationInner>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, TransformationsUpdateHeadersInner.class);
    }

    /**
     * Gets details about the specified transformation.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param transformationName The name of the transformation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TransformationInner object if successful.
     */
    public TransformationInner get(String resourceGroupName, String jobName, String transformationName) {
        return getWithServiceResponseAsync(resourceGroupName, jobName, transformationName).toBlocking().single().body();
    }

    /**
     * Gets details about the specified transformation.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param transformationName The name of the transformation.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TransformationInner> getAsync(String resourceGroupName, String jobName, String transformationName, final ServiceCallback<TransformationInner> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getWithServiceResponseAsync(resourceGroupName, jobName, transformationName), serviceCallback);
    }

    /**
     * Gets details about the specified transformation.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param transformationName The name of the transformation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformationInner object
     */
    public Observable<TransformationInner> getAsync(String resourceGroupName, String jobName, String transformationName) {
        return getWithServiceResponseAsync(resourceGroupName, jobName, transformationName).map(new Func1<ServiceResponseWithHeaders<TransformationInner, TransformationsGetHeadersInner>, TransformationInner>() {
            @Override
            public TransformationInner call(ServiceResponseWithHeaders<TransformationInner, TransformationsGetHeadersInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets details about the specified transformation.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param transformationName The name of the transformation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformationInner object
     */
    public Observable<ServiceResponseWithHeaders<TransformationInner, TransformationsGetHeadersInner>> getWithServiceResponseAsync(String resourceGroupName, String jobName, String transformationName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        if (transformationName == null) {
            throw new IllegalArgumentException("Parameter transformationName is required and cannot be null.");
        }
        final String apiVersion = "2016-03-01";
        return service.get(this.client.subscriptionId(), resourceGroupName, jobName, transformationName, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<TransformationInner, TransformationsGetHeadersInner>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<TransformationInner, TransformationsGetHeadersInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<TransformationInner, TransformationsGetHeadersInner> clientResponse = getDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<TransformationInner, TransformationsGetHeadersInner> getDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<TransformationInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<TransformationInner>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, TransformationsGetHeadersInner.class);
    }

}
