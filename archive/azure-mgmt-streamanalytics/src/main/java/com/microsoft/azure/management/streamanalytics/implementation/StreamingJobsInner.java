/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.management.streamanalytics.implementation;

import com.microsoft.azure.management.resources.fluentcore.collection.InnerSupportsGet;
import com.microsoft.azure.management.resources.fluentcore.collection.InnerSupportsDelete;
import com.microsoft.azure.management.resources.fluentcore.collection.InnerSupportsListing;
import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.AzureServiceFuture;
import com.microsoft.azure.CloudException;
import com.microsoft.azure.ListOperationCallback;
import com.microsoft.azure.Page;
import com.microsoft.azure.PagedList;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.ServiceResponseWithHeaders;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.List;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.PATCH;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.http.Url;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in StreamingJobs.
 */
public class StreamingJobsInner implements InnerSupportsGet<StreamingJobInner>, InnerSupportsDelete<Void>, InnerSupportsListing<StreamingJobInner> {
    /** The Retrofit service to perform REST calls. */
    private StreamingJobsService service;
    /** The service client containing this operation class. */
    private StreamAnalyticsManagementClientImpl client;

    /**
     * Initializes an instance of StreamingJobsInner.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public StreamingJobsInner(Retrofit retrofit, StreamAnalyticsManagementClientImpl client) {
        this.service = retrofit.create(StreamingJobsService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for StreamingJobs to be
     * used by Retrofit to perform actually REST calls.
     */
    interface StreamingJobsService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.streamanalytics.StreamingJobs createOrReplace" })
        @PUT("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}")
        Observable<Response<ResponseBody>> createOrReplace(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("jobName") String jobName, @Body StreamingJobInner streamingJob, @Header("If-Match") String ifMatch, @Header("If-None-Match") String ifNoneMatch, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.streamanalytics.StreamingJobs beginCreateOrReplace" })
        @PUT("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}")
        Observable<Response<ResponseBody>> beginCreateOrReplace(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("jobName") String jobName, @Body StreamingJobInner streamingJob, @Header("If-Match") String ifMatch, @Header("If-None-Match") String ifNoneMatch, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.streamanalytics.StreamingJobs update" })
        @PATCH("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}")
        Observable<Response<ResponseBody>> update(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("jobName") String jobName, @Body StreamingJobInner streamingJob, @Header("If-Match") String ifMatch, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.streamanalytics.StreamingJobs delete" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> delete(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("jobName") String jobName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.streamanalytics.StreamingJobs beginDelete" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> beginDelete(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("jobName") String jobName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.streamanalytics.StreamingJobs getByResourceGroup" })
        @GET("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}")
        Observable<Response<ResponseBody>> getByResourceGroup(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("jobName") String jobName, @Query("$expand") String expand, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.streamanalytics.StreamingJobs listByResourceGroup" })
        @GET("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs")
        Observable<Response<ResponseBody>> listByResourceGroup(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Query("$expand") String expand, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.streamanalytics.StreamingJobs list" })
        @GET("subscriptions/{subscriptionId}/providers/Microsoft.StreamAnalytics/streamingjobs")
        Observable<Response<ResponseBody>> list(@Path("subscriptionId") String subscriptionId, @Query("$expand") String expand, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.streamanalytics.StreamingJobs start" })
        @POST("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/start")
        Observable<Response<ResponseBody>> start(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("jobName") String jobName, @Body StartStreamingJobParametersInner startJobParameters, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.streamanalytics.StreamingJobs beginStart" })
        @POST("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/start")
        Observable<Response<ResponseBody>> beginStart(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("jobName") String jobName, @Body StartStreamingJobParametersInner startJobParameters, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.streamanalytics.StreamingJobs stop" })
        @POST("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/stop")
        Observable<Response<ResponseBody>> stop(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("jobName") String jobName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.streamanalytics.StreamingJobs beginStop" })
        @POST("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/stop")
        Observable<Response<ResponseBody>> beginStop(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("jobName") String jobName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.streamanalytics.StreamingJobs listByResourceGroupNext" })
        @GET
        Observable<Response<ResponseBody>> listByResourceGroupNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.streamanalytics.StreamingJobs listNext" })
        @GET
        Observable<Response<ResponseBody>> listNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

    }

    /**
     * Creates a streaming job or replaces an already existing streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param streamingJob The definition of the streaming job that will be used to create a new streaming job or replace the existing one.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StreamingJobInner object if successful.
     */
    public StreamingJobInner createOrReplace(String resourceGroupName, String jobName, StreamingJobInner streamingJob) {
        return createOrReplaceWithServiceResponseAsync(resourceGroupName, jobName, streamingJob).toBlocking().last().body();
    }

    /**
     * Creates a streaming job or replaces an already existing streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param streamingJob The definition of the streaming job that will be used to create a new streaming job or replace the existing one.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StreamingJobInner> createOrReplaceAsync(String resourceGroupName, String jobName, StreamingJobInner streamingJob, final ServiceCallback<StreamingJobInner> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createOrReplaceWithServiceResponseAsync(resourceGroupName, jobName, streamingJob), serviceCallback);
    }

    /**
     * Creates a streaming job or replaces an already existing streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param streamingJob The definition of the streaming job that will be used to create a new streaming job or replace the existing one.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<StreamingJobInner> createOrReplaceAsync(String resourceGroupName, String jobName, StreamingJobInner streamingJob) {
        return createOrReplaceWithServiceResponseAsync(resourceGroupName, jobName, streamingJob).map(new Func1<ServiceResponseWithHeaders<StreamingJobInner, StreamingJobsCreateOrReplaceHeadersInner>, StreamingJobInner>() {
            @Override
            public StreamingJobInner call(ServiceResponseWithHeaders<StreamingJobInner, StreamingJobsCreateOrReplaceHeadersInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a streaming job or replaces an already existing streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param streamingJob The definition of the streaming job that will be used to create a new streaming job or replace the existing one.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponseWithHeaders<StreamingJobInner, StreamingJobsCreateOrReplaceHeadersInner>> createOrReplaceWithServiceResponseAsync(String resourceGroupName, String jobName, StreamingJobInner streamingJob) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        if (streamingJob == null) {
            throw new IllegalArgumentException("Parameter streamingJob is required and cannot be null.");
        }
        Validator.validate(streamingJob);
        final String apiVersion = "2016-03-01";
        final String ifMatch = null;
        final String ifNoneMatch = null;
        Observable<Response<ResponseBody>> observable = service.createOrReplace(this.client.subscriptionId(), resourceGroupName, jobName, streamingJob, ifMatch, ifNoneMatch, apiVersion, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultWithHeadersAsync(observable, new TypeToken<StreamingJobInner>() { }.getType(), StreamingJobsCreateOrReplaceHeadersInner.class);
    }
    /**
     * Creates a streaming job or replaces an already existing streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param streamingJob The definition of the streaming job that will be used to create a new streaming job or replace the existing one.
     * @param ifMatch The ETag of the streaming job. Omit this value to always overwrite the current record set. Specify the last-seen ETag value to prevent accidentally overwritting concurrent changes.
     * @param ifNoneMatch Set to '*' to allow a new streaming job to be created, but to prevent updating an existing record set. Other values will result in a 412 Pre-condition Failed response.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StreamingJobInner object if successful.
     */
    public StreamingJobInner createOrReplace(String resourceGroupName, String jobName, StreamingJobInner streamingJob, String ifMatch, String ifNoneMatch) {
        return createOrReplaceWithServiceResponseAsync(resourceGroupName, jobName, streamingJob, ifMatch, ifNoneMatch).toBlocking().last().body();
    }

    /**
     * Creates a streaming job or replaces an already existing streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param streamingJob The definition of the streaming job that will be used to create a new streaming job or replace the existing one.
     * @param ifMatch The ETag of the streaming job. Omit this value to always overwrite the current record set. Specify the last-seen ETag value to prevent accidentally overwritting concurrent changes.
     * @param ifNoneMatch Set to '*' to allow a new streaming job to be created, but to prevent updating an existing record set. Other values will result in a 412 Pre-condition Failed response.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StreamingJobInner> createOrReplaceAsync(String resourceGroupName, String jobName, StreamingJobInner streamingJob, String ifMatch, String ifNoneMatch, final ServiceCallback<StreamingJobInner> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createOrReplaceWithServiceResponseAsync(resourceGroupName, jobName, streamingJob, ifMatch, ifNoneMatch), serviceCallback);
    }

    /**
     * Creates a streaming job or replaces an already existing streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param streamingJob The definition of the streaming job that will be used to create a new streaming job or replace the existing one.
     * @param ifMatch The ETag of the streaming job. Omit this value to always overwrite the current record set. Specify the last-seen ETag value to prevent accidentally overwritting concurrent changes.
     * @param ifNoneMatch Set to '*' to allow a new streaming job to be created, but to prevent updating an existing record set. Other values will result in a 412 Pre-condition Failed response.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<StreamingJobInner> createOrReplaceAsync(String resourceGroupName, String jobName, StreamingJobInner streamingJob, String ifMatch, String ifNoneMatch) {
        return createOrReplaceWithServiceResponseAsync(resourceGroupName, jobName, streamingJob, ifMatch, ifNoneMatch).map(new Func1<ServiceResponseWithHeaders<StreamingJobInner, StreamingJobsCreateOrReplaceHeadersInner>, StreamingJobInner>() {
            @Override
            public StreamingJobInner call(ServiceResponseWithHeaders<StreamingJobInner, StreamingJobsCreateOrReplaceHeadersInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a streaming job or replaces an already existing streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param streamingJob The definition of the streaming job that will be used to create a new streaming job or replace the existing one.
     * @param ifMatch The ETag of the streaming job. Omit this value to always overwrite the current record set. Specify the last-seen ETag value to prevent accidentally overwritting concurrent changes.
     * @param ifNoneMatch Set to '*' to allow a new streaming job to be created, but to prevent updating an existing record set. Other values will result in a 412 Pre-condition Failed response.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponseWithHeaders<StreamingJobInner, StreamingJobsCreateOrReplaceHeadersInner>> createOrReplaceWithServiceResponseAsync(String resourceGroupName, String jobName, StreamingJobInner streamingJob, String ifMatch, String ifNoneMatch) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        if (streamingJob == null) {
            throw new IllegalArgumentException("Parameter streamingJob is required and cannot be null.");
        }
        Validator.validate(streamingJob);
        final String apiVersion = "2016-03-01";
        Observable<Response<ResponseBody>> observable = service.createOrReplace(this.client.subscriptionId(), resourceGroupName, jobName, streamingJob, ifMatch, ifNoneMatch, apiVersion, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultWithHeadersAsync(observable, new TypeToken<StreamingJobInner>() { }.getType(), StreamingJobsCreateOrReplaceHeadersInner.class);
    }

    /**
     * Creates a streaming job or replaces an already existing streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param streamingJob The definition of the streaming job that will be used to create a new streaming job or replace the existing one.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StreamingJobInner object if successful.
     */
    public StreamingJobInner beginCreateOrReplace(String resourceGroupName, String jobName, StreamingJobInner streamingJob) {
        return beginCreateOrReplaceWithServiceResponseAsync(resourceGroupName, jobName, streamingJob).toBlocking().single().body();
    }

    /**
     * Creates a streaming job or replaces an already existing streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param streamingJob The definition of the streaming job that will be used to create a new streaming job or replace the existing one.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StreamingJobInner> beginCreateOrReplaceAsync(String resourceGroupName, String jobName, StreamingJobInner streamingJob, final ServiceCallback<StreamingJobInner> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(beginCreateOrReplaceWithServiceResponseAsync(resourceGroupName, jobName, streamingJob), serviceCallback);
    }

    /**
     * Creates a streaming job or replaces an already existing streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param streamingJob The definition of the streaming job that will be used to create a new streaming job or replace the existing one.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StreamingJobInner object
     */
    public Observable<StreamingJobInner> beginCreateOrReplaceAsync(String resourceGroupName, String jobName, StreamingJobInner streamingJob) {
        return beginCreateOrReplaceWithServiceResponseAsync(resourceGroupName, jobName, streamingJob).map(new Func1<ServiceResponseWithHeaders<StreamingJobInner, StreamingJobsCreateOrReplaceHeadersInner>, StreamingJobInner>() {
            @Override
            public StreamingJobInner call(ServiceResponseWithHeaders<StreamingJobInner, StreamingJobsCreateOrReplaceHeadersInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a streaming job or replaces an already existing streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param streamingJob The definition of the streaming job that will be used to create a new streaming job or replace the existing one.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StreamingJobInner object
     */
    public Observable<ServiceResponseWithHeaders<StreamingJobInner, StreamingJobsCreateOrReplaceHeadersInner>> beginCreateOrReplaceWithServiceResponseAsync(String resourceGroupName, String jobName, StreamingJobInner streamingJob) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        if (streamingJob == null) {
            throw new IllegalArgumentException("Parameter streamingJob is required and cannot be null.");
        }
        Validator.validate(streamingJob);
        final String apiVersion = "2016-03-01";
        final String ifMatch = null;
        final String ifNoneMatch = null;
        return service.beginCreateOrReplace(this.client.subscriptionId(), resourceGroupName, jobName, streamingJob, ifMatch, ifNoneMatch, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<StreamingJobInner, StreamingJobsCreateOrReplaceHeadersInner>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<StreamingJobInner, StreamingJobsCreateOrReplaceHeadersInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<StreamingJobInner, StreamingJobsCreateOrReplaceHeadersInner> clientResponse = beginCreateOrReplaceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Creates a streaming job or replaces an already existing streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param streamingJob The definition of the streaming job that will be used to create a new streaming job or replace the existing one.
     * @param ifMatch The ETag of the streaming job. Omit this value to always overwrite the current record set. Specify the last-seen ETag value to prevent accidentally overwritting concurrent changes.
     * @param ifNoneMatch Set to '*' to allow a new streaming job to be created, but to prevent updating an existing record set. Other values will result in a 412 Pre-condition Failed response.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StreamingJobInner object if successful.
     */
    public StreamingJobInner beginCreateOrReplace(String resourceGroupName, String jobName, StreamingJobInner streamingJob, String ifMatch, String ifNoneMatch) {
        return beginCreateOrReplaceWithServiceResponseAsync(resourceGroupName, jobName, streamingJob, ifMatch, ifNoneMatch).toBlocking().single().body();
    }

    /**
     * Creates a streaming job or replaces an already existing streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param streamingJob The definition of the streaming job that will be used to create a new streaming job or replace the existing one.
     * @param ifMatch The ETag of the streaming job. Omit this value to always overwrite the current record set. Specify the last-seen ETag value to prevent accidentally overwritting concurrent changes.
     * @param ifNoneMatch Set to '*' to allow a new streaming job to be created, but to prevent updating an existing record set. Other values will result in a 412 Pre-condition Failed response.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StreamingJobInner> beginCreateOrReplaceAsync(String resourceGroupName, String jobName, StreamingJobInner streamingJob, String ifMatch, String ifNoneMatch, final ServiceCallback<StreamingJobInner> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(beginCreateOrReplaceWithServiceResponseAsync(resourceGroupName, jobName, streamingJob, ifMatch, ifNoneMatch), serviceCallback);
    }

    /**
     * Creates a streaming job or replaces an already existing streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param streamingJob The definition of the streaming job that will be used to create a new streaming job or replace the existing one.
     * @param ifMatch The ETag of the streaming job. Omit this value to always overwrite the current record set. Specify the last-seen ETag value to prevent accidentally overwritting concurrent changes.
     * @param ifNoneMatch Set to '*' to allow a new streaming job to be created, but to prevent updating an existing record set. Other values will result in a 412 Pre-condition Failed response.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StreamingJobInner object
     */
    public Observable<StreamingJobInner> beginCreateOrReplaceAsync(String resourceGroupName, String jobName, StreamingJobInner streamingJob, String ifMatch, String ifNoneMatch) {
        return beginCreateOrReplaceWithServiceResponseAsync(resourceGroupName, jobName, streamingJob, ifMatch, ifNoneMatch).map(new Func1<ServiceResponseWithHeaders<StreamingJobInner, StreamingJobsCreateOrReplaceHeadersInner>, StreamingJobInner>() {
            @Override
            public StreamingJobInner call(ServiceResponseWithHeaders<StreamingJobInner, StreamingJobsCreateOrReplaceHeadersInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a streaming job or replaces an already existing streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param streamingJob The definition of the streaming job that will be used to create a new streaming job or replace the existing one.
     * @param ifMatch The ETag of the streaming job. Omit this value to always overwrite the current record set. Specify the last-seen ETag value to prevent accidentally overwritting concurrent changes.
     * @param ifNoneMatch Set to '*' to allow a new streaming job to be created, but to prevent updating an existing record set. Other values will result in a 412 Pre-condition Failed response.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StreamingJobInner object
     */
    public Observable<ServiceResponseWithHeaders<StreamingJobInner, StreamingJobsCreateOrReplaceHeadersInner>> beginCreateOrReplaceWithServiceResponseAsync(String resourceGroupName, String jobName, StreamingJobInner streamingJob, String ifMatch, String ifNoneMatch) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        if (streamingJob == null) {
            throw new IllegalArgumentException("Parameter streamingJob is required and cannot be null.");
        }
        Validator.validate(streamingJob);
        final String apiVersion = "2016-03-01";
        return service.beginCreateOrReplace(this.client.subscriptionId(), resourceGroupName, jobName, streamingJob, ifMatch, ifNoneMatch, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<StreamingJobInner, StreamingJobsCreateOrReplaceHeadersInner>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<StreamingJobInner, StreamingJobsCreateOrReplaceHeadersInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<StreamingJobInner, StreamingJobsCreateOrReplaceHeadersInner> clientResponse = beginCreateOrReplaceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<StreamingJobInner, StreamingJobsCreateOrReplaceHeadersInner> beginCreateOrReplaceDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<StreamingJobInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<StreamingJobInner>() { }.getType())
                .register(201, new TypeToken<StreamingJobInner>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, StreamingJobsCreateOrReplaceHeadersInner.class);
    }

    /**
     * Updates an existing streaming job. This can be used to partially update (ie. update one or two properties) a streaming job without affecting the rest the job definition.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param streamingJob A streaming job object. The properties specified here will overwrite the corresponding properties in the existing streaming job (ie. Those properties will be updated). Any properties that are set to null here will mean that the corresponding property in the existing input will remain the same and not change as a result of this PATCH operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StreamingJobInner object if successful.
     */
    public StreamingJobInner update(String resourceGroupName, String jobName, StreamingJobInner streamingJob) {
        return updateWithServiceResponseAsync(resourceGroupName, jobName, streamingJob).toBlocking().single().body();
    }

    /**
     * Updates an existing streaming job. This can be used to partially update (ie. update one or two properties) a streaming job without affecting the rest the job definition.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param streamingJob A streaming job object. The properties specified here will overwrite the corresponding properties in the existing streaming job (ie. Those properties will be updated). Any properties that are set to null here will mean that the corresponding property in the existing input will remain the same and not change as a result of this PATCH operation.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StreamingJobInner> updateAsync(String resourceGroupName, String jobName, StreamingJobInner streamingJob, final ServiceCallback<StreamingJobInner> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateWithServiceResponseAsync(resourceGroupName, jobName, streamingJob), serviceCallback);
    }

    /**
     * Updates an existing streaming job. This can be used to partially update (ie. update one or two properties) a streaming job without affecting the rest the job definition.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param streamingJob A streaming job object. The properties specified here will overwrite the corresponding properties in the existing streaming job (ie. Those properties will be updated). Any properties that are set to null here will mean that the corresponding property in the existing input will remain the same and not change as a result of this PATCH operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StreamingJobInner object
     */
    public Observable<StreamingJobInner> updateAsync(String resourceGroupName, String jobName, StreamingJobInner streamingJob) {
        return updateWithServiceResponseAsync(resourceGroupName, jobName, streamingJob).map(new Func1<ServiceResponseWithHeaders<StreamingJobInner, StreamingJobsUpdateHeadersInner>, StreamingJobInner>() {
            @Override
            public StreamingJobInner call(ServiceResponseWithHeaders<StreamingJobInner, StreamingJobsUpdateHeadersInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates an existing streaming job. This can be used to partially update (ie. update one or two properties) a streaming job without affecting the rest the job definition.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param streamingJob A streaming job object. The properties specified here will overwrite the corresponding properties in the existing streaming job (ie. Those properties will be updated). Any properties that are set to null here will mean that the corresponding property in the existing input will remain the same and not change as a result of this PATCH operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StreamingJobInner object
     */
    public Observable<ServiceResponseWithHeaders<StreamingJobInner, StreamingJobsUpdateHeadersInner>> updateWithServiceResponseAsync(String resourceGroupName, String jobName, StreamingJobInner streamingJob) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        if (streamingJob == null) {
            throw new IllegalArgumentException("Parameter streamingJob is required and cannot be null.");
        }
        Validator.validate(streamingJob);
        final String apiVersion = "2016-03-01";
        final String ifMatch = null;
        return service.update(this.client.subscriptionId(), resourceGroupName, jobName, streamingJob, ifMatch, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<StreamingJobInner, StreamingJobsUpdateHeadersInner>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<StreamingJobInner, StreamingJobsUpdateHeadersInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<StreamingJobInner, StreamingJobsUpdateHeadersInner> clientResponse = updateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Updates an existing streaming job. This can be used to partially update (ie. update one or two properties) a streaming job without affecting the rest the job definition.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param streamingJob A streaming job object. The properties specified here will overwrite the corresponding properties in the existing streaming job (ie. Those properties will be updated). Any properties that are set to null here will mean that the corresponding property in the existing input will remain the same and not change as a result of this PATCH operation.
     * @param ifMatch The ETag of the streaming job. Omit this value to always overwrite the current record set. Specify the last-seen ETag value to prevent accidentally overwritting concurrent changes.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StreamingJobInner object if successful.
     */
    public StreamingJobInner update(String resourceGroupName, String jobName, StreamingJobInner streamingJob, String ifMatch) {
        return updateWithServiceResponseAsync(resourceGroupName, jobName, streamingJob, ifMatch).toBlocking().single().body();
    }

    /**
     * Updates an existing streaming job. This can be used to partially update (ie. update one or two properties) a streaming job without affecting the rest the job definition.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param streamingJob A streaming job object. The properties specified here will overwrite the corresponding properties in the existing streaming job (ie. Those properties will be updated). Any properties that are set to null here will mean that the corresponding property in the existing input will remain the same and not change as a result of this PATCH operation.
     * @param ifMatch The ETag of the streaming job. Omit this value to always overwrite the current record set. Specify the last-seen ETag value to prevent accidentally overwritting concurrent changes.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StreamingJobInner> updateAsync(String resourceGroupName, String jobName, StreamingJobInner streamingJob, String ifMatch, final ServiceCallback<StreamingJobInner> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateWithServiceResponseAsync(resourceGroupName, jobName, streamingJob, ifMatch), serviceCallback);
    }

    /**
     * Updates an existing streaming job. This can be used to partially update (ie. update one or two properties) a streaming job without affecting the rest the job definition.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param streamingJob A streaming job object. The properties specified here will overwrite the corresponding properties in the existing streaming job (ie. Those properties will be updated). Any properties that are set to null here will mean that the corresponding property in the existing input will remain the same and not change as a result of this PATCH operation.
     * @param ifMatch The ETag of the streaming job. Omit this value to always overwrite the current record set. Specify the last-seen ETag value to prevent accidentally overwritting concurrent changes.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StreamingJobInner object
     */
    public Observable<StreamingJobInner> updateAsync(String resourceGroupName, String jobName, StreamingJobInner streamingJob, String ifMatch) {
        return updateWithServiceResponseAsync(resourceGroupName, jobName, streamingJob, ifMatch).map(new Func1<ServiceResponseWithHeaders<StreamingJobInner, StreamingJobsUpdateHeadersInner>, StreamingJobInner>() {
            @Override
            public StreamingJobInner call(ServiceResponseWithHeaders<StreamingJobInner, StreamingJobsUpdateHeadersInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates an existing streaming job. This can be used to partially update (ie. update one or two properties) a streaming job without affecting the rest the job definition.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param streamingJob A streaming job object. The properties specified here will overwrite the corresponding properties in the existing streaming job (ie. Those properties will be updated). Any properties that are set to null here will mean that the corresponding property in the existing input will remain the same and not change as a result of this PATCH operation.
     * @param ifMatch The ETag of the streaming job. Omit this value to always overwrite the current record set. Specify the last-seen ETag value to prevent accidentally overwritting concurrent changes.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StreamingJobInner object
     */
    public Observable<ServiceResponseWithHeaders<StreamingJobInner, StreamingJobsUpdateHeadersInner>> updateWithServiceResponseAsync(String resourceGroupName, String jobName, StreamingJobInner streamingJob, String ifMatch) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        if (streamingJob == null) {
            throw new IllegalArgumentException("Parameter streamingJob is required and cannot be null.");
        }
        Validator.validate(streamingJob);
        final String apiVersion = "2016-03-01";
        return service.update(this.client.subscriptionId(), resourceGroupName, jobName, streamingJob, ifMatch, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<StreamingJobInner, StreamingJobsUpdateHeadersInner>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<StreamingJobInner, StreamingJobsUpdateHeadersInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<StreamingJobInner, StreamingJobsUpdateHeadersInner> clientResponse = updateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<StreamingJobInner, StreamingJobsUpdateHeadersInner> updateDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<StreamingJobInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<StreamingJobInner>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, StreamingJobsUpdateHeadersInner.class);
    }

    /**
     * Deletes a streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void delete(String resourceGroupName, String jobName) {
        deleteWithServiceResponseAsync(resourceGroupName, jobName).toBlocking().last().body();
    }

    /**
     * Deletes a streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteAsync(String resourceGroupName, String jobName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteWithServiceResponseAsync(resourceGroupName, jobName), serviceCallback);
    }

    /**
     * Deletes a streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<Void> deleteAsync(String resourceGroupName, String jobName) {
        return deleteWithServiceResponseAsync(resourceGroupName, jobName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<Void>> deleteWithServiceResponseAsync(String resourceGroupName, String jobName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        final String apiVersion = "2016-03-01";
        Observable<Response<ResponseBody>> observable = service.delete(this.client.subscriptionId(), resourceGroupName, jobName, apiVersion, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<Void>() { }.getType());
    }

    /**
     * Deletes a streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void beginDelete(String resourceGroupName, String jobName) {
        beginDeleteWithServiceResponseAsync(resourceGroupName, jobName).toBlocking().single().body();
    }

    /**
     * Deletes a streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> beginDeleteAsync(String resourceGroupName, String jobName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(beginDeleteWithServiceResponseAsync(resourceGroupName, jobName), serviceCallback);
    }

    /**
     * Deletes a streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> beginDeleteAsync(String resourceGroupName, String jobName) {
        return beginDeleteWithServiceResponseAsync(resourceGroupName, jobName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes a streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> beginDeleteWithServiceResponseAsync(String resourceGroupName, String jobName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        final String apiVersion = "2016-03-01";
        return service.beginDelete(this.client.subscriptionId(), resourceGroupName, jobName, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = beginDeleteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> beginDeleteDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets details about the specified streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StreamingJobInner object if successful.
     */
    public StreamingJobInner getByResourceGroup(String resourceGroupName, String jobName) {
        return getByResourceGroupWithServiceResponseAsync(resourceGroupName, jobName).toBlocking().single().body();
    }

    /**
     * Gets details about the specified streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StreamingJobInner> getByResourceGroupAsync(String resourceGroupName, String jobName, final ServiceCallback<StreamingJobInner> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getByResourceGroupWithServiceResponseAsync(resourceGroupName, jobName), serviceCallback);
    }

    /**
     * Gets details about the specified streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StreamingJobInner object
     */
    public Observable<StreamingJobInner> getByResourceGroupAsync(String resourceGroupName, String jobName) {
        return getByResourceGroupWithServiceResponseAsync(resourceGroupName, jobName).map(new Func1<ServiceResponseWithHeaders<StreamingJobInner, StreamingJobsGetHeadersInner>, StreamingJobInner>() {
            @Override
            public StreamingJobInner call(ServiceResponseWithHeaders<StreamingJobInner, StreamingJobsGetHeadersInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets details about the specified streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StreamingJobInner object
     */
    public Observable<ServiceResponseWithHeaders<StreamingJobInner, StreamingJobsGetHeadersInner>> getByResourceGroupWithServiceResponseAsync(String resourceGroupName, String jobName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        final String apiVersion = "2016-03-01";
        final String expand = null;
        return service.getByResourceGroup(this.client.subscriptionId(), resourceGroupName, jobName, expand, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<StreamingJobInner, StreamingJobsGetHeadersInner>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<StreamingJobInner, StreamingJobsGetHeadersInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<StreamingJobInner, StreamingJobsGetHeadersInner> clientResponse = getByResourceGroupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets details about the specified streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param expand The $expand OData query parameter. This is a comma-separated list of additional streaming job properties to include in the response, beyond the default set returned when this parameter is absent. The default set is all streaming job properties other than 'inputs', 'transformation', 'outputs', and 'functions'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StreamingJobInner object if successful.
     */
    public StreamingJobInner getByResourceGroup(String resourceGroupName, String jobName, String expand) {
        return getByResourceGroupWithServiceResponseAsync(resourceGroupName, jobName, expand).toBlocking().single().body();
    }

    /**
     * Gets details about the specified streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param expand The $expand OData query parameter. This is a comma-separated list of additional streaming job properties to include in the response, beyond the default set returned when this parameter is absent. The default set is all streaming job properties other than 'inputs', 'transformation', 'outputs', and 'functions'.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StreamingJobInner> getByResourceGroupAsync(String resourceGroupName, String jobName, String expand, final ServiceCallback<StreamingJobInner> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getByResourceGroupWithServiceResponseAsync(resourceGroupName, jobName, expand), serviceCallback);
    }

    /**
     * Gets details about the specified streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param expand The $expand OData query parameter. This is a comma-separated list of additional streaming job properties to include in the response, beyond the default set returned when this parameter is absent. The default set is all streaming job properties other than 'inputs', 'transformation', 'outputs', and 'functions'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StreamingJobInner object
     */
    public Observable<StreamingJobInner> getByResourceGroupAsync(String resourceGroupName, String jobName, String expand) {
        return getByResourceGroupWithServiceResponseAsync(resourceGroupName, jobName, expand).map(new Func1<ServiceResponseWithHeaders<StreamingJobInner, StreamingJobsGetHeadersInner>, StreamingJobInner>() {
            @Override
            public StreamingJobInner call(ServiceResponseWithHeaders<StreamingJobInner, StreamingJobsGetHeadersInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets details about the specified streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param expand The $expand OData query parameter. This is a comma-separated list of additional streaming job properties to include in the response, beyond the default set returned when this parameter is absent. The default set is all streaming job properties other than 'inputs', 'transformation', 'outputs', and 'functions'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StreamingJobInner object
     */
    public Observable<ServiceResponseWithHeaders<StreamingJobInner, StreamingJobsGetHeadersInner>> getByResourceGroupWithServiceResponseAsync(String resourceGroupName, String jobName, String expand) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        final String apiVersion = "2016-03-01";
        return service.getByResourceGroup(this.client.subscriptionId(), resourceGroupName, jobName, expand, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<StreamingJobInner, StreamingJobsGetHeadersInner>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<StreamingJobInner, StreamingJobsGetHeadersInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<StreamingJobInner, StreamingJobsGetHeadersInner> clientResponse = getByResourceGroupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<StreamingJobInner, StreamingJobsGetHeadersInner> getByResourceGroupDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<StreamingJobInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<StreamingJobInner>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, StreamingJobsGetHeadersInner.class);
    }

    /**
     * Lists all of the streaming jobs in the specified resource group.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;StreamingJobInner&gt; object if successful.
     */
    public PagedList<StreamingJobInner> listByResourceGroup(final String resourceGroupName) {
        ServiceResponse<Page<StreamingJobInner>> response = listByResourceGroupSinglePageAsync(resourceGroupName).toBlocking().single();
        return new PagedList<StreamingJobInner>(response.body()) {
            @Override
            public Page<StreamingJobInner> nextPage(String nextPageLink) {
                return listByResourceGroupNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists all of the streaming jobs in the specified resource group.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<StreamingJobInner>> listByResourceGroupAsync(final String resourceGroupName, final ListOperationCallback<StreamingJobInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByResourceGroupSinglePageAsync(resourceGroupName),
            new Func1<String, Observable<ServiceResponse<Page<StreamingJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<StreamingJobInner>>> call(String nextPageLink) {
                    return listByResourceGroupNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists all of the streaming jobs in the specified resource group.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;StreamingJobInner&gt; object
     */
    public Observable<Page<StreamingJobInner>> listByResourceGroupAsync(final String resourceGroupName) {
        return listByResourceGroupWithServiceResponseAsync(resourceGroupName)
            .map(new Func1<ServiceResponse<Page<StreamingJobInner>>, Page<StreamingJobInner>>() {
                @Override
                public Page<StreamingJobInner> call(ServiceResponse<Page<StreamingJobInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists all of the streaming jobs in the specified resource group.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;StreamingJobInner&gt; object
     */
    public Observable<ServiceResponse<Page<StreamingJobInner>>> listByResourceGroupWithServiceResponseAsync(final String resourceGroupName) {
        return listByResourceGroupSinglePageAsync(resourceGroupName)
            .concatMap(new Func1<ServiceResponse<Page<StreamingJobInner>>, Observable<ServiceResponse<Page<StreamingJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<StreamingJobInner>>> call(ServiceResponse<Page<StreamingJobInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByResourceGroupNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists all of the streaming jobs in the specified resource group.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;StreamingJobInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<StreamingJobInner>>> listByResourceGroupSinglePageAsync(final String resourceGroupName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        final String apiVersion = "2016-03-01";
        final String expand = null;
        return service.listByResourceGroup(this.client.subscriptionId(), resourceGroupName, expand, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<StreamingJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<StreamingJobInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<StreamingJobInner>> result = listByResourceGroupDelegate(response);
                        return Observable.just(new ServiceResponse<Page<StreamingJobInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Lists all of the streaming jobs in the specified resource group.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param expand The $expand OData query parameter. This is a comma-separated list of additional streaming job properties to include in the response, beyond the default set returned when this parameter is absent. The default set is all streaming job properties other than 'inputs', 'transformation', 'outputs', and 'functions'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;StreamingJobInner&gt; object if successful.
     */
    public PagedList<StreamingJobInner> listByResourceGroup(final String resourceGroupName, final String expand) {
        ServiceResponse<Page<StreamingJobInner>> response = listByResourceGroupSinglePageAsync(resourceGroupName, expand).toBlocking().single();
        return new PagedList<StreamingJobInner>(response.body()) {
            @Override
            public Page<StreamingJobInner> nextPage(String nextPageLink) {
                return listByResourceGroupNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists all of the streaming jobs in the specified resource group.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param expand The $expand OData query parameter. This is a comma-separated list of additional streaming job properties to include in the response, beyond the default set returned when this parameter is absent. The default set is all streaming job properties other than 'inputs', 'transformation', 'outputs', and 'functions'.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<StreamingJobInner>> listByResourceGroupAsync(final String resourceGroupName, final String expand, final ListOperationCallback<StreamingJobInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByResourceGroupSinglePageAsync(resourceGroupName, expand),
            new Func1<String, Observable<ServiceResponse<Page<StreamingJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<StreamingJobInner>>> call(String nextPageLink) {
                    return listByResourceGroupNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists all of the streaming jobs in the specified resource group.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param expand The $expand OData query parameter. This is a comma-separated list of additional streaming job properties to include in the response, beyond the default set returned when this parameter is absent. The default set is all streaming job properties other than 'inputs', 'transformation', 'outputs', and 'functions'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;StreamingJobInner&gt; object
     */
    public Observable<Page<StreamingJobInner>> listByResourceGroupAsync(final String resourceGroupName, final String expand) {
        return listByResourceGroupWithServiceResponseAsync(resourceGroupName, expand)
            .map(new Func1<ServiceResponse<Page<StreamingJobInner>>, Page<StreamingJobInner>>() {
                @Override
                public Page<StreamingJobInner> call(ServiceResponse<Page<StreamingJobInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists all of the streaming jobs in the specified resource group.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param expand The $expand OData query parameter. This is a comma-separated list of additional streaming job properties to include in the response, beyond the default set returned when this parameter is absent. The default set is all streaming job properties other than 'inputs', 'transformation', 'outputs', and 'functions'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;StreamingJobInner&gt; object
     */
    public Observable<ServiceResponse<Page<StreamingJobInner>>> listByResourceGroupWithServiceResponseAsync(final String resourceGroupName, final String expand) {
        return listByResourceGroupSinglePageAsync(resourceGroupName, expand)
            .concatMap(new Func1<ServiceResponse<Page<StreamingJobInner>>, Observable<ServiceResponse<Page<StreamingJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<StreamingJobInner>>> call(ServiceResponse<Page<StreamingJobInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByResourceGroupNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists all of the streaming jobs in the specified resource group.
     *
    ServiceResponse<PageImpl<StreamingJobInner>> * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
    ServiceResponse<PageImpl<StreamingJobInner>> * @param expand The $expand OData query parameter. This is a comma-separated list of additional streaming job properties to include in the response, beyond the default set returned when this parameter is absent. The default set is all streaming job properties other than 'inputs', 'transformation', 'outputs', and 'functions'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;StreamingJobInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<StreamingJobInner>>> listByResourceGroupSinglePageAsync(final String resourceGroupName, final String expand) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        final String apiVersion = "2016-03-01";
        return service.listByResourceGroup(this.client.subscriptionId(), resourceGroupName, expand, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<StreamingJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<StreamingJobInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<StreamingJobInner>> result = listByResourceGroupDelegate(response);
                        return Observable.just(new ServiceResponse<Page<StreamingJobInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<StreamingJobInner>> listByResourceGroupDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<StreamingJobInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<StreamingJobInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Lists all of the streaming jobs in the given subscription.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;StreamingJobInner&gt; object if successful.
     */
    public PagedList<StreamingJobInner> list() {
        ServiceResponse<Page<StreamingJobInner>> response = listSinglePageAsync().toBlocking().single();
        return new PagedList<StreamingJobInner>(response.body()) {
            @Override
            public Page<StreamingJobInner> nextPage(String nextPageLink) {
                return listNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists all of the streaming jobs in the given subscription.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<StreamingJobInner>> listAsync(final ListOperationCallback<StreamingJobInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listSinglePageAsync(),
            new Func1<String, Observable<ServiceResponse<Page<StreamingJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<StreamingJobInner>>> call(String nextPageLink) {
                    return listNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists all of the streaming jobs in the given subscription.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;StreamingJobInner&gt; object
     */
    public Observable<Page<StreamingJobInner>> listAsync() {
        return listWithServiceResponseAsync()
            .map(new Func1<ServiceResponse<Page<StreamingJobInner>>, Page<StreamingJobInner>>() {
                @Override
                public Page<StreamingJobInner> call(ServiceResponse<Page<StreamingJobInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists all of the streaming jobs in the given subscription.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;StreamingJobInner&gt; object
     */
    public Observable<ServiceResponse<Page<StreamingJobInner>>> listWithServiceResponseAsync() {
        return listSinglePageAsync()
            .concatMap(new Func1<ServiceResponse<Page<StreamingJobInner>>, Observable<ServiceResponse<Page<StreamingJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<StreamingJobInner>>> call(ServiceResponse<Page<StreamingJobInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists all of the streaming jobs in the given subscription.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;StreamingJobInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<StreamingJobInner>>> listSinglePageAsync() {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-03-01";
        final String expand = null;
        return service.list(this.client.subscriptionId(), expand, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<StreamingJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<StreamingJobInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<StreamingJobInner>> result = listDelegate(response);
                        return Observable.just(new ServiceResponse<Page<StreamingJobInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Lists all of the streaming jobs in the given subscription.
     *
     * @param expand The $expand OData query parameter. This is a comma-separated list of additional streaming job properties to include in the response, beyond the default set returned when this parameter is absent. The default set is all streaming job properties other than 'inputs', 'transformation', 'outputs', and 'functions'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;StreamingJobInner&gt; object if successful.
     */
    public PagedList<StreamingJobInner> list(final String expand) {
        ServiceResponse<Page<StreamingJobInner>> response = listSinglePageAsync(expand).toBlocking().single();
        return new PagedList<StreamingJobInner>(response.body()) {
            @Override
            public Page<StreamingJobInner> nextPage(String nextPageLink) {
                return listNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists all of the streaming jobs in the given subscription.
     *
     * @param expand The $expand OData query parameter. This is a comma-separated list of additional streaming job properties to include in the response, beyond the default set returned when this parameter is absent. The default set is all streaming job properties other than 'inputs', 'transformation', 'outputs', and 'functions'.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<StreamingJobInner>> listAsync(final String expand, final ListOperationCallback<StreamingJobInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listSinglePageAsync(expand),
            new Func1<String, Observable<ServiceResponse<Page<StreamingJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<StreamingJobInner>>> call(String nextPageLink) {
                    return listNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists all of the streaming jobs in the given subscription.
     *
     * @param expand The $expand OData query parameter. This is a comma-separated list of additional streaming job properties to include in the response, beyond the default set returned when this parameter is absent. The default set is all streaming job properties other than 'inputs', 'transformation', 'outputs', and 'functions'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;StreamingJobInner&gt; object
     */
    public Observable<Page<StreamingJobInner>> listAsync(final String expand) {
        return listWithServiceResponseAsync(expand)
            .map(new Func1<ServiceResponse<Page<StreamingJobInner>>, Page<StreamingJobInner>>() {
                @Override
                public Page<StreamingJobInner> call(ServiceResponse<Page<StreamingJobInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists all of the streaming jobs in the given subscription.
     *
     * @param expand The $expand OData query parameter. This is a comma-separated list of additional streaming job properties to include in the response, beyond the default set returned when this parameter is absent. The default set is all streaming job properties other than 'inputs', 'transformation', 'outputs', and 'functions'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;StreamingJobInner&gt; object
     */
    public Observable<ServiceResponse<Page<StreamingJobInner>>> listWithServiceResponseAsync(final String expand) {
        return listSinglePageAsync(expand)
            .concatMap(new Func1<ServiceResponse<Page<StreamingJobInner>>, Observable<ServiceResponse<Page<StreamingJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<StreamingJobInner>>> call(ServiceResponse<Page<StreamingJobInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists all of the streaming jobs in the given subscription.
     *
    ServiceResponse<PageImpl<StreamingJobInner>> * @param expand The $expand OData query parameter. This is a comma-separated list of additional streaming job properties to include in the response, beyond the default set returned when this parameter is absent. The default set is all streaming job properties other than 'inputs', 'transformation', 'outputs', and 'functions'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;StreamingJobInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<StreamingJobInner>>> listSinglePageAsync(final String expand) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-03-01";
        return service.list(this.client.subscriptionId(), expand, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<StreamingJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<StreamingJobInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<StreamingJobInner>> result = listDelegate(response);
                        return Observable.just(new ServiceResponse<Page<StreamingJobInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<StreamingJobInner>> listDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<StreamingJobInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<StreamingJobInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Starts a streaming job. Once a job is started it will start processing input events and produce output.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void start(String resourceGroupName, String jobName) {
        startWithServiceResponseAsync(resourceGroupName, jobName).toBlocking().last().body();
    }

    /**
     * Starts a streaming job. Once a job is started it will start processing input events and produce output.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> startAsync(String resourceGroupName, String jobName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(startWithServiceResponseAsync(resourceGroupName, jobName), serviceCallback);
    }

    /**
     * Starts a streaming job. Once a job is started it will start processing input events and produce output.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<Void> startAsync(String resourceGroupName, String jobName) {
        return startWithServiceResponseAsync(resourceGroupName, jobName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Starts a streaming job. Once a job is started it will start processing input events and produce output.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<Void>> startWithServiceResponseAsync(String resourceGroupName, String jobName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        final String apiVersion = "2016-03-01";
        final StartStreamingJobParametersInner startJobParameters = null;
        Observable<Response<ResponseBody>> observable = service.start(this.client.subscriptionId(), resourceGroupName, jobName, startJobParameters, apiVersion, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<Void>() { }.getType());
    }
    /**
     * Starts a streaming job. Once a job is started it will start processing input events and produce output.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param startJobParameters Parameters applicable to a start streaming job operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void start(String resourceGroupName, String jobName, StartStreamingJobParametersInner startJobParameters) {
        startWithServiceResponseAsync(resourceGroupName, jobName, startJobParameters).toBlocking().last().body();
    }

    /**
     * Starts a streaming job. Once a job is started it will start processing input events and produce output.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param startJobParameters Parameters applicable to a start streaming job operation.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> startAsync(String resourceGroupName, String jobName, StartStreamingJobParametersInner startJobParameters, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(startWithServiceResponseAsync(resourceGroupName, jobName, startJobParameters), serviceCallback);
    }

    /**
     * Starts a streaming job. Once a job is started it will start processing input events and produce output.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param startJobParameters Parameters applicable to a start streaming job operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<Void> startAsync(String resourceGroupName, String jobName, StartStreamingJobParametersInner startJobParameters) {
        return startWithServiceResponseAsync(resourceGroupName, jobName, startJobParameters).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Starts a streaming job. Once a job is started it will start processing input events and produce output.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param startJobParameters Parameters applicable to a start streaming job operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<Void>> startWithServiceResponseAsync(String resourceGroupName, String jobName, StartStreamingJobParametersInner startJobParameters) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        Validator.validate(startJobParameters);
        final String apiVersion = "2016-03-01";
        Observable<Response<ResponseBody>> observable = service.start(this.client.subscriptionId(), resourceGroupName, jobName, startJobParameters, apiVersion, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<Void>() { }.getType());
    }

    /**
     * Starts a streaming job. Once a job is started it will start processing input events and produce output.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void beginStart(String resourceGroupName, String jobName) {
        beginStartWithServiceResponseAsync(resourceGroupName, jobName).toBlocking().single().body();
    }

    /**
     * Starts a streaming job. Once a job is started it will start processing input events and produce output.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> beginStartAsync(String resourceGroupName, String jobName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(beginStartWithServiceResponseAsync(resourceGroupName, jobName), serviceCallback);
    }

    /**
     * Starts a streaming job. Once a job is started it will start processing input events and produce output.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> beginStartAsync(String resourceGroupName, String jobName) {
        return beginStartWithServiceResponseAsync(resourceGroupName, jobName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Starts a streaming job. Once a job is started it will start processing input events and produce output.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> beginStartWithServiceResponseAsync(String resourceGroupName, String jobName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        final String apiVersion = "2016-03-01";
        final StartStreamingJobParametersInner startJobParameters = null;
        return service.beginStart(this.client.subscriptionId(), resourceGroupName, jobName, startJobParameters, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = beginStartDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Starts a streaming job. Once a job is started it will start processing input events and produce output.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param startJobParameters Parameters applicable to a start streaming job operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void beginStart(String resourceGroupName, String jobName, StartStreamingJobParametersInner startJobParameters) {
        beginStartWithServiceResponseAsync(resourceGroupName, jobName, startJobParameters).toBlocking().single().body();
    }

    /**
     * Starts a streaming job. Once a job is started it will start processing input events and produce output.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param startJobParameters Parameters applicable to a start streaming job operation.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> beginStartAsync(String resourceGroupName, String jobName, StartStreamingJobParametersInner startJobParameters, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(beginStartWithServiceResponseAsync(resourceGroupName, jobName, startJobParameters), serviceCallback);
    }

    /**
     * Starts a streaming job. Once a job is started it will start processing input events and produce output.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param startJobParameters Parameters applicable to a start streaming job operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> beginStartAsync(String resourceGroupName, String jobName, StartStreamingJobParametersInner startJobParameters) {
        return beginStartWithServiceResponseAsync(resourceGroupName, jobName, startJobParameters).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Starts a streaming job. Once a job is started it will start processing input events and produce output.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param startJobParameters Parameters applicable to a start streaming job operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> beginStartWithServiceResponseAsync(String resourceGroupName, String jobName, StartStreamingJobParametersInner startJobParameters) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        Validator.validate(startJobParameters);
        final String apiVersion = "2016-03-01";
        return service.beginStart(this.client.subscriptionId(), resourceGroupName, jobName, startJobParameters, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = beginStartDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> beginStartDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Stops a running streaming job. This will cause a running streaming job to stop processing input events and producing output.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void stop(String resourceGroupName, String jobName) {
        stopWithServiceResponseAsync(resourceGroupName, jobName).toBlocking().last().body();
    }

    /**
     * Stops a running streaming job. This will cause a running streaming job to stop processing input events and producing output.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> stopAsync(String resourceGroupName, String jobName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(stopWithServiceResponseAsync(resourceGroupName, jobName), serviceCallback);
    }

    /**
     * Stops a running streaming job. This will cause a running streaming job to stop processing input events and producing output.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<Void> stopAsync(String resourceGroupName, String jobName) {
        return stopWithServiceResponseAsync(resourceGroupName, jobName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Stops a running streaming job. This will cause a running streaming job to stop processing input events and producing output.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<Void>> stopWithServiceResponseAsync(String resourceGroupName, String jobName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        final String apiVersion = "2016-03-01";
        Observable<Response<ResponseBody>> observable = service.stop(this.client.subscriptionId(), resourceGroupName, jobName, apiVersion, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<Void>() { }.getType());
    }

    /**
     * Stops a running streaming job. This will cause a running streaming job to stop processing input events and producing output.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void beginStop(String resourceGroupName, String jobName) {
        beginStopWithServiceResponseAsync(resourceGroupName, jobName).toBlocking().single().body();
    }

    /**
     * Stops a running streaming job. This will cause a running streaming job to stop processing input events and producing output.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> beginStopAsync(String resourceGroupName, String jobName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(beginStopWithServiceResponseAsync(resourceGroupName, jobName), serviceCallback);
    }

    /**
     * Stops a running streaming job. This will cause a running streaming job to stop processing input events and producing output.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> beginStopAsync(String resourceGroupName, String jobName) {
        return beginStopWithServiceResponseAsync(resourceGroupName, jobName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Stops a running streaming job. This will cause a running streaming job to stop processing input events and producing output.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> beginStopWithServiceResponseAsync(String resourceGroupName, String jobName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        final String apiVersion = "2016-03-01";
        return service.beginStop(this.client.subscriptionId(), resourceGroupName, jobName, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = beginStopDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> beginStopDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Lists all of the streaming jobs in the specified resource group.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;StreamingJobInner&gt; object if successful.
     */
    public PagedList<StreamingJobInner> listByResourceGroupNext(final String nextPageLink) {
        ServiceResponse<Page<StreamingJobInner>> response = listByResourceGroupNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<StreamingJobInner>(response.body()) {
            @Override
            public Page<StreamingJobInner> nextPage(String nextPageLink) {
                return listByResourceGroupNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists all of the streaming jobs in the specified resource group.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<StreamingJobInner>> listByResourceGroupNextAsync(final String nextPageLink, final ServiceFuture<List<StreamingJobInner>> serviceFuture, final ListOperationCallback<StreamingJobInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByResourceGroupNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<StreamingJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<StreamingJobInner>>> call(String nextPageLink) {
                    return listByResourceGroupNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists all of the streaming jobs in the specified resource group.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;StreamingJobInner&gt; object
     */
    public Observable<Page<StreamingJobInner>> listByResourceGroupNextAsync(final String nextPageLink) {
        return listByResourceGroupNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<StreamingJobInner>>, Page<StreamingJobInner>>() {
                @Override
                public Page<StreamingJobInner> call(ServiceResponse<Page<StreamingJobInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists all of the streaming jobs in the specified resource group.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;StreamingJobInner&gt; object
     */
    public Observable<ServiceResponse<Page<StreamingJobInner>>> listByResourceGroupNextWithServiceResponseAsync(final String nextPageLink) {
        return listByResourceGroupNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<StreamingJobInner>>, Observable<ServiceResponse<Page<StreamingJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<StreamingJobInner>>> call(ServiceResponse<Page<StreamingJobInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByResourceGroupNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists all of the streaming jobs in the specified resource group.
     *
    ServiceResponse<PageImpl<StreamingJobInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;StreamingJobInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<StreamingJobInner>>> listByResourceGroupNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listByResourceGroupNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<StreamingJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<StreamingJobInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<StreamingJobInner>> result = listByResourceGroupNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<StreamingJobInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<StreamingJobInner>> listByResourceGroupNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<StreamingJobInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<StreamingJobInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Lists all of the streaming jobs in the given subscription.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;StreamingJobInner&gt; object if successful.
     */
    public PagedList<StreamingJobInner> listNext(final String nextPageLink) {
        ServiceResponse<Page<StreamingJobInner>> response = listNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<StreamingJobInner>(response.body()) {
            @Override
            public Page<StreamingJobInner> nextPage(String nextPageLink) {
                return listNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists all of the streaming jobs in the given subscription.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<StreamingJobInner>> listNextAsync(final String nextPageLink, final ServiceFuture<List<StreamingJobInner>> serviceFuture, final ListOperationCallback<StreamingJobInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<StreamingJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<StreamingJobInner>>> call(String nextPageLink) {
                    return listNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists all of the streaming jobs in the given subscription.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;StreamingJobInner&gt; object
     */
    public Observable<Page<StreamingJobInner>> listNextAsync(final String nextPageLink) {
        return listNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<StreamingJobInner>>, Page<StreamingJobInner>>() {
                @Override
                public Page<StreamingJobInner> call(ServiceResponse<Page<StreamingJobInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists all of the streaming jobs in the given subscription.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;StreamingJobInner&gt; object
     */
    public Observable<ServiceResponse<Page<StreamingJobInner>>> listNextWithServiceResponseAsync(final String nextPageLink) {
        return listNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<StreamingJobInner>>, Observable<ServiceResponse<Page<StreamingJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<StreamingJobInner>>> call(ServiceResponse<Page<StreamingJobInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists all of the streaming jobs in the given subscription.
     *
    ServiceResponse<PageImpl<StreamingJobInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;StreamingJobInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<StreamingJobInner>>> listNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<StreamingJobInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<StreamingJobInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<StreamingJobInner>> result = listNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<StreamingJobInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<StreamingJobInner>> listNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<StreamingJobInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<StreamingJobInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

}
