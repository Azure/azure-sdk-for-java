/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 */
package com.microsoft.azure.management.network.implementation;

import com.microsoft.azure.management.apigeneration.LangDefinition;
import com.microsoft.azure.management.network.PublicIpAddress;
import com.microsoft.azure.management.resources.fluentcore.arm.models.Resource;
import com.microsoft.azure.management.resources.fluentcore.arm.models.implementation.GroupableParentResourceImpl;
import com.microsoft.azure.management.resources.fluentcore.model.Creatable;

import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;

/**
 * Base impl for some networking-related classes.
 * @param <FluentT> the wrapper interface
 * @param <InnerT> the wrapped inner type
 * @param <FluentImplT> the wrapper impl type
 * @param <InnerCollectionT> the inner collection (client) type
 */
@LangDefinition
abstract class NetworkGroupableParentResourceImpl<
        FluentT extends Resource,
        InnerT extends com.microsoft.azure.Resource,
        FluentImplT extends NetworkGroupableParentResourceImpl<FluentT, InnerT, FluentImplT, InnerCollectionT>,
        InnerCollectionT>
    extends GroupableParentResourceImpl<
        FluentT,
        InnerT,
        FluentImplT,
        NetworkManager> {

    protected static final String DEFAULT = "default";
    protected final Map<String, String> creatablePIPKeys = new HashMap<>();
    protected final InnerCollectionT innerCollection;

    NetworkGroupableParentResourceImpl(String name,
            final InnerT innerModel,
            final InnerCollectionT innerCollection,
            final NetworkManager networkManager) {
        super(name, innerModel, networkManager);
        this.innerCollection = innerCollection;
    }

    // Verbs

    // Helpers

    abstract FluentImplT withExistingPublicIpAddress(String resourceId, String childName);

    @Override
    protected void beforeCreating()  {
        // Account for the newly created public IPs
        for (Entry<String, String> pipFrontendAssociation : this.creatablePIPKeys.entrySet()) {
            PublicIpAddress pip = (PublicIpAddress) this.createdResource(pipFrontendAssociation.getKey());
            if (pip != null) {
                withExistingPublicIpAddress(pip.id(), pipFrontendAssociation.getValue());
            }
        }
        this.creatablePIPKeys.clear();
    }

    NetworkManager manager() {
        return this.myManager;
    }

    @SuppressWarnings("unchecked")
    public FluentImplT withNewPublicIpAddress(Creatable<PublicIpAddress> creatablePIP) {
        this.creatablePIPKeys.put(creatablePIP.key(), DEFAULT);
        this.addCreatableDependency(creatablePIP);
        return (FluentImplT) this;
    }

    public FluentImplT withExistingPublicIpAddress(PublicIpAddress pip) {
        return withExistingPublicIpAddress(pip.id(), DEFAULT);
    }

    public FluentImplT withExistingPublicIpAddress(String resourceId) {
        return withExistingPublicIpAddress(resourceId, DEFAULT);
    }

    public FluentImplT withNewPublicIpAddress() {
        // Autogenerated DNS leaf label for the PIP
        String dnsLeafLabel = this.name().toLowerCase().replace("\\s", "");
        return withNewPublicIpAddress(dnsLeafLabel);
    }

    public FluentImplT withNewPublicIpAddress(String dnsLeafLabel) {
        PublicIpAddress.DefinitionStages.WithGroup precreatablePIP = manager().publicIpAddresses().define(dnsLeafLabel)
                .withRegion(this.regionName());
        Creatable<PublicIpAddress> creatablePip;
        if (super.creatableGroup == null) {
            creatablePip = precreatablePIP.withExistingResourceGroup(this.resourceGroupName());
        } else {
            creatablePip = precreatablePIP.withNewResourceGroup(super.creatableGroup);
        }

        return withNewPublicIpAddress(creatablePip);
    }
}