/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.management.streamanalytics.v2016_03_01.implementation;

import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.AzureServiceFuture;
import com.microsoft.azure.CloudException;
import com.microsoft.azure.ListOperationCallback;
import com.microsoft.azure.management.streamanalytics.v2016_03_01.InputsCreateOrReplaceHeaders;
import com.microsoft.azure.management.streamanalytics.v2016_03_01.InputsGetHeaders;
import com.microsoft.azure.management.streamanalytics.v2016_03_01.InputsUpdateHeaders;
import com.microsoft.azure.Page;
import com.microsoft.azure.PagedList;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.ServiceResponseWithHeaders;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.List;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.PATCH;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.http.Url;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in Inputs.
 */
public class InputsInner {
    /** The Retrofit service to perform REST calls. */
    private InputsService service;
    /** The service client containing this operation class. */
    private StreamAnalyticsManagementClientImpl client;

    /**
     * Initializes an instance of InputsInner.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public InputsInner(Retrofit retrofit, StreamAnalyticsManagementClientImpl client) {
        this.service = retrofit.create(InputsService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for Inputs to be
     * used by Retrofit to perform actually REST calls.
     */
    interface InputsService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.streamanalytics.v2016_03_01.Inputs createOrReplace" })
        @PUT("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/inputs/{inputName}")
        Observable<Response<ResponseBody>> createOrReplace(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("jobName") String jobName, @Path("inputName") String inputName, @Body InputInner input, @Header("If-Match") String ifMatch, @Header("If-None-Match") String ifNoneMatch, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.streamanalytics.v2016_03_01.Inputs update" })
        @PATCH("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/inputs/{inputName}")
        Observable<Response<ResponseBody>> update(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("jobName") String jobName, @Path("inputName") String inputName, @Body InputInner input, @Header("If-Match") String ifMatch, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.streamanalytics.v2016_03_01.Inputs delete" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/inputs/{inputName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> delete(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("jobName") String jobName, @Path("inputName") String inputName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.streamanalytics.v2016_03_01.Inputs get" })
        @GET("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/inputs/{inputName}")
        Observable<Response<ResponseBody>> get(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("jobName") String jobName, @Path("inputName") String inputName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.streamanalytics.v2016_03_01.Inputs listByStreamingJob" })
        @GET("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/inputs")
        Observable<Response<ResponseBody>> listByStreamingJob(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("jobName") String jobName, @Query("$select") String select, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.streamanalytics.v2016_03_01.Inputs test" })
        @POST("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/inputs/{inputName}/test")
        Observable<Response<ResponseBody>> test(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("jobName") String jobName, @Path("inputName") String inputName, @Body InputInner input, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.streamanalytics.v2016_03_01.Inputs beginTest" })
        @POST("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StreamAnalytics/streamingjobs/{jobName}/inputs/{inputName}/test")
        Observable<Response<ResponseBody>> beginTest(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("jobName") String jobName, @Path("inputName") String inputName, @Body InputInner input, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.streamanalytics.v2016_03_01.Inputs listByStreamingJobNext" })
        @GET
        Observable<Response<ResponseBody>> listByStreamingJobNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

    }

    /**
     * Creates an input or replaces an already existing input under an existing streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param inputName The name of the input.
     * @param input The definition of the input that will be used to create a new input or replace the existing one under the streaming job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the InputInner object if successful.
     */
    public InputInner createOrReplace(String resourceGroupName, String jobName, String inputName, InputInner input) {
        return createOrReplaceWithServiceResponseAsync(resourceGroupName, jobName, inputName, input).toBlocking().single().body();
    }

    /**
     * Creates an input or replaces an already existing input under an existing streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param inputName The name of the input.
     * @param input The definition of the input that will be used to create a new input or replace the existing one under the streaming job.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<InputInner> createOrReplaceAsync(String resourceGroupName, String jobName, String inputName, InputInner input, final ServiceCallback<InputInner> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createOrReplaceWithServiceResponseAsync(resourceGroupName, jobName, inputName, input), serviceCallback);
    }

    /**
     * Creates an input or replaces an already existing input under an existing streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param inputName The name of the input.
     * @param input The definition of the input that will be used to create a new input or replace the existing one under the streaming job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the InputInner object
     */
    public Observable<InputInner> createOrReplaceAsync(String resourceGroupName, String jobName, String inputName, InputInner input) {
        return createOrReplaceWithServiceResponseAsync(resourceGroupName, jobName, inputName, input).map(new Func1<ServiceResponseWithHeaders<InputInner, InputsCreateOrReplaceHeaders>, InputInner>() {
            @Override
            public InputInner call(ServiceResponseWithHeaders<InputInner, InputsCreateOrReplaceHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates an input or replaces an already existing input under an existing streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param inputName The name of the input.
     * @param input The definition of the input that will be used to create a new input or replace the existing one under the streaming job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the InputInner object
     */
    public Observable<ServiceResponseWithHeaders<InputInner, InputsCreateOrReplaceHeaders>> createOrReplaceWithServiceResponseAsync(String resourceGroupName, String jobName, String inputName, InputInner input) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        if (inputName == null) {
            throw new IllegalArgumentException("Parameter inputName is required and cannot be null.");
        }
        if (input == null) {
            throw new IllegalArgumentException("Parameter input is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(input);
        final String ifMatch = null;
        final String ifNoneMatch = null;
        return service.createOrReplace(this.client.subscriptionId(), resourceGroupName, jobName, inputName, input, ifMatch, ifNoneMatch, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<InputInner, InputsCreateOrReplaceHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<InputInner, InputsCreateOrReplaceHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<InputInner, InputsCreateOrReplaceHeaders> clientResponse = createOrReplaceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Creates an input or replaces an already existing input under an existing streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param inputName The name of the input.
     * @param input The definition of the input that will be used to create a new input or replace the existing one under the streaming job.
     * @param ifMatch The ETag of the input. Omit this value to always overwrite the current input. Specify the last-seen ETag value to prevent accidentally overwritting concurrent changes.
     * @param ifNoneMatch Set to '*' to allow a new input to be created, but to prevent updating an existing input. Other values will result in a 412 Pre-condition Failed response.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the InputInner object if successful.
     */
    public InputInner createOrReplace(String resourceGroupName, String jobName, String inputName, InputInner input, String ifMatch, String ifNoneMatch) {
        return createOrReplaceWithServiceResponseAsync(resourceGroupName, jobName, inputName, input, ifMatch, ifNoneMatch).toBlocking().single().body();
    }

    /**
     * Creates an input or replaces an already existing input under an existing streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param inputName The name of the input.
     * @param input The definition of the input that will be used to create a new input or replace the existing one under the streaming job.
     * @param ifMatch The ETag of the input. Omit this value to always overwrite the current input. Specify the last-seen ETag value to prevent accidentally overwritting concurrent changes.
     * @param ifNoneMatch Set to '*' to allow a new input to be created, but to prevent updating an existing input. Other values will result in a 412 Pre-condition Failed response.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<InputInner> createOrReplaceAsync(String resourceGroupName, String jobName, String inputName, InputInner input, String ifMatch, String ifNoneMatch, final ServiceCallback<InputInner> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createOrReplaceWithServiceResponseAsync(resourceGroupName, jobName, inputName, input, ifMatch, ifNoneMatch), serviceCallback);
    }

    /**
     * Creates an input or replaces an already existing input under an existing streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param inputName The name of the input.
     * @param input The definition of the input that will be used to create a new input or replace the existing one under the streaming job.
     * @param ifMatch The ETag of the input. Omit this value to always overwrite the current input. Specify the last-seen ETag value to prevent accidentally overwritting concurrent changes.
     * @param ifNoneMatch Set to '*' to allow a new input to be created, but to prevent updating an existing input. Other values will result in a 412 Pre-condition Failed response.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the InputInner object
     */
    public Observable<InputInner> createOrReplaceAsync(String resourceGroupName, String jobName, String inputName, InputInner input, String ifMatch, String ifNoneMatch) {
        return createOrReplaceWithServiceResponseAsync(resourceGroupName, jobName, inputName, input, ifMatch, ifNoneMatch).map(new Func1<ServiceResponseWithHeaders<InputInner, InputsCreateOrReplaceHeaders>, InputInner>() {
            @Override
            public InputInner call(ServiceResponseWithHeaders<InputInner, InputsCreateOrReplaceHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates an input or replaces an already existing input under an existing streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param inputName The name of the input.
     * @param input The definition of the input that will be used to create a new input or replace the existing one under the streaming job.
     * @param ifMatch The ETag of the input. Omit this value to always overwrite the current input. Specify the last-seen ETag value to prevent accidentally overwritting concurrent changes.
     * @param ifNoneMatch Set to '*' to allow a new input to be created, but to prevent updating an existing input. Other values will result in a 412 Pre-condition Failed response.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the InputInner object
     */
    public Observable<ServiceResponseWithHeaders<InputInner, InputsCreateOrReplaceHeaders>> createOrReplaceWithServiceResponseAsync(String resourceGroupName, String jobName, String inputName, InputInner input, String ifMatch, String ifNoneMatch) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        if (inputName == null) {
            throw new IllegalArgumentException("Parameter inputName is required and cannot be null.");
        }
        if (input == null) {
            throw new IllegalArgumentException("Parameter input is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(input);
        return service.createOrReplace(this.client.subscriptionId(), resourceGroupName, jobName, inputName, input, ifMatch, ifNoneMatch, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<InputInner, InputsCreateOrReplaceHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<InputInner, InputsCreateOrReplaceHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<InputInner, InputsCreateOrReplaceHeaders> clientResponse = createOrReplaceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<InputInner, InputsCreateOrReplaceHeaders> createOrReplaceDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<InputInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<InputInner>() { }.getType())
                .register(201, new TypeToken<InputInner>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, InputsCreateOrReplaceHeaders.class);
    }

    /**
     * Updates an existing input under an existing streaming job. This can be used to partially update (ie. update one or two properties) an input without affecting the rest the job or input definition.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param inputName The name of the input.
     * @param input An Input object. The properties specified here will overwrite the corresponding properties in the existing input (ie. Those properties will be updated). Any properties that are set to null here will mean that the corresponding property in the existing input will remain the same and not change as a result of this PATCH operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the InputInner object if successful.
     */
    public InputInner update(String resourceGroupName, String jobName, String inputName, InputInner input) {
        return updateWithServiceResponseAsync(resourceGroupName, jobName, inputName, input).toBlocking().single().body();
    }

    /**
     * Updates an existing input under an existing streaming job. This can be used to partially update (ie. update one or two properties) an input without affecting the rest the job or input definition.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param inputName The name of the input.
     * @param input An Input object. The properties specified here will overwrite the corresponding properties in the existing input (ie. Those properties will be updated). Any properties that are set to null here will mean that the corresponding property in the existing input will remain the same and not change as a result of this PATCH operation.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<InputInner> updateAsync(String resourceGroupName, String jobName, String inputName, InputInner input, final ServiceCallback<InputInner> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateWithServiceResponseAsync(resourceGroupName, jobName, inputName, input), serviceCallback);
    }

    /**
     * Updates an existing input under an existing streaming job. This can be used to partially update (ie. update one or two properties) an input without affecting the rest the job or input definition.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param inputName The name of the input.
     * @param input An Input object. The properties specified here will overwrite the corresponding properties in the existing input (ie. Those properties will be updated). Any properties that are set to null here will mean that the corresponding property in the existing input will remain the same and not change as a result of this PATCH operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the InputInner object
     */
    public Observable<InputInner> updateAsync(String resourceGroupName, String jobName, String inputName, InputInner input) {
        return updateWithServiceResponseAsync(resourceGroupName, jobName, inputName, input).map(new Func1<ServiceResponseWithHeaders<InputInner, InputsUpdateHeaders>, InputInner>() {
            @Override
            public InputInner call(ServiceResponseWithHeaders<InputInner, InputsUpdateHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates an existing input under an existing streaming job. This can be used to partially update (ie. update one or two properties) an input without affecting the rest the job or input definition.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param inputName The name of the input.
     * @param input An Input object. The properties specified here will overwrite the corresponding properties in the existing input (ie. Those properties will be updated). Any properties that are set to null here will mean that the corresponding property in the existing input will remain the same and not change as a result of this PATCH operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the InputInner object
     */
    public Observable<ServiceResponseWithHeaders<InputInner, InputsUpdateHeaders>> updateWithServiceResponseAsync(String resourceGroupName, String jobName, String inputName, InputInner input) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        if (inputName == null) {
            throw new IllegalArgumentException("Parameter inputName is required and cannot be null.");
        }
        if (input == null) {
            throw new IllegalArgumentException("Parameter input is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(input);
        final String ifMatch = null;
        return service.update(this.client.subscriptionId(), resourceGroupName, jobName, inputName, input, ifMatch, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<InputInner, InputsUpdateHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<InputInner, InputsUpdateHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<InputInner, InputsUpdateHeaders> clientResponse = updateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Updates an existing input under an existing streaming job. This can be used to partially update (ie. update one or two properties) an input without affecting the rest the job or input definition.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param inputName The name of the input.
     * @param input An Input object. The properties specified here will overwrite the corresponding properties in the existing input (ie. Those properties will be updated). Any properties that are set to null here will mean that the corresponding property in the existing input will remain the same and not change as a result of this PATCH operation.
     * @param ifMatch The ETag of the input. Omit this value to always overwrite the current input. Specify the last-seen ETag value to prevent accidentally overwritting concurrent changes.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the InputInner object if successful.
     */
    public InputInner update(String resourceGroupName, String jobName, String inputName, InputInner input, String ifMatch) {
        return updateWithServiceResponseAsync(resourceGroupName, jobName, inputName, input, ifMatch).toBlocking().single().body();
    }

    /**
     * Updates an existing input under an existing streaming job. This can be used to partially update (ie. update one or two properties) an input without affecting the rest the job or input definition.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param inputName The name of the input.
     * @param input An Input object. The properties specified here will overwrite the corresponding properties in the existing input (ie. Those properties will be updated). Any properties that are set to null here will mean that the corresponding property in the existing input will remain the same and not change as a result of this PATCH operation.
     * @param ifMatch The ETag of the input. Omit this value to always overwrite the current input. Specify the last-seen ETag value to prevent accidentally overwritting concurrent changes.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<InputInner> updateAsync(String resourceGroupName, String jobName, String inputName, InputInner input, String ifMatch, final ServiceCallback<InputInner> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateWithServiceResponseAsync(resourceGroupName, jobName, inputName, input, ifMatch), serviceCallback);
    }

    /**
     * Updates an existing input under an existing streaming job. This can be used to partially update (ie. update one or two properties) an input without affecting the rest the job or input definition.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param inputName The name of the input.
     * @param input An Input object. The properties specified here will overwrite the corresponding properties in the existing input (ie. Those properties will be updated). Any properties that are set to null here will mean that the corresponding property in the existing input will remain the same and not change as a result of this PATCH operation.
     * @param ifMatch The ETag of the input. Omit this value to always overwrite the current input. Specify the last-seen ETag value to prevent accidentally overwritting concurrent changes.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the InputInner object
     */
    public Observable<InputInner> updateAsync(String resourceGroupName, String jobName, String inputName, InputInner input, String ifMatch) {
        return updateWithServiceResponseAsync(resourceGroupName, jobName, inputName, input, ifMatch).map(new Func1<ServiceResponseWithHeaders<InputInner, InputsUpdateHeaders>, InputInner>() {
            @Override
            public InputInner call(ServiceResponseWithHeaders<InputInner, InputsUpdateHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates an existing input under an existing streaming job. This can be used to partially update (ie. update one or two properties) an input without affecting the rest the job or input definition.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param inputName The name of the input.
     * @param input An Input object. The properties specified here will overwrite the corresponding properties in the existing input (ie. Those properties will be updated). Any properties that are set to null here will mean that the corresponding property in the existing input will remain the same and not change as a result of this PATCH operation.
     * @param ifMatch The ETag of the input. Omit this value to always overwrite the current input. Specify the last-seen ETag value to prevent accidentally overwritting concurrent changes.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the InputInner object
     */
    public Observable<ServiceResponseWithHeaders<InputInner, InputsUpdateHeaders>> updateWithServiceResponseAsync(String resourceGroupName, String jobName, String inputName, InputInner input, String ifMatch) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        if (inputName == null) {
            throw new IllegalArgumentException("Parameter inputName is required and cannot be null.");
        }
        if (input == null) {
            throw new IllegalArgumentException("Parameter input is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(input);
        return service.update(this.client.subscriptionId(), resourceGroupName, jobName, inputName, input, ifMatch, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<InputInner, InputsUpdateHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<InputInner, InputsUpdateHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<InputInner, InputsUpdateHeaders> clientResponse = updateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<InputInner, InputsUpdateHeaders> updateDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<InputInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<InputInner>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, InputsUpdateHeaders.class);
    }

    /**
     * Deletes an input from the streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param inputName The name of the input.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void delete(String resourceGroupName, String jobName, String inputName) {
        deleteWithServiceResponseAsync(resourceGroupName, jobName, inputName).toBlocking().single().body();
    }

    /**
     * Deletes an input from the streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param inputName The name of the input.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteAsync(String resourceGroupName, String jobName, String inputName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteWithServiceResponseAsync(resourceGroupName, jobName, inputName), serviceCallback);
    }

    /**
     * Deletes an input from the streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param inputName The name of the input.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteAsync(String resourceGroupName, String jobName, String inputName) {
        return deleteWithServiceResponseAsync(resourceGroupName, jobName, inputName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes an input from the streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param inputName The name of the input.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteWithServiceResponseAsync(String resourceGroupName, String jobName, String inputName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        if (inputName == null) {
            throw new IllegalArgumentException("Parameter inputName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.delete(this.client.subscriptionId(), resourceGroupName, jobName, inputName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets details about the specified input.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param inputName The name of the input.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the InputInner object if successful.
     */
    public InputInner get(String resourceGroupName, String jobName, String inputName) {
        return getWithServiceResponseAsync(resourceGroupName, jobName, inputName).toBlocking().single().body();
    }

    /**
     * Gets details about the specified input.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param inputName The name of the input.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<InputInner> getAsync(String resourceGroupName, String jobName, String inputName, final ServiceCallback<InputInner> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getWithServiceResponseAsync(resourceGroupName, jobName, inputName), serviceCallback);
    }

    /**
     * Gets details about the specified input.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param inputName The name of the input.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the InputInner object
     */
    public Observable<InputInner> getAsync(String resourceGroupName, String jobName, String inputName) {
        return getWithServiceResponseAsync(resourceGroupName, jobName, inputName).map(new Func1<ServiceResponseWithHeaders<InputInner, InputsGetHeaders>, InputInner>() {
            @Override
            public InputInner call(ServiceResponseWithHeaders<InputInner, InputsGetHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets details about the specified input.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param inputName The name of the input.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the InputInner object
     */
    public Observable<ServiceResponseWithHeaders<InputInner, InputsGetHeaders>> getWithServiceResponseAsync(String resourceGroupName, String jobName, String inputName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        if (inputName == null) {
            throw new IllegalArgumentException("Parameter inputName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.get(this.client.subscriptionId(), resourceGroupName, jobName, inputName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<InputInner, InputsGetHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<InputInner, InputsGetHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<InputInner, InputsGetHeaders> clientResponse = getDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<InputInner, InputsGetHeaders> getDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<InputInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<InputInner>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, InputsGetHeaders.class);
    }

    /**
     * Lists all of the inputs under the specified streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;InputInner&gt; object if successful.
     */
    public PagedList<InputInner> listByStreamingJob(final String resourceGroupName, final String jobName) {
        ServiceResponse<Page<InputInner>> response = listByStreamingJobSinglePageAsync(resourceGroupName, jobName).toBlocking().single();
        return new PagedList<InputInner>(response.body()) {
            @Override
            public Page<InputInner> nextPage(String nextPageLink) {
                return listByStreamingJobNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists all of the inputs under the specified streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<InputInner>> listByStreamingJobAsync(final String resourceGroupName, final String jobName, final ListOperationCallback<InputInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByStreamingJobSinglePageAsync(resourceGroupName, jobName),
            new Func1<String, Observable<ServiceResponse<Page<InputInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<InputInner>>> call(String nextPageLink) {
                    return listByStreamingJobNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists all of the inputs under the specified streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;InputInner&gt; object
     */
    public Observable<Page<InputInner>> listByStreamingJobAsync(final String resourceGroupName, final String jobName) {
        return listByStreamingJobWithServiceResponseAsync(resourceGroupName, jobName)
            .map(new Func1<ServiceResponse<Page<InputInner>>, Page<InputInner>>() {
                @Override
                public Page<InputInner> call(ServiceResponse<Page<InputInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists all of the inputs under the specified streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;InputInner&gt; object
     */
    public Observable<ServiceResponse<Page<InputInner>>> listByStreamingJobWithServiceResponseAsync(final String resourceGroupName, final String jobName) {
        return listByStreamingJobSinglePageAsync(resourceGroupName, jobName)
            .concatMap(new Func1<ServiceResponse<Page<InputInner>>, Observable<ServiceResponse<Page<InputInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<InputInner>>> call(ServiceResponse<Page<InputInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByStreamingJobNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists all of the inputs under the specified streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;InputInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<InputInner>>> listByStreamingJobSinglePageAsync(final String resourceGroupName, final String jobName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String select = null;
        return service.listByStreamingJob(this.client.subscriptionId(), resourceGroupName, jobName, select, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<InputInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<InputInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<InputInner>> result = listByStreamingJobDelegate(response);
                        return Observable.just(new ServiceResponse<Page<InputInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Lists all of the inputs under the specified streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param select The $select OData query parameter. This is a comma-separated list of structural properties to include in the response, or * to include all properties. By default, all properties are returned except diagnostics. Currently only accepts '*' as a valid value.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;InputInner&gt; object if successful.
     */
    public PagedList<InputInner> listByStreamingJob(final String resourceGroupName, final String jobName, final String select) {
        ServiceResponse<Page<InputInner>> response = listByStreamingJobSinglePageAsync(resourceGroupName, jobName, select).toBlocking().single();
        return new PagedList<InputInner>(response.body()) {
            @Override
            public Page<InputInner> nextPage(String nextPageLink) {
                return listByStreamingJobNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists all of the inputs under the specified streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param select The $select OData query parameter. This is a comma-separated list of structural properties to include in the response, or * to include all properties. By default, all properties are returned except diagnostics. Currently only accepts '*' as a valid value.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<InputInner>> listByStreamingJobAsync(final String resourceGroupName, final String jobName, final String select, final ListOperationCallback<InputInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByStreamingJobSinglePageAsync(resourceGroupName, jobName, select),
            new Func1<String, Observable<ServiceResponse<Page<InputInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<InputInner>>> call(String nextPageLink) {
                    return listByStreamingJobNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists all of the inputs under the specified streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param select The $select OData query parameter. This is a comma-separated list of structural properties to include in the response, or * to include all properties. By default, all properties are returned except diagnostics. Currently only accepts '*' as a valid value.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;InputInner&gt; object
     */
    public Observable<Page<InputInner>> listByStreamingJobAsync(final String resourceGroupName, final String jobName, final String select) {
        return listByStreamingJobWithServiceResponseAsync(resourceGroupName, jobName, select)
            .map(new Func1<ServiceResponse<Page<InputInner>>, Page<InputInner>>() {
                @Override
                public Page<InputInner> call(ServiceResponse<Page<InputInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists all of the inputs under the specified streaming job.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param select The $select OData query parameter. This is a comma-separated list of structural properties to include in the response, or * to include all properties. By default, all properties are returned except diagnostics. Currently only accepts '*' as a valid value.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;InputInner&gt; object
     */
    public Observable<ServiceResponse<Page<InputInner>>> listByStreamingJobWithServiceResponseAsync(final String resourceGroupName, final String jobName, final String select) {
        return listByStreamingJobSinglePageAsync(resourceGroupName, jobName, select)
            .concatMap(new Func1<ServiceResponse<Page<InputInner>>, Observable<ServiceResponse<Page<InputInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<InputInner>>> call(ServiceResponse<Page<InputInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByStreamingJobNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists all of the inputs under the specified streaming job.
     *
    ServiceResponse<PageImpl<InputInner>> * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
    ServiceResponse<PageImpl<InputInner>> * @param jobName The name of the streaming job.
    ServiceResponse<PageImpl<InputInner>> * @param select The $select OData query parameter. This is a comma-separated list of structural properties to include in the response, or * to include all properties. By default, all properties are returned except diagnostics. Currently only accepts '*' as a valid value.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;InputInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<InputInner>>> listByStreamingJobSinglePageAsync(final String resourceGroupName, final String jobName, final String select) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listByStreamingJob(this.client.subscriptionId(), resourceGroupName, jobName, select, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<InputInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<InputInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<InputInner>> result = listByStreamingJobDelegate(response);
                        return Observable.just(new ServiceResponse<Page<InputInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<InputInner>> listByStreamingJobDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<InputInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<InputInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Tests whether an inputs datasource is reachable and usable by the Azure Stream Analytics service.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param inputName The name of the input.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ResourceTestStatusInner object if successful.
     */
    public ResourceTestStatusInner test(String resourceGroupName, String jobName, String inputName) {
        return testWithServiceResponseAsync(resourceGroupName, jobName, inputName).toBlocking().last().body();
    }

    /**
     * Tests whether an inputs datasource is reachable and usable by the Azure Stream Analytics service.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param inputName The name of the input.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ResourceTestStatusInner> testAsync(String resourceGroupName, String jobName, String inputName, final ServiceCallback<ResourceTestStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(testWithServiceResponseAsync(resourceGroupName, jobName, inputName), serviceCallback);
    }

    /**
     * Tests whether an inputs datasource is reachable and usable by the Azure Stream Analytics service.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param inputName The name of the input.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ResourceTestStatusInner> testAsync(String resourceGroupName, String jobName, String inputName) {
        return testWithServiceResponseAsync(resourceGroupName, jobName, inputName).map(new Func1<ServiceResponse<ResourceTestStatusInner>, ResourceTestStatusInner>() {
            @Override
            public ResourceTestStatusInner call(ServiceResponse<ResourceTestStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Tests whether an inputs datasource is reachable and usable by the Azure Stream Analytics service.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param inputName The name of the input.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<ResourceTestStatusInner>> testWithServiceResponseAsync(String resourceGroupName, String jobName, String inputName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        if (inputName == null) {
            throw new IllegalArgumentException("Parameter inputName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final InputInner input = null;
        Observable<Response<ResponseBody>> observable = service.test(this.client.subscriptionId(), resourceGroupName, jobName, inputName, input, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<ResourceTestStatusInner>() { }.getType());
    }
    /**
     * Tests whether an inputs datasource is reachable and usable by the Azure Stream Analytics service.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param inputName The name of the input.
     * @param input If the input specified does not already exist, this parameter must contain the full input definition intended to be tested. If the input specified already exists, this parameter can be left null to test the existing input as is or if specified, the properties specified will overwrite the corresponding properties in the existing input (exactly like a PATCH operation) and the resulting input will be tested.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ResourceTestStatusInner object if successful.
     */
    public ResourceTestStatusInner test(String resourceGroupName, String jobName, String inputName, InputInner input) {
        return testWithServiceResponseAsync(resourceGroupName, jobName, inputName, input).toBlocking().last().body();
    }

    /**
     * Tests whether an inputs datasource is reachable and usable by the Azure Stream Analytics service.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param inputName The name of the input.
     * @param input If the input specified does not already exist, this parameter must contain the full input definition intended to be tested. If the input specified already exists, this parameter can be left null to test the existing input as is or if specified, the properties specified will overwrite the corresponding properties in the existing input (exactly like a PATCH operation) and the resulting input will be tested.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ResourceTestStatusInner> testAsync(String resourceGroupName, String jobName, String inputName, InputInner input, final ServiceCallback<ResourceTestStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(testWithServiceResponseAsync(resourceGroupName, jobName, inputName, input), serviceCallback);
    }

    /**
     * Tests whether an inputs datasource is reachable and usable by the Azure Stream Analytics service.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param inputName The name of the input.
     * @param input If the input specified does not already exist, this parameter must contain the full input definition intended to be tested. If the input specified already exists, this parameter can be left null to test the existing input as is or if specified, the properties specified will overwrite the corresponding properties in the existing input (exactly like a PATCH operation) and the resulting input will be tested.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ResourceTestStatusInner> testAsync(String resourceGroupName, String jobName, String inputName, InputInner input) {
        return testWithServiceResponseAsync(resourceGroupName, jobName, inputName, input).map(new Func1<ServiceResponse<ResourceTestStatusInner>, ResourceTestStatusInner>() {
            @Override
            public ResourceTestStatusInner call(ServiceResponse<ResourceTestStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Tests whether an inputs datasource is reachable and usable by the Azure Stream Analytics service.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param inputName The name of the input.
     * @param input If the input specified does not already exist, this parameter must contain the full input definition intended to be tested. If the input specified already exists, this parameter can be left null to test the existing input as is or if specified, the properties specified will overwrite the corresponding properties in the existing input (exactly like a PATCH operation) and the resulting input will be tested.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<ResourceTestStatusInner>> testWithServiceResponseAsync(String resourceGroupName, String jobName, String inputName, InputInner input) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        if (inputName == null) {
            throw new IllegalArgumentException("Parameter inputName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(input);
        Observable<Response<ResponseBody>> observable = service.test(this.client.subscriptionId(), resourceGroupName, jobName, inputName, input, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<ResourceTestStatusInner>() { }.getType());
    }

    /**
     * Tests whether an inputs datasource is reachable and usable by the Azure Stream Analytics service.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param inputName The name of the input.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ResourceTestStatusInner object if successful.
     */
    public ResourceTestStatusInner beginTest(String resourceGroupName, String jobName, String inputName) {
        return beginTestWithServiceResponseAsync(resourceGroupName, jobName, inputName).toBlocking().single().body();
    }

    /**
     * Tests whether an inputs datasource is reachable and usable by the Azure Stream Analytics service.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param inputName The name of the input.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ResourceTestStatusInner> beginTestAsync(String resourceGroupName, String jobName, String inputName, final ServiceCallback<ResourceTestStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginTestWithServiceResponseAsync(resourceGroupName, jobName, inputName), serviceCallback);
    }

    /**
     * Tests whether an inputs datasource is reachable and usable by the Azure Stream Analytics service.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param inputName The name of the input.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ResourceTestStatusInner object
     */
    public Observable<ResourceTestStatusInner> beginTestAsync(String resourceGroupName, String jobName, String inputName) {
        return beginTestWithServiceResponseAsync(resourceGroupName, jobName, inputName).map(new Func1<ServiceResponse<ResourceTestStatusInner>, ResourceTestStatusInner>() {
            @Override
            public ResourceTestStatusInner call(ServiceResponse<ResourceTestStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Tests whether an inputs datasource is reachable and usable by the Azure Stream Analytics service.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param inputName The name of the input.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ResourceTestStatusInner object
     */
    public Observable<ServiceResponse<ResourceTestStatusInner>> beginTestWithServiceResponseAsync(String resourceGroupName, String jobName, String inputName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        if (inputName == null) {
            throw new IllegalArgumentException("Parameter inputName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final InputInner input = null;
        return service.beginTest(this.client.subscriptionId(), resourceGroupName, jobName, inputName, input, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ResourceTestStatusInner>>>() {
                @Override
                public Observable<ServiceResponse<ResourceTestStatusInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ResourceTestStatusInner> clientResponse = beginTestDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Tests whether an inputs datasource is reachable and usable by the Azure Stream Analytics service.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param inputName The name of the input.
     * @param input If the input specified does not already exist, this parameter must contain the full input definition intended to be tested. If the input specified already exists, this parameter can be left null to test the existing input as is or if specified, the properties specified will overwrite the corresponding properties in the existing input (exactly like a PATCH operation) and the resulting input will be tested.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ResourceTestStatusInner object if successful.
     */
    public ResourceTestStatusInner beginTest(String resourceGroupName, String jobName, String inputName, InputInner input) {
        return beginTestWithServiceResponseAsync(resourceGroupName, jobName, inputName, input).toBlocking().single().body();
    }

    /**
     * Tests whether an inputs datasource is reachable and usable by the Azure Stream Analytics service.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param inputName The name of the input.
     * @param input If the input specified does not already exist, this parameter must contain the full input definition intended to be tested. If the input specified already exists, this parameter can be left null to test the existing input as is or if specified, the properties specified will overwrite the corresponding properties in the existing input (exactly like a PATCH operation) and the resulting input will be tested.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ResourceTestStatusInner> beginTestAsync(String resourceGroupName, String jobName, String inputName, InputInner input, final ServiceCallback<ResourceTestStatusInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginTestWithServiceResponseAsync(resourceGroupName, jobName, inputName, input), serviceCallback);
    }

    /**
     * Tests whether an inputs datasource is reachable and usable by the Azure Stream Analytics service.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param inputName The name of the input.
     * @param input If the input specified does not already exist, this parameter must contain the full input definition intended to be tested. If the input specified already exists, this parameter can be left null to test the existing input as is or if specified, the properties specified will overwrite the corresponding properties in the existing input (exactly like a PATCH operation) and the resulting input will be tested.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ResourceTestStatusInner object
     */
    public Observable<ResourceTestStatusInner> beginTestAsync(String resourceGroupName, String jobName, String inputName, InputInner input) {
        return beginTestWithServiceResponseAsync(resourceGroupName, jobName, inputName, input).map(new Func1<ServiceResponse<ResourceTestStatusInner>, ResourceTestStatusInner>() {
            @Override
            public ResourceTestStatusInner call(ServiceResponse<ResourceTestStatusInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Tests whether an inputs datasource is reachable and usable by the Azure Stream Analytics service.
     *
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * @param jobName The name of the streaming job.
     * @param inputName The name of the input.
     * @param input If the input specified does not already exist, this parameter must contain the full input definition intended to be tested. If the input specified already exists, this parameter can be left null to test the existing input as is or if specified, the properties specified will overwrite the corresponding properties in the existing input (exactly like a PATCH operation) and the resulting input will be tested.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ResourceTestStatusInner object
     */
    public Observable<ServiceResponse<ResourceTestStatusInner>> beginTestWithServiceResponseAsync(String resourceGroupName, String jobName, String inputName, InputInner input) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (jobName == null) {
            throw new IllegalArgumentException("Parameter jobName is required and cannot be null.");
        }
        if (inputName == null) {
            throw new IllegalArgumentException("Parameter inputName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(input);
        return service.beginTest(this.client.subscriptionId(), resourceGroupName, jobName, inputName, input, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ResourceTestStatusInner>>>() {
                @Override
                public Observable<ServiceResponse<ResourceTestStatusInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ResourceTestStatusInner> clientResponse = beginTestDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ResourceTestStatusInner> beginTestDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ResourceTestStatusInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ResourceTestStatusInner>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Lists all of the inputs under the specified streaming job.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;InputInner&gt; object if successful.
     */
    public PagedList<InputInner> listByStreamingJobNext(final String nextPageLink) {
        ServiceResponse<Page<InputInner>> response = listByStreamingJobNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<InputInner>(response.body()) {
            @Override
            public Page<InputInner> nextPage(String nextPageLink) {
                return listByStreamingJobNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Lists all of the inputs under the specified streaming job.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<InputInner>> listByStreamingJobNextAsync(final String nextPageLink, final ServiceFuture<List<InputInner>> serviceFuture, final ListOperationCallback<InputInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByStreamingJobNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<InputInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<InputInner>>> call(String nextPageLink) {
                    return listByStreamingJobNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists all of the inputs under the specified streaming job.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;InputInner&gt; object
     */
    public Observable<Page<InputInner>> listByStreamingJobNextAsync(final String nextPageLink) {
        return listByStreamingJobNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<InputInner>>, Page<InputInner>>() {
                @Override
                public Page<InputInner> call(ServiceResponse<Page<InputInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Lists all of the inputs under the specified streaming job.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;InputInner&gt; object
     */
    public Observable<ServiceResponse<Page<InputInner>>> listByStreamingJobNextWithServiceResponseAsync(final String nextPageLink) {
        return listByStreamingJobNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<InputInner>>, Observable<ServiceResponse<Page<InputInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<InputInner>>> call(ServiceResponse<Page<InputInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByStreamingJobNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists all of the inputs under the specified streaming job.
     *
    ServiceResponse<PageImpl<InputInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;InputInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<InputInner>>> listByStreamingJobNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listByStreamingJobNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<InputInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<InputInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<InputInner>> result = listByStreamingJobNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<InputInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<InputInner>> listByStreamingJobNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<InputInner>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<InputInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

}
